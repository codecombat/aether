(function(global) {
  'use strict';
  if (global.$traceurRuntime) {
    return;
  }
  var $Object = Object;
  var $TypeError = TypeError;
  var $create = $Object.create;
  var $defineProperties = $Object.defineProperties;
  var $defineProperty = $Object.defineProperty;
  var $freeze = $Object.freeze;
  var $getOwnPropertyDescriptor = $Object.getOwnPropertyDescriptor;
  var $getOwnPropertyNames = $Object.getOwnPropertyNames;
  var $getPrototypeOf = $Object.getPrototypeOf;
  var $hasOwnProperty = $Object.prototype.hasOwnProperty;
  var $toString = $Object.prototype.toString;
  function nonEnum(value) {
    return {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    };
  }
  var method = nonEnum;
  var counter = 0;
  function newUniqueString() {
    return '__$' + Math.floor(Math.random() * 1e9) + '$' + ++counter + '$__';
  }
  var symbolInternalProperty = newUniqueString();
  var symbolDescriptionProperty = newUniqueString();
  var symbolDataProperty = newUniqueString();
  var symbolValues = $create(null);
  function isSymbol(symbol) {
    return typeof symbol === 'object' && symbol instanceof SymbolValue;
  }
  function typeOf(v) {
    if (isSymbol(v)) return 'symbol';
    return typeof v;
  }
  function Symbol(description) {
    var value = new SymbolValue(description);
    if (!(this instanceof Symbol)) return value;
    throw new TypeError('Symbol cannot be new\'ed');
  }
  $defineProperty(Symbol.prototype, 'constructor', nonEnum(Symbol));
  $defineProperty(Symbol.prototype, 'toString', method(function() {
    var symbolValue = this[symbolDataProperty];
    if (!getOption('symbols')) return symbolValue[symbolInternalProperty];
    if (!symbolValue) throw TypeError('Conversion from symbol to string');
    var desc = symbolValue[symbolDescriptionProperty];
    if (desc === undefined) desc = '';
    return 'Symbol(' + desc + ')';
  }));
  $defineProperty(Symbol.prototype, 'valueOf', method(function() {
    var symbolValue = this[symbolDataProperty];
    if (!symbolValue) throw TypeError('Conversion from symbol to string');
    if (!getOption('symbols')) return symbolValue[symbolInternalProperty];
    return symbolValue;
  }));
  function SymbolValue(description) {
    var key = newUniqueString();
    $defineProperty(this, symbolDataProperty, {value: this});
    $defineProperty(this, symbolInternalProperty, {value: key});
    $defineProperty(this, symbolDescriptionProperty, {value: description});
    $freeze(this);
    symbolValues[key] = this;
  }
  $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(Symbol));
  $defineProperty(SymbolValue.prototype, 'toString', {
    value: Symbol.prototype.toString,
    enumerable: false
  });
  $defineProperty(SymbolValue.prototype, 'valueOf', {
    value: Symbol.prototype.valueOf,
    enumerable: false
  });
  $freeze(SymbolValue.prototype);
  Symbol.iterator = Symbol();
  function toProperty(name) {
    if (isSymbol(name)) return name[symbolInternalProperty];
    return name;
  }
  function getOwnPropertyNames(object) {
    var rv = [];
    var names = $getOwnPropertyNames(object);
    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      if (!symbolValues[name]) rv.push(name);
    }
    return rv;
  }
  function getOwnPropertyDescriptor(object, name) {
    return $getOwnPropertyDescriptor(object, toProperty(name));
  }
  function getOwnPropertySymbols(object) {
    var rv = [];
    var names = $getOwnPropertyNames(object);
    for (var i = 0; i < names.length; i++) {
      var symbol = symbolValues[names[i]];
      if (symbol) rv.push(symbol);
    }
    return rv;
  }
  function hasOwnProperty(name) {
    return $hasOwnProperty.call(this, toProperty(name));
  }
  function getOption(name) {
    return global.traceur && global.traceur.options[name];
  }
  function setProperty(object, name, value) {
    var sym,
        desc;
    if (isSymbol(name)) {
      sym = name;
      name = name[symbolInternalProperty];
    }
    object[name] = value;
    if (sym && (desc = $getOwnPropertyDescriptor(object, name))) $defineProperty(object, name, {enumerable: false});
    return value;
  }
  function defineProperty(object, name, descriptor) {
    if (isSymbol(name)) {
      if (descriptor.enumerable) {
        descriptor = $create(descriptor, {enumerable: {value: false}});
      }
      name = name[symbolInternalProperty];
    }
    $defineProperty(object, name, descriptor);
    return object;
  }
  function polyfillObject(Object) {
    $defineProperty(Object, 'defineProperty', {value: defineProperty});
    $defineProperty(Object, 'getOwnPropertyNames', {value: getOwnPropertyNames});
    $defineProperty(Object, 'getOwnPropertyDescriptor', {value: getOwnPropertyDescriptor});
    $defineProperty(Object.prototype, 'hasOwnProperty', {value: hasOwnProperty});
    Object.getOwnPropertySymbols = getOwnPropertySymbols;
    function is(left, right) {
      if (left === right) return left !== 0 || 1 / left === 1 / right;
      return left !== left && right !== right;
    }
    $defineProperty(Object, 'is', method(is));
    function assign(target, source) {
      var props = $getOwnPropertyNames(source);
      var p,
          length = props.length;
      for (p = 0; p < length; p++) {
        target[props[p]] = source[props[p]];
      }
      return target;
    }
    $defineProperty(Object, 'assign', method(assign));
    function mixin(target, source) {
      var props = $getOwnPropertyNames(source);
      var p,
          descriptor,
          length = props.length;
      for (p = 0; p < length; p++) {
        descriptor = $getOwnPropertyDescriptor(source, props[p]);
        $defineProperty(target, props[p], descriptor);
      }
      return target;
    }
    $defineProperty(Object, 'mixin', method(mixin));
  }
  function exportStar(object) {
    for (var i = 1; i < arguments.length; i++) {
      var names = $getOwnPropertyNames(arguments[i]);
      for (var j = 0; j < names.length; j++) {
        (function(mod, name) {
          $defineProperty(object, name, {
            get: function() {
              return mod[name];
            },
            enumerable: true
          });
        })(arguments[i], names[j]);
      }
    }
    return object;
  }
  function toObject(value) {
    if (value == null) throw $TypeError();
    return $Object(value);
  }
  function spread() {
    var rv = [],
        k = 0;
    for (var i = 0; i < arguments.length; i++) {
      var valueToSpread = toObject(arguments[i]);
      for (var j = 0; j < valueToSpread.length; j++) {
        rv[k++] = valueToSpread[j];
      }
    }
    return rv;
  }
  function getPropertyDescriptor(object, name) {
    while (object !== null) {
      var result = $getOwnPropertyDescriptor(object, name);
      if (result) return result;
      object = $getPrototypeOf(object);
    }
    return undefined;
  }
  function superDescriptor(homeObject, name) {
    var proto = $getPrototypeOf(homeObject);
    if (!proto) throw $TypeError('super is null');
    return getPropertyDescriptor(proto, name);
  }
  function superCall(self, homeObject, name, args) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor) {
      if ('value'in descriptor) return descriptor.value.apply(self, args);
      if (descriptor.get) return descriptor.get.call(self).apply(self, args);
    }
    throw $TypeError("super has no method '" + name + "'.");
  }
  function superGet(self, homeObject, name) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor) {
      if (descriptor.get) return descriptor.get.call(self); else if ('value'in descriptor) return descriptor.value;
    }
    return undefined;
  }
  function superSet(self, homeObject, name, value) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor && descriptor.set) {
      descriptor.set.call(self, value);
      return;
    }
    throw $TypeError("super has no setter '" + name + "'.");
  }
  function getDescriptors(object) {
    var descriptors = {},
        name,
        names = $getOwnPropertyNames(object);
    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      descriptors[name] = $getOwnPropertyDescriptor(object, name);
    }
    return descriptors;
  }
  function createClass(ctor, object, staticObject, superClass) {
    $defineProperty(object, 'constructor', {
      value: ctor,
      configurable: true,
      enumerable: false,
      writable: true
    });
    if (arguments.length > 3) {
      if (typeof superClass === 'function') ctor.__proto__ = superClass;
      ctor.prototype = $create(getProtoParent(superClass), getDescriptors(object));
    } else {
      ctor.prototype = object;
    }
    $defineProperty(ctor, 'prototype', {
      configurable: false,
      writable: false
    });
    return $defineProperties(ctor, getDescriptors(staticObject));
  }
  function getProtoParent(superClass) {
    if (typeof superClass === 'function') {
      var prototype = superClass.prototype;
      if ($Object(prototype) === prototype || prototype === null) return superClass.prototype;
    }
    if (superClass === null) return null;
    throw new TypeError();
  }
  function defaultSuperCall(self, homeObject, args) {
    if ($getPrototypeOf(homeObject) !== null) superCall(self, homeObject, 'constructor', args);
  }
  var ST_NEWBORN = 0;
  var ST_EXECUTING = 1;
  var ST_SUSPENDED = 2;
  var ST_CLOSED = 3;
  var END_STATE = - 3;
  function addIterator(object) {
    return defineProperty(object, Symbol.iterator, nonEnum(function() {
      return this;
    }));
  }
  function GeneratorContext() {
    this.state = 0;
    this.GState = ST_NEWBORN;
    this.storedException = undefined;
    this.finallyFallThrough = undefined;
    this.sent = undefined;
    this.returnValue = undefined;
    this.tryStack_ = [];
  }
  GeneratorContext.prototype = {
    pushTry: function(catchState, finallyState) {
      if (finallyState !== null) {
        var finallyFallThrough = null;
        for (var i = this.tryStack_.length - 1; i >= 0; i--) {
          if (this.tryStack_[i]. catch !== undefined) {
            finallyFallThrough = this.tryStack_[i]. catch;
            break;
          }
        }
        if (finallyFallThrough === null) finallyFallThrough = - 3;
        this.tryStack_.push({
          finally: finallyState,
          finallyFallThrough: finallyFallThrough
        });
      }
      if (catchState !== null) {
        this.tryStack_.push({ catch: catchState});
      }
    },
    popTry: function() {
      this.tryStack_.pop();
    }
  };
  function getNextOrThrow(ctx, moveNext, action) {
    return function(x) {
      switch (ctx.GState) {
        case ST_EXECUTING:
          throw new Error(("\"" + action + "\" on executing generator"));
        case ST_CLOSED:
          throw new Error(("\"" + action + "\" on closed generator"));
        case ST_NEWBORN:
          if (action === 'throw') {
            ctx.GState = ST_CLOSED;
            throw x;
          }
          if (x !== undefined) throw $TypeError('Sent value to newborn generator');
        case ST_SUSPENDED:
          ctx.GState = ST_EXECUTING;
          ctx.action = action;
          ctx.sent = x;
          var value = moveNext(ctx);
          var done = value === ctx;
          if (done) value = ctx.returnValue;
          ctx.GState = done ? ST_CLOSED: ST_SUSPENDED;
          return {
            value: value,
            done: done
          };
      }
    };
  }
  function generatorWrap(innerFunction, self) {
    var moveNext = getMoveNext(innerFunction, self);
    var ctx = new GeneratorContext();
    return addIterator({
      next: getNextOrThrow(ctx, moveNext, 'next'),
      throw: getNextOrThrow(ctx, moveNext, 'throw')
    });
  }
  function AsyncFunctionContext() {
    GeneratorContext.call(this);
    this.err = undefined;
    var ctx = this;
    ctx.result = new Promise(function(resolve, reject) {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
  }
  AsyncFunctionContext.prototype = Object.create(GeneratorContext.prototype);
  function asyncWrap(innerFunction, self) {
    var moveNext = getMoveNext(innerFunction, self);
    var ctx = new AsyncFunctionContext();
    ctx.createCallback = function(newState) {
      return function(value) {
        ctx.state = newState;
        ctx.value = value;
        moveNext(ctx);
      };
    };
    ctx.createErrback = function(newState) {
      return function(err) {
        ctx.state = newState;
        ctx.err = err;
        moveNext(ctx);
      };
    };
    moveNext(ctx);
    return ctx.result;
  }
  function getMoveNext(innerFunction, self) {
    return function(ctx) {
      while (true) {
        try {
          return innerFunction.call(self, ctx);
        } catch (ex) {
          ctx.storedException = ex;
          var last = ctx.tryStack_[ctx.tryStack_.length - 1];
          if (!last) {
            ctx.GState = ST_CLOSED;
            ctx.state = END_STATE;
            throw ex;
          }
          ctx.state = last. catch !== undefined ? last. catch: last. finally;
          if (last.finallyFallThrough !== undefined) ctx.finallyFallThrough = last.finallyFallThrough;
        }
      }
    };
  }
  function setupGlobals(global) {
    global.Symbol = Symbol;
    polyfillObject(global.Object);
  }
  setupGlobals(global);
  global.$traceurRuntime = {
    asyncWrap: asyncWrap,
    createClass: createClass,
    defaultSuperCall: defaultSuperCall,
    exportStar: exportStar,
    generatorWrap: generatorWrap,
    setProperty: setProperty,
    setupGlobals: setupGlobals,
    spread: spread,
    superCall: superCall,
    superGet: superGet,
    superSet: superSet,
    toObject: toObject,
    toProperty: toProperty,
    typeof: typeOf
  };
})(typeof global !== 'undefined' ? global: this);
(function() {
  function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
    var out = [];
    if (opt_scheme) {
      out.push(opt_scheme, ':');
    }
    if (opt_domain) {
      out.push('//');
      if (opt_userInfo) {
        out.push(opt_userInfo, '@');
      }
      out.push(opt_domain);
      if (opt_port) {
        out.push(':', opt_port);
      }
    }
    if (opt_path) {
      out.push(opt_path);
    }
    if (opt_queryData) {
      out.push('?', opt_queryData);
    }
    if (opt_fragment) {
      out.push('#', opt_fragment);
    }
    return out.join('');
  }
  ;
  var splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\w\\d\\-\\u0100-\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\?([^#]*))?' + '(?:#(.*))?' + '$');
  var ComponentIndex = {
    SCHEME: 1,
    USER_INFO: 2,
    DOMAIN: 3,
    PORT: 4,
    PATH: 5,
    QUERY_DATA: 6,
    FRAGMENT: 7
  };
  function split(uri) {
    return (uri.match(splitRe));
  }
  function removeDotSegments(path) {
    if (path === '/') return '/';
    var leadingSlash = path[0] === '/' ? '/': '';
    var trailingSlash = path.slice(- 1) === '/' ? '/': '';
    var segments = path.split('/');
    var out = [];
    var up = 0;
    for (var pos = 0; pos < segments.length; pos++) {
      var segment = segments[pos];
      switch (segment) {
        case '':
        case '.':
          break;
        case '..':
          if (out.length) out.pop(); else up++;
          break;
        default:
          out.push(segment);
      }
    }
    if (!leadingSlash) {
      while (up-- > 0) {
        out.unshift('..');
      }
      if (out.length === 0) out.push('.');
    }
    return leadingSlash + out.join('/') + trailingSlash;
  }
  function joinAndCanonicalizePath(parts) {
    var path = parts[ComponentIndex.PATH];
    path = removeDotSegments(path.replace(/\/\//.g, '/'));
    parts[ComponentIndex.PATH] = path;
    return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);
  }
  function canonicalizeUrl(url) {
    var parts = split(url);
    return joinAndCanonicalizePath(parts);
  }
  function resolveUrl(base, url) {
    var parts = split(url);
    var baseParts = split(base);
    if (parts[ComponentIndex.SCHEME]) {
      return joinAndCanonicalizePath(parts);
    } else {
      parts[ComponentIndex.SCHEME] = baseParts[ComponentIndex.SCHEME];
    }
    for (var i = ComponentIndex.SCHEME; i <= ComponentIndex.PORT; i++) {
      if (!parts[i]) {
        parts[i] = baseParts[i];
      }
    }
    if (parts[ComponentIndex.PATH][0] == '/') {
      return joinAndCanonicalizePath(parts);
    }
    var path = baseParts[ComponentIndex.PATH];
    var index = path.lastIndexOf('/');
    path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];
    parts[ComponentIndex.PATH] = path;
    return joinAndCanonicalizePath(parts);
  }
  function isAbsolute(name) {
    if (!name) return false;
    if (name[0] === '/') return true;
    var parts = split(name);
    if (parts[ComponentIndex.SCHEME]) return true;
    return false;
  }
  $traceurRuntime.canonicalizeUrl = canonicalizeUrl;
  $traceurRuntime.isAbsolute = isAbsolute;
  $traceurRuntime.removeDotSegments = removeDotSegments;
  $traceurRuntime.resolveUrl = resolveUrl;
})();
(function(global) {
  'use strict';
  var $__2 = $traceurRuntime,
      canonicalizeUrl = $__2.canonicalizeUrl,
      resolveUrl = $__2.resolveUrl,
      isAbsolute = $__2.isAbsolute;
  var moduleInstantiators = Object.create(null);
  var baseURL;
  if (global.location && global.location.href) baseURL = resolveUrl(global.location.href, './'); else baseURL = '';
  var UncoatedModuleEntry = function UncoatedModuleEntry(url, uncoatedModule) {
    this.url = url;
    this.value_ = uncoatedModule;
  };
  ($traceurRuntime.createClass)(UncoatedModuleEntry, {}, {});
  var UncoatedModuleInstantiator = function UncoatedModuleInstantiator(url, func) {
    $traceurRuntime.superCall(this, $UncoatedModuleInstantiator.prototype, "constructor", [url, null]);
    this.func = func;
  };
  var $UncoatedModuleInstantiator = UncoatedModuleInstantiator;
  ($traceurRuntime.createClass)(UncoatedModuleInstantiator, {getUncoatedModule: function() {
      if (this.value_) return this.value_;
      return this.value_ = this.func.call(global);
    }}, {}, UncoatedModuleEntry);
  function getUncoatedModuleInstantiator(name) {
    if (!name) return;
    var url = ModuleStore.normalize(name);
    return moduleInstantiators[url];
  }
  ;
  var moduleInstances = Object.create(null);
  var liveModuleSentinel = {};
  function Module(uncoatedModule) {
    var isLive = arguments[1];
    var coatedModule = Object.create(null);
    Object.getOwnPropertyNames(uncoatedModule).forEach((function(name) {
      var getter,
          value;
      if (isLive === liveModuleSentinel) {
        var descr = Object.getOwnPropertyDescriptor(uncoatedModule, name);
        if (descr.get) getter = descr.get;
      }
      if (!getter) {
        value = uncoatedModule[name];
        getter = function() {
          return value;
        };
      }
      Object.defineProperty(coatedModule, name, {
        get: getter,
        enumerable: true
      });
    }));
    Object.preventExtensions(coatedModule);
    return coatedModule;
  }
  var ModuleStore = {
    normalize: function(name, refererName, refererAddress) {
      if (typeof name !== "string") throw new TypeError("module name must be a string, not " + typeof name);
      if (isAbsolute(name)) return canonicalizeUrl(name);
      if (/[^\.]\/\.\.\//.test(name)) {
        throw new Error('module name embeds /../: ' + name);
      }
      if (name[0] === '.' && refererName) return resolveUrl(refererName, name);
      return canonicalizeUrl(name);
    },
    get: function(normalizedName) {
      var m = getUncoatedModuleInstantiator(normalizedName);
      if (!m) return undefined;
      var moduleInstance = moduleInstances[m.url];
      if (moduleInstance) return moduleInstance;
      moduleInstance = Module(m.getUncoatedModule(), liveModuleSentinel);
      return moduleInstances[m.url] = moduleInstance;
    },
    set: function(normalizedName, module) {
      normalizedName = String(normalizedName);
      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, (function() {
        return module;
      }));
      moduleInstances[normalizedName] = module;
    },
    get baseURL() {
      return baseURL;
    },
    set baseURL(v) {
      baseURL = String(v);
    },
    registerModule: function(name, func) {
      var normalizedName = ModuleStore.normalize(name);
      if (moduleInstantiators[normalizedName]) throw new Error('duplicate module named ' + normalizedName);
      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, func);
    },
    getAnonymousModule: function(func) {
      return new Module(func.call(global), liveModuleSentinel);
    },
    getForTesting: function(name) {
      var $__0 = this;
      if (!this.testingPrefix_) {
        Object.keys(moduleInstances).some((function(key) {
          var m = /(traceur@[^\/]*\/)/.exec(key);
          if (m) {
            $__0.testingPrefix_ = m[1];
            return true;
          }
        }));
      }
      return this.get(this.testingPrefix_ + name);
    }
  };
  ModuleStore.set('@traceur/src/runtime/ModuleStore', new Module({ModuleStore: ModuleStore}));
  var setupGlobals = $traceurRuntime.setupGlobals;
  $traceurRuntime.setupGlobals = function(global) {
    setupGlobals(global);
  };
  $traceurRuntime.ModuleStore = ModuleStore;
  global.System = {
    registerModule: ModuleStore.registerModule,
    get: ModuleStore.get,
    set: ModuleStore.set,
    normalize: ModuleStore.normalize
  };
  $traceurRuntime.getModuleImpl = function(name) {
    var instantiator = getUncoatedModuleInstantiator(name);
    return instantiator && instantiator.getUncoatedModule();
  };
})(typeof global !== 'undefined' ? global: this);
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/runtime/polyfills/utils", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/runtime/polyfills/utils";
  var toObject = $traceurRuntime.toObject;
  function toUint32(x) {
    return x | 0;
  }
  return {
    get toObject() {
      return toObject;
    },
    get toUint32() {
      return toUint32;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/runtime/polyfills/ArrayIterator", function() {
  "use strict";
  var $__4;
  var __moduleName = "traceur@0.0.20/src/runtime/polyfills/ArrayIterator";
  var $__5 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/polyfills/utils"),
      toObject = $__5.toObject,
      toUint32 = $__5.toUint32;
  var ARRAY_ITERATOR_KIND_KEYS = 1;
  var ARRAY_ITERATOR_KIND_VALUES = 2;
  var ARRAY_ITERATOR_KIND_ENTRIES = 3;
  var ArrayIterator = function ArrayIterator() {};
  ($traceurRuntime.createClass)(ArrayIterator, ($__4 = {}, Object.defineProperty($__4, "next", {
    value: function() {
      var iterator = toObject(this);
      var array = iterator.iteratorObject_;
      if (!array) {
        throw new TypeError('Object is not an ArrayIterator');
      }
      var index = iterator.arrayIteratorNextIndex_;
      var itemKind = iterator.arrayIterationKind_;
      var length = toUint32(array.length);
      if (index >= length) {
        iterator.arrayIteratorNextIndex_ = Infinity;
        return createIteratorResultObject(undefined, true);
      }
      iterator.arrayIteratorNextIndex_ = index + 1;
      if (itemKind == ARRAY_ITERATOR_KIND_VALUES) return createIteratorResultObject(array[index], false);
      if (itemKind == ARRAY_ITERATOR_KIND_ENTRIES) return createIteratorResultObject([index, array[index]], false);
      return createIteratorResultObject(index, false);
    },
    configurable: true,
    enumerable: true,
    writable: true
  }), Object.defineProperty($__4, Symbol.iterator, {
    value: function() {
      return this;
    },
    configurable: true,
    enumerable: true,
    writable: true
  }), $__4), {});
  function createArrayIterator(array, kind) {
    var object = toObject(array);
    var iterator = new ArrayIterator;
    iterator.iteratorObject_ = object;
    iterator.arrayIteratorNextIndex_ = 0;
    iterator.arrayIterationKind_ = kind;
    return iterator;
  }
  function createIteratorResultObject(value, done) {
    return {
      value: value,
      done: done
    };
  }
  function entries() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_ENTRIES);
  }
  function keys() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_KEYS);
  }
  function values() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_VALUES);
  }
  return {
    get entries() {
      return entries;
    },
    get keys() {
      return keys;
    },
    get values() {
      return values;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/events", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/events";
  var indexOf = function(callbacks, callback) {
    for (var i = 0,
        l = callbacks.length; i < l; i++) {
      if (callbacks[i] === callback) {
        return i;
      }
    }
    return - 1;
  };
  var callbacksFor = function(object) {
    var callbacks = object._promiseCallbacks;
    if (!callbacks) {
      callbacks = object._promiseCallbacks = {};
    }
    return callbacks;
  };
  var $__default = {
    mixin: function(object) {
      object.on = this.on;
      object.off = this.off;
      object.trigger = this.trigger;
      object._promiseCallbacks = undefined;
      return object;
    },
    on: function(eventName, callback) {
      var allCallbacks = callbacksFor(this),
          callbacks;
      callbacks = allCallbacks[eventName];
      if (!callbacks) {
        callbacks = allCallbacks[eventName] = [];
      }
      if (indexOf(callbacks, callback) === - 1) {
        callbacks.push(callback);
      }
    },
    off: function(eventName, callback) {
      var allCallbacks = callbacksFor(this),
          callbacks,
          index;
      if (!callback) {
        allCallbacks[eventName] = [];
        return;
      }
      callbacks = allCallbacks[eventName];
      index = indexOf(callbacks, callback);
      if (index !== - 1) {
        callbacks.splice(index, 1);
      }
    },
    trigger: function(eventName, options) {
      var allCallbacks = callbacksFor(this),
          callbacks,
          callbackTuple,
          callback,
          binding;
      if (callbacks = allCallbacks[eventName]) {
        for (var i = 0; i < callbacks.length; i++) {
          callback = callbacks[i];
          callback(options);
        }
      }
    }
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/config", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/config";
  var EventTarget = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/events").default;
  var config = {instrument: false};
  EventTarget.mixin(config);
  function configure(name, value) {
    if (name === 'onerror') {
      config.on('error', value);
      return;
    }
    if (arguments.length === 2) {
      config[name] = value;
    } else {
      return config[name];
    }
  }
  ;
  return {
    get config() {
      return config;
    },
    get configure() {
      return configure;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/utils", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/utils";
  function objectOrFunction(x) {
    return typeof x === "function" || (typeof x === "object" && x !== null);
  }
  function isFunction(x) {
    return typeof x === "function";
  }
  function isNonThenable(x) {
    return !objectOrFunction(x);
  }
  function isArray(x) {
    return Object.prototype.toString.call(x) === "[object Array]";
  }
  var now = Date.now || function() {
    return new Date().getTime();
  };
  var keysOf = Object.keys || function(object) {
    var result = [];
    for (var prop in object) {
      result.push(prop);
    }
    return result;
  };
  return {
    get objectOrFunction() {
      return objectOrFunction;
    },
    get isFunction() {
      return isFunction;
    },
    get isNonThenable() {
      return isNonThenable;
    },
    get isArray() {
      return isArray;
    },
    get now() {
      return now;
    },
    get keysOf() {
      return keysOf;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/instrument", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/instrument";
  var config = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/config").config;
  var now = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/utils").now;
  var $__default = function instrument(eventName, promise, child) {
    try {
      config.trigger(eventName, {
        guid: promise._guidKey + promise._id,
        eventName: eventName,
        detail: promise._detail,
        childGuid: child && promise._guidKey + child._id,
        label: promise._label,
        timeStamp: now(),
        stack: new Error(promise._label).stack
      });
    } catch (error) {
      setTimeout(function() {
        throw error;
      }, 0);
    }
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise/all", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise/all";
  var $__8 = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/utils"),
      isArray = $__8.isArray,
      isNonThenable = $__8.isNonThenable;
  var $__default = function all(entries, label) {
    var Constructor = this;
    return new Constructor(function(resolve, reject) {
      if (!isArray(entries)) {
        throw new TypeError('You must pass an array to all.');
      }
      var remaining = entries.length;
      var results = new Array(remaining);
      var entry,
          pending = true;
      if (remaining === 0) {
        resolve(results);
        return;
      }
      function fulfillmentAt(index) {
        return function(value) {
          results[index] = value;
          if (--remaining === 0) {
            resolve(results);
          }
        };
      }
      function onRejection(reason) {
        remaining = 0;
        reject(reason);
      }
      for (var index = 0; index < entries.length; index++) {
        entry = entries[index];
        if (isNonThenable(entry)) {
          results[index] = entry;
          if (--remaining === 0) {
            resolve(results);
          }
        } else {
          Constructor.cast(entry).then(fulfillmentAt(index), onRejection);
        }
      }
    }, label);
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise/cast", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise/cast";
  var $__default = function cast(object, label) {
    var Constructor = this;
    if (object && typeof object === 'object' && object.constructor === Constructor) {
      return object;
    }
    return new Constructor(function(resolve) {
      resolve(object);
    }, label);
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise/race", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise/race";
  var $__9 = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/utils"),
      isArray = $__9.isArray,
      isFunction = $__9.isFunction,
      isNonThenable = $__9.isNonThenable;
  var $__default = function race(entries, label) {
    var Constructor = this,
        entry;
    return new Constructor(function(resolve, reject) {
      if (!isArray(entries)) {
        throw new TypeError('You must pass an array to race.');
      }
      var pending = true;
      function onFulfillment(value) {
        if (pending) {
          pending = false;
          resolve(value);
        }
      }
      function onRejection(reason) {
        if (pending) {
          pending = false;
          reject(reason);
        }
      }
      for (var i = 0; i < entries.length; i++) {
        entry = entries[i];
        if (isNonThenable(entry)) {
          pending = false;
          resolve(entry);
          return;
        } else {
          Constructor.cast(entry).then(onFulfillment, onRejection);
        }
      }
    }, label);
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise/reject", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise/reject";
  var $__default = function reject(reason, label) {
    var Constructor = this;
    return new Constructor(function(resolve, reject) {
      reject(reason);
    }, label);
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise/resolve", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise/resolve";
  var $__default = function resolve(value, label) {
    var Constructor = this;
    return new Constructor(function(resolve, reject) {
      resolve(value);
    }, label);
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise";
  var config = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/config").config;
  var EventTarget = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/events").default;
  var instrument = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/instrument").default;
  var $__10 = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/utils"),
      objectOrFunction = $__10.objectOrFunction,
      isFunction = $__10.isFunction,
      now = $__10.now;
  var cast = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise/cast").default;
  var all = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise/all").default;
  var race = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise/race").default;
  var Resolve = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise/resolve").default;
  var Reject = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise/reject").default;
  var guidKey = 'rsvp_' + now() + '-';
  var counter = 0;
  function noop() {}
  var $__default = Promise;
  function Promise(resolver, label) {
    if (!isFunction(resolver)) {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }
    if (!(this instanceof Promise)) {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }
    this._id = counter++;
    this._label = label;
    this._subscribers = [];
    if (config.instrument) {
      instrument('created', this);
    }
    if (noop !== resolver) {
      invokeResolver(resolver, this);
    }
  }
  function invokeResolver(resolver, promise) {
    function resolvePromise(value) {
      resolve(promise, value);
    }
    function rejectPromise(reason) {
      reject(promise, reason);
    }
    try {
      resolver(resolvePromise, rejectPromise);
    } catch (e) {
      rejectPromise(e);
    }
  }
  Promise.cast = cast;
  Promise.all = all;
  Promise.race = race;
  Promise.resolve = Resolve;
  Promise.reject = Reject;
  var PENDING = void 0;
  var SEALED = 0;
  var FULFILLED = 1;
  var REJECTED = 2;
  function subscribe(parent, child, onFulfillment, onRejection) {
    var subscribers = parent._subscribers;
    var length = subscribers.length;
    subscribers[length] = child;
    subscribers[length + FULFILLED] = onFulfillment;
    subscribers[length + REJECTED] = onRejection;
  }
  function publish(promise, settled) {
    var child,
        callback,
        subscribers = promise._subscribers,
        detail = promise._detail;
    if (config.instrument) {
      instrument(settled === FULFILLED ? 'fulfilled': 'rejected', promise);
    }
    for (var i = 0; i < subscribers.length; i += 3) {
      child = subscribers[i];
      callback = subscribers[i + settled];
      invokeCallback(settled, child, callback, detail);
    }
    promise._subscribers = null;
  }
  Promise.prototype = {
    constructor: Promise,
    _id: undefined,
    _guidKey: guidKey,
    _label: undefined,
    _state: undefined,
    _detail: undefined,
    _subscribers: undefined,
    _onerror: function(reason) {
      config.trigger('error', reason);
    },
    then: function(onFulfillment, onRejection, label) {
      var promise = this;
      this._onerror = null;
      var thenPromise = new this.constructor(noop, label);
      if (this._state) {
        var callbacks = arguments;
        config.async(function invokePromiseCallback() {
          invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);
        });
      } else {
        subscribe(this, thenPromise, onFulfillment, onRejection);
      }
      if (config.instrument) {
        instrument('chained', promise, thenPromise);
      }
      return thenPromise;
    },
    'catch': function(onRejection, label) {
      return this.then(null, onRejection, label);
    },
    'finally': function(callback, label) {
      var constructor = this.constructor;
      return this.then(function(value) {
        return constructor.cast(callback()).then(function() {
          return value;
        });
      }, function(reason) {
        return constructor.cast(callback()).then(function() {
          throw reason;
        });
      }, label);
    }
  };
  function invokeCallback(settled, promise, callback, detail) {
    var hasCallback = isFunction(callback),
        value,
        error,
        succeeded,
        failed;
    if (hasCallback) {
      try {
        value = callback(detail);
        succeeded = true;
      } catch (e) {
        failed = true;
        error = e;
      }
    } else {
      value = detail;
      succeeded = true;
    }
    if (handleThenable(promise, value)) {
      return;
    } else if (hasCallback && succeeded) {
      resolve(promise, value);
    } else if (failed) {
      reject(promise, error);
    } else if (settled === FULFILLED) {
      resolve(promise, value);
    } else if (settled === REJECTED) {
      reject(promise, value);
    }
  }
  function handleThenable(promise, value) {
    var then = null,
        resolved;
    try {
      if (promise === value) {
        throw new TypeError("A promises callback cannot return that same promise.");
      }
      if (objectOrFunction(value)) {
        then = value.then;
        if (isFunction(then)) {
          then.call(value, function(val) {
            if (resolved) {
              return true;
            }
            resolved = true;
            if (value !== val) {
              resolve(promise, val);
            } else {
              fulfill(promise, val);
            }
          }, function(val) {
            if (resolved) {
              return true;
            }
            resolved = true;
            reject(promise, val);
          }, 'derived from: ' + (promise._label || ' unknown promise'));
          return true;
        }
      }
    } catch (error) {
      if (resolved) {
        return true;
      }
      reject(promise, error);
      return true;
    }
    return false;
  }
  function resolve(promise, value) {
    if (promise === value) {
      fulfill(promise, value);
    } else if (!handleThenable(promise, value)) {
      fulfill(promise, value);
    }
  }
  function fulfill(promise, value) {
    if (promise._state !== PENDING) {
      return;
    }
    promise._state = SEALED;
    promise._detail = value;
    config.async(publishFulfillment, promise);
  }
  function reject(promise, reason) {
    if (promise._state !== PENDING) {
      return;
    }
    promise._state = SEALED;
    promise._detail = reason;
    config.async(publishRejection, promise);
  }
  function publishFulfillment(promise) {
    publish(promise, promise._state = FULFILLED);
  }
  function publishRejection(promise) {
    if (promise._onerror) {
      promise._onerror(promise._detail);
    }
    publish(promise, promise._state = REJECTED);
  }
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/all", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/all";
  var Promise = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise").default;
  var $__default = function all(array, label) {
    return Promise.all(array, label);
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/all_settled", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/all_settled";
  var Promise = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise").default;
  var $__12 = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/utils"),
      isArray = $__12.isArray,
      isNonThenable = $__12.isNonThenable;
  var $__default = function allSettled(entries, label) {
    return new Promise(function(resolve, reject) {
      if (!isArray(entries)) {
        throw new TypeError('You must pass an array to allSettled.');
      }
      var remaining = entries.length;
      var entry;
      if (remaining === 0) {
        resolve([]);
        return;
      }
      var results = new Array(remaining);
      function fulfilledResolver(index) {
        return function(value) {
          resolveAll(index, fulfilled(value));
        };
      }
      function rejectedResolver(index) {
        return function(reason) {
          resolveAll(index, rejected(reason));
        };
      }
      function resolveAll(index, value) {
        results[index] = value;
        if (--remaining === 0) {
          resolve(results);
        }
      }
      for (var index = 0; index < entries.length; index++) {
        entry = entries[index];
        if (isNonThenable(entry)) {
          resolveAll(index, fulfilled(entry));
        } else {
          Promise.cast(entry).then(fulfilledResolver(index), rejectedResolver(index));
        }
      }
    }, label);
  };
  function fulfilled(value) {
    return {
      state: 'fulfilled',
      value: value
    };
  }
  function rejected(reason) {
    return {
      state: 'rejected',
      reason: reason
    };
  }
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/asap", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/asap";
  var $__default = function asap(callback, arg) {
    var length = queue.push([callback, arg]);
    if (length === 1) {
      scheduleFlush();
    }
  };
  var browserGlobal = (typeof window !== 'undefined') ? window: {};
  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
  function useNextTick() {
    return function() {
      process.nextTick(flush);
    };
  }
  function useMutationObserver() {
    var iterations = 0;
    var observer = new BrowserMutationObserver(flush);
    var node = document.createTextNode('');
    observer.observe(node, {characterData: true});
    return function() {
      node.data = (iterations = ++iterations % 2);
    };
  }
  function useSetTimeout() {
    return function() {
      setTimeout(flush, 1);
    };
  }
  var queue = [];
  function flush() {
    for (var i = 0; i < queue.length; i++) {
      var tuple = queue[i];
      var callback = tuple[0],
          arg = tuple[1];
      callback(arg);
    }
    queue = [];
  }
  var scheduleFlush;
  if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
    scheduleFlush = useNextTick();
  } else if (BrowserMutationObserver) {
    scheduleFlush = useMutationObserver();
  } else {
    scheduleFlush = useSetTimeout();
  }
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/defer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/defer";
  var Promise = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise").default;
  var $__default = function defer(label) {
    var deferred = {};
    deferred.promise = new Promise(function(resolve, reject) {
      deferred.resolve = resolve;
      deferred.reject = reject;
    }, label);
    return deferred;
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/map", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/map";
  var Promise = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise").default;
  var all = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/all").default;
  var $__14 = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/utils"),
      isArray = $__14.isArray,
      isFunction = $__14.isFunction;
  var $__default = function map(promises, mapFn, label) {
    return all(promises, label).then(function(results) {
      if (!isArray(promises)) {
        throw new TypeError('You must pass an array to map.');
      }
      if (!isFunction(mapFn)) {
        throw new TypeError("You must pass a function to map's second argument.");
      }
      var resultLen = results.length,
          mappedResults = [],
          i;
      for (i = 0; i < resultLen; i++) {
        mappedResults.push(mapFn(results[i]));
      }
      return all(mappedResults, label);
    });
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/filter", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/filter";
  var all = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/all").default;
  var map = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/map").default;
  var $__15 = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/utils"),
      isFunction = $__15.isFunction,
      isArray = $__15.isArray;
  function filter(promises, filterFn, label) {
    return all(promises, label).then(function(values) {
      if (!isArray(promises)) {
        throw new TypeError('You must pass an array to filter.');
      }
      if (!isFunction(filterFn)) {
        throw new TypeError("You must pass a function to filter's second argument.");
      }
      return map(promises, filterFn, label).then(function(filterResults) {
        var i,
            valuesLen = values.length,
            filtered = [];
        for (i = 0; i < valuesLen; i++) {
          if (filterResults[i]) filtered.push(values[i]);
        }
        return filtered;
      });
    });
  }
  var $__default = filter;
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/hash", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/hash";
  var Promise = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise").default;
  var $__16 = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/utils"),
      isNonThenable = $__16.isNonThenable,
      keysOf = $__16.keysOf;
  var $__default = function hash(object, label) {
    return new Promise(function(resolve, reject) {
      var results = {};
      var keys = keysOf(object);
      var remaining = keys.length;
      var entry,
          property;
      if (remaining === 0) {
        resolve(results);
        return;
      }
      function fulfilledTo(property) {
        return function(value) {
          results[property] = value;
          if (--remaining === 0) {
            resolve(results);
          }
        };
      }
      function onRejection(reason) {
        remaining = 0;
        reject(reason);
      }
      for (var i = 0; i < keys.length; i++) {
        property = keys[i];
        entry = object[property];
        if (isNonThenable(entry)) {
          results[property] = entry;
          if (--remaining === 0) {
            resolve(results);
          }
        } else {
          Promise.cast(entry).then(fulfilledTo(property), onRejection);
        }
      }
    });
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/node", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/node";
  var Promise = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise").default;
  var slice = Array.prototype.slice;
  function makeNodeCallbackFor(resolve, reject) {
    return function(error, value) {
      if (error) {
        reject(error);
      } else if (arguments.length > 2) {
        resolve(slice.call(arguments, 1));
      } else {
        resolve(value);
      }
    };
  }
  var $__default = function denodeify(nodeFunc, binding) {
    return function() {
      var nodeArgs = slice.call(arguments),
          resolve,
          reject;
      var thisArg = this || binding;
      return new Promise(function(resolve, reject) {
        Promise.all(nodeArgs).then(function(nodeArgs) {
          try {
            nodeArgs.push(makeNodeCallbackFor(resolve, reject));
            nodeFunc.apply(thisArg, nodeArgs);
          } catch (e) {
            reject(e);
          }
        });
      });
    };
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/race", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/race";
  var Promise = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise").default;
  var $__default = function race(array, label) {
    return Promise.race(array, label);
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/reject", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/reject";
  var Promise = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise").default;
  var $__default = function reject(reason, label) {
    return Promise.reject(reason, label);
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/resolve", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/resolve";
  var Promise = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise").default;
  var $__default = function resolve(value, label) {
    return Promise.resolve(value, label);
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp/rethrow", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp/rethrow";
  var $__default = function rethrow(reason) {
    setTimeout(function() {
      throw reason;
    });
    throw reason;
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/node_modules/rsvp/lib/rsvp", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/node_modules/rsvp/lib/rsvp";
  var Promise = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/promise").default;
  var EventTarget = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/events").default;
  var denodeify = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/node").default;
  var all = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/all").default;
  var allSettled = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/all_settled").default;
  var race = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/race").default;
  var hash = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/hash").default;
  var rethrow = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/rethrow").default;
  var defer = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/defer").default;
  var $__21 = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/config"),
      config = $__21.config,
      configure = $__21.configure;
  var map = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/map").default;
  var resolve = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/resolve").default;
  var reject = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/reject").default;
  var filter = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/filter").default;
  var asap = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp/asap").default;
  config.async = asap;
  function async(callback, arg) {
    config.async(callback, arg);
  }
  function on() {
    config.on.apply(config, arguments);
  }
  function off() {
    config.off.apply(config, arguments);
  }
  if (typeof window !== 'undefined' && typeof window.__PROMISE_INSTRUMENTATION__ === 'object') {
    var callbacks = window.__PROMISE_INSTRUMENTATION__;
    configure('instrument', true);
    for (var eventName in callbacks) {
      if (callbacks.hasOwnProperty(eventName)) {
        on(eventName, callbacks[eventName]);
      }
    }
  }
  ;
  return {
    get Promise() {
      return Promise;
    },
    get EventTarget() {
      return EventTarget;
    },
    get all() {
      return all;
    },
    get allSettled() {
      return allSettled;
    },
    get race() {
      return race;
    },
    get hash() {
      return hash;
    },
    get rethrow() {
      return rethrow;
    },
    get defer() {
      return defer;
    },
    get denodeify() {
      return denodeify;
    },
    get configure() {
      return configure;
    },
    get on() {
      return on;
    },
    get off() {
      return off;
    },
    get resolve() {
      return resolve;
    },
    get reject() {
      return reject;
    },
    get async() {
      return async;
    },
    get map() {
      return map;
    },
    get filter() {
      return filter;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/runtime/polyfills/Promise", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/runtime/polyfills/Promise";
  var async = $traceurRuntime.getModuleImpl("traceur@0.0.20/node_modules/rsvp/lib/rsvp").async;
  function isPromise(x) {
    return x && typeof x === 'object' && x.status_ !== undefined;
  }
  function chain(promise) {
    var onResolve = arguments[1] !== (void 0) ? arguments[1]: (function(x) {
      return x;
    });
    var onReject = arguments[2] !== (void 0) ? arguments[2]: (function(e) {
      throw e;
    });
    var deferred = getDeferred(promise.constructor);
    switch (promise.status_) {
      case undefined:
        throw TypeError;
      case 'pending':
        promise.onResolve_.push([deferred, onResolve]);
        promise.onReject_.push([deferred, onReject]);
        break;
      case 'resolved':
        promiseReact(deferred, onResolve, promise.value_);
        break;
      case 'rejected':
        promiseReact(deferred, onReject, promise.value_);
        break;
    }
    return deferred.promise;
  }
  function getDeferred(C) {
    var result = {};
    result.promise = new C((function(resolve, reject) {
      result.resolve = resolve;
      result.reject = reject;
    }));
    return result;
  }
  var Promise = function Promise(resolver) {
    var $__22 = this;
    this.status_ = 'pending';
    this.onResolve_ = [];
    this.onReject_ = [];
    resolver((function(x) {
      promiseResolve($__22, x);
    }), (function(r) {
      promiseReject($__22, r);
    }));
  };
  ($traceurRuntime.createClass)(Promise, {
    catch: function(onReject) {
      return this.then(undefined, onReject);
    },
    then: function() {
      var onResolve = arguments[0] !== (void 0) ? arguments[0]: (function(x) {
        return x;
      });
      var onReject = arguments[1];
      var $__22 = this;
      var constructor = this.constructor;
      return chain(this, (function(x) {
        x = promiseCoerce(constructor, x);
        return x === $__22 ? onReject(new TypeError): isPromise(x) ? x.then(onResolve, onReject): onResolve(x);
      }), onReject);
    }
  }, {
    resolve: function(x) {
      return new this((function(resolve, reject) {
        resolve(x);
      }));
    },
    reject: function(r) {
      return new this((function(resolve, reject) {
        reject(r);
      }));
    },
    cast: function(x) {
      if (x instanceof this) return x;
      if (isPromise(x)) {
        var result = getDeferred(this);
        chain(x, result.resolve, result.reject);
        return result.promise;
      }
      return this.resolve(x);
    },
    all: function(values) {
      var deferred = getDeferred(this);
      var count = 0;
      var resolutions = [];
      try {
        for (var i = 0; i < values.length; i++) {
          ++count;
          this.cast(values[i]).then(function(i, x) {
            resolutions[i] = x;
            if (--count === 0) deferred.resolve(resolutions);
          }.bind(undefined, i), (function(r) {
            if (count > 0) count = 0;
            deferred.reject(r);
          }));
        }
        if (count === 0) deferred.resolve(resolutions);
      } catch (e) {
        deferred.reject(e);
      }
      return deferred.promise;
    },
    race: function(values) {
      var deferred = getDeferred(this);
      try {
        for (var i = 0; i < values.length; i++) {
          this.cast(values[i]).then((function(x) {
            deferred.resolve(x);
          }), (function(r) {
            deferred.reject(r);
          }));
        }
      } catch (e) {
        deferred.reject(e);
      }
      return deferred.promise;
    }
  });
  function promiseResolve(promise, x) {
    promiseDone(promise, 'resolved', x, promise.onResolve_);
  }
  function promiseReject(promise, r) {
    promiseDone(promise, 'rejected', r, promise.onReject_);
  }
  function promiseDone(promise, status, value, reactions) {
    if (promise.status_ !== 'pending') return;
    for (var i = 0; i < reactions.length; i++) {
      promiseReact(reactions[i][0], reactions[i][1], value);
    }
    promise.status_ = status;
    promise.value_ = value;
    promise.onResolve_ = promise.onReject_ = undefined;
  }
  function promiseReact(deferred, handler, x) {
    async((function() {
      try {
        var y = handler(x);
        if (y === deferred.promise) throw new TypeError; else if (isPromise(y)) chain(y, deferred.resolve, deferred.reject); else deferred.resolve(y);
      } catch (e) {
        deferred.reject(e);
      }
    }));
  }
  var thenableSymbol = '@@thenable';
  function promiseCoerce(constructor, x) {
    if (isPromise(x)) {
      return x;
    } else if (x && typeof x.then === 'function') {
      var p = x[thenableSymbol];
      if (p) {
        return p;
      } else {
        var deferred = getDeferred(constructor);
        x[thenableSymbol] = deferred.promise;
        try {
          x.then(deferred.resolve, deferred.reject);
        } catch (e) {
          deferred.reject(e);
        }
        return deferred.promise;
      }
    } else {
      return x;
    }
  }
  return {get Promise() {
      return Promise;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/runtime/polyfills/String", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/runtime/polyfills/String";
  var $toString = Object.prototype.toString;
  var $indexOf = String.prototype.indexOf;
  var $lastIndexOf = String.prototype.lastIndexOf;
  function startsWith(search) {
    var string = String(this);
    if (this == null || $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var position = arguments.length > 1 ? arguments[1]: undefined;
    var pos = position ? Number(position): 0;
    if (isNaN(pos)) {
      pos = 0;
    }
    var start = Math.min(Math.max(pos, 0), stringLength);
    return $indexOf.call(string, searchString, pos) == start;
  }
  function endsWith(search) {
    var string = String(this);
    if (this == null || $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var pos = stringLength;
    if (arguments.length > 1) {
      var position = arguments[1];
      if (position !== undefined) {
        pos = position ? Number(position): 0;
        if (isNaN(pos)) {
          pos = 0;
        }
      }
    }
    var end = Math.min(Math.max(pos, 0), stringLength);
    var start = end - searchLength;
    if (start < 0) {
      return false;
    }
    return $lastIndexOf.call(string, searchString, start) == start;
  }
  function contains(search) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var position = arguments.length > 1 ? arguments[1]: undefined;
    var pos = position ? Number(position): 0;
    if (isNaN(pos)) {
      pos = 0;
    }
    var start = Math.min(Math.max(pos, 0), stringLength);
    return $indexOf.call(string, searchString, pos) != - 1;
  }
  function repeat(count) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var n = count ? Number(count): 0;
    if (isNaN(n)) {
      n = 0;
    }
    if (n < 0 || n == Infinity) {
      throw RangeError();
    }
    if (n == 0) {
      return '';
    }
    var result = '';
    while (n--) {
      result += string;
    }
    return result;
  }
  function codePointAt(position) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var size = string.length;
    var index = position ? Number(position): 0;
    if (isNaN(index)) {
      index = 0;
    }
    if (index < 0 || index >= size) {
      return undefined;
    }
    var first = string.charCodeAt(index);
    var second;
    if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {
      second = string.charCodeAt(index + 1);
      if (second >= 0xDC00 && second <= 0xDFFF) {
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }
  function raw(callsite) {
    var raw = callsite.raw;
    var len = raw.length >>> 0;
    if (len === 0) return '';
    var s = '';
    var i = 0;
    while (true) {
      s += raw[i];
      if (i + 1 === len) return s;
      s += arguments[++i];
    }
  }
  function fromCodePoint() {
    var codeUnits = [];
    var floor = Math.floor;
    var highSurrogate;
    var lowSurrogate;
    var index = - 1;
    var length = arguments.length;
    if (!length) {
      return '';
    }
    while (++index < length) {
      var codePoint = Number(arguments[index]);
      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {
        throw RangeError('Invalid code point: ' + codePoint);
      }
      if (codePoint <= 0xFFFF) {
        codeUnits.push(codePoint);
      } else {
        codePoint -= 0x10000;
        highSurrogate = (codePoint >> 10) + 0xD800;
        lowSurrogate = (codePoint % 0x400) + 0xDC00;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
    }
    return String.fromCharCode.apply(null, codeUnits);
  }
  return {
    get startsWith() {
      return startsWith;
    },
    get endsWith() {
      return endsWith;
    },
    get contains() {
      return contains;
    },
    get repeat() {
      return repeat;
    },
    get codePointAt() {
      return codePointAt;
    },
    get raw() {
      return raw;
    },
    get fromCodePoint() {
      return fromCodePoint;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/runtime/polyfills/polyfills", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/runtime/polyfills/polyfills";
  var Promise = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/polyfills/Promise").Promise;
  var $__25 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/polyfills/String"),
      codePointAt = $__25.codePointAt,
      contains = $__25.contains,
      endsWith = $__25.endsWith,
      fromCodePoint = $__25.fromCodePoint,
      repeat = $__25.repeat,
      raw = $__25.raw,
      startsWith = $__25.startsWith;
  var $__25 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/polyfills/ArrayIterator"),
      entries = $__25.entries,
      keys = $__25.keys,
      values = $__25.values;
  function maybeDefineMethod(object, name, value) {
    if (!(name in object)) {
      Object.defineProperty(object, name, {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
  }
  function maybeAddFunctions(object, functions) {
    for (var i = 0; i < functions.length; i += 2) {
      var name = functions[i];
      var value = functions[i + 1];
      maybeDefineMethod(object, name, value);
    }
  }
  function polyfillPromise(global) {
    if (!global.Promise) global.Promise = Promise;
  }
  function polyfillString(String) {
    maybeAddFunctions(String.prototype, ['codePointAt', codePointAt, 'contains', contains, 'endsWith', endsWith, 'startsWith', startsWith, 'repeat', repeat]);
    maybeAddFunctions(String, ['fromCodePoint', fromCodePoint, 'raw', raw]);
  }
  function polyfillArray(Array, Symbol) {
    maybeAddFunctions(Array.prototype, ['entries', entries, 'keys', keys, 'values', values]);
    if (Symbol && Symbol.iterator) {
      Object.defineProperty(Array.prototype, Symbol.iterator, {
        value: values,
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
  }
  function polyfill(global) {
    polyfillPromise(global);
    polyfillString(global.String);
    polyfillArray(global.Array, global.Symbol);
  }
  polyfill(this);
  var setupGlobals = $traceurRuntime.setupGlobals;
  $traceurRuntime.setupGlobals = function(global) {
    setupGlobals(global);
    polyfill(global);
  };
  return {};
});
var $__27 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/polyfills/polyfills");
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/options", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/options";
  var parseOptions = Object.create(null);
  var transformOptions = Object.create(null);
  var defaultValues = Object.create(null);
  var experimentalOptions = Object.create(null);
  var options = {
    set experimental(v) {
      v = coerceOptionValue(v);
      Object.keys(experimentalOptions).forEach((function(name) {
        options[name] = v;
      }));
    },
    get experimental() {
      var value;
      Object.keys(experimentalOptions).every((function(name) {
        var currentValue = options[name];
        if (value === undefined) {
          value = currentValue;
          return true;
        }
        if (currentValue !== value) {
          value = null;
          return false;
        }
        return true;
      }));
      return value;
    }
  };
  var descriptions = {experimental: 'Turns on all experimental features'};
  function reset() {
    var allOff = arguments[0];
    var useDefault = allOff === undefined;
    Object.keys(options).forEach((function(name) {
      options[name] = useDefault && defaultValues[name];
    }));
  }
  function fromString(s) {
    fromArgv(s.split(/\s+/));
  }
  function fromArgv(args) {
    args.forEach(parseCommand);
  }
  function setFromObject(object) {
    Object.keys(object).forEach((function(name) {
      options[name] = object[name];
    }));
  }
  function coerceOptionValue(v) {
    switch (v) {
      case 'false':
        return false;
      case 'true':
      case true:
        return true;
      default:
        return !!v && String(v);
    }
  }
  function setOption(name, value) {
    name = toCamelCase(name);
    value = coerceOptionValue(value);
    if (name in options) {
      options[name] = value;
    } else {
      throw Error('Unknown option: ' + name);
    }
  }
  function addOptions(flags) {
    Object.keys(options).forEach(function(name) {
      var dashedName = toDashCase(name);
      if ((name in parseOptions) && (name in transformOptions)) {
        flags.option('--' + dashedName + ' [true|false|parse]', descriptions[name]);
        flags.on(dashedName, (function(value) {
          return setOption(dashedName, value);
        }));
      } else if (options[name] !== null) {
        flags.option('--' + dashedName, descriptions[name]);
        flags.on(dashedName, (function() {
          return setOption(dashedName, true);
        }));
      }
    });
    flags.option('--referrer <name>', 'Bracket output code with System.referrerName=<name>', (function(name) {
      setOption('referrer', name);
      return name;
    }));
    flags.option('--type-assertion-module <path>', 'Absolute path to the type assertion module.', (function(path) {
      setOption('type-assertion-module', path);
      return path;
    }));
  }
  function filterOption(dashedName) {
    var name = toCamelCase(dashedName);
    return name === 'experimental' || !(name in options);
  }
  Object.defineProperties(options, {
    reset: {value: reset},
    fromString: {value: fromString},
    fromArgv: {value: fromArgv},
    setFromObject: {value: setFromObject},
    addOptions: {value: addOptions},
    filterOption: {value: filterOption}
  });
  function parseCommand(s) {
    var re = /--([^=]+)(?:=(.+))?/;
    var m = re.exec(s);
    if (m) setOption(m[1], m[2] || true);
  }
  function toCamelCase(s) {
    return s.replace(/-\w/g, function(ch) {
      return ch[1].toUpperCase();
    });
  }
  function toDashCase(s) {
    return s.replace(/[A-W]/g, function(ch) {
      return '-' + ch.toLowerCase();
    });
  }
  var EXPERIMENTAL = 0;
  var ON_BY_DEFAULT = 1;
  function addFeatureOption(name, kind) {
    if (kind === EXPERIMENTAL) experimentalOptions[name] = true;
    Object.defineProperty(parseOptions, name, {
      get: function() {
        return !!options[name];
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(transformOptions, name, {
      get: function() {
        var v = options[name];
        if (v === 'parse') return false;
        return v;
      },
      enumerable: true,
      configurable: true
    });
    var defaultValue = kind === ON_BY_DEFAULT;
    options[name] = defaultValue;
    defaultValues[name] = defaultValue;
  }
  function addBoolOption(name) {
    defaultValues[name] = false;
    options[name] = false;
  }
  addFeatureOption('arrayComprehension', ON_BY_DEFAULT);
  addFeatureOption('arrowFunctions', ON_BY_DEFAULT);
  addFeatureOption('classes', ON_BY_DEFAULT);
  addFeatureOption('computedPropertyNames', ON_BY_DEFAULT);
  addFeatureOption('defaultParameters', ON_BY_DEFAULT);
  addFeatureOption('destructuring', ON_BY_DEFAULT);
  addFeatureOption('forOf', ON_BY_DEFAULT);
  addFeatureOption('generatorComprehension', ON_BY_DEFAULT);
  addFeatureOption('generators', ON_BY_DEFAULT);
  addFeatureOption('modules', ON_BY_DEFAULT);
  addFeatureOption('numericLiterals', ON_BY_DEFAULT);
  addFeatureOption('propertyMethods', ON_BY_DEFAULT);
  addFeatureOption('propertyNameShorthand', ON_BY_DEFAULT);
  addFeatureOption('restParameters', ON_BY_DEFAULT);
  addFeatureOption('spread', ON_BY_DEFAULT);
  addFeatureOption('templateLiterals', ON_BY_DEFAULT);
  addFeatureOption('blockBinding', EXPERIMENTAL);
  addFeatureOption('symbols', EXPERIMENTAL);
  addFeatureOption('deferredFunctions', EXPERIMENTAL);
  addFeatureOption('types', EXPERIMENTAL);
  addFeatureOption('annotations', EXPERIMENTAL);
  addBoolOption('debug');
  addBoolOption('sourceMaps');
  addBoolOption('freeVariableChecker');
  addBoolOption('validate');
  addBoolOption('unstarredGenerators');
  addBoolOption('typeAssertions');
  defaultValues.referrer = '';
  options.referrer = null;
  defaultValues.typeAssertionModule = null;
  options.typeAssertionModule = null;
  return {
    get parseOptions() {
      return parseOptions;
    },
    get transformOptions() {
      return transformOptions;
    },
    get options() {
      return options;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/TokenType", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/TokenType";
  var AMPERSAND = '&';
  var AMPERSAND_EQUAL = '&=';
  var AND = '&&';
  var ARROW = '=>';
  var AT = '@';
  var AWAIT = 'await';
  var BACK_QUOTE = '`';
  var BANG = '!';
  var BAR = '|';
  var BAR_EQUAL = '|=';
  var BREAK = 'break';
  var CARET = '^';
  var CARET_EQUAL = '^=';
  var CASE = 'case';
  var CATCH = 'catch';
  var CLASS = 'class';
  var CLOSE_ANGLE = '>';
  var CLOSE_CURLY = '}';
  var CLOSE_PAREN = ')';
  var CLOSE_SQUARE = ']';
  var COLON = ':';
  var COMMA = ',';
  var CONST = 'const';
  var CONTINUE = 'continue';
  var DEBUGGER = 'debugger';
  var DEFAULT = 'default';
  var DELETE = 'delete';
  var DO = 'do';
  var DOT_DOT_DOT = '...';
  var ELSE = 'else';
  var END_OF_FILE = 'End of File';
  var ENUM = 'enum';
  var EQUAL = '=';
  var EQUAL_EQUAL = '==';
  var EQUAL_EQUAL_EQUAL = '===';
  var ERROR = 'error';
  var EXPORT = 'export';
  var EXTENDS = 'extends';
  var FALSE = 'false';
  var FINALLY = 'finally';
  var FOR = 'for';
  var FUNCTION = 'function';
  var GREATER_EQUAL = '>=';
  var IDENTIFIER = 'identifier';
  var IF = 'if';
  var IMPLEMENTS = 'implements';
  var IMPORT = 'import';
  var IN = 'in';
  var INSTANCEOF = 'instanceof';
  var INTERFACE = 'interface';
  var LEFT_SHIFT = '<<';
  var LEFT_SHIFT_EQUAL = '<<=';
  var LESS_EQUAL = '<=';
  var LET = 'let';
  var MINUS = '-';
  var MINUS_EQUAL = '-=';
  var MINUS_MINUS = '--';
  var NEW = 'new';
  var NO_SUBSTITUTION_TEMPLATE = 'no substitution template';
  var NOT_EQUAL = '!=';
  var NOT_EQUAL_EQUAL = '!==';
  var NULL = 'null';
  var NUMBER = 'number literal';
  var OPEN_ANGLE = '<';
  var OPEN_CURLY = '{';
  var OPEN_PAREN = '(';
  var OPEN_SQUARE = '[';
  var OR = '||';
  var PACKAGE = 'package';
  var PERCENT = '%';
  var PERCENT_EQUAL = '%=';
  var PERIOD = '.';
  var PLUS = '+';
  var PLUS_EQUAL = '+=';
  var PLUS_PLUS = '++';
  var PRIVATE = 'private';
  var PROTECTED = 'protected';
  var PUBLIC = 'public';
  var QUESTION = '?';
  var REGULAR_EXPRESSION = 'regular expression literal';
  var RETURN = 'return';
  var RIGHT_SHIFT = '>>';
  var RIGHT_SHIFT_EQUAL = '>>=';
  var SEMI_COLON = ';';
  var SLASH = '/';
  var SLASH_EQUAL = '/=';
  var STAR = '*';
  var STAR_EQUAL = '*=';
  var STATIC = 'static';
  var STRING = 'string literal';
  var SUPER = 'super';
  var SWITCH = 'switch';
  var TEMPLATE_HEAD = 'template head';
  var TEMPLATE_MIDDLE = 'template middle';
  var TEMPLATE_TAIL = 'template tail';
  var THIS = 'this';
  var THROW = 'throw';
  var TILDE = '~';
  var TRUE = 'true';
  var TRY = 'try';
  var TYPEOF = 'typeof';
  var UNSIGNED_RIGHT_SHIFT = '>>>';
  var UNSIGNED_RIGHT_SHIFT_EQUAL = '>>>=';
  var VAR = 'var';
  var VOID = 'void';
  var WHILE = 'while';
  var WITH = 'with';
  var YIELD = 'yield';
  return {
    get AMPERSAND() {
      return AMPERSAND;
    },
    get AMPERSAND_EQUAL() {
      return AMPERSAND_EQUAL;
    },
    get AND() {
      return AND;
    },
    get ARROW() {
      return ARROW;
    },
    get AT() {
      return AT;
    },
    get AWAIT() {
      return AWAIT;
    },
    get BACK_QUOTE() {
      return BACK_QUOTE;
    },
    get BANG() {
      return BANG;
    },
    get BAR() {
      return BAR;
    },
    get BAR_EQUAL() {
      return BAR_EQUAL;
    },
    get BREAK() {
      return BREAK;
    },
    get CARET() {
      return CARET;
    },
    get CARET_EQUAL() {
      return CARET_EQUAL;
    },
    get CASE() {
      return CASE;
    },
    get CATCH() {
      return CATCH;
    },
    get CLASS() {
      return CLASS;
    },
    get CLOSE_ANGLE() {
      return CLOSE_ANGLE;
    },
    get CLOSE_CURLY() {
      return CLOSE_CURLY;
    },
    get CLOSE_PAREN() {
      return CLOSE_PAREN;
    },
    get CLOSE_SQUARE() {
      return CLOSE_SQUARE;
    },
    get COLON() {
      return COLON;
    },
    get COMMA() {
      return COMMA;
    },
    get CONST() {
      return CONST;
    },
    get CONTINUE() {
      return CONTINUE;
    },
    get DEBUGGER() {
      return DEBUGGER;
    },
    get DEFAULT() {
      return DEFAULT;
    },
    get DELETE() {
      return DELETE;
    },
    get DO() {
      return DO;
    },
    get DOT_DOT_DOT() {
      return DOT_DOT_DOT;
    },
    get ELSE() {
      return ELSE;
    },
    get END_OF_FILE() {
      return END_OF_FILE;
    },
    get ENUM() {
      return ENUM;
    },
    get EQUAL() {
      return EQUAL;
    },
    get EQUAL_EQUAL() {
      return EQUAL_EQUAL;
    },
    get EQUAL_EQUAL_EQUAL() {
      return EQUAL_EQUAL_EQUAL;
    },
    get ERROR() {
      return ERROR;
    },
    get EXPORT() {
      return EXPORT;
    },
    get EXTENDS() {
      return EXTENDS;
    },
    get FALSE() {
      return FALSE;
    },
    get FINALLY() {
      return FINALLY;
    },
    get FOR() {
      return FOR;
    },
    get FUNCTION() {
      return FUNCTION;
    },
    get GREATER_EQUAL() {
      return GREATER_EQUAL;
    },
    get IDENTIFIER() {
      return IDENTIFIER;
    },
    get IF() {
      return IF;
    },
    get IMPLEMENTS() {
      return IMPLEMENTS;
    },
    get IMPORT() {
      return IMPORT;
    },
    get IN() {
      return IN;
    },
    get INSTANCEOF() {
      return INSTANCEOF;
    },
    get INTERFACE() {
      return INTERFACE;
    },
    get LEFT_SHIFT() {
      return LEFT_SHIFT;
    },
    get LEFT_SHIFT_EQUAL() {
      return LEFT_SHIFT_EQUAL;
    },
    get LESS_EQUAL() {
      return LESS_EQUAL;
    },
    get LET() {
      return LET;
    },
    get MINUS() {
      return MINUS;
    },
    get MINUS_EQUAL() {
      return MINUS_EQUAL;
    },
    get MINUS_MINUS() {
      return MINUS_MINUS;
    },
    get NEW() {
      return NEW;
    },
    get NO_SUBSTITUTION_TEMPLATE() {
      return NO_SUBSTITUTION_TEMPLATE;
    },
    get NOT_EQUAL() {
      return NOT_EQUAL;
    },
    get NOT_EQUAL_EQUAL() {
      return NOT_EQUAL_EQUAL;
    },
    get NULL() {
      return NULL;
    },
    get NUMBER() {
      return NUMBER;
    },
    get OPEN_ANGLE() {
      return OPEN_ANGLE;
    },
    get OPEN_CURLY() {
      return OPEN_CURLY;
    },
    get OPEN_PAREN() {
      return OPEN_PAREN;
    },
    get OPEN_SQUARE() {
      return OPEN_SQUARE;
    },
    get OR() {
      return OR;
    },
    get PACKAGE() {
      return PACKAGE;
    },
    get PERCENT() {
      return PERCENT;
    },
    get PERCENT_EQUAL() {
      return PERCENT_EQUAL;
    },
    get PERIOD() {
      return PERIOD;
    },
    get PLUS() {
      return PLUS;
    },
    get PLUS_EQUAL() {
      return PLUS_EQUAL;
    },
    get PLUS_PLUS() {
      return PLUS_PLUS;
    },
    get PRIVATE() {
      return PRIVATE;
    },
    get PROTECTED() {
      return PROTECTED;
    },
    get PUBLIC() {
      return PUBLIC;
    },
    get QUESTION() {
      return QUESTION;
    },
    get REGULAR_EXPRESSION() {
      return REGULAR_EXPRESSION;
    },
    get RETURN() {
      return RETURN;
    },
    get RIGHT_SHIFT() {
      return RIGHT_SHIFT;
    },
    get RIGHT_SHIFT_EQUAL() {
      return RIGHT_SHIFT_EQUAL;
    },
    get SEMI_COLON() {
      return SEMI_COLON;
    },
    get SLASH() {
      return SLASH;
    },
    get SLASH_EQUAL() {
      return SLASH_EQUAL;
    },
    get STAR() {
      return STAR;
    },
    get STAR_EQUAL() {
      return STAR_EQUAL;
    },
    get STATIC() {
      return STATIC;
    },
    get STRING() {
      return STRING;
    },
    get SUPER() {
      return SUPER;
    },
    get SWITCH() {
      return SWITCH;
    },
    get TEMPLATE_HEAD() {
      return TEMPLATE_HEAD;
    },
    get TEMPLATE_MIDDLE() {
      return TEMPLATE_MIDDLE;
    },
    get TEMPLATE_TAIL() {
      return TEMPLATE_TAIL;
    },
    get THIS() {
      return THIS;
    },
    get THROW() {
      return THROW;
    },
    get TILDE() {
      return TILDE;
    },
    get TRUE() {
      return TRUE;
    },
    get TRY() {
      return TRY;
    },
    get TYPEOF() {
      return TYPEOF;
    },
    get UNSIGNED_RIGHT_SHIFT() {
      return UNSIGNED_RIGHT_SHIFT;
    },
    get UNSIGNED_RIGHT_SHIFT_EQUAL() {
      return UNSIGNED_RIGHT_SHIFT_EQUAL;
    },
    get VAR() {
      return VAR;
    },
    get VOID() {
      return VOID;
    },
    get WHILE() {
      return WHILE;
    },
    get WITH() {
      return WITH;
    },
    get YIELD() {
      return YIELD;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/Token", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/Token";
  var $__29 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      AMPERSAND_EQUAL = $__29.AMPERSAND_EQUAL,
      BAR_EQUAL = $__29.BAR_EQUAL,
      CARET_EQUAL = $__29.CARET_EQUAL,
      EQUAL = $__29.EQUAL,
      LEFT_SHIFT_EQUAL = $__29.LEFT_SHIFT_EQUAL,
      MINUS_EQUAL = $__29.MINUS_EQUAL,
      PERCENT_EQUAL = $__29.PERCENT_EQUAL,
      PLUS_EQUAL = $__29.PLUS_EQUAL,
      RIGHT_SHIFT_EQUAL = $__29.RIGHT_SHIFT_EQUAL,
      SLASH_EQUAL = $__29.SLASH_EQUAL,
      STAR_EQUAL = $__29.STAR_EQUAL,
      UNSIGNED_RIGHT_SHIFT_EQUAL = $__29.UNSIGNED_RIGHT_SHIFT_EQUAL;
  var Token = function Token(type, location) {
    this.type = type;
    this.location = location;
  };
  ($traceurRuntime.createClass)(Token, {
    toString: function() {
      return this.type;
    },
    isAssignmentOperator: function() {
      return isAssignmentOperator(this.type);
    },
    isKeyword: function() {
      return false;
    },
    isStrictKeyword: function() {
      return false;
    }
  }, {});
  function isAssignmentOperator(type) {
    switch (type) {
      case AMPERSAND_EQUAL:
      case BAR_EQUAL:
      case CARET_EQUAL:
      case EQUAL:
      case LEFT_SHIFT_EQUAL:
      case MINUS_EQUAL:
      case PERCENT_EQUAL:
      case PLUS_EQUAL:
      case RIGHT_SHIFT_EQUAL:
      case SLASH_EQUAL:
      case STAR_EQUAL:
      case UNSIGNED_RIGHT_SHIFT_EQUAL:
        return true;
    }
    return false;
  }
  return {
    get Token() {
      return Token;
    },
    get isAssignmentOperator() {
      return isAssignmentOperator;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/IdentifierToken", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/IdentifierToken";
  var Token = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Token").Token;
  var IDENTIFIER = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").IDENTIFIER;
  var IdentifierToken = function IdentifierToken(location, value) {
    this.location = location;
    this.value = value;
  };
  ($traceurRuntime.createClass)(IdentifierToken, {
    toString: function() {
      return this.value;
    },
    get type() {
      return IDENTIFIER;
    }
  }, {}, Token);
  return {get IdentifierToken() {
      return IdentifierToken;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/ParseTreeVisitor", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/ParseTreeVisitor";
  var ParseTreeVisitor = function ParseTreeVisitor() {};
  ($traceurRuntime.createClass)(ParseTreeVisitor, {
    visitAny: function(tree) {
      tree && tree.visit(this);
    },
    visit: function(tree) {
      this.visitAny(tree);
    },
    visitList: function(list) {
      if (list) {
        for (var i = 0; i < list.length; i++) {
          this.visitAny(list[i]);
        }
      }
    },
    visitStateMachine: function(tree) {
      throw Error('State machines should not live outside of the GeneratorTransformer.');
    },
    visitAnnotation: function(tree) {
      this.visitAny(tree.name);
      this.visitAny(tree.args);
    },
    visitAnonBlock: function(tree) {
      this.visitList(tree.statements);
    },
    visitArgumentList: function(tree) {
      this.visitList(tree.args);
    },
    visitArrayComprehension: function(tree) {
      this.visitList(tree.comprehensionList);
      this.visitAny(tree.expression);
    },
    visitArrayLiteralExpression: function(tree) {
      this.visitList(tree.elements);
    },
    visitArrayPattern: function(tree) {
      this.visitList(tree.elements);
    },
    visitArrowFunctionExpression: function(tree) {
      this.visitAny(tree.formalParameters);
      this.visitAny(tree.functionBody);
    },
    visitAwaitStatement: function(tree) {
      this.visitAny(tree.expression);
    },
    visitBinaryOperator: function(tree) {
      this.visitAny(tree.left);
      this.visitAny(tree.right);
    },
    visitBindingElement: function(tree) {
      this.visitAny(tree.binding);
      this.visitAny(tree.initialiser);
    },
    visitBindingIdentifier: function(tree) {},
    visitBlock: function(tree) {
      this.visitList(tree.statements);
    },
    visitBreakStatement: function(tree) {},
    visitCallExpression: function(tree) {
      this.visitAny(tree.operand);
      this.visitAny(tree.args);
    },
    visitCaseClause: function(tree) {
      this.visitAny(tree.expression);
      this.visitList(tree.statements);
    },
    visitCatch: function(tree) {
      this.visitAny(tree.binding);
      this.visitAny(tree.catchBody);
    },
    visitClassDeclaration: function(tree) {
      this.visitAny(tree.name);
      this.visitAny(tree.superClass);
      this.visitList(tree.elements);
      this.visitList(tree.annotations);
    },
    visitClassExpression: function(tree) {
      this.visitAny(tree.name);
      this.visitAny(tree.superClass);
      this.visitList(tree.elements);
      this.visitList(tree.annotations);
    },
    visitCommaExpression: function(tree) {
      this.visitList(tree.expressions);
    },
    visitComprehensionFor: function(tree) {
      this.visitAny(tree.left);
      this.visitAny(tree.iterator);
    },
    visitComprehensionIf: function(tree) {
      this.visitAny(tree.expression);
    },
    visitComputedPropertyName: function(tree) {
      this.visitAny(tree.expression);
    },
    visitConditionalExpression: function(tree) {
      this.visitAny(tree.condition);
      this.visitAny(tree.left);
      this.visitAny(tree.right);
    },
    visitContinueStatement: function(tree) {},
    visitCoverFormals: function(tree) {
      this.visitList(tree.expressions);
    },
    visitCoverInitialisedName: function(tree) {
      this.visitAny(tree.initialiser);
    },
    visitDebuggerStatement: function(tree) {},
    visitDefaultClause: function(tree) {
      this.visitList(tree.statements);
    },
    visitDoWhileStatement: function(tree) {
      this.visitAny(tree.body);
      this.visitAny(tree.condition);
    },
    visitEmptyStatement: function(tree) {},
    visitExportDeclaration: function(tree) {
      this.visitAny(tree.declaration);
      this.visitList(tree.annotations);
    },
    visitExportDefault: function(tree) {
      this.visitAny(tree.expression);
    },
    visitExportSpecifier: function(tree) {},
    visitExportSpecifierSet: function(tree) {
      this.visitList(tree.specifiers);
    },
    visitExportStar: function(tree) {},
    visitExpressionStatement: function(tree) {
      this.visitAny(tree.expression);
    },
    visitFinally: function(tree) {
      this.visitAny(tree.block);
    },
    visitForInStatement: function(tree) {
      this.visitAny(tree.initialiser);
      this.visitAny(tree.collection);
      this.visitAny(tree.body);
    },
    visitForOfStatement: function(tree) {
      this.visitAny(tree.initialiser);
      this.visitAny(tree.collection);
      this.visitAny(tree.body);
    },
    visitForStatement: function(tree) {
      this.visitAny(tree.initialiser);
      this.visitAny(tree.condition);
      this.visitAny(tree.increment);
      this.visitAny(tree.body);
    },
    visitFormalParameter: function(tree) {
      this.visitAny(tree.parameter);
      this.visitAny(tree.typeAnnotation);
      this.visitList(tree.annotations);
    },
    visitFormalParameterList: function(tree) {
      this.visitList(tree.parameters);
    },
    visitFunctionBody: function(tree) {
      this.visitList(tree.statements);
    },
    visitFunctionDeclaration: function(tree) {
      this.visitAny(tree.name);
      this.visitAny(tree.formalParameterList);
      this.visitAny(tree.typeAnnotation);
      this.visitList(tree.annotations);
      this.visitAny(tree.functionBody);
    },
    visitFunctionExpression: function(tree) {
      this.visitAny(tree.name);
      this.visitAny(tree.formalParameterList);
      this.visitAny(tree.typeAnnotation);
      this.visitList(tree.annotations);
      this.visitAny(tree.functionBody);
    },
    visitGeneratorComprehension: function(tree) {
      this.visitList(tree.comprehensionList);
      this.visitAny(tree.expression);
    },
    visitGetAccessor: function(tree) {
      this.visitAny(tree.name);
      this.visitAny(tree.typeAnnotation);
      this.visitList(tree.annotations);
      this.visitAny(tree.body);
    },
    visitIdentifierExpression: function(tree) {},
    visitIfStatement: function(tree) {
      this.visitAny(tree.condition);
      this.visitAny(tree.ifClause);
      this.visitAny(tree.elseClause);
    },
    visitImportedBinding: function(tree) {
      this.visitAny(tree.binding);
    },
    visitImportDeclaration: function(tree) {
      this.visitAny(tree.importClause);
      this.visitAny(tree.moduleSpecifier);
    },
    visitImportSpecifier: function(tree) {},
    visitImportSpecifierSet: function(tree) {
      this.visitList(tree.specifiers);
    },
    visitLabelledStatement: function(tree) {
      this.visitAny(tree.statement);
    },
    visitLiteralExpression: function(tree) {},
    visitLiteralPropertyName: function(tree) {},
    visitMemberExpression: function(tree) {
      this.visitAny(tree.operand);
    },
    visitMemberLookupExpression: function(tree) {
      this.visitAny(tree.operand);
      this.visitAny(tree.memberExpression);
    },
    visitModule: function(tree) {
      this.visitList(tree.scriptItemList);
    },
    visitModuleDeclaration: function(tree) {
      this.visitAny(tree.expression);
    },
    visitModuleSpecifier: function(tree) {},
    visitNamedExport: function(tree) {
      this.visitAny(tree.moduleSpecifier);
      this.visitAny(tree.specifierSet);
    },
    visitNewExpression: function(tree) {
      this.visitAny(tree.operand);
      this.visitAny(tree.args);
    },
    visitObjectLiteralExpression: function(tree) {
      this.visitList(tree.propertyNameAndValues);
    },
    visitObjectPattern: function(tree) {
      this.visitList(tree.fields);
    },
    visitObjectPatternField: function(tree) {
      this.visitAny(tree.name);
      this.visitAny(tree.element);
    },
    visitParenExpression: function(tree) {
      this.visitAny(tree.expression);
    },
    visitPostfixExpression: function(tree) {
      this.visitAny(tree.operand);
    },
    visitPredefinedType: function(tree) {},
    visitScript: function(tree) {
      this.visitList(tree.scriptItemList);
    },
    visitPropertyMethodAssignment: function(tree) {
      this.visitAny(tree.name);
      this.visitAny(tree.formalParameterList);
      this.visitAny(tree.typeAnnotation);
      this.visitList(tree.annotations);
      this.visitAny(tree.functionBody);
    },
    visitPropertyNameAssignment: function(tree) {
      this.visitAny(tree.name);
      this.visitAny(tree.value);
    },
    visitPropertyNameShorthand: function(tree) {},
    visitRestParameter: function(tree) {
      this.visitAny(tree.identifier);
    },
    visitReturnStatement: function(tree) {
      this.visitAny(tree.expression);
    },
    visitSetAccessor: function(tree) {
      this.visitAny(tree.name);
      this.visitAny(tree.parameter);
      this.visitList(tree.annotations);
      this.visitAny(tree.body);
    },
    visitSpreadExpression: function(tree) {
      this.visitAny(tree.expression);
    },
    visitSpreadPatternElement: function(tree) {
      this.visitAny(tree.lvalue);
    },
    visitSuperExpression: function(tree) {},
    visitSwitchStatement: function(tree) {
      this.visitAny(tree.expression);
      this.visitList(tree.caseClauses);
    },
    visitSyntaxErrorTree: function(tree) {},
    visitTemplateLiteralExpression: function(tree) {
      this.visitAny(tree.operand);
      this.visitList(tree.elements);
    },
    visitTemplateLiteralPortion: function(tree) {},
    visitTemplateSubstitution: function(tree) {
      this.visitAny(tree.expression);
    },
    visitThisExpression: function(tree) {},
    visitThrowStatement: function(tree) {
      this.visitAny(tree.value);
    },
    visitTryStatement: function(tree) {
      this.visitAny(tree.body);
      this.visitAny(tree.catchBlock);
      this.visitAny(tree.finallyBlock);
    },
    visitTypeName: function(tree) {
      this.visitAny(tree.moduleName);
    },
    visitUnaryExpression: function(tree) {
      this.visitAny(tree.operand);
    },
    visitVariableDeclaration: function(tree) {
      this.visitAny(tree.lvalue);
      this.visitAny(tree.typeAnnotation);
      this.visitAny(tree.initialiser);
    },
    visitVariableDeclarationList: function(tree) {
      this.visitList(tree.declarations);
    },
    visitVariableStatement: function(tree) {
      this.visitAny(tree.declarations);
    },
    visitWhileStatement: function(tree) {
      this.visitAny(tree.condition);
      this.visitAny(tree.body);
    },
    visitWithStatement: function(tree) {
      this.visitAny(tree.expression);
      this.visitAny(tree.body);
    },
    visitYieldExpression: function(tree) {
      this.visitAny(tree.expression);
    }
  }, {});
  return {get ParseTreeVisitor() {
      return ParseTreeVisitor;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/PredefinedName", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/PredefinedName";
  var ANY = 'any';
  var $ARGUMENTS = '$arguments';
  var APPLY = 'apply';
  var ARGUMENTS = 'arguments';
  var ARRAY = 'Array';
  var AS = 'as';
  var BIND = 'bind';
  var CALL = 'call';
  var CONFIGURABLE = 'configurable';
  var CONSTRUCTOR = 'constructor';
  var CREATE = 'create';
  var CURRENT = 'current';
  var DEFINE_PROPERTIES = 'defineProperties';
  var DEFINE_PROPERTY = 'defineProperty';
  var ENUMERABLE = 'enumerable';
  var FREEZE = 'freeze';
  var FROM = 'from';
  var FUNCTION = 'Function';
  var GET = 'get';
  var HAS = 'has';
  var LENGTH = 'length';
  var MODULE = 'module';
  var NEW = 'new';
  var OBJECT = 'Object';
  var OBJECT_NAME = 'Object';
  var OF = 'of';
  var PREVENT_EXTENSIONS = 'preventExtensions';
  var PROTOTYPE = 'prototype';
  var PUSH = 'push';
  var RAW = 'raw';
  var SET = 'set';
  var SLICE = 'slice';
  var THIS = 'this';
  var TRACEUR_RUNTIME = '$traceurRuntime';
  var UNDEFINED = 'undefined';
  var WRITABLE = 'writable';
  function getParameterName(index) {
    return '$' + index;
  }
  ;
  return {
    get ANY() {
      return ANY;
    },
    get $ARGUMENTS() {
      return $ARGUMENTS;
    },
    get APPLY() {
      return APPLY;
    },
    get ARGUMENTS() {
      return ARGUMENTS;
    },
    get ARRAY() {
      return ARRAY;
    },
    get AS() {
      return AS;
    },
    get BIND() {
      return BIND;
    },
    get CALL() {
      return CALL;
    },
    get CONFIGURABLE() {
      return CONFIGURABLE;
    },
    get CONSTRUCTOR() {
      return CONSTRUCTOR;
    },
    get CREATE() {
      return CREATE;
    },
    get CURRENT() {
      return CURRENT;
    },
    get DEFINE_PROPERTIES() {
      return DEFINE_PROPERTIES;
    },
    get DEFINE_PROPERTY() {
      return DEFINE_PROPERTY;
    },
    get ENUMERABLE() {
      return ENUMERABLE;
    },
    get FREEZE() {
      return FREEZE;
    },
    get FROM() {
      return FROM;
    },
    get FUNCTION() {
      return FUNCTION;
    },
    get GET() {
      return GET;
    },
    get HAS() {
      return HAS;
    },
    get LENGTH() {
      return LENGTH;
    },
    get MODULE() {
      return MODULE;
    },
    get NEW() {
      return NEW;
    },
    get OBJECT() {
      return OBJECT;
    },
    get OBJECT_NAME() {
      return OBJECT_NAME;
    },
    get OF() {
      return OF;
    },
    get PREVENT_EXTENSIONS() {
      return PREVENT_EXTENSIONS;
    },
    get PROTOTYPE() {
      return PROTOTYPE;
    },
    get PUSH() {
      return PUSH;
    },
    get RAW() {
      return RAW;
    },
    get SET() {
      return SET;
    },
    get SLICE() {
      return SLICE;
    },
    get THIS() {
      return THIS;
    },
    get TRACEUR_RUNTIME() {
      return TRACEUR_RUNTIME;
    },
    get UNDEFINED() {
      return UNDEFINED;
    },
    get WRITABLE() {
      return WRITABLE;
    },
    get getParameterName() {
      return getParameterName;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/trees/ParseTreeType", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/trees/ParseTreeType";
  var ANNOTATION = 'ANNOTATION';
  var ANON_BLOCK = 'ANON_BLOCK';
  var ARGUMENT_LIST = 'ARGUMENT_LIST';
  var ARRAY_COMPREHENSION = 'ARRAY_COMPREHENSION';
  var ARRAY_LITERAL_EXPRESSION = 'ARRAY_LITERAL_EXPRESSION';
  var ARRAY_PATTERN = 'ARRAY_PATTERN';
  var ARROW_FUNCTION_EXPRESSION = 'ARROW_FUNCTION_EXPRESSION';
  var AWAIT_STATEMENT = 'AWAIT_STATEMENT';
  var BINARY_OPERATOR = 'BINARY_OPERATOR';
  var BINDING_ELEMENT = 'BINDING_ELEMENT';
  var BINDING_IDENTIFIER = 'BINDING_IDENTIFIER';
  var BLOCK = 'BLOCK';
  var BREAK_STATEMENT = 'BREAK_STATEMENT';
  var CALL_EXPRESSION = 'CALL_EXPRESSION';
  var CASE_CLAUSE = 'CASE_CLAUSE';
  var CATCH = 'CATCH';
  var CLASS_DECLARATION = 'CLASS_DECLARATION';
  var CLASS_EXPRESSION = 'CLASS_EXPRESSION';
  var COMMA_EXPRESSION = 'COMMA_EXPRESSION';
  var COMPREHENSION_FOR = 'COMPREHENSION_FOR';
  var COMPREHENSION_IF = 'COMPREHENSION_IF';
  var COMPUTED_PROPERTY_NAME = 'COMPUTED_PROPERTY_NAME';
  var CONDITIONAL_EXPRESSION = 'CONDITIONAL_EXPRESSION';
  var CONTINUE_STATEMENT = 'CONTINUE_STATEMENT';
  var COVER_FORMALS = 'COVER_FORMALS';
  var COVER_INITIALISED_NAME = 'COVER_INITIALISED_NAME';
  var DEBUGGER_STATEMENT = 'DEBUGGER_STATEMENT';
  var DEFAULT_CLAUSE = 'DEFAULT_CLAUSE';
  var DO_WHILE_STATEMENT = 'DO_WHILE_STATEMENT';
  var EMPTY_STATEMENT = 'EMPTY_STATEMENT';
  var EXPORT_DECLARATION = 'EXPORT_DECLARATION';
  var EXPORT_DEFAULT = 'EXPORT_DEFAULT';
  var EXPORT_SPECIFIER = 'EXPORT_SPECIFIER';
  var EXPORT_SPECIFIER_SET = 'EXPORT_SPECIFIER_SET';
  var EXPORT_STAR = 'EXPORT_STAR';
  var EXPRESSION_STATEMENT = 'EXPRESSION_STATEMENT';
  var FINALLY = 'FINALLY';
  var FOR_IN_STATEMENT = 'FOR_IN_STATEMENT';
  var FOR_OF_STATEMENT = 'FOR_OF_STATEMENT';
  var FOR_STATEMENT = 'FOR_STATEMENT';
  var FORMAL_PARAMETER = 'FORMAL_PARAMETER';
  var FORMAL_PARAMETER_LIST = 'FORMAL_PARAMETER_LIST';
  var FUNCTION_BODY = 'FUNCTION_BODY';
  var FUNCTION_DECLARATION = 'FUNCTION_DECLARATION';
  var FUNCTION_EXPRESSION = 'FUNCTION_EXPRESSION';
  var GENERATOR_COMPREHENSION = 'GENERATOR_COMPREHENSION';
  var GET_ACCESSOR = 'GET_ACCESSOR';
  var IDENTIFIER_EXPRESSION = 'IDENTIFIER_EXPRESSION';
  var IF_STATEMENT = 'IF_STATEMENT';
  var IMPORT_DECLARATION = 'IMPORT_DECLARATION';
  var IMPORT_SPECIFIER = 'IMPORT_SPECIFIER';
  var IMPORT_SPECIFIER_SET = 'IMPORT_SPECIFIER_SET';
  var IMPORTED_BINDING = 'IMPORTED_BINDING';
  var LABELLED_STATEMENT = 'LABELLED_STATEMENT';
  var LITERAL_EXPRESSION = 'LITERAL_EXPRESSION';
  var LITERAL_PROPERTY_NAME = 'LITERAL_PROPERTY_NAME';
  var MEMBER_EXPRESSION = 'MEMBER_EXPRESSION';
  var MEMBER_LOOKUP_EXPRESSION = 'MEMBER_LOOKUP_EXPRESSION';
  var MODULE = 'MODULE';
  var MODULE_DECLARATION = 'MODULE_DECLARATION';
  var MODULE_SPECIFIER = 'MODULE_SPECIFIER';
  var NAMED_EXPORT = 'NAMED_EXPORT';
  var NEW_EXPRESSION = 'NEW_EXPRESSION';
  var OBJECT_LITERAL_EXPRESSION = 'OBJECT_LITERAL_EXPRESSION';
  var OBJECT_PATTERN = 'OBJECT_PATTERN';
  var OBJECT_PATTERN_FIELD = 'OBJECT_PATTERN_FIELD';
  var PAREN_EXPRESSION = 'PAREN_EXPRESSION';
  var POSTFIX_EXPRESSION = 'POSTFIX_EXPRESSION';
  var PREDEFINED_TYPE = 'PREDEFINED_TYPE';
  var PROPERTY_METHOD_ASSIGNMENT = 'PROPERTY_METHOD_ASSIGNMENT';
  var PROPERTY_NAME_ASSIGNMENT = 'PROPERTY_NAME_ASSIGNMENT';
  var PROPERTY_NAME_SHORTHAND = 'PROPERTY_NAME_SHORTHAND';
  var REST_PARAMETER = 'REST_PARAMETER';
  var RETURN_STATEMENT = 'RETURN_STATEMENT';
  var SCRIPT = 'SCRIPT';
  var SET_ACCESSOR = 'SET_ACCESSOR';
  var SPREAD_EXPRESSION = 'SPREAD_EXPRESSION';
  var SPREAD_PATTERN_ELEMENT = 'SPREAD_PATTERN_ELEMENT';
  var STATE_MACHINE = 'STATE_MACHINE';
  var SUPER_EXPRESSION = 'SUPER_EXPRESSION';
  var SWITCH_STATEMENT = 'SWITCH_STATEMENT';
  var SYNTAX_ERROR_TREE = 'SYNTAX_ERROR_TREE';
  var TEMPLATE_LITERAL_EXPRESSION = 'TEMPLATE_LITERAL_EXPRESSION';
  var TEMPLATE_LITERAL_PORTION = 'TEMPLATE_LITERAL_PORTION';
  var TEMPLATE_SUBSTITUTION = 'TEMPLATE_SUBSTITUTION';
  var THIS_EXPRESSION = 'THIS_EXPRESSION';
  var THROW_STATEMENT = 'THROW_STATEMENT';
  var TRY_STATEMENT = 'TRY_STATEMENT';
  var TYPE_NAME = 'TYPE_NAME';
  var UNARY_EXPRESSION = 'UNARY_EXPRESSION';
  var VARIABLE_DECLARATION = 'VARIABLE_DECLARATION';
  var VARIABLE_DECLARATION_LIST = 'VARIABLE_DECLARATION_LIST';
  var VARIABLE_STATEMENT = 'VARIABLE_STATEMENT';
  var WHILE_STATEMENT = 'WHILE_STATEMENT';
  var WITH_STATEMENT = 'WITH_STATEMENT';
  var YIELD_EXPRESSION = 'YIELD_EXPRESSION';
  return {
    get ANNOTATION() {
      return ANNOTATION;
    },
    get ANON_BLOCK() {
      return ANON_BLOCK;
    },
    get ARGUMENT_LIST() {
      return ARGUMENT_LIST;
    },
    get ARRAY_COMPREHENSION() {
      return ARRAY_COMPREHENSION;
    },
    get ARRAY_LITERAL_EXPRESSION() {
      return ARRAY_LITERAL_EXPRESSION;
    },
    get ARRAY_PATTERN() {
      return ARRAY_PATTERN;
    },
    get ARROW_FUNCTION_EXPRESSION() {
      return ARROW_FUNCTION_EXPRESSION;
    },
    get AWAIT_STATEMENT() {
      return AWAIT_STATEMENT;
    },
    get BINARY_OPERATOR() {
      return BINARY_OPERATOR;
    },
    get BINDING_ELEMENT() {
      return BINDING_ELEMENT;
    },
    get BINDING_IDENTIFIER() {
      return BINDING_IDENTIFIER;
    },
    get BLOCK() {
      return BLOCK;
    },
    get BREAK_STATEMENT() {
      return BREAK_STATEMENT;
    },
    get CALL_EXPRESSION() {
      return CALL_EXPRESSION;
    },
    get CASE_CLAUSE() {
      return CASE_CLAUSE;
    },
    get CATCH() {
      return CATCH;
    },
    get CLASS_DECLARATION() {
      return CLASS_DECLARATION;
    },
    get CLASS_EXPRESSION() {
      return CLASS_EXPRESSION;
    },
    get COMMA_EXPRESSION() {
      return COMMA_EXPRESSION;
    },
    get COMPREHENSION_FOR() {
      return COMPREHENSION_FOR;
    },
    get COMPREHENSION_IF() {
      return COMPREHENSION_IF;
    },
    get COMPUTED_PROPERTY_NAME() {
      return COMPUTED_PROPERTY_NAME;
    },
    get CONDITIONAL_EXPRESSION() {
      return CONDITIONAL_EXPRESSION;
    },
    get CONTINUE_STATEMENT() {
      return CONTINUE_STATEMENT;
    },
    get COVER_FORMALS() {
      return COVER_FORMALS;
    },
    get COVER_INITIALISED_NAME() {
      return COVER_INITIALISED_NAME;
    },
    get DEBUGGER_STATEMENT() {
      return DEBUGGER_STATEMENT;
    },
    get DEFAULT_CLAUSE() {
      return DEFAULT_CLAUSE;
    },
    get DO_WHILE_STATEMENT() {
      return DO_WHILE_STATEMENT;
    },
    get EMPTY_STATEMENT() {
      return EMPTY_STATEMENT;
    },
    get EXPORT_DECLARATION() {
      return EXPORT_DECLARATION;
    },
    get EXPORT_DEFAULT() {
      return EXPORT_DEFAULT;
    },
    get EXPORT_SPECIFIER() {
      return EXPORT_SPECIFIER;
    },
    get EXPORT_SPECIFIER_SET() {
      return EXPORT_SPECIFIER_SET;
    },
    get EXPORT_STAR() {
      return EXPORT_STAR;
    },
    get EXPRESSION_STATEMENT() {
      return EXPRESSION_STATEMENT;
    },
    get FINALLY() {
      return FINALLY;
    },
    get FOR_IN_STATEMENT() {
      return FOR_IN_STATEMENT;
    },
    get FOR_OF_STATEMENT() {
      return FOR_OF_STATEMENT;
    },
    get FOR_STATEMENT() {
      return FOR_STATEMENT;
    },
    get FORMAL_PARAMETER() {
      return FORMAL_PARAMETER;
    },
    get FORMAL_PARAMETER_LIST() {
      return FORMAL_PARAMETER_LIST;
    },
    get FUNCTION_BODY() {
      return FUNCTION_BODY;
    },
    get FUNCTION_DECLARATION() {
      return FUNCTION_DECLARATION;
    },
    get FUNCTION_EXPRESSION() {
      return FUNCTION_EXPRESSION;
    },
    get GENERATOR_COMPREHENSION() {
      return GENERATOR_COMPREHENSION;
    },
    get GET_ACCESSOR() {
      return GET_ACCESSOR;
    },
    get IDENTIFIER_EXPRESSION() {
      return IDENTIFIER_EXPRESSION;
    },
    get IF_STATEMENT() {
      return IF_STATEMENT;
    },
    get IMPORT_DECLARATION() {
      return IMPORT_DECLARATION;
    },
    get IMPORT_SPECIFIER() {
      return IMPORT_SPECIFIER;
    },
    get IMPORT_SPECIFIER_SET() {
      return IMPORT_SPECIFIER_SET;
    },
    get IMPORTED_BINDING() {
      return IMPORTED_BINDING;
    },
    get LABELLED_STATEMENT() {
      return LABELLED_STATEMENT;
    },
    get LITERAL_EXPRESSION() {
      return LITERAL_EXPRESSION;
    },
    get LITERAL_PROPERTY_NAME() {
      return LITERAL_PROPERTY_NAME;
    },
    get MEMBER_EXPRESSION() {
      return MEMBER_EXPRESSION;
    },
    get MEMBER_LOOKUP_EXPRESSION() {
      return MEMBER_LOOKUP_EXPRESSION;
    },
    get MODULE() {
      return MODULE;
    },
    get MODULE_DECLARATION() {
      return MODULE_DECLARATION;
    },
    get MODULE_SPECIFIER() {
      return MODULE_SPECIFIER;
    },
    get NAMED_EXPORT() {
      return NAMED_EXPORT;
    },
    get NEW_EXPRESSION() {
      return NEW_EXPRESSION;
    },
    get OBJECT_LITERAL_EXPRESSION() {
      return OBJECT_LITERAL_EXPRESSION;
    },
    get OBJECT_PATTERN() {
      return OBJECT_PATTERN;
    },
    get OBJECT_PATTERN_FIELD() {
      return OBJECT_PATTERN_FIELD;
    },
    get PAREN_EXPRESSION() {
      return PAREN_EXPRESSION;
    },
    get POSTFIX_EXPRESSION() {
      return POSTFIX_EXPRESSION;
    },
    get PREDEFINED_TYPE() {
      return PREDEFINED_TYPE;
    },
    get PROPERTY_METHOD_ASSIGNMENT() {
      return PROPERTY_METHOD_ASSIGNMENT;
    },
    get PROPERTY_NAME_ASSIGNMENT() {
      return PROPERTY_NAME_ASSIGNMENT;
    },
    get PROPERTY_NAME_SHORTHAND() {
      return PROPERTY_NAME_SHORTHAND;
    },
    get REST_PARAMETER() {
      return REST_PARAMETER;
    },
    get RETURN_STATEMENT() {
      return RETURN_STATEMENT;
    },
    get SCRIPT() {
      return SCRIPT;
    },
    get SET_ACCESSOR() {
      return SET_ACCESSOR;
    },
    get SPREAD_EXPRESSION() {
      return SPREAD_EXPRESSION;
    },
    get SPREAD_PATTERN_ELEMENT() {
      return SPREAD_PATTERN_ELEMENT;
    },
    get STATE_MACHINE() {
      return STATE_MACHINE;
    },
    get SUPER_EXPRESSION() {
      return SUPER_EXPRESSION;
    },
    get SWITCH_STATEMENT() {
      return SWITCH_STATEMENT;
    },
    get SYNTAX_ERROR_TREE() {
      return SYNTAX_ERROR_TREE;
    },
    get TEMPLATE_LITERAL_EXPRESSION() {
      return TEMPLATE_LITERAL_EXPRESSION;
    },
    get TEMPLATE_LITERAL_PORTION() {
      return TEMPLATE_LITERAL_PORTION;
    },
    get TEMPLATE_SUBSTITUTION() {
      return TEMPLATE_SUBSTITUTION;
    },
    get THIS_EXPRESSION() {
      return THIS_EXPRESSION;
    },
    get THROW_STATEMENT() {
      return THROW_STATEMENT;
    },
    get TRY_STATEMENT() {
      return TRY_STATEMENT;
    },
    get TYPE_NAME() {
      return TYPE_NAME;
    },
    get UNARY_EXPRESSION() {
      return UNARY_EXPRESSION;
    },
    get VARIABLE_DECLARATION() {
      return VARIABLE_DECLARATION;
    },
    get VARIABLE_DECLARATION_LIST() {
      return VARIABLE_DECLARATION_LIST;
    },
    get VARIABLE_STATEMENT() {
      return VARIABLE_STATEMENT;
    },
    get WHILE_STATEMENT() {
      return WHILE_STATEMENT;
    },
    get WITH_STATEMENT() {
      return WITH_STATEMENT;
    },
    get YIELD_EXPRESSION() {
      return YIELD_EXPRESSION;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/util/JSON", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/util/JSON";
  function transform(v) {
    var replacer = arguments[1] !== (void 0) ? arguments[1]: (function(k, v) {
      return v;
    });
    return transform_(replacer('', v), replacer);
  }
  function transform_(v, replacer) {
    var rv,
        tv;
    if (Array.isArray(v)) {
      var len = v.length;
      rv = Array(len);
      for (var i = 0; i < len; i++) {
        tv = transform_(replacer(String(i), v[i]), replacer);
        rv[i] = tv === undefined ? null: tv;
      }
      return rv;
    }
    if (v instanceof Object) {
      rv = {};
      Object.keys(v).forEach((function(k) {
        tv = transform_(replacer(k, v[k]), replacer);
        if (tv !== undefined) {
          rv[k] = tv;
        }
      }));
      return rv;
    }
    return v;
  }
  return {get transform() {
      return transform;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/trees/ParseTree", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/trees/ParseTree";
  var ParseTreeType = $traceurRuntime.ModuleStore.get("traceur@0.0.20/src/syntax/trees/ParseTreeType");
  var $__34 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      STRING = $__34.STRING,
      VAR = $__34.VAR;
  var Token = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Token").Token;
  var utilJSON = $traceurRuntime.ModuleStore.get("traceur@0.0.20/src/util/JSON");
  var $__34 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      ARGUMENT_LIST = $__34.ARGUMENT_LIST,
      ARRAY_COMPREHENSION = $__34.ARRAY_COMPREHENSION,
      ARRAY_LITERAL_EXPRESSION = $__34.ARRAY_LITERAL_EXPRESSION,
      ARRAY_PATTERN = $__34.ARRAY_PATTERN,
      ARROW_FUNCTION_EXPRESSION = $__34.ARROW_FUNCTION_EXPRESSION,
      AWAIT_STATEMENT = $__34.AWAIT_STATEMENT,
      BINARY_OPERATOR = $__34.BINARY_OPERATOR,
      BINDING_ELEMENT = $__34.BINDING_ELEMENT,
      BINDING_IDENTIFIER = $__34.BINDING_IDENTIFIER,
      BLOCK = $__34.BLOCK,
      BREAK_STATEMENT = $__34.BREAK_STATEMENT,
      CALL_EXPRESSION = $__34.CALL_EXPRESSION,
      CASE_CLAUSE = $__34.CASE_CLAUSE,
      CATCH = $__34.CATCH,
      CLASS_DECLARATION = $__34.CLASS_DECLARATION,
      CLASS_EXPRESSION = $__34.CLASS_EXPRESSION,
      COMMA_EXPRESSION = $__34.COMMA_EXPRESSION,
      COMPREHENSION_FOR = $__34.COMPREHENSION_FOR,
      COMPREHENSION_IF = $__34.COMPREHENSION_IF,
      COMPUTED_PROPERTY_NAME = $__34.COMPUTED_PROPERTY_NAME,
      CONDITIONAL_EXPRESSION = $__34.CONDITIONAL_EXPRESSION,
      CONTINUE_STATEMENT = $__34.CONTINUE_STATEMENT,
      COVER_FORMALS = $__34.COVER_FORMALS,
      COVER_INITIALISED_NAME = $__34.COVER_INITIALISED_NAME,
      DEBUGGER_STATEMENT = $__34.DEBUGGER_STATEMENT,
      DEFAULT_CLAUSE = $__34.DEFAULT_CLAUSE,
      DO_WHILE_STATEMENT = $__34.DO_WHILE_STATEMENT,
      EMPTY_STATEMENT = $__34.EMPTY_STATEMENT,
      EXPORT_DECLARATION = $__34.EXPORT_DECLARATION,
      EXPORT_SPECIFIER = $__34.EXPORT_SPECIFIER,
      EXPORT_SPECIFIER_SET = $__34.EXPORT_SPECIFIER_SET,
      EXPORT_STAR = $__34.EXPORT_STAR,
      EXPRESSION_STATEMENT = $__34.EXPRESSION_STATEMENT,
      FINALLY = $__34.FINALLY,
      FOR_IN_STATEMENT = $__34.FOR_IN_STATEMENT,
      FOR_OF_STATEMENT = $__34.FOR_OF_STATEMENT,
      FOR_STATEMENT = $__34.FOR_STATEMENT,
      FORMAL_PARAMETER = $__34.FORMAL_PARAMETER,
      FORMAL_PARAMETER_LIST = $__34.FORMAL_PARAMETER_LIST,
      FUNCTION_BODY = $__34.FUNCTION_BODY,
      FUNCTION_DECLARATION = $__34.FUNCTION_DECLARATION,
      FUNCTION_EXPRESSION = $__34.FUNCTION_EXPRESSION,
      GENERATOR_COMPREHENSION = $__34.GENERATOR_COMPREHENSION,
      GET_ACCESSOR = $__34.GET_ACCESSOR,
      IDENTIFIER_EXPRESSION = $__34.IDENTIFIER_EXPRESSION,
      IF_STATEMENT = $__34.IF_STATEMENT,
      IMPORT_DECLARATION = $__34.IMPORT_DECLARATION,
      IMPORT_SPECIFIER = $__34.IMPORT_SPECIFIER,
      IMPORT_SPECIFIER_SET = $__34.IMPORT_SPECIFIER_SET,
      LABELLED_STATEMENT = $__34.LABELLED_STATEMENT,
      LITERAL_EXPRESSION = $__34.LITERAL_EXPRESSION,
      LITERAL_PROPERTY_NAME = $__34.LITERAL_PROPERTY_NAME,
      MEMBER_EXPRESSION = $__34.MEMBER_EXPRESSION,
      MEMBER_LOOKUP_EXPRESSION = $__34.MEMBER_LOOKUP_EXPRESSION,
      MODULE = $__34.MODULE,
      MODULE_DECLARATION = $__34.MODULE_DECLARATION,
      MODULE_SPECIFIER = $__34.MODULE_SPECIFIER,
      NAMED_EXPORT = $__34.NAMED_EXPORT,
      NEW_EXPRESSION = $__34.NEW_EXPRESSION,
      OBJECT_LITERAL_EXPRESSION = $__34.OBJECT_LITERAL_EXPRESSION,
      OBJECT_PATTERN = $__34.OBJECT_PATTERN,
      OBJECT_PATTERN_FIELD = $__34.OBJECT_PATTERN_FIELD,
      PAREN_EXPRESSION = $__34.PAREN_EXPRESSION,
      POSTFIX_EXPRESSION = $__34.POSTFIX_EXPRESSION,
      PREDEFINED_TYPE = $__34.PREDEFINED_TYPE,
      PROPERTY_METHOD_ASSIGNMENT = $__34.PROPERTY_METHOD_ASSIGNMENT,
      PROPERTY_NAME_ASSIGNMENT = $__34.PROPERTY_NAME_ASSIGNMENT,
      PROPERTY_NAME_SHORTHAND = $__34.PROPERTY_NAME_SHORTHAND,
      REST_PARAMETER = $__34.REST_PARAMETER,
      RETURN_STATEMENT = $__34.RETURN_STATEMENT,
      SCRIPT = $__34.SCRIPT,
      SET_ACCESSOR = $__34.SET_ACCESSOR,
      SPREAD_EXPRESSION = $__34.SPREAD_EXPRESSION,
      SPREAD_PATTERN_ELEMENT = $__34.SPREAD_PATTERN_ELEMENT,
      STATE_MACHINE = $__34.STATE_MACHINE,
      SUPER_EXPRESSION = $__34.SUPER_EXPRESSION,
      SWITCH_STATEMENT = $__34.SWITCH_STATEMENT,
      SYNTAX_ERROR_TREE = $__34.SYNTAX_ERROR_TREE,
      TEMPLATE_LITERAL_EXPRESSION = $__34.TEMPLATE_LITERAL_EXPRESSION,
      TEMPLATE_LITERAL_PORTION = $__34.TEMPLATE_LITERAL_PORTION,
      TEMPLATE_SUBSTITUTION = $__34.TEMPLATE_SUBSTITUTION,
      THIS_EXPRESSION = $__34.THIS_EXPRESSION,
      THROW_STATEMENT = $__34.THROW_STATEMENT,
      TRY_STATEMENT = $__34.TRY_STATEMENT,
      TYPE_NAME = $__34.TYPE_NAME,
      UNARY_EXPRESSION = $__34.UNARY_EXPRESSION,
      VARIABLE_DECLARATION = $__34.VARIABLE_DECLARATION,
      VARIABLE_DECLARATION_LIST = $__34.VARIABLE_DECLARATION_LIST,
      VARIABLE_STATEMENT = $__34.VARIABLE_STATEMENT,
      WHILE_STATEMENT = $__34.WHILE_STATEMENT,
      WITH_STATEMENT = $__34.WITH_STATEMENT,
      YIELD_EXPRESSION = $__34.YIELD_EXPRESSION;
  ;
  var ParseTree = function ParseTree(type, location) {
    throw new Error("Don't use for now. 'super' is currently very slow.");
    this.type = type;
    this.location = location;
  };
  var $ParseTree = ParseTree;
  ($traceurRuntime.createClass)(ParseTree, {
    isPattern: function() {
      switch (this.type) {
        case ARRAY_PATTERN:
        case OBJECT_PATTERN:
          return true;
        case PAREN_EXPRESSION:
          return this.expression.isPattern();
        default:
          return false;
      }
    },
    isLeftHandSideExpression: function() {
      switch (this.type) {
        case THIS_EXPRESSION:
        case CLASS_EXPRESSION:
        case SUPER_EXPRESSION:
        case IDENTIFIER_EXPRESSION:
        case LITERAL_EXPRESSION:
        case ARRAY_LITERAL_EXPRESSION:
        case OBJECT_LITERAL_EXPRESSION:
        case NEW_EXPRESSION:
        case MEMBER_EXPRESSION:
        case MEMBER_LOOKUP_EXPRESSION:
        case CALL_EXPRESSION:
        case FUNCTION_EXPRESSION:
        case TEMPLATE_LITERAL_EXPRESSION:
          return true;
        case PAREN_EXPRESSION:
          return this.expression.isLeftHandSideExpression();
        default:
          return false;
      }
    },
    isArrowFunctionExpression: function() {
      switch (this.type) {
        case ARRAY_COMPREHENSION:
        case ARRAY_LITERAL_EXPRESSION:
        case ARROW_FUNCTION_EXPRESSION:
        case BINARY_OPERATOR:
        case CALL_EXPRESSION:
        case CLASS_EXPRESSION:
        case CONDITIONAL_EXPRESSION:
        case FUNCTION_EXPRESSION:
        case GENERATOR_COMPREHENSION:
        case IDENTIFIER_EXPRESSION:
        case LITERAL_EXPRESSION:
        case MEMBER_EXPRESSION:
        case MEMBER_LOOKUP_EXPRESSION:
        case NEW_EXPRESSION:
        case OBJECT_LITERAL_EXPRESSION:
        case PAREN_EXPRESSION:
        case POSTFIX_EXPRESSION:
        case TEMPLATE_LITERAL_EXPRESSION:
        case SUPER_EXPRESSION:
        case THIS_EXPRESSION:
        case UNARY_EXPRESSION:
        case YIELD_EXPRESSION:
          return true;
        default:
          return false;
      }
    },
    isMemberExpression: function() {
      switch (this.type) {
        case THIS_EXPRESSION:
        case CLASS_EXPRESSION:
        case SUPER_EXPRESSION:
        case IDENTIFIER_EXPRESSION:
        case LITERAL_EXPRESSION:
        case ARRAY_LITERAL_EXPRESSION:
        case OBJECT_LITERAL_EXPRESSION:
        case PAREN_EXPRESSION:
        case TEMPLATE_LITERAL_EXPRESSION:
        case FUNCTION_EXPRESSION:
        case MEMBER_LOOKUP_EXPRESSION:
        case MEMBER_EXPRESSION:
        case CALL_EXPRESSION:
          return true;
        case NEW_EXPRESSION:
          return this.args != null;
      }
      return false;
    },
    isExpression: function() {
      return this.isArrowFunctionExpression() || this.type == COMMA_EXPRESSION;
    },
    isAssignmentOrSpread: function() {
      return this.isArrowFunctionExpression() || this.type == SPREAD_EXPRESSION;
    },
    isRestParameter: function() {
      return this.type == REST_PARAMETER || (this.type == FORMAL_PARAMETER && this.parameter.isRestParameter());
    },
    isSpreadPatternElement: function() {
      return this.type == SPREAD_PATTERN_ELEMENT;
    },
    isStatementListItem: function() {
      return this.isStatement() || this.isDeclaration();
    },
    isStatement: function() {
      switch (this.type) {
        case BLOCK:
        case VARIABLE_STATEMENT:
        case EMPTY_STATEMENT:
        case EXPRESSION_STATEMENT:
        case IF_STATEMENT:
        case CONTINUE_STATEMENT:
        case BREAK_STATEMENT:
        case RETURN_STATEMENT:
        case WITH_STATEMENT:
        case LABELLED_STATEMENT:
        case THROW_STATEMENT:
        case TRY_STATEMENT:
        case DEBUGGER_STATEMENT:
        case AWAIT_STATEMENT:
          return true;
      }
      return this.isBreakableStatement();
    },
    isDeclaration: function() {
      switch (this.type) {
        case FUNCTION_DECLARATION:
        case CLASS_DECLARATION:
          return true;
      }
      return this.isLexicalDeclaration();
    },
    isLexicalDeclaration: function() {
      switch (this.type) {
        case VARIABLE_STATEMENT:
          return this.declarations.declarationType !== VAR;
      }
      return false;
    },
    isBreakableStatement: function() {
      switch (this.type) {
        case SWITCH_STATEMENT:
          return true;
      }
      return this.isIterationStatement();
    },
    isIterationStatement: function() {
      switch (this.type) {
        case DO_WHILE_STATEMENT:
        case FOR_IN_STATEMENT:
        case FOR_OF_STATEMENT:
        case FOR_STATEMENT:
        case WHILE_STATEMENT:
          return true;
      }
      return false;
    },
    isScriptElement: function() {
      switch (this.type) {
        case CLASS_DECLARATION:
        case EXPORT_DECLARATION:
        case FUNCTION_DECLARATION:
        case IMPORT_DECLARATION:
        case MODULE_DECLARATION:
        case VARIABLE_DECLARATION:
          return true;
      }
      return this.isStatement();
    },
    getDirectivePrologueStringToken_: function() {
      var tree = this;
      if (tree.type !== EXPRESSION_STATEMENT || !(tree = tree.expression)) return null;
      if (tree.type !== LITERAL_EXPRESSION || !(tree = tree.literalToken)) return null;
      if (tree.type !== STRING) return null;
      return tree;
    },
    isDirectivePrologue: function() {
      return this.getDirectivePrologueStringToken_() !== null;
    },
    isUseStrictDirective: function() {
      var token = this.getDirectivePrologueStringToken_();
      if (!token) return false;
      var v = token.value;
      return v === '"use strict"' || v === "'use strict'";
    },
    toJSON: function() {
      return utilJSON.transform(this, $ParseTree.replacer);
    },
    stringify: function() {
      var indent = arguments[0] !== (void 0) ? arguments[0]: 2;
      return JSON.stringify(this, $ParseTree.replacer, indent);
    }
  }, {
    stripLocation: function(key, value) {
      if (key === 'location') {
        return undefined;
      }
      return value;
    },
    replacer: function(k, v) {
      if (v instanceof $ParseTree || v instanceof Token) {
        var rv = {type: v.type};
        Object.keys(v).forEach(function(name) {
          if (name !== 'location') rv[name] = v[name];
        });
        return rv;
      }
      return v;
    }
  });
  return {
    get ParseTreeType() {
      return ParseTreeType;
    },
    get ParseTree() {
      return ParseTree;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/trees/ParseTrees", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/trees/ParseTrees";
  var ParseTree = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTree").ParseTree;
  var ParseTreeType = $traceurRuntime.ModuleStore.get("traceur@0.0.20/src/syntax/trees/ParseTreeType");
  var ANNOTATION = ParseTreeType.ANNOTATION;
  var Annotation = function Annotation(location, name, args) {
    this.location = location;
    this.name = name;
    this.args = args;
  };
  ($traceurRuntime.createClass)(Annotation, {
    transform: function(transformer) {
      return transformer.transformAnnotation(this);
    },
    visit: function(visitor) {
      visitor.visitAnnotation(this);
    },
    get type() {
      return ANNOTATION;
    }
  }, {}, ParseTree);
  var ANON_BLOCK = ParseTreeType.ANON_BLOCK;
  var AnonBlock = function AnonBlock(location, statements) {
    this.location = location;
    this.statements = statements;
  };
  ($traceurRuntime.createClass)(AnonBlock, {
    transform: function(transformer) {
      return transformer.transformAnonBlock(this);
    },
    visit: function(visitor) {
      visitor.visitAnonBlock(this);
    },
    get type() {
      return ANON_BLOCK;
    }
  }, {}, ParseTree);
  var ARGUMENT_LIST = ParseTreeType.ARGUMENT_LIST;
  var ArgumentList = function ArgumentList(location, args) {
    this.location = location;
    this.args = args;
  };
  ($traceurRuntime.createClass)(ArgumentList, {
    transform: function(transformer) {
      return transformer.transformArgumentList(this);
    },
    visit: function(visitor) {
      visitor.visitArgumentList(this);
    },
    get type() {
      return ARGUMENT_LIST;
    }
  }, {}, ParseTree);
  var ARRAY_COMPREHENSION = ParseTreeType.ARRAY_COMPREHENSION;
  var ArrayComprehension = function ArrayComprehension(location, comprehensionList, expression) {
    this.location = location;
    this.comprehensionList = comprehensionList;
    this.expression = expression;
  };
  ($traceurRuntime.createClass)(ArrayComprehension, {
    transform: function(transformer) {
      return transformer.transformArrayComprehension(this);
    },
    visit: function(visitor) {
      visitor.visitArrayComprehension(this);
    },
    get type() {
      return ARRAY_COMPREHENSION;
    }
  }, {}, ParseTree);
  var ARRAY_LITERAL_EXPRESSION = ParseTreeType.ARRAY_LITERAL_EXPRESSION;
  var ArrayLiteralExpression = function ArrayLiteralExpression(location, elements) {
    this.location = location;
    this.elements = elements;
  };
  ($traceurRuntime.createClass)(ArrayLiteralExpression, {
    transform: function(transformer) {
      return transformer.transformArrayLiteralExpression(this);
    },
    visit: function(visitor) {
      visitor.visitArrayLiteralExpression(this);
    },
    get type() {
      return ARRAY_LITERAL_EXPRESSION;
    }
  }, {}, ParseTree);
  var ARRAY_PATTERN = ParseTreeType.ARRAY_PATTERN;
  var ArrayPattern = function ArrayPattern(location, elements) {
    this.location = location;
    this.elements = elements;
  };
  ($traceurRuntime.createClass)(ArrayPattern, {
    transform: function(transformer) {
      return transformer.transformArrayPattern(this);
    },
    visit: function(visitor) {
      visitor.visitArrayPattern(this);
    },
    get type() {
      return ARRAY_PATTERN;
    }
  }, {}, ParseTree);
  var ARROW_FUNCTION_EXPRESSION = ParseTreeType.ARROW_FUNCTION_EXPRESSION;
  var ArrowFunctionExpression = function ArrowFunctionExpression(location, formalParameters, functionBody) {
    this.location = location;
    this.formalParameters = formalParameters;
    this.functionBody = functionBody;
  };
  ($traceurRuntime.createClass)(ArrowFunctionExpression, {
    transform: function(transformer) {
      return transformer.transformArrowFunctionExpression(this);
    },
    visit: function(visitor) {
      visitor.visitArrowFunctionExpression(this);
    },
    get type() {
      return ARROW_FUNCTION_EXPRESSION;
    }
  }, {}, ParseTree);
  var AWAIT_STATEMENT = ParseTreeType.AWAIT_STATEMENT;
  var AwaitStatement = function AwaitStatement(location, identifier, expression) {
    this.location = location;
    this.identifier = identifier;
    this.expression = expression;
  };
  ($traceurRuntime.createClass)(AwaitStatement, {
    transform: function(transformer) {
      return transformer.transformAwaitStatement(this);
    },
    visit: function(visitor) {
      visitor.visitAwaitStatement(this);
    },
    get type() {
      return AWAIT_STATEMENT;
    }
  }, {}, ParseTree);
  var BINARY_OPERATOR = ParseTreeType.BINARY_OPERATOR;
  var BinaryOperator = function BinaryOperator(location, left, operator, right) {
    this.location = location;
    this.left = left;
    this.operator = operator;
    this.right = right;
  };
  ($traceurRuntime.createClass)(BinaryOperator, {
    transform: function(transformer) {
      return transformer.transformBinaryOperator(this);
    },
    visit: function(visitor) {
      visitor.visitBinaryOperator(this);
    },
    get type() {
      return BINARY_OPERATOR;
    }
  }, {}, ParseTree);
  var BINDING_ELEMENT = ParseTreeType.BINDING_ELEMENT;
  var BindingElement = function BindingElement(location, binding, initialiser) {
    this.location = location;
    this.binding = binding;
    this.initialiser = initialiser;
  };
  ($traceurRuntime.createClass)(BindingElement, {
    transform: function(transformer) {
      return transformer.transformBindingElement(this);
    },
    visit: function(visitor) {
      visitor.visitBindingElement(this);
    },
    get type() {
      return BINDING_ELEMENT;
    }
  }, {}, ParseTree);
  var BINDING_IDENTIFIER = ParseTreeType.BINDING_IDENTIFIER;
  var BindingIdentifier = function BindingIdentifier(location, identifierToken) {
    this.location = location;
    this.identifierToken = identifierToken;
  };
  ($traceurRuntime.createClass)(BindingIdentifier, {
    transform: function(transformer) {
      return transformer.transformBindingIdentifier(this);
    },
    visit: function(visitor) {
      visitor.visitBindingIdentifier(this);
    },
    get type() {
      return BINDING_IDENTIFIER;
    }
  }, {}, ParseTree);
  var BLOCK = ParseTreeType.BLOCK;
  var Block = function Block(location, statements) {
    this.location = location;
    this.statements = statements;
  };
  ($traceurRuntime.createClass)(Block, {
    transform: function(transformer) {
      return transformer.transformBlock(this);
    },
    visit: function(visitor) {
      visitor.visitBlock(this);
    },
    get type() {
      return BLOCK;
    }
  }, {}, ParseTree);
  var BREAK_STATEMENT = ParseTreeType.BREAK_STATEMENT;
  var BreakStatement = function BreakStatement(location, name) {
    this.location = location;
    this.name = name;
  };
  ($traceurRuntime.createClass)(BreakStatement, {
    transform: function(transformer) {
      return transformer.transformBreakStatement(this);
    },
    visit: function(visitor) {
      visitor.visitBreakStatement(this);
    },
    get type() {
      return BREAK_STATEMENT;
    }
  }, {}, ParseTree);
  var CALL_EXPRESSION = ParseTreeType.CALL_EXPRESSION;
  var CallExpression = function CallExpression(location, operand, args) {
    this.location = location;
    this.operand = operand;
    this.args = args;
  };
  ($traceurRuntime.createClass)(CallExpression, {
    transform: function(transformer) {
      return transformer.transformCallExpression(this);
    },
    visit: function(visitor) {
      visitor.visitCallExpression(this);
    },
    get type() {
      return CALL_EXPRESSION;
    }
  }, {}, ParseTree);
  var CASE_CLAUSE = ParseTreeType.CASE_CLAUSE;
  var CaseClause = function CaseClause(location, expression, statements) {
    this.location = location;
    this.expression = expression;
    this.statements = statements;
  };
  ($traceurRuntime.createClass)(CaseClause, {
    transform: function(transformer) {
      return transformer.transformCaseClause(this);
    },
    visit: function(visitor) {
      visitor.visitCaseClause(this);
    },
    get type() {
      return CASE_CLAUSE;
    }
  }, {}, ParseTree);
  var CATCH = ParseTreeType.CATCH;
  var Catch = function Catch(location, binding, catchBody) {
    this.location = location;
    this.binding = binding;
    this.catchBody = catchBody;
  };
  ($traceurRuntime.createClass)(Catch, {
    transform: function(transformer) {
      return transformer.transformCatch(this);
    },
    visit: function(visitor) {
      visitor.visitCatch(this);
    },
    get type() {
      return CATCH;
    }
  }, {}, ParseTree);
  var CLASS_DECLARATION = ParseTreeType.CLASS_DECLARATION;
  var ClassDeclaration = function ClassDeclaration(location, name, superClass, elements, annotations) {
    this.location = location;
    this.name = name;
    this.superClass = superClass;
    this.elements = elements;
    this.annotations = annotations;
  };
  ($traceurRuntime.createClass)(ClassDeclaration, {
    transform: function(transformer) {
      return transformer.transformClassDeclaration(this);
    },
    visit: function(visitor) {
      visitor.visitClassDeclaration(this);
    },
    get type() {
      return CLASS_DECLARATION;
    }
  }, {}, ParseTree);
  var CLASS_EXPRESSION = ParseTreeType.CLASS_EXPRESSION;
  var ClassExpression = function ClassExpression(location, name, superClass, elements, annotations) {
    this.location = location;
    this.name = name;
    this.superClass = superClass;
    this.elements = elements;
    this.annotations = annotations;
  };
  ($traceurRuntime.createClass)(ClassExpression, {
    transform: function(transformer) {
      return transformer.transformClassExpression(this);
    },
    visit: function(visitor) {
      visitor.visitClassExpression(this);
    },
    get type() {
      return CLASS_EXPRESSION;
    }
  }, {}, ParseTree);
  var COMMA_EXPRESSION = ParseTreeType.COMMA_EXPRESSION;
  var CommaExpression = function CommaExpression(location, expressions) {
    this.location = location;
    this.expressions = expressions;
  };
  ($traceurRuntime.createClass)(CommaExpression, {
    transform: function(transformer) {
      return transformer.transformCommaExpression(this);
    },
    visit: function(visitor) {
      visitor.visitCommaExpression(this);
    },
    get type() {
      return COMMA_EXPRESSION;
    }
  }, {}, ParseTree);
  var COMPREHENSION_FOR = ParseTreeType.COMPREHENSION_FOR;
  var ComprehensionFor = function ComprehensionFor(location, left, iterator) {
    this.location = location;
    this.left = left;
    this.iterator = iterator;
  };
  ($traceurRuntime.createClass)(ComprehensionFor, {
    transform: function(transformer) {
      return transformer.transformComprehensionFor(this);
    },
    visit: function(visitor) {
      visitor.visitComprehensionFor(this);
    },
    get type() {
      return COMPREHENSION_FOR;
    }
  }, {}, ParseTree);
  var COMPREHENSION_IF = ParseTreeType.COMPREHENSION_IF;
  var ComprehensionIf = function ComprehensionIf(location, expression) {
    this.location = location;
    this.expression = expression;
  };
  ($traceurRuntime.createClass)(ComprehensionIf, {
    transform: function(transformer) {
      return transformer.transformComprehensionIf(this);
    },
    visit: function(visitor) {
      visitor.visitComprehensionIf(this);
    },
    get type() {
      return COMPREHENSION_IF;
    }
  }, {}, ParseTree);
  var COMPUTED_PROPERTY_NAME = ParseTreeType.COMPUTED_PROPERTY_NAME;
  var ComputedPropertyName = function ComputedPropertyName(location, expression) {
    this.location = location;
    this.expression = expression;
  };
  ($traceurRuntime.createClass)(ComputedPropertyName, {
    transform: function(transformer) {
      return transformer.transformComputedPropertyName(this);
    },
    visit: function(visitor) {
      visitor.visitComputedPropertyName(this);
    },
    get type() {
      return COMPUTED_PROPERTY_NAME;
    }
  }, {}, ParseTree);
  var CONDITIONAL_EXPRESSION = ParseTreeType.CONDITIONAL_EXPRESSION;
  var ConditionalExpression = function ConditionalExpression(location, condition, left, right) {
    this.location = location;
    this.condition = condition;
    this.left = left;
    this.right = right;
  };
  ($traceurRuntime.createClass)(ConditionalExpression, {
    transform: function(transformer) {
      return transformer.transformConditionalExpression(this);
    },
    visit: function(visitor) {
      visitor.visitConditionalExpression(this);
    },
    get type() {
      return CONDITIONAL_EXPRESSION;
    }
  }, {}, ParseTree);
  var CONTINUE_STATEMENT = ParseTreeType.CONTINUE_STATEMENT;
  var ContinueStatement = function ContinueStatement(location, name) {
    this.location = location;
    this.name = name;
  };
  ($traceurRuntime.createClass)(ContinueStatement, {
    transform: function(transformer) {
      return transformer.transformContinueStatement(this);
    },
    visit: function(visitor) {
      visitor.visitContinueStatement(this);
    },
    get type() {
      return CONTINUE_STATEMENT;
    }
  }, {}, ParseTree);
  var COVER_FORMALS = ParseTreeType.COVER_FORMALS;
  var CoverFormals = function CoverFormals(location, expressions) {
    this.location = location;
    this.expressions = expressions;
  };
  ($traceurRuntime.createClass)(CoverFormals, {
    transform: function(transformer) {
      return transformer.transformCoverFormals(this);
    },
    visit: function(visitor) {
      visitor.visitCoverFormals(this);
    },
    get type() {
      return COVER_FORMALS;
    }
  }, {}, ParseTree);
  var COVER_INITIALISED_NAME = ParseTreeType.COVER_INITIALISED_NAME;
  var CoverInitialisedName = function CoverInitialisedName(location, name, equalToken, initialiser) {
    this.location = location;
    this.name = name;
    this.equalToken = equalToken;
    this.initialiser = initialiser;
  };
  ($traceurRuntime.createClass)(CoverInitialisedName, {
    transform: function(transformer) {
      return transformer.transformCoverInitialisedName(this);
    },
    visit: function(visitor) {
      visitor.visitCoverInitialisedName(this);
    },
    get type() {
      return COVER_INITIALISED_NAME;
    }
  }, {}, ParseTree);
  var DEBUGGER_STATEMENT = ParseTreeType.DEBUGGER_STATEMENT;
  var DebuggerStatement = function DebuggerStatement(location) {
    this.location = location;
  };
  ($traceurRuntime.createClass)(DebuggerStatement, {
    transform: function(transformer) {
      return transformer.transformDebuggerStatement(this);
    },
    visit: function(visitor) {
      visitor.visitDebuggerStatement(this);
    },
    get type() {
      return DEBUGGER_STATEMENT;
    }
  }, {}, ParseTree);
  var DEFAULT_CLAUSE = ParseTreeType.DEFAULT_CLAUSE;
  var DefaultClause = function DefaultClause(location, statements) {
    this.location = location;
    this.statements = statements;
  };
  ($traceurRuntime.createClass)(DefaultClause, {
    transform: function(transformer) {
      return transformer.transformDefaultClause(this);
    },
    visit: function(visitor) {
      visitor.visitDefaultClause(this);
    },
    get type() {
      return DEFAULT_CLAUSE;
    }
  }, {}, ParseTree);
  var DO_WHILE_STATEMENT = ParseTreeType.DO_WHILE_STATEMENT;
  var DoWhileStatement = function DoWhileStatement(location, body, condition) {
    this.location = location;
    this.body = body;
    this.condition = condition;
  };
  ($traceurRuntime.createClass)(DoWhileStatement, {
    transform: function(transformer) {
      return transformer.transformDoWhileStatement(this);
    },
    visit: function(visitor) {
      visitor.visitDoWhileStatement(this);
    },
    get type() {
      return DO_WHILE_STATEMENT;
    }
  }, {}, ParseTree);
  var EMPTY_STATEMENT = ParseTreeType.EMPTY_STATEMENT;
  var EmptyStatement = function EmptyStatement(location) {
    this.location = location;
  };
  ($traceurRuntime.createClass)(EmptyStatement, {
    transform: function(transformer) {
      return transformer.transformEmptyStatement(this);
    },
    visit: function(visitor) {
      visitor.visitEmptyStatement(this);
    },
    get type() {
      return EMPTY_STATEMENT;
    }
  }, {}, ParseTree);
  var EXPORT_DECLARATION = ParseTreeType.EXPORT_DECLARATION;
  var ExportDeclaration = function ExportDeclaration(location, declaration, annotations) {
    this.location = location;
    this.declaration = declaration;
    this.annotations = annotations;
  };
  ($traceurRuntime.createClass)(ExportDeclaration, {
    transform: function(transformer) {
      return transformer.transformExportDeclaration(this);
    },
    visit: function(visitor) {
      visitor.visitExportDeclaration(this);
    },
    get type() {
      return EXPORT_DECLARATION;
    }
  }, {}, ParseTree);
  var EXPORT_DEFAULT = ParseTreeType.EXPORT_DEFAULT;
  var ExportDefault = function ExportDefault(location, expression) {
    this.location = location;
    this.expression = expression;
  };
  ($traceurRuntime.createClass)(ExportDefault, {
    transform: function(transformer) {
      return transformer.transformExportDefault(this);
    },
    visit: function(visitor) {
      visitor.visitExportDefault(this);
    },
    get type() {
      return EXPORT_DEFAULT;
    }
  }, {}, ParseTree);
  var EXPORT_SPECIFIER = ParseTreeType.EXPORT_SPECIFIER;
  var ExportSpecifier = function ExportSpecifier(location, lhs, rhs) {
    this.location = location;
    this.lhs = lhs;
    this.rhs = rhs;
  };
  ($traceurRuntime.createClass)(ExportSpecifier, {
    transform: function(transformer) {
      return transformer.transformExportSpecifier(this);
    },
    visit: function(visitor) {
      visitor.visitExportSpecifier(this);
    },
    get type() {
      return EXPORT_SPECIFIER;
    }
  }, {}, ParseTree);
  var EXPORT_SPECIFIER_SET = ParseTreeType.EXPORT_SPECIFIER_SET;
  var ExportSpecifierSet = function ExportSpecifierSet(location, specifiers) {
    this.location = location;
    this.specifiers = specifiers;
  };
  ($traceurRuntime.createClass)(ExportSpecifierSet, {
    transform: function(transformer) {
      return transformer.transformExportSpecifierSet(this);
    },
    visit: function(visitor) {
      visitor.visitExportSpecifierSet(this);
    },
    get type() {
      return EXPORT_SPECIFIER_SET;
    }
  }, {}, ParseTree);
  var EXPORT_STAR = ParseTreeType.EXPORT_STAR;
  var ExportStar = function ExportStar(location) {
    this.location = location;
  };
  ($traceurRuntime.createClass)(ExportStar, {
    transform: function(transformer) {
      return transformer.transformExportStar(this);
    },
    visit: function(visitor) {
      visitor.visitExportStar(this);
    },
    get type() {
      return EXPORT_STAR;
    }
  }, {}, ParseTree);
  var EXPRESSION_STATEMENT = ParseTreeType.EXPRESSION_STATEMENT;
  var ExpressionStatement = function ExpressionStatement(location, expression) {
    this.location = location;
    this.expression = expression;
  };
  ($traceurRuntime.createClass)(ExpressionStatement, {
    transform: function(transformer) {
      return transformer.transformExpressionStatement(this);
    },
    visit: function(visitor) {
      visitor.visitExpressionStatement(this);
    },
    get type() {
      return EXPRESSION_STATEMENT;
    }
  }, {}, ParseTree);
  var FINALLY = ParseTreeType.FINALLY;
  var Finally = function Finally(location, block) {
    this.location = location;
    this.block = block;
  };
  ($traceurRuntime.createClass)(Finally, {
    transform: function(transformer) {
      return transformer.transformFinally(this);
    },
    visit: function(visitor) {
      visitor.visitFinally(this);
    },
    get type() {
      return FINALLY;
    }
  }, {}, ParseTree);
  var FOR_IN_STATEMENT = ParseTreeType.FOR_IN_STATEMENT;
  var ForInStatement = function ForInStatement(location, initialiser, collection, body) {
    this.location = location;
    this.initialiser = initialiser;
    this.collection = collection;
    this.body = body;
  };
  ($traceurRuntime.createClass)(ForInStatement, {
    transform: function(transformer) {
      return transformer.transformForInStatement(this);
    },
    visit: function(visitor) {
      visitor.visitForInStatement(this);
    },
    get type() {
      return FOR_IN_STATEMENT;
    }
  }, {}, ParseTree);
  var FOR_OF_STATEMENT = ParseTreeType.FOR_OF_STATEMENT;
  var ForOfStatement = function ForOfStatement(location, initialiser, collection, body) {
    this.location = location;
    this.initialiser = initialiser;
    this.collection = collection;
    this.body = body;
  };
  ($traceurRuntime.createClass)(ForOfStatement, {
    transform: function(transformer) {
      return transformer.transformForOfStatement(this);
    },
    visit: function(visitor) {
      visitor.visitForOfStatement(this);
    },
    get type() {
      return FOR_OF_STATEMENT;
    }
  }, {}, ParseTree);
  var FOR_STATEMENT = ParseTreeType.FOR_STATEMENT;
  var ForStatement = function ForStatement(location, initialiser, condition, increment, body) {
    this.location = location;
    this.initialiser = initialiser;
    this.condition = condition;
    this.increment = increment;
    this.body = body;
  };
  ($traceurRuntime.createClass)(ForStatement, {
    transform: function(transformer) {
      return transformer.transformForStatement(this);
    },
    visit: function(visitor) {
      visitor.visitForStatement(this);
    },
    get type() {
      return FOR_STATEMENT;
    }
  }, {}, ParseTree);
  var FORMAL_PARAMETER = ParseTreeType.FORMAL_PARAMETER;
  var FormalParameter = function FormalParameter(location, parameter, typeAnnotation, annotations) {
    this.location = location;
    this.parameter = parameter;
    this.typeAnnotation = typeAnnotation;
    this.annotations = annotations;
  };
  ($traceurRuntime.createClass)(FormalParameter, {
    transform: function(transformer) {
      return transformer.transformFormalParameter(this);
    },
    visit: function(visitor) {
      visitor.visitFormalParameter(this);
    },
    get type() {
      return FORMAL_PARAMETER;
    }
  }, {}, ParseTree);
  var FORMAL_PARAMETER_LIST = ParseTreeType.FORMAL_PARAMETER_LIST;
  var FormalParameterList = function FormalParameterList(location, parameters) {
    this.location = location;
    this.parameters = parameters;
  };
  ($traceurRuntime.createClass)(FormalParameterList, {
    transform: function(transformer) {
      return transformer.transformFormalParameterList(this);
    },
    visit: function(visitor) {
      visitor.visitFormalParameterList(this);
    },
    get type() {
      return FORMAL_PARAMETER_LIST;
    }
  }, {}, ParseTree);
  var FUNCTION_BODY = ParseTreeType.FUNCTION_BODY;
  var FunctionBody = function FunctionBody(location, statements) {
    this.location = location;
    this.statements = statements;
  };
  ($traceurRuntime.createClass)(FunctionBody, {
    transform: function(transformer) {
      return transformer.transformFunctionBody(this);
    },
    visit: function(visitor) {
      visitor.visitFunctionBody(this);
    },
    get type() {
      return FUNCTION_BODY;
    }
  }, {}, ParseTree);
  var FUNCTION_DECLARATION = ParseTreeType.FUNCTION_DECLARATION;
  var FunctionDeclaration = function FunctionDeclaration(location, name, isGenerator, formalParameterList, typeAnnotation, annotations, functionBody) {
    this.location = location;
    this.name = name;
    this.isGenerator = isGenerator;
    this.formalParameterList = formalParameterList;
    this.typeAnnotation = typeAnnotation;
    this.annotations = annotations;
    this.functionBody = functionBody;
  };
  ($traceurRuntime.createClass)(FunctionDeclaration, {
    transform: function(transformer) {
      return transformer.transformFunctionDeclaration(this);
    },
    visit: function(visitor) {
      visitor.visitFunctionDeclaration(this);
    },
    get type() {
      return FUNCTION_DECLARATION;
    }
  }, {}, ParseTree);
  var FUNCTION_EXPRESSION = ParseTreeType.FUNCTION_EXPRESSION;
  var FunctionExpression = function FunctionExpression(location, name, isGenerator, formalParameterList, typeAnnotation, annotations, functionBody) {
    this.location = location;
    this.name = name;
    this.isGenerator = isGenerator;
    this.formalParameterList = formalParameterList;
    this.typeAnnotation = typeAnnotation;
    this.annotations = annotations;
    this.functionBody = functionBody;
  };
  ($traceurRuntime.createClass)(FunctionExpression, {
    transform: function(transformer) {
      return transformer.transformFunctionExpression(this);
    },
    visit: function(visitor) {
      visitor.visitFunctionExpression(this);
    },
    get type() {
      return FUNCTION_EXPRESSION;
    }
  }, {}, ParseTree);
  var GENERATOR_COMPREHENSION = ParseTreeType.GENERATOR_COMPREHENSION;
  var GeneratorComprehension = function GeneratorComprehension(location, comprehensionList, expression) {
    this.location = location;
    this.comprehensionList = comprehensionList;
    this.expression = expression;
  };
  ($traceurRuntime.createClass)(GeneratorComprehension, {
    transform: function(transformer) {
      return transformer.transformGeneratorComprehension(this);
    },
    visit: function(visitor) {
      visitor.visitGeneratorComprehension(this);
    },
    get type() {
      return GENERATOR_COMPREHENSION;
    }
  }, {}, ParseTree);
  var GET_ACCESSOR = ParseTreeType.GET_ACCESSOR;
  var GetAccessor = function GetAccessor(location, isStatic, name, typeAnnotation, annotations, body) {
    this.location = location;
    this.isStatic = isStatic;
    this.name = name;
    this.typeAnnotation = typeAnnotation;
    this.annotations = annotations;
    this.body = body;
  };
  ($traceurRuntime.createClass)(GetAccessor, {
    transform: function(transformer) {
      return transformer.transformGetAccessor(this);
    },
    visit: function(visitor) {
      visitor.visitGetAccessor(this);
    },
    get type() {
      return GET_ACCESSOR;
    }
  }, {}, ParseTree);
  var IDENTIFIER_EXPRESSION = ParseTreeType.IDENTIFIER_EXPRESSION;
  var IdentifierExpression = function IdentifierExpression(location, identifierToken) {
    this.location = location;
    this.identifierToken = identifierToken;
  };
  ($traceurRuntime.createClass)(IdentifierExpression, {
    transform: function(transformer) {
      return transformer.transformIdentifierExpression(this);
    },
    visit: function(visitor) {
      visitor.visitIdentifierExpression(this);
    },
    get type() {
      return IDENTIFIER_EXPRESSION;
    }
  }, {}, ParseTree);
  var IF_STATEMENT = ParseTreeType.IF_STATEMENT;
  var IfStatement = function IfStatement(location, condition, ifClause, elseClause) {
    this.location = location;
    this.condition = condition;
    this.ifClause = ifClause;
    this.elseClause = elseClause;
  };
  ($traceurRuntime.createClass)(IfStatement, {
    transform: function(transformer) {
      return transformer.transformIfStatement(this);
    },
    visit: function(visitor) {
      visitor.visitIfStatement(this);
    },
    get type() {
      return IF_STATEMENT;
    }
  }, {}, ParseTree);
  var IMPORTED_BINDING = ParseTreeType.IMPORTED_BINDING;
  var ImportedBinding = function ImportedBinding(location, binding) {
    this.location = location;
    this.binding = binding;
  };
  ($traceurRuntime.createClass)(ImportedBinding, {
    transform: function(transformer) {
      return transformer.transformImportedBinding(this);
    },
    visit: function(visitor) {
      visitor.visitImportedBinding(this);
    },
    get type() {
      return IMPORTED_BINDING;
    }
  }, {}, ParseTree);
  var IMPORT_DECLARATION = ParseTreeType.IMPORT_DECLARATION;
  var ImportDeclaration = function ImportDeclaration(location, importClause, moduleSpecifier) {
    this.location = location;
    this.importClause = importClause;
    this.moduleSpecifier = moduleSpecifier;
  };
  ($traceurRuntime.createClass)(ImportDeclaration, {
    transform: function(transformer) {
      return transformer.transformImportDeclaration(this);
    },
    visit: function(visitor) {
      visitor.visitImportDeclaration(this);
    },
    get type() {
      return IMPORT_DECLARATION;
    }
  }, {}, ParseTree);
  var IMPORT_SPECIFIER = ParseTreeType.IMPORT_SPECIFIER;
  var ImportSpecifier = function ImportSpecifier(location, lhs, rhs) {
    this.location = location;
    this.lhs = lhs;
    this.rhs = rhs;
  };
  ($traceurRuntime.createClass)(ImportSpecifier, {
    transform: function(transformer) {
      return transformer.transformImportSpecifier(this);
    },
    visit: function(visitor) {
      visitor.visitImportSpecifier(this);
    },
    get type() {
      return IMPORT_SPECIFIER;
    }
  }, {}, ParseTree);
  var IMPORT_SPECIFIER_SET = ParseTreeType.IMPORT_SPECIFIER_SET;
  var ImportSpecifierSet = function ImportSpecifierSet(location, specifiers) {
    this.location = location;
    this.specifiers = specifiers;
  };
  ($traceurRuntime.createClass)(ImportSpecifierSet, {
    transform: function(transformer) {
      return transformer.transformImportSpecifierSet(this);
    },
    visit: function(visitor) {
      visitor.visitImportSpecifierSet(this);
    },
    get type() {
      return IMPORT_SPECIFIER_SET;
    }
  }, {}, ParseTree);
  var LABELLED_STATEMENT = ParseTreeType.LABELLED_STATEMENT;
  var LabelledStatement = function LabelledStatement(location, name, statement) {
    this.location = location;
    this.name = name;
    this.statement = statement;
  };
  ($traceurRuntime.createClass)(LabelledStatement, {
    transform: function(transformer) {
      return transformer.transformLabelledStatement(this);
    },
    visit: function(visitor) {
      visitor.visitLabelledStatement(this);
    },
    get type() {
      return LABELLED_STATEMENT;
    }
  }, {}, ParseTree);
  var LITERAL_EXPRESSION = ParseTreeType.LITERAL_EXPRESSION;
  var LiteralExpression = function LiteralExpression(location, literalToken) {
    this.location = location;
    this.literalToken = literalToken;
  };
  ($traceurRuntime.createClass)(LiteralExpression, {
    transform: function(transformer) {
      return transformer.transformLiteralExpression(this);
    },
    visit: function(visitor) {
      visitor.visitLiteralExpression(this);
    },
    get type() {
      return LITERAL_EXPRESSION;
    }
  }, {}, ParseTree);
  var LITERAL_PROPERTY_NAME = ParseTreeType.LITERAL_PROPERTY_NAME;
  var LiteralPropertyName = function LiteralPropertyName(location, literalToken) {
    this.location = location;
    this.literalToken = literalToken;
  };
  ($traceurRuntime.createClass)(LiteralPropertyName, {
    transform: function(transformer) {
      return transformer.transformLiteralPropertyName(this);
    },
    visit: function(visitor) {
      visitor.visitLiteralPropertyName(this);
    },
    get type() {
      return LITERAL_PROPERTY_NAME;
    }
  }, {}, ParseTree);
  var MEMBER_EXPRESSION = ParseTreeType.MEMBER_EXPRESSION;
  var MemberExpression = function MemberExpression(location, operand, memberName) {
    this.location = location;
    this.operand = operand;
    this.memberName = memberName;
  };
  ($traceurRuntime.createClass)(MemberExpression, {
    transform: function(transformer) {
      return transformer.transformMemberExpression(this);
    },
    visit: function(visitor) {
      visitor.visitMemberExpression(this);
    },
    get type() {
      return MEMBER_EXPRESSION;
    }
  }, {}, ParseTree);
  var MEMBER_LOOKUP_EXPRESSION = ParseTreeType.MEMBER_LOOKUP_EXPRESSION;
  var MemberLookupExpression = function MemberLookupExpression(location, operand, memberExpression) {
    this.location = location;
    this.operand = operand;
    this.memberExpression = memberExpression;
  };
  ($traceurRuntime.createClass)(MemberLookupExpression, {
    transform: function(transformer) {
      return transformer.transformMemberLookupExpression(this);
    },
    visit: function(visitor) {
      visitor.visitMemberLookupExpression(this);
    },
    get type() {
      return MEMBER_LOOKUP_EXPRESSION;
    }
  }, {}, ParseTree);
  var MODULE = ParseTreeType.MODULE;
  var Module = function Module(location, scriptItemList, moduleName) {
    this.location = location;
    this.scriptItemList = scriptItemList;
    this.moduleName = moduleName;
  };
  ($traceurRuntime.createClass)(Module, {
    transform: function(transformer) {
      return transformer.transformModule(this);
    },
    visit: function(visitor) {
      visitor.visitModule(this);
    },
    get type() {
      return MODULE;
    }
  }, {}, ParseTree);
  var MODULE_DECLARATION = ParseTreeType.MODULE_DECLARATION;
  var ModuleDeclaration = function ModuleDeclaration(location, identifier, expression) {
    this.location = location;
    this.identifier = identifier;
    this.expression = expression;
  };
  ($traceurRuntime.createClass)(ModuleDeclaration, {
    transform: function(transformer) {
      return transformer.transformModuleDeclaration(this);
    },
    visit: function(visitor) {
      visitor.visitModuleDeclaration(this);
    },
    get type() {
      return MODULE_DECLARATION;
    }
  }, {}, ParseTree);
  var MODULE_SPECIFIER = ParseTreeType.MODULE_SPECIFIER;
  var ModuleSpecifier = function ModuleSpecifier(location, token) {
    this.location = location;
    this.token = token;
  };
  ($traceurRuntime.createClass)(ModuleSpecifier, {
    transform: function(transformer) {
      return transformer.transformModuleSpecifier(this);
    },
    visit: function(visitor) {
      visitor.visitModuleSpecifier(this);
    },
    get type() {
      return MODULE_SPECIFIER;
    }
  }, {}, ParseTree);
  var NAMED_EXPORT = ParseTreeType.NAMED_EXPORT;
  var NamedExport = function NamedExport(location, moduleSpecifier, specifierSet) {
    this.location = location;
    this.moduleSpecifier = moduleSpecifier;
    this.specifierSet = specifierSet;
  };
  ($traceurRuntime.createClass)(NamedExport, {
    transform: function(transformer) {
      return transformer.transformNamedExport(this);
    },
    visit: function(visitor) {
      visitor.visitNamedExport(this);
    },
    get type() {
      return NAMED_EXPORT;
    }
  }, {}, ParseTree);
  var NEW_EXPRESSION = ParseTreeType.NEW_EXPRESSION;
  var NewExpression = function NewExpression(location, operand, args) {
    this.location = location;
    this.operand = operand;
    this.args = args;
  };
  ($traceurRuntime.createClass)(NewExpression, {
    transform: function(transformer) {
      return transformer.transformNewExpression(this);
    },
    visit: function(visitor) {
      visitor.visitNewExpression(this);
    },
    get type() {
      return NEW_EXPRESSION;
    }
  }, {}, ParseTree);
  var OBJECT_LITERAL_EXPRESSION = ParseTreeType.OBJECT_LITERAL_EXPRESSION;
  var ObjectLiteralExpression = function ObjectLiteralExpression(location, propertyNameAndValues) {
    this.location = location;
    this.propertyNameAndValues = propertyNameAndValues;
  };
  ($traceurRuntime.createClass)(ObjectLiteralExpression, {
    transform: function(transformer) {
      return transformer.transformObjectLiteralExpression(this);
    },
    visit: function(visitor) {
      visitor.visitObjectLiteralExpression(this);
    },
    get type() {
      return OBJECT_LITERAL_EXPRESSION;
    }
  }, {}, ParseTree);
  var OBJECT_PATTERN = ParseTreeType.OBJECT_PATTERN;
  var ObjectPattern = function ObjectPattern(location, fields) {
    this.location = location;
    this.fields = fields;
  };
  ($traceurRuntime.createClass)(ObjectPattern, {
    transform: function(transformer) {
      return transformer.transformObjectPattern(this);
    },
    visit: function(visitor) {
      visitor.visitObjectPattern(this);
    },
    get type() {
      return OBJECT_PATTERN;
    }
  }, {}, ParseTree);
  var OBJECT_PATTERN_FIELD = ParseTreeType.OBJECT_PATTERN_FIELD;
  var ObjectPatternField = function ObjectPatternField(location, name, element) {
    this.location = location;
    this.name = name;
    this.element = element;
  };
  ($traceurRuntime.createClass)(ObjectPatternField, {
    transform: function(transformer) {
      return transformer.transformObjectPatternField(this);
    },
    visit: function(visitor) {
      visitor.visitObjectPatternField(this);
    },
    get type() {
      return OBJECT_PATTERN_FIELD;
    }
  }, {}, ParseTree);
  var PAREN_EXPRESSION = ParseTreeType.PAREN_EXPRESSION;
  var ParenExpression = function ParenExpression(location, expression) {
    this.location = location;
    this.expression = expression;
  };
  ($traceurRuntime.createClass)(ParenExpression, {
    transform: function(transformer) {
      return transformer.transformParenExpression(this);
    },
    visit: function(visitor) {
      visitor.visitParenExpression(this);
    },
    get type() {
      return PAREN_EXPRESSION;
    }
  }, {}, ParseTree);
  var POSTFIX_EXPRESSION = ParseTreeType.POSTFIX_EXPRESSION;
  var PostfixExpression = function PostfixExpression(location, operand, operator) {
    this.location = location;
    this.operand = operand;
    this.operator = operator;
  };
  ($traceurRuntime.createClass)(PostfixExpression, {
    transform: function(transformer) {
      return transformer.transformPostfixExpression(this);
    },
    visit: function(visitor) {
      visitor.visitPostfixExpression(this);
    },
    get type() {
      return POSTFIX_EXPRESSION;
    }
  }, {}, ParseTree);
  var PREDEFINED_TYPE = ParseTreeType.PREDEFINED_TYPE;
  var PredefinedType = function PredefinedType(location, typeToken) {
    this.location = location;
    this.typeToken = typeToken;
  };
  ($traceurRuntime.createClass)(PredefinedType, {
    transform: function(transformer) {
      return transformer.transformPredefinedType(this);
    },
    visit: function(visitor) {
      visitor.visitPredefinedType(this);
    },
    get type() {
      return PREDEFINED_TYPE;
    }
  }, {}, ParseTree);
  var SCRIPT = ParseTreeType.SCRIPT;
  var Script = function Script(location, scriptItemList, moduleName) {
    this.location = location;
    this.scriptItemList = scriptItemList;
    this.moduleName = moduleName;
  };
  ($traceurRuntime.createClass)(Script, {
    transform: function(transformer) {
      return transformer.transformScript(this);
    },
    visit: function(visitor) {
      visitor.visitScript(this);
    },
    get type() {
      return SCRIPT;
    }
  }, {}, ParseTree);
  var PROPERTY_METHOD_ASSIGNMENT = ParseTreeType.PROPERTY_METHOD_ASSIGNMENT;
  var PropertyMethodAssignment = function PropertyMethodAssignment(location, isStatic, isGenerator, name, formalParameterList, typeAnnotation, annotations, functionBody) {
    this.location = location;
    this.isStatic = isStatic;
    this.isGenerator = isGenerator;
    this.name = name;
    this.formalParameterList = formalParameterList;
    this.typeAnnotation = typeAnnotation;
    this.annotations = annotations;
    this.functionBody = functionBody;
  };
  ($traceurRuntime.createClass)(PropertyMethodAssignment, {
    transform: function(transformer) {
      return transformer.transformPropertyMethodAssignment(this);
    },
    visit: function(visitor) {
      visitor.visitPropertyMethodAssignment(this);
    },
    get type() {
      return PROPERTY_METHOD_ASSIGNMENT;
    }
  }, {}, ParseTree);
  var PROPERTY_NAME_ASSIGNMENT = ParseTreeType.PROPERTY_NAME_ASSIGNMENT;
  var PropertyNameAssignment = function PropertyNameAssignment(location, name, value) {
    this.location = location;
    this.name = name;
    this.value = value;
  };
  ($traceurRuntime.createClass)(PropertyNameAssignment, {
    transform: function(transformer) {
      return transformer.transformPropertyNameAssignment(this);
    },
    visit: function(visitor) {
      visitor.visitPropertyNameAssignment(this);
    },
    get type() {
      return PROPERTY_NAME_ASSIGNMENT;
    }
  }, {}, ParseTree);
  var PROPERTY_NAME_SHORTHAND = ParseTreeType.PROPERTY_NAME_SHORTHAND;
  var PropertyNameShorthand = function PropertyNameShorthand(location, name) {
    this.location = location;
    this.name = name;
  };
  ($traceurRuntime.createClass)(PropertyNameShorthand, {
    transform: function(transformer) {
      return transformer.transformPropertyNameShorthand(this);
    },
    visit: function(visitor) {
      visitor.visitPropertyNameShorthand(this);
    },
    get type() {
      return PROPERTY_NAME_SHORTHAND;
    }
  }, {}, ParseTree);
  var REST_PARAMETER = ParseTreeType.REST_PARAMETER;
  var RestParameter = function RestParameter(location, identifier) {
    this.location = location;
    this.identifier = identifier;
  };
  ($traceurRuntime.createClass)(RestParameter, {
    transform: function(transformer) {
      return transformer.transformRestParameter(this);
    },
    visit: function(visitor) {
      visitor.visitRestParameter(this);
    },
    get type() {
      return REST_PARAMETER;
    }
  }, {}, ParseTree);
  var RETURN_STATEMENT = ParseTreeType.RETURN_STATEMENT;
  var ReturnStatement = function ReturnStatement(location, expression) {
    this.location = location;
    this.expression = expression;
  };
  ($traceurRuntime.createClass)(ReturnStatement, {
    transform: function(transformer) {
      return transformer.transformReturnStatement(this);
    },
    visit: function(visitor) {
      visitor.visitReturnStatement(this);
    },
    get type() {
      return RETURN_STATEMENT;
    }
  }, {}, ParseTree);
  var SET_ACCESSOR = ParseTreeType.SET_ACCESSOR;
  var SetAccessor = function SetAccessor(location, isStatic, name, parameter, annotations, body) {
    this.location = location;
    this.isStatic = isStatic;
    this.name = name;
    this.parameter = parameter;
    this.annotations = annotations;
    this.body = body;
  };
  ($traceurRuntime.createClass)(SetAccessor, {
    transform: function(transformer) {
      return transformer.transformSetAccessor(this);
    },
    visit: function(visitor) {
      visitor.visitSetAccessor(this);
    },
    get type() {
      return SET_ACCESSOR;
    }
  }, {}, ParseTree);
  var SPREAD_EXPRESSION = ParseTreeType.SPREAD_EXPRESSION;
  var SpreadExpression = function SpreadExpression(location, expression) {
    this.location = location;
    this.expression = expression;
  };
  ($traceurRuntime.createClass)(SpreadExpression, {
    transform: function(transformer) {
      return transformer.transformSpreadExpression(this);
    },
    visit: function(visitor) {
      visitor.visitSpreadExpression(this);
    },
    get type() {
      return SPREAD_EXPRESSION;
    }
  }, {}, ParseTree);
  var SPREAD_PATTERN_ELEMENT = ParseTreeType.SPREAD_PATTERN_ELEMENT;
  var SpreadPatternElement = function SpreadPatternElement(location, lvalue) {
    this.location = location;
    this.lvalue = lvalue;
  };
  ($traceurRuntime.createClass)(SpreadPatternElement, {
    transform: function(transformer) {
      return transformer.transformSpreadPatternElement(this);
    },
    visit: function(visitor) {
      visitor.visitSpreadPatternElement(this);
    },
    get type() {
      return SPREAD_PATTERN_ELEMENT;
    }
  }, {}, ParseTree);
  var SUPER_EXPRESSION = ParseTreeType.SUPER_EXPRESSION;
  var SuperExpression = function SuperExpression(location) {
    this.location = location;
  };
  ($traceurRuntime.createClass)(SuperExpression, {
    transform: function(transformer) {
      return transformer.transformSuperExpression(this);
    },
    visit: function(visitor) {
      visitor.visitSuperExpression(this);
    },
    get type() {
      return SUPER_EXPRESSION;
    }
  }, {}, ParseTree);
  var SWITCH_STATEMENT = ParseTreeType.SWITCH_STATEMENT;
  var SwitchStatement = function SwitchStatement(location, expression, caseClauses) {
    this.location = location;
    this.expression = expression;
    this.caseClauses = caseClauses;
  };
  ($traceurRuntime.createClass)(SwitchStatement, {
    transform: function(transformer) {
      return transformer.transformSwitchStatement(this);
    },
    visit: function(visitor) {
      visitor.visitSwitchStatement(this);
    },
    get type() {
      return SWITCH_STATEMENT;
    }
  }, {}, ParseTree);
  var SYNTAX_ERROR_TREE = ParseTreeType.SYNTAX_ERROR_TREE;
  var SyntaxErrorTree = function SyntaxErrorTree(location, nextToken, message) {
    this.location = location;
    this.nextToken = nextToken;
    this.message = message;
  };
  ($traceurRuntime.createClass)(SyntaxErrorTree, {
    transform: function(transformer) {
      return transformer.transformSyntaxErrorTree(this);
    },
    visit: function(visitor) {
      visitor.visitSyntaxErrorTree(this);
    },
    get type() {
      return SYNTAX_ERROR_TREE;
    }
  }, {}, ParseTree);
  var TEMPLATE_LITERAL_EXPRESSION = ParseTreeType.TEMPLATE_LITERAL_EXPRESSION;
  var TemplateLiteralExpression = function TemplateLiteralExpression(location, operand, elements) {
    this.location = location;
    this.operand = operand;
    this.elements = elements;
  };
  ($traceurRuntime.createClass)(TemplateLiteralExpression, {
    transform: function(transformer) {
      return transformer.transformTemplateLiteralExpression(this);
    },
    visit: function(visitor) {
      visitor.visitTemplateLiteralExpression(this);
    },
    get type() {
      return TEMPLATE_LITERAL_EXPRESSION;
    }
  }, {}, ParseTree);
  var TEMPLATE_LITERAL_PORTION = ParseTreeType.TEMPLATE_LITERAL_PORTION;
  var TemplateLiteralPortion = function TemplateLiteralPortion(location, value) {
    this.location = location;
    this.value = value;
  };
  ($traceurRuntime.createClass)(TemplateLiteralPortion, {
    transform: function(transformer) {
      return transformer.transformTemplateLiteralPortion(this);
    },
    visit: function(visitor) {
      visitor.visitTemplateLiteralPortion(this);
    },
    get type() {
      return TEMPLATE_LITERAL_PORTION;
    }
  }, {}, ParseTree);
  var TEMPLATE_SUBSTITUTION = ParseTreeType.TEMPLATE_SUBSTITUTION;
  var TemplateSubstitution = function TemplateSubstitution(location, expression) {
    this.location = location;
    this.expression = expression;
  };
  ($traceurRuntime.createClass)(TemplateSubstitution, {
    transform: function(transformer) {
      return transformer.transformTemplateSubstitution(this);
    },
    visit: function(visitor) {
      visitor.visitTemplateSubstitution(this);
    },
    get type() {
      return TEMPLATE_SUBSTITUTION;
    }
  }, {}, ParseTree);
  var THIS_EXPRESSION = ParseTreeType.THIS_EXPRESSION;
  var ThisExpression = function ThisExpression(location) {
    this.location = location;
  };
  ($traceurRuntime.createClass)(ThisExpression, {
    transform: function(transformer) {
      return transformer.transformThisExpression(this);
    },
    visit: function(visitor) {
      visitor.visitThisExpression(this);
    },
    get type() {
      return THIS_EXPRESSION;
    }
  }, {}, ParseTree);
  var THROW_STATEMENT = ParseTreeType.THROW_STATEMENT;
  var ThrowStatement = function ThrowStatement(location, value) {
    this.location = location;
    this.value = value;
  };
  ($traceurRuntime.createClass)(ThrowStatement, {
    transform: function(transformer) {
      return transformer.transformThrowStatement(this);
    },
    visit: function(visitor) {
      visitor.visitThrowStatement(this);
    },
    get type() {
      return THROW_STATEMENT;
    }
  }, {}, ParseTree);
  var TRY_STATEMENT = ParseTreeType.TRY_STATEMENT;
  var TryStatement = function TryStatement(location, body, catchBlock, finallyBlock) {
    this.location = location;
    this.body = body;
    this.catchBlock = catchBlock;
    this.finallyBlock = finallyBlock;
  };
  ($traceurRuntime.createClass)(TryStatement, {
    transform: function(transformer) {
      return transformer.transformTryStatement(this);
    },
    visit: function(visitor) {
      visitor.visitTryStatement(this);
    },
    get type() {
      return TRY_STATEMENT;
    }
  }, {}, ParseTree);
  var TYPE_NAME = ParseTreeType.TYPE_NAME;
  var TypeName = function TypeName(location, moduleName, name) {
    this.location = location;
    this.moduleName = moduleName;
    this.name = name;
  };
  ($traceurRuntime.createClass)(TypeName, {
    transform: function(transformer) {
      return transformer.transformTypeName(this);
    },
    visit: function(visitor) {
      visitor.visitTypeName(this);
    },
    get type() {
      return TYPE_NAME;
    }
  }, {}, ParseTree);
  var UNARY_EXPRESSION = ParseTreeType.UNARY_EXPRESSION;
  var UnaryExpression = function UnaryExpression(location, operator, operand) {
    this.location = location;
    this.operator = operator;
    this.operand = operand;
  };
  ($traceurRuntime.createClass)(UnaryExpression, {
    transform: function(transformer) {
      return transformer.transformUnaryExpression(this);
    },
    visit: function(visitor) {
      visitor.visitUnaryExpression(this);
    },
    get type() {
      return UNARY_EXPRESSION;
    }
  }, {}, ParseTree);
  var VARIABLE_DECLARATION = ParseTreeType.VARIABLE_DECLARATION;
  var VariableDeclaration = function VariableDeclaration(location, lvalue, typeAnnotation, initialiser) {
    this.location = location;
    this.lvalue = lvalue;
    this.typeAnnotation = typeAnnotation;
    this.initialiser = initialiser;
  };
  ($traceurRuntime.createClass)(VariableDeclaration, {
    transform: function(transformer) {
      return transformer.transformVariableDeclaration(this);
    },
    visit: function(visitor) {
      visitor.visitVariableDeclaration(this);
    },
    get type() {
      return VARIABLE_DECLARATION;
    }
  }, {}, ParseTree);
  var VARIABLE_DECLARATION_LIST = ParseTreeType.VARIABLE_DECLARATION_LIST;
  var VariableDeclarationList = function VariableDeclarationList(location, declarationType, declarations) {
    this.location = location;
    this.declarationType = declarationType;
    this.declarations = declarations;
  };
  ($traceurRuntime.createClass)(VariableDeclarationList, {
    transform: function(transformer) {
      return transformer.transformVariableDeclarationList(this);
    },
    visit: function(visitor) {
      visitor.visitVariableDeclarationList(this);
    },
    get type() {
      return VARIABLE_DECLARATION_LIST;
    }
  }, {}, ParseTree);
  var VARIABLE_STATEMENT = ParseTreeType.VARIABLE_STATEMENT;
  var VariableStatement = function VariableStatement(location, declarations) {
    this.location = location;
    this.declarations = declarations;
  };
  ($traceurRuntime.createClass)(VariableStatement, {
    transform: function(transformer) {
      return transformer.transformVariableStatement(this);
    },
    visit: function(visitor) {
      visitor.visitVariableStatement(this);
    },
    get type() {
      return VARIABLE_STATEMENT;
    }
  }, {}, ParseTree);
  var WHILE_STATEMENT = ParseTreeType.WHILE_STATEMENT;
  var WhileStatement = function WhileStatement(location, condition, body) {
    this.location = location;
    this.condition = condition;
    this.body = body;
  };
  ($traceurRuntime.createClass)(WhileStatement, {
    transform: function(transformer) {
      return transformer.transformWhileStatement(this);
    },
    visit: function(visitor) {
      visitor.visitWhileStatement(this);
    },
    get type() {
      return WHILE_STATEMENT;
    }
  }, {}, ParseTree);
  var WITH_STATEMENT = ParseTreeType.WITH_STATEMENT;
  var WithStatement = function WithStatement(location, expression, body) {
    this.location = location;
    this.expression = expression;
    this.body = body;
  };
  ($traceurRuntime.createClass)(WithStatement, {
    transform: function(transformer) {
      return transformer.transformWithStatement(this);
    },
    visit: function(visitor) {
      visitor.visitWithStatement(this);
    },
    get type() {
      return WITH_STATEMENT;
    }
  }, {}, ParseTree);
  var YIELD_EXPRESSION = ParseTreeType.YIELD_EXPRESSION;
  var YieldExpression = function YieldExpression(location, expression, isYieldFor) {
    this.location = location;
    this.expression = expression;
    this.isYieldFor = isYieldFor;
  };
  ($traceurRuntime.createClass)(YieldExpression, {
    transform: function(transformer) {
      return transformer.transformYieldExpression(this);
    },
    visit: function(visitor) {
      visitor.visitYieldExpression(this);
    },
    get type() {
      return YIELD_EXPRESSION;
    }
  }, {}, ParseTree);
  return {
    get Annotation() {
      return Annotation;
    },
    get AnonBlock() {
      return AnonBlock;
    },
    get ArgumentList() {
      return ArgumentList;
    },
    get ArrayComprehension() {
      return ArrayComprehension;
    },
    get ArrayLiteralExpression() {
      return ArrayLiteralExpression;
    },
    get ArrayPattern() {
      return ArrayPattern;
    },
    get ArrowFunctionExpression() {
      return ArrowFunctionExpression;
    },
    get AwaitStatement() {
      return AwaitStatement;
    },
    get BinaryOperator() {
      return BinaryOperator;
    },
    get BindingElement() {
      return BindingElement;
    },
    get BindingIdentifier() {
      return BindingIdentifier;
    },
    get Block() {
      return Block;
    },
    get BreakStatement() {
      return BreakStatement;
    },
    get CallExpression() {
      return CallExpression;
    },
    get CaseClause() {
      return CaseClause;
    },
    get Catch() {
      return Catch;
    },
    get ClassDeclaration() {
      return ClassDeclaration;
    },
    get ClassExpression() {
      return ClassExpression;
    },
    get CommaExpression() {
      return CommaExpression;
    },
    get ComprehensionFor() {
      return ComprehensionFor;
    },
    get ComprehensionIf() {
      return ComprehensionIf;
    },
    get ComputedPropertyName() {
      return ComputedPropertyName;
    },
    get ConditionalExpression() {
      return ConditionalExpression;
    },
    get ContinueStatement() {
      return ContinueStatement;
    },
    get CoverFormals() {
      return CoverFormals;
    },
    get CoverInitialisedName() {
      return CoverInitialisedName;
    },
    get DebuggerStatement() {
      return DebuggerStatement;
    },
    get DefaultClause() {
      return DefaultClause;
    },
    get DoWhileStatement() {
      return DoWhileStatement;
    },
    get EmptyStatement() {
      return EmptyStatement;
    },
    get ExportDeclaration() {
      return ExportDeclaration;
    },
    get ExportDefault() {
      return ExportDefault;
    },
    get ExportSpecifier() {
      return ExportSpecifier;
    },
    get ExportSpecifierSet() {
      return ExportSpecifierSet;
    },
    get ExportStar() {
      return ExportStar;
    },
    get ExpressionStatement() {
      return ExpressionStatement;
    },
    get Finally() {
      return Finally;
    },
    get ForInStatement() {
      return ForInStatement;
    },
    get ForOfStatement() {
      return ForOfStatement;
    },
    get ForStatement() {
      return ForStatement;
    },
    get FormalParameter() {
      return FormalParameter;
    },
    get FormalParameterList() {
      return FormalParameterList;
    },
    get FunctionBody() {
      return FunctionBody;
    },
    get FunctionDeclaration() {
      return FunctionDeclaration;
    },
    get FunctionExpression() {
      return FunctionExpression;
    },
    get GeneratorComprehension() {
      return GeneratorComprehension;
    },
    get GetAccessor() {
      return GetAccessor;
    },
    get IdentifierExpression() {
      return IdentifierExpression;
    },
    get IfStatement() {
      return IfStatement;
    },
    get ImportedBinding() {
      return ImportedBinding;
    },
    get ImportDeclaration() {
      return ImportDeclaration;
    },
    get ImportSpecifier() {
      return ImportSpecifier;
    },
    get ImportSpecifierSet() {
      return ImportSpecifierSet;
    },
    get LabelledStatement() {
      return LabelledStatement;
    },
    get LiteralExpression() {
      return LiteralExpression;
    },
    get LiteralPropertyName() {
      return LiteralPropertyName;
    },
    get MemberExpression() {
      return MemberExpression;
    },
    get MemberLookupExpression() {
      return MemberLookupExpression;
    },
    get Module() {
      return Module;
    },
    get ModuleDeclaration() {
      return ModuleDeclaration;
    },
    get ModuleSpecifier() {
      return ModuleSpecifier;
    },
    get NamedExport() {
      return NamedExport;
    },
    get NewExpression() {
      return NewExpression;
    },
    get ObjectLiteralExpression() {
      return ObjectLiteralExpression;
    },
    get ObjectPattern() {
      return ObjectPattern;
    },
    get ObjectPatternField() {
      return ObjectPatternField;
    },
    get ParenExpression() {
      return ParenExpression;
    },
    get PostfixExpression() {
      return PostfixExpression;
    },
    get PredefinedType() {
      return PredefinedType;
    },
    get Script() {
      return Script;
    },
    get PropertyMethodAssignment() {
      return PropertyMethodAssignment;
    },
    get PropertyNameAssignment() {
      return PropertyNameAssignment;
    },
    get PropertyNameShorthand() {
      return PropertyNameShorthand;
    },
    get RestParameter() {
      return RestParameter;
    },
    get ReturnStatement() {
      return ReturnStatement;
    },
    get SetAccessor() {
      return SetAccessor;
    },
    get SpreadExpression() {
      return SpreadExpression;
    },
    get SpreadPatternElement() {
      return SpreadPatternElement;
    },
    get SuperExpression() {
      return SuperExpression;
    },
    get SwitchStatement() {
      return SwitchStatement;
    },
    get SyntaxErrorTree() {
      return SyntaxErrorTree;
    },
    get TemplateLiteralExpression() {
      return TemplateLiteralExpression;
    },
    get TemplateLiteralPortion() {
      return TemplateLiteralPortion;
    },
    get TemplateSubstitution() {
      return TemplateSubstitution;
    },
    get ThisExpression() {
      return ThisExpression;
    },
    get ThrowStatement() {
      return ThrowStatement;
    },
    get TryStatement() {
      return TryStatement;
    },
    get TypeName() {
      return TypeName;
    },
    get UnaryExpression() {
      return UnaryExpression;
    },
    get VariableDeclaration() {
      return VariableDeclaration;
    },
    get VariableDeclarationList() {
      return VariableDeclarationList;
    },
    get VariableStatement() {
      return VariableStatement;
    },
    get WhileStatement() {
      return WhileStatement;
    },
    get WithStatement() {
      return WithStatement;
    },
    get YieldExpression() {
      return YieldExpression;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/semantics/FreeVariableChecker", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/semantics/FreeVariableChecker";
  var ARGUMENTS = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/PredefinedName").ARGUMENTS;
  var $__40 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      BindingIdentifier = $__40.BindingIdentifier,
      IdentifierExpression = $__40.IdentifierExpression;
  var IdentifierToken = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/IdentifierToken").IdentifierToken;
  var IDENTIFIER_EXPRESSION = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType").IDENTIFIER_EXPRESSION;
  var ParseTreeVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/ParseTreeVisitor").ParseTreeVisitor;
  var TYPEOF = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").TYPEOF;
  var global = this;
  var Scope = function Scope(parent) {
    this.parent = parent;
    this.references = Object.create(null);
    this.declarations = Object.create(null);
  };
  ($traceurRuntime.createClass)(Scope, {}, {});
  function getVariableName(name) {
    if (name instanceof IdentifierExpression) {
      name = name.identifierToken;
    } else if (name instanceof BindingIdentifier) {
      name = name.identifierToken;
    }
    if (name instanceof IdentifierToken) {
      name = name.value;
    }
    return name;
  }
  var FreeVariableChecker = function FreeVariableChecker(reporter) {
    $traceurRuntime.superCall(this, $FreeVariableChecker.prototype, "constructor", []);
    this.reporter_ = reporter;
    this.scope_ = null;
    this.disableChecksLevel_ = 0;
  };
  var $FreeVariableChecker = FreeVariableChecker;
  ($traceurRuntime.createClass)(FreeVariableChecker, {
    pushScope_: function() {
      return this.scope_ = new Scope(this.scope_);
    },
    pop_: function(scope) {
      if (this.scope_ != scope) {
        throw new Error('FreeVariableChecker scope mismatch');
      }
      this.validateScope_();
      this.scope_ = scope.parent;
    },
    visitScript: function(tree, global) {
      var scope = this.pushScope_();
      var object = global;
      while (object) {
        Object.getOwnPropertyNames(object).forEach(this.declareVariable_, this);
        object = Object.getPrototypeOf(object);
      }
      this.visitList(tree.scriptItemList);
      this.pop_(scope);
    },
    visitFunction_: function(name, formalParameterList, body) {
      var scope = this.pushScope_();
      this.visitAny(name);
      this.declareVariable_(ARGUMENTS);
      this.visitAny(formalParameterList);
      this.visitAny(body);
      this.pop_(scope);
    },
    visitFunctionDeclaration: function(tree) {
      this.declareVariable_(tree.name);
      this.visitFunction_(null, tree.formalParameterList, tree.functionBody);
    },
    visitFunctionExpression: function(tree) {
      this.visitFunction_(tree.name, tree.formalParameterList, tree.functionBody);
    },
    visitArrowFunctionExpression: function(tree) {
      this.visitFunction_(null, tree.formalParameters, tree.functionBody);
    },
    visitGetAccessor: function(tree) {
      var scope = this.pushScope_();
      $traceurRuntime.superCall(this, $FreeVariableChecker.prototype, "visitGetAccessor", [tree]);
      this.pop_(scope);
    },
    visitSetAccessor: function(tree) {
      var scope = this.pushScope_();
      $traceurRuntime.superCall(this, $FreeVariableChecker.prototype, "visitSetAccessor", [tree]);
      this.pop_(scope);
    },
    visitCatch: function(tree) {
      var scope = this.pushScope_();
      $traceurRuntime.superCall(this, $FreeVariableChecker.prototype, "visitCatch", [tree]);
      this.pop_(scope);
    },
    visitBindingIdentifier: function(tree) {
      this.declareVariable_(tree);
    },
    visitIdentifierExpression: function(tree) {
      if (this.disableChecksLevel_) return;
      var name = getVariableName(tree);
      var scope = this.scope_;
      if (!(name in scope.references)) {
        scope.references[name] = tree.location;
      }
    },
    visitUnaryExpression: function(tree) {
      if (tree.operator.type === TYPEOF && tree.operand.type === IDENTIFIER_EXPRESSION) {
        this.declareVariable_(tree.operand);
      } else {
        $traceurRuntime.superCall(this, $FreeVariableChecker.prototype, "visitUnaryExpression", [tree]);
      }
    },
    visitWithStatement: function(tree) {
      this.visitAny(tree.expression);
      this.disableChecksLevel_++;
      this.visitAny(tree.body);
      this.disableChecksLevel_--;
    },
    declareVariable_: function(tree) {
      var name = getVariableName(tree);
      if (name) {
        var scope = this.scope_;
        if (!(name in scope.declarations)) {
          scope.declarations[name] = tree.location;
        }
      }
    },
    validateScope_: function() {
      var $__37 = this;
      if (this.disableChecksLevel_) return;
      var scope = this.scope_;
      var errors = [];
      for (var name in scope.references) {
        if (!(name in scope.declarations)) {
          var location = scope.references[name];
          if (!scope.parent) {
            if (!location) {
              throw new Error(("generated variable " + name + " is not defined"));
            }
            errors.push([location.start, '%s is not defined', name]);
          } else if (!(name in scope.parent.references)) {
            scope.parent.references[name] = location;
          }
        }
      }
      if (errors.length) {
        errors.sort((function(x, y) {
          return x[0].offset - y[0].offset;
        }));
        errors.forEach((function(e) {
          var $__41;
          ($__41 = $__37).reportError_.apply($__41, $traceurRuntime.toObject(e));
        }));
      }
    },
    reportError_: function() {
      var $__41;
      for (var args = [],
          $__39 = 0; $__39 < arguments.length; $__39++) args[$__39] = arguments[$__39];
      ($__41 = this.reporter_).reportError.apply($__41, $traceurRuntime.toObject(args));
    }
  }, {checkScript: function(reporter, tree) {
      new $FreeVariableChecker(reporter).visitScript(tree, global);
    }}, ParseTreeVisitor);
  return {
    get getVariableName() {
      return getVariableName;
    },
    get FreeVariableChecker() {
      return FreeVariableChecker;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/Keywords", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/Keywords";
  var keywords = ['break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'export', 'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof', 'let', 'new', 'return', 'super', 'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with', 'enum', 'extends', 'null', 'true', 'false', 'await'];
  var strictKeywords = ['implements', 'interface', 'package', 'private', 'protected', 'public', 'static', 'yield'];
  var keywordsByName = Object.create(null);
  var NORMAL_KEYWORD = 1;
  var STRICT_KEYWORD = 2;
  keywords.forEach((function(value) {
    keywordsByName[value] = NORMAL_KEYWORD;
  }));
  strictKeywords.forEach((function(value) {
    keywordsByName[value] = STRICT_KEYWORD;
  }));
  function getKeywordType(value) {
    return keywordsByName[value];
  }
  function isStrictKeyword(value) {
    return getKeywordType(value) === STRICT_KEYWORD;
  }
  return {
    get NORMAL_KEYWORD() {
      return NORMAL_KEYWORD;
    },
    get STRICT_KEYWORD() {
      return STRICT_KEYWORD;
    },
    get getKeywordType() {
      return getKeywordType;
    },
    get isStrictKeyword() {
      return isStrictKeyword;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/outputgeneration/ParseTreeWriter", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/outputgeneration/ParseTreeWriter";
  var ParseTreeVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/ParseTreeVisitor").ParseTreeVisitor;
  var $__43 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/PredefinedName"),
      AS = $__43.AS,
      FROM = $__43.FROM,
      GET = $__43.GET,
      OF = $__43.OF,
      MODULE = $__43.MODULE,
      SET = $__43.SET;
  var Token = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Token").Token;
  var getKeywordType = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Keywords").getKeywordType;
  var $__43 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      AMPERSAND = $__43.AMPERSAND,
      AMPERSAND_EQUAL = $__43.AMPERSAND_EQUAL,
      AND = $__43.AND,
      ARROW = $__43.ARROW,
      AT = $__43.AT,
      AWAIT = $__43.AWAIT,
      BACK_QUOTE = $__43.BACK_QUOTE,
      BANG = $__43.BANG,
      BAR = $__43.BAR,
      BAR_EQUAL = $__43.BAR_EQUAL,
      BREAK = $__43.BREAK,
      CARET = $__43.CARET,
      CARET_EQUAL = $__43.CARET_EQUAL,
      CASE = $__43.CASE,
      CATCH = $__43.CATCH,
      CLASS = $__43.CLASS,
      CLOSE_ANGLE = $__43.CLOSE_ANGLE,
      CLOSE_CURLY = $__43.CLOSE_CURLY,
      CLOSE_PAREN = $__43.CLOSE_PAREN,
      CLOSE_SQUARE = $__43.CLOSE_SQUARE,
      COLON = $__43.COLON,
      COMMA = $__43.COMMA,
      CONST = $__43.CONST,
      CONTINUE = $__43.CONTINUE,
      DEBUGGER = $__43.DEBUGGER,
      DEFAULT = $__43.DEFAULT,
      DELETE = $__43.DELETE,
      DO = $__43.DO,
      DOT_DOT_DOT = $__43.DOT_DOT_DOT,
      ELSE = $__43.ELSE,
      END_OF_FILE = $__43.END_OF_FILE,
      ENUM = $__43.ENUM,
      EQUAL = $__43.EQUAL,
      EQUAL_EQUAL = $__43.EQUAL_EQUAL,
      EQUAL_EQUAL_EQUAL = $__43.EQUAL_EQUAL_EQUAL,
      ERROR = $__43.ERROR,
      EXPORT = $__43.EXPORT,
      EXTENDS = $__43.EXTENDS,
      FALSE = $__43.FALSE,
      FINALLY = $__43.FINALLY,
      FOR = $__43.FOR,
      FUNCTION = $__43.FUNCTION,
      GREATER_EQUAL = $__43.GREATER_EQUAL,
      IDENTIFIER = $__43.IDENTIFIER,
      IF = $__43.IF,
      IMPLEMENTS = $__43.IMPLEMENTS,
      IMPORT = $__43.IMPORT,
      IN = $__43.IN,
      INSTANCEOF = $__43.INSTANCEOF,
      INTERFACE = $__43.INTERFACE,
      LEFT_SHIFT = $__43.LEFT_SHIFT,
      LEFT_SHIFT_EQUAL = $__43.LEFT_SHIFT_EQUAL,
      LESS_EQUAL = $__43.LESS_EQUAL,
      LET = $__43.LET,
      MINUS = $__43.MINUS,
      MINUS_EQUAL = $__43.MINUS_EQUAL,
      MINUS_MINUS = $__43.MINUS_MINUS,
      NEW = $__43.NEW,
      NO_SUBSTITUTION_TEMPLATE = $__43.NO_SUBSTITUTION_TEMPLATE,
      NOT_EQUAL = $__43.NOT_EQUAL,
      NOT_EQUAL_EQUAL = $__43.NOT_EQUAL_EQUAL,
      NULL = $__43.NULL,
      NUMBER = $__43.NUMBER,
      OPEN_ANGLE = $__43.OPEN_ANGLE,
      OPEN_CURLY = $__43.OPEN_CURLY,
      OPEN_PAREN = $__43.OPEN_PAREN,
      OPEN_SQUARE = $__43.OPEN_SQUARE,
      OR = $__43.OR,
      PACKAGE = $__43.PACKAGE,
      PERCENT = $__43.PERCENT,
      PERCENT_EQUAL = $__43.PERCENT_EQUAL,
      PERIOD = $__43.PERIOD,
      PLUS = $__43.PLUS,
      PLUS_EQUAL = $__43.PLUS_EQUAL,
      PLUS_PLUS = $__43.PLUS_PLUS,
      PRIVATE = $__43.PRIVATE,
      PROTECTED = $__43.PROTECTED,
      PUBLIC = $__43.PUBLIC,
      QUESTION = $__43.QUESTION,
      REGULAR_EXPRESSION = $__43.REGULAR_EXPRESSION,
      RETURN = $__43.RETURN,
      RIGHT_SHIFT = $__43.RIGHT_SHIFT,
      RIGHT_SHIFT_EQUAL = $__43.RIGHT_SHIFT_EQUAL,
      SEMI_COLON = $__43.SEMI_COLON,
      SLASH = $__43.SLASH,
      SLASH_EQUAL = $__43.SLASH_EQUAL,
      STAR = $__43.STAR,
      STAR_EQUAL = $__43.STAR_EQUAL,
      STATIC = $__43.STATIC,
      STRING = $__43.STRING,
      SUPER = $__43.SUPER,
      SWITCH = $__43.SWITCH,
      TEMPLATE_HEAD = $__43.TEMPLATE_HEAD,
      TEMPLATE_MIDDLE = $__43.TEMPLATE_MIDDLE,
      TEMPLATE_TAIL = $__43.TEMPLATE_TAIL,
      THIS = $__43.THIS,
      THROW = $__43.THROW,
      TILDE = $__43.TILDE,
      TRUE = $__43.TRUE,
      TRY = $__43.TRY,
      TYPEOF = $__43.TYPEOF,
      UNSIGNED_RIGHT_SHIFT = $__43.UNSIGNED_RIGHT_SHIFT,
      UNSIGNED_RIGHT_SHIFT_EQUAL = $__43.UNSIGNED_RIGHT_SHIFT_EQUAL,
      VAR = $__43.VAR,
      VOID = $__43.VOID,
      WHILE = $__43.WHILE,
      WITH = $__43.WITH,
      YIELD = $__43.YIELD;
  var NEW_LINE = '\n';
  var LINE_LENGTH = 80;
  var ParseTreeWriter = function ParseTreeWriter() {
    var $__43 = arguments[0] !== (void 0) ? arguments[0]: {},
        highlighted = "highlighted"in $__43 ? $__43.highlighted: false,
        showLineNumbers = "showLineNumbers"in $__43 ? $__43.showLineNumbers: false,
        prettyPrint = "prettyPrint"in $__43 ? $__43.prettyPrint: true;
    $traceurRuntime.superCall(this, $ParseTreeWriter.prototype, "constructor", []);
    this.highlighted_ = highlighted;
    this.showLineNumbers_ = showLineNumbers;
    this.prettyPrint_ = prettyPrint;
    this.result_ = '';
    this.currentLine_ = '';
    this.currentLineComment_ = null;
    this.indentDepth_ = 0;
    this.lastToken_ = null;
    this.currentParameterTypeAnnotation_ = null;
  };
  var $ParseTreeWriter = ParseTreeWriter;
  ($traceurRuntime.createClass)(ParseTreeWriter, {
    toString: function() {
      if (this.currentLine_.length > 0) {
        this.result_ += this.currentLine_;
        this.currentLine_ = '';
      }
      return this.result_;
    },
    visitAny: function(tree) {
      if (!tree) {
        return;
      }
      if (tree === this.highlighted_) {
        this.write_('\x1B[41m');
      }
      if (tree.location !== null && tree.location.start !== null && this.showLineNumbers_) {
        var line = tree.location.start.line + 1;
        var column = tree.location.start.column;
        this.currentLineComment_ = ("Line: " + line + "." + column);
      }
      this.currentLocation = tree.location;
      $traceurRuntime.superCall(this, $ParseTreeWriter.prototype, "visitAny", [tree]);
      if (tree === this.highlighted_) {
        this.write_('\x1B[0m');
      }
    },
    visitAnnotation: function(tree) {
      this.write_(AT);
      this.visitAny(tree.name);
      if (tree.args !== null) {
        this.write_(OPEN_PAREN);
        this.writeList_(tree.args, COMMA, false);
        this.write_(CLOSE_PAREN);
      }
    },
    visitArgumentList: function(tree) {
      this.write_(OPEN_PAREN);
      this.writeList_(tree.args, COMMA, false);
      this.write_(CLOSE_PAREN);
    },
    visitArrayComprehension: function(tree) {
      this.write_(OPEN_SQUARE);
      this.visitList(tree.comprehensionList);
      this.visitAny(tree.expression);
      this.write_(CLOSE_SQUARE);
    },
    visitArrayLiteralExpression: function(tree) {
      this.write_(OPEN_SQUARE);
      this.writeList_(tree.elements, COMMA, false);
      this.write_(CLOSE_SQUARE);
    },
    visitArrayPattern: function(tree) {
      this.write_(OPEN_SQUARE);
      this.writeList_(tree.elements, COMMA, false);
      this.write_(CLOSE_SQUARE);
    },
    visitArrowFunctionExpression: function(tree) {
      this.write_(OPEN_PAREN);
      this.visitAny(tree.formalParameters);
      this.write_(CLOSE_PAREN);
      this.write_(ARROW);
      this.visitAny(tree.functionBody);
    },
    visitAwaitStatement: function(tree) {
      this.write_(AWAIT);
      if (tree.identifier !== null) {
        this.write_(tree.identifier);
        this.write_(EQUAL);
      }
      this.visitAny(tree.expression);
      this.write_(SEMI_COLON);
    },
    visitBinaryOperator: function(tree) {
      this.visitAny(tree.left);
      this.write_(tree.operator);
      this.visitAny(tree.right);
    },
    visitBindingElement: function(tree) {
      var typeAnnotation = this.currentParameterTypeAnnotation_;
      this.currentParameterTypeAnnotation_ = null;
      this.visitAny(tree.binding);
      this.writeTypeAnnotation_(typeAnnotation);
      if (tree.initialiser) {
        this.write_(EQUAL);
        this.visitAny(tree.initialiser);
      }
    },
    visitBindingIdentifier: function(tree) {
      this.write_(tree.identifierToken);
    },
    visitBlock: function(tree) {
      this.write_(OPEN_CURLY);
      this.writelnList_(tree.statements);
      this.write_(CLOSE_CURLY);
    },
    visitBreakStatement: function(tree) {
      this.write_(BREAK);
      if (tree.name !== null) {
        this.write_(tree.name);
      }
      this.write_(SEMI_COLON);
    },
    visitCallExpression: function(tree) {
      this.visitAny(tree.operand);
      this.visitAny(tree.args);
    },
    visitCaseClause: function(tree) {
      this.write_(CASE);
      this.visitAny(tree.expression);
      this.write_(COLON);
      this.indentDepth_++;
      this.writelnList_(tree.statements);
      this.indentDepth_--;
    },
    visitCatch: function(tree) {
      this.write_(CATCH);
      this.write_(OPEN_PAREN);
      this.visitAny(tree.binding);
      this.write_(CLOSE_PAREN);
      this.visitAny(tree.catchBody);
    },
    visitClassShared_: function(tree) {
      this.writeAnnotations_(tree.annotations);
      this.write_(CLASS);
      this.visitAny(tree.name);
      if (tree.superClass !== null) {
        this.write_(EXTENDS);
        this.visitAny(tree.superClass);
      }
      this.write_(OPEN_CURLY);
      this.writelnList_(tree.elements);
      this.write_(CLOSE_CURLY);
    },
    visitClassDeclaration: function(tree) {
      this.visitClassShared_(tree);
    },
    visitClassExpression: function(tree) {
      this.visitClassShared_(tree);
    },
    visitCommaExpression: function(tree) {
      this.writeList_(tree.expressions, COMMA, false);
    },
    visitComprehensionFor: function(tree) {
      this.write_(FOR);
      this.write_(OPEN_PAREN);
      this.visitAny(tree.left);
      this.write_(OF);
      this.visitAny(tree.iterator);
      this.write_(CLOSE_PAREN);
    },
    visitComprehensionIf: function(tree) {
      this.write_(IF);
      this.write_(OPEN_PAREN);
      this.visitAny(tree.expression);
      this.write_(CLOSE_PAREN);
    },
    visitComputedPropertyName: function(tree) {
      this.write_(OPEN_SQUARE);
      this.visitAny(tree.expression);
      this.write_(CLOSE_SQUARE);
    },
    visitConditionalExpression: function(tree) {
      this.visitAny(tree.condition);
      this.write_(QUESTION);
      this.visitAny(tree.left);
      this.write_(COLON);
      this.visitAny(tree.right);
    },
    visitContinueStatement: function(tree) {
      this.write_(CONTINUE);
      if (tree.name !== null) {
        this.write_(tree.name);
      }
      this.write_(SEMI_COLON);
    },
    visitDebuggerStatement: function(tree) {
      this.write_(DEBUGGER);
      this.write_(SEMI_COLON);
    },
    visitDefaultClause: function(tree) {
      this.write_(DEFAULT);
      this.write_(COLON);
      this.indentDepth_++;
      this.writelnList_(tree.statements);
      this.indentDepth_--;
    },
    visitDoWhileStatement: function(tree) {
      this.write_(DO);
      this.visitAny(tree.body);
      this.write_(WHILE);
      this.write_(OPEN_PAREN);
      this.visitAny(tree.condition);
      this.write_(CLOSE_PAREN);
      this.write_(SEMI_COLON);
    },
    visitEmptyStatement: function(tree) {
      this.write_(SEMI_COLON);
    },
    visitExportDeclaration: function(tree) {
      this.writeAnnotations_(tree.annotations);
      this.write_(EXPORT);
      this.visitAny(tree.declaration);
    },
    visitExportDefault: function(tree) {
      this.write_(DEFAULT);
      this.visitAny(tree.expression);
      this.write_(SEMI_COLON);
    },
    visitNamedExport: function(tree) {
      this.visitAny(tree.specifierSet);
      if (tree.moduleSpecifier) {
        this.write_(FROM);
        this.visitAny(tree.moduleSpecifier);
      }
      this.write_(SEMI_COLON);
    },
    visitExportSpecifier: function(tree) {
      this.write_(tree.lhs);
      if (tree.rhs) {
        this.write_(AS);
        this.write_(tree.rhs);
      }
    },
    visitExportSpecifierSet: function(tree) {
      this.write_(OPEN_CURLY);
      this.writeList_(tree.specifiers, COMMA, false);
      this.write_(CLOSE_CURLY);
    },
    visitExportStar: function(tree) {
      this.write_(STAR);
    },
    visitExpressionStatement: function(tree) {
      this.visitAny(tree.expression);
      this.write_(SEMI_COLON);
    },
    visitFinally: function(tree) {
      this.write_(FINALLY);
      this.visitAny(tree.block);
    },
    visitForOfStatement: function(tree) {
      this.write_(FOR);
      this.write_(OPEN_PAREN);
      this.visitAny(tree.initialiser);
      this.write_(OF);
      this.visitAny(tree.collection);
      this.write_(CLOSE_PAREN);
      this.visitAny(tree.body);
    },
    visitForInStatement: function(tree) {
      this.write_(FOR);
      this.write_(OPEN_PAREN);
      this.visitAny(tree.initialiser);
      this.write_(IN);
      this.visitAny(tree.collection);
      this.write_(CLOSE_PAREN);
      this.visitAny(tree.body);
    },
    visitForStatement: function(tree) {
      this.write_(FOR);
      this.write_(OPEN_PAREN);
      this.visitAny(tree.initialiser);
      this.write_(SEMI_COLON);
      this.visitAny(tree.condition);
      this.write_(SEMI_COLON);
      this.visitAny(tree.increment);
      this.write_(CLOSE_PAREN);
      this.visitAny(tree.body);
    },
    visitFormalParameterList: function(tree) {
      var first = true;
      for (var i = 0; i < tree.parameters.length; i++) {
        var parameter = tree.parameters[i];
        if (first) {
          first = false;
        } else {
          this.write_(COMMA);
        }
        this.visitAny(parameter);
      }
    },
    visitFormalParameter: function(tree) {
      this.writeAnnotations_(tree.annotations, false);
      this.currentParameterTypeAnnotation_ = tree.typeAnnotation;
      this.visitAny(tree.parameter);
      this.currentParameterTypeAnnotation_ = null;
    },
    visitFunctionBody: function(tree) {
      this.write_(OPEN_CURLY);
      this.writelnList_(tree.statements);
      this.write_(CLOSE_CURLY);
    },
    visitFunctionDeclaration: function(tree) {
      this.visitFunction_(tree);
    },
    visitFunctionExpression: function(tree) {
      this.visitFunction_(tree);
    },
    visitFunction_: function(tree) {
      this.writeAnnotations_(tree.annotations);
      this.write_(FUNCTION);
      if (tree.isGenerator) {
        this.write_(STAR);
      }
      this.visitAny(tree.name);
      this.write_(OPEN_PAREN);
      this.visitAny(tree.formalParameterList);
      this.write_(CLOSE_PAREN);
      this.writeTypeAnnotation_(tree.typeAnnotation);
      this.visitAny(tree.functionBody);
    },
    visitGeneratorComprehension: function(tree) {
      this.write_(OPEN_PAREN);
      this.visitList(tree.comprehensionList);
      this.visitAny(tree.expression);
      this.write_(CLOSE_PAREN);
    },
    visitGetAccessor: function(tree) {
      this.writeAnnotations_(tree.annotations);
      if (tree.isStatic) this.write_(STATIC);
      this.write_(GET);
      this.visitAny(tree.name);
      this.write_(OPEN_PAREN);
      this.write_(CLOSE_PAREN);
      this.writeTypeAnnotation_(tree.typeAnnotation);
      this.visitAny(tree.body);
    },
    visitIdentifierExpression: function(tree) {
      this.write_(tree.identifierToken);
    },
    visitIfStatement: function(tree) {
      this.write_(IF);
      this.write_(OPEN_PAREN);
      this.visitAny(tree.condition);
      this.write_(CLOSE_PAREN);
      this.visitAny(tree.ifClause);
      if (tree.elseClause) {
        this.write_(ELSE);
        this.visitAny(tree.elseClause);
      }
    },
    visitImportDeclaration: function(tree) {
      this.write_(IMPORT);
      if (this.importClause) {
        this.visitAny(tree.importClause);
        this.write_(FROM);
      }
      this.visitAny(tree.moduleSpecifier);
      this.write_(SEMI_COLON);
    },
    visitImportSpecifier: function(tree) {
      this.write_(tree.lhs);
      if (tree.rhs !== null) {
        this.write_(AS);
        this.write_(tree.rhs);
      }
    },
    visitImportSpecifierSet: function(tree) {
      if (tree.specifiers.type == STAR) {
        this.write_(STAR);
      } else {
        this.write_(OPEN_CURLY);
        this.writelnList_(tree.specifiers, COMMA);
        this.write_(CLOSE_CURLY);
      }
    },
    visitLabelledStatement: function(tree) {
      this.write_(tree.name);
      this.write_(COLON);
      this.visitAny(tree.statement);
    },
    visitLiteralExpression: function(tree) {
      this.write_(tree.literalToken);
    },
    visitLiteralPropertyName: function(tree) {
      this.write_(tree.literalToken);
    },
    visitMemberExpression: function(tree) {
      this.visitAny(tree.operand);
      this.write_(PERIOD);
      this.write_(tree.memberName);
    },
    visitMemberLookupExpression: function(tree) {
      this.visitAny(tree.operand);
      this.write_(OPEN_SQUARE);
      this.visitAny(tree.memberExpression);
      this.write_(CLOSE_SQUARE);
    },
    visitSyntaxErrorTree: function(tree) {
      this.write_('(function() {' + ("throw SyntaxError(" + JSON.stringify(tree.message) + ");") + '})()');
    },
    visitModule: function(tree) {
      this.writelnList_(tree.scriptItemList, null);
    },
    visitModuleSpecifier: function(tree) {
      this.write_(tree.token);
    },
    visitModuleDeclaration: function(tree) {
      this.write_(MODULE);
      this.write_(tree.identifier);
      this.write_(FROM);
      this.visitAny(tree.expression);
      this.write_(SEMI_COLON);
    },
    visitNewExpression: function(tree) {
      this.write_(NEW);
      this.visitAny(tree.operand);
      this.visitAny(tree.args);
    },
    visitObjectLiteralExpression: function(tree) {
      this.write_(OPEN_CURLY);
      if (tree.propertyNameAndValues.length > 1) this.writeln_();
      this.writelnList_(tree.propertyNameAndValues, COMMA);
      if (tree.propertyNameAndValues.length > 1) this.writeln_();
      this.write_(CLOSE_CURLY);
    },
    visitObjectPattern: function(tree) {
      this.write_(OPEN_CURLY);
      this.writelnList_(tree.fields, COMMA);
      this.write_(CLOSE_CURLY);
    },
    visitObjectPatternField: function(tree) {
      this.visitAny(tree.name);
      if (tree.element !== null) {
        this.write_(COLON);
        this.visitAny(tree.element);
      }
    },
    visitParenExpression: function(tree) {
      this.write_(OPEN_PAREN);
      $traceurRuntime.superCall(this, $ParseTreeWriter.prototype, "visitParenExpression", [tree]);
      this.write_(CLOSE_PAREN);
    },
    visitPostfixExpression: function(tree) {
      this.visitAny(tree.operand);
      this.write_(tree.operator);
    },
    visitPredefinedType: function(tree) {
      this.write_(tree.typeToken);
    },
    visitScript: function(tree) {
      this.writelnList_(tree.scriptItemList, null);
    },
    visitPropertyMethodAssignment: function(tree) {
      this.writeAnnotations_(tree.annotations);
      if (tree.isStatic) this.write_(STATIC);
      if (tree.isGenerator) this.write_(STAR);
      this.visitAny(tree.name);
      this.write_(OPEN_PAREN);
      this.visitAny(tree.formalParameterList);
      this.write_(CLOSE_PAREN);
      this.writeTypeAnnotation_(tree.typeAnnotation);
      this.visitAny(tree.functionBody);
    },
    visitPropertyNameAssignment: function(tree) {
      this.visitAny(tree.name);
      this.write_(COLON);
      this.visitAny(tree.value);
    },
    visitPropertyNameShorthand: function(tree) {
      this.write_(tree.name);
    },
    visitTemplateLiteralExpression: function(tree) {
      this.visitAny(tree.operand);
      this.writeRaw_(BACK_QUOTE);
      this.visitList(tree.elements);
      this.writeRaw_(BACK_QUOTE);
    },
    visitTemplateLiteralPortion: function(tree) {
      this.writeRaw_(tree.value);
    },
    visitTemplateSubstitution: function(tree) {
      this.writeRaw_('$');
      this.writeRaw_(OPEN_CURLY);
      this.visitAny(tree.expression);
      this.writeRaw_(CLOSE_CURLY);
    },
    visitReturnStatement: function(tree) {
      this.write_(RETURN);
      this.visitAny(tree.expression);
      this.write_(SEMI_COLON);
    },
    visitRestParameter: function(tree) {
      this.write_(DOT_DOT_DOT);
      this.write_(tree.identifier.identifierToken);
      this.writeTypeAnnotation_(this.currentParameterTypeAnnotation_);
    },
    visitSetAccessor: function(tree) {
      this.writeAnnotations_(tree.annotations);
      if (tree.isStatic) this.write_(STATIC);
      this.write_(SET);
      this.visitAny(tree.name);
      this.write_(OPEN_PAREN);
      this.visitAny(tree.parameter);
      this.write_(CLOSE_PAREN);
      this.visitAny(tree.body);
    },
    visitSpreadExpression: function(tree) {
      this.write_(DOT_DOT_DOT);
      this.visitAny(tree.expression);
    },
    visitSpreadPatternElement: function(tree) {
      this.write_(DOT_DOT_DOT);
      this.visitAny(tree.lvalue);
    },
    visitStateMachine: function(tree) {
      throw new Error('State machines cannot be converted to source');
    },
    visitSuperExpression: function(tree) {
      this.write_(SUPER);
    },
    visitSwitchStatement: function(tree) {
      this.write_(SWITCH);
      this.write_(OPEN_PAREN);
      this.visitAny(tree.expression);
      this.write_(CLOSE_PAREN);
      this.write_(OPEN_CURLY);
      this.writelnList_(tree.caseClauses);
      this.write_(CLOSE_CURLY);
    },
    visitThisExpression: function(tree) {
      this.write_(THIS);
    },
    visitThrowStatement: function(tree) {
      this.write_(THROW);
      this.visitAny(tree.value);
      this.write_(SEMI_COLON);
    },
    visitTryStatement: function(tree) {
      this.write_(TRY);
      this.visitAny(tree.body);
      this.visitAny(tree.catchBlock);
      this.visitAny(tree.finallyBlock);
    },
    visitTypeName: function(tree) {
      if (tree.moduleName) {
        this.visitAny(tree.moduleName);
        this.write_(PERIOD);
      }
      this.write_(tree.name);
    },
    visitUnaryExpression: function(tree) {
      this.write_(tree.operator);
      this.visitAny(tree.operand);
    },
    visitVariableDeclarationList: function(tree) {
      this.write_(tree.declarationType);
      this.writeList_(tree.declarations, COMMA, true, 2);
    },
    visitVariableDeclaration: function(tree) {
      this.visitAny(tree.lvalue);
      this.writeTypeAnnotation_(tree.typeAnnotation);
      if (tree.initialiser !== null) {
        this.write_(EQUAL);
        this.visitAny(tree.initialiser);
      }
    },
    visitVariableStatement: function(tree) {
      $traceurRuntime.superCall(this, $ParseTreeWriter.prototype, "visitVariableStatement", [tree]);
      this.write_(SEMI_COLON);
    },
    visitWhileStatement: function(tree) {
      this.write_(WHILE);
      this.write_(OPEN_PAREN);
      this.visitAny(tree.condition);
      this.write_(CLOSE_PAREN);
      this.visitAny(tree.body);
    },
    visitWithStatement: function(tree) {
      this.write_(WITH);
      this.write_(OPEN_PAREN);
      this.visitAny(tree.expression);
      this.write_(CLOSE_PAREN);
      this.visitAny(tree.body);
    },
    visitYieldExpression: function(tree) {
      this.write_(YIELD);
      if (tree.isYieldFor) {
        this.write_(STAR);
      }
      this.visitAny(tree.expression);
    },
    writeCurrentln_: function() {
      this.result_ += this.currentLine_ + NEW_LINE;
    },
    writeln_: function() {
      if (this.currentLineComment_) {
        while (this.currentLine_.length < LINE_LENGTH) {
          this.currentLine_ += ' ';
        }
        this.currentLine_ += ' // ' + this.currentLineComment_;
        this.currentLineComment_ = null;
      }
      if (this.currentLine_) this.writeCurrentln_();
      this.currentLine_ = '';
    },
    writelnList_: function(list, delimiter) {
      if (delimiter) {
        this.writeList_(list, delimiter, true);
      } else {
        if (list.length > 0) this.writeln_();
        this.writeList_(list, null, true);
        if (list.length > 0) this.writeln_();
      }
    },
    writeList_: function(list, delimiter, writeNewLine) {
      var indent = arguments[3] !== (void 0) ? arguments[3]: 0;
      var first = true;
      for (var i = 0; i < list.length; i++) {
        var element = list[i];
        if (first) {
          first = false;
        } else {
          if (delimiter !== null) {
            this.write_(delimiter);
          }
          if (writeNewLine) {
            if (i === 1) this.indentDepth_ += indent;
            this.writeln_();
          }
        }
        this.visitAny(element);
      }
      if (writeNewLine && list.length > 1) this.indentDepth_ -= indent;
    },
    writeRaw_: function(value) {
      if (value !== null) this.currentLine_ += value;
    },
    write_: function(value) {
      if (value === CLOSE_CURLY) {
        this.indentDepth_--;
      }
      if (value !== null) {
        if (this.prettyPrint_) {
          if (!this.currentLine_) {
            this.lastToken_ = '';
            for (var i = 0,
                indent = this.indentDepth_; i < indent; i++) {
              this.currentLine_ += '  ';
            }
          }
        }
        if (this.needsSpace_(value)) this.currentLine_ += ' ';
        this.lastToken_ = value;
        this.currentLine_ += value;
      }
      if (value === OPEN_CURLY) {
        this.indentDepth_++;
      }
    },
    writeTypeAnnotation_: function(typeAnnotation) {
      if (typeAnnotation !== null) {
        this.write_(COLON);
        this.visitAny(typeAnnotation);
      }
    },
    writeAnnotations_: function(annotations) {
      var writeNewLine = arguments[1] !== (void 0) ? arguments[1]: this.prettyPrint_;
      if (annotations.length > 0) {
        this.writeList_(annotations, null, writeNewLine);
        if (writeNewLine) this.writeln_();
      }
    },
    isIdentifierNameOrNumber_: function(token) {
      if (token instanceof Token) {
        if (token.isKeyword()) return true;
        switch (token.type) {
          case IDENTIFIER:
          case NUMBER:
            return true;
        }
      }
      var value = token.toString();
      switch (value) {
        case AS:
        case FROM:
        case GET:
        case OF:
        case MODULE:
        case SET:
          return true;
      }
      return !!getKeywordType(value);
    },
    needsSpace_: function(token) {
      if (!this.lastToken_) return false;
      if (this.lastToken_.type === REGULAR_EXPRESSION && this.isIdentifierNameOrNumber_(token)) {
        return true;
      }
      var value = token.toString();
      var lastValue = this.lastToken_.toString();
      switch (value) {
        case CLOSE_CURLY:
        case CLOSE_PAREN:
        case CLOSE_SQUARE:
        case COLON:
        case COMMA:
        case PERIOD:
        case SEMI_COLON:
          return false;
        case CATCH:
        case ELSE:
        case FINALLY:
        case WHILE:
          return this.prettyPrint_;
        case OPEN_CURLY:
          switch (lastValue) {
            case OPEN_CURLY:
            case OPEN_PAREN:
            case OPEN_SQUARE:
              return false;
          }
          return this.prettyPrint_;
      }
      switch (lastValue) {
        case OPEN_CURLY:
        case OPEN_PAREN:
        case OPEN_SQUARE:
          return false;
        case CATCH:
        case COLON:
        case COMMA:
        case DO:
        case FINALLY:
        case FOR:
        case IF:
        case SEMI_COLON:
        case SWITCH:
        case TRY:
        case WHILE:
        case WITH:
          return this.prettyPrint_;
        case CASE:
        case CLASS:
        case CONST:
        case DELETE:
        case ELSE:
        case ENUM:
        case EXPORT:
        case EXTENDS:
        case IMPLEMENTS:
        case IMPORT:
        case IN:
        case INSTANCEOF:
        case INTERFACE:
        case LET:
        case NEW:
        case PACKAGE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case RETURN:
        case STATIC:
        case THROW:
        case TYPEOF:
        case VAR:
        case VOID:
        case YIELD:
        case FROM:
        case OF:
        case MODULE:
          return this.prettyPrint_ || this.isIdentifierNameOrNumber_(token);
      }
      if ((lastValue == PLUS || lastValue == PLUS_PLUS) && (value == PLUS || value == PLUS_PLUS) || (lastValue == MINUS || lastValue == MINUS_MINUS) && (value == MINUS || value == MINUS_MINUS)) {
        return true;
      }
      if (this.spaceArround_(lastValue) || this.spaceArround_(value)) return true;
      if (this.isIdentifierNameOrNumber_(token)) {
        if (lastValue === CLOSE_PAREN) return this.prettyPrint_;
        return this.isIdentifierNameOrNumber_(this.lastToken_);
      }
      return false;
    },
    spaceArround_: function(value) {
      switch (value) {
        case AMPERSAND:
        case AMPERSAND_EQUAL:
        case AND:
        case ARROW:
        case AWAIT:
        case BAR:
        case BAR_EQUAL:
        case CARET_EQUAL:
        case CLOSE_ANGLE:
        case EQUAL:
        case EQUAL_EQUAL:
        case EQUAL_EQUAL_EQUAL:
        case GREATER_EQUAL:
        case LEFT_SHIFT:
        case LEFT_SHIFT_EQUAL:
        case LESS_EQUAL:
        case MINUS:
        case MINUS_EQUAL:
        case NOT_EQUAL:
        case NOT_EQUAL_EQUAL:
        case OPEN_ANGLE:
        case OR:
        case PERCENT:
        case PERCENT_EQUAL:
        case PLUS:
        case PLUS_EQUAL:
        case QUESTION:
        case RIGHT_SHIFT:
        case RIGHT_SHIFT_EQUAL:
        case SLASH:
        case SLASH_EQUAL:
        case STAR:
        case STAR_EQUAL:
        case UNSIGNED_RIGHT_SHIFT:
        case UNSIGNED_RIGHT_SHIFT_EQUAL:
          return this.prettyPrint_;
      }
      return false;
    }
  }, {}, ParseTreeVisitor);
  return {get ParseTreeWriter() {
      return ParseTreeWriter;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/outputgeneration/ParseTreeMapWriter", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/outputgeneration/ParseTreeMapWriter";
  var ParseTreeWriter = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/outputgeneration/ParseTreeWriter").ParseTreeWriter;
  var ParseTreeMapWriter = function ParseTreeMapWriter(sourceMapGenerator) {
    var options = arguments[1];
    $traceurRuntime.superCall(this, $ParseTreeMapWriter.prototype, "constructor", [options]);
    this.sourceMapGenerator_ = sourceMapGenerator;
    this.outputLineCount_ = 1;
  };
  var $ParseTreeMapWriter = ParseTreeMapWriter;
  ($traceurRuntime.createClass)(ParseTreeMapWriter, {
    write_: function(value) {
      if (this.currentLocation) this.addMapping();
      $traceurRuntime.superCall(this, $ParseTreeMapWriter.prototype, "write_", [value]);
    },
    writeCurrentln_: function() {
      $traceurRuntime.superCall(this, $ParseTreeMapWriter.prototype, "writeCurrentln_", []);
      this.outputLineCount_++;
    },
    addMapping: function() {
      var start = this.currentLocation.start;
      var mapping = {
        generated: {
          line: this.outputLineCount_,
          column: this.currentLine_.length
        },
        original: {
          line: start.line + 1,
          column: start.column
        },
        source: start.source.name
      };
      this.sourceMapGenerator_.addMapping(mapping);
      this.sourceMapGenerator_.setSourceContent(start.source.name, start.source.contents);
    }
  }, {}, ParseTreeWriter);
  return {get ParseTreeMapWriter() {
      return ParseTreeMapWriter;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/outputgeneration/TreeWriter", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/outputgeneration/TreeWriter";
  var ParseTreeMapWriter = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/outputgeneration/ParseTreeMapWriter").ParseTreeMapWriter;
  var ParseTreeWriter = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/outputgeneration/ParseTreeWriter").ParseTreeWriter;
  function write(tree) {
    var options = arguments[1];
    var sourceMapGenerator = options && options.sourceMapGenerator;
    var writer;
    if (sourceMapGenerator) writer = new ParseTreeMapWriter(sourceMapGenerator, options); else writer = new ParseTreeWriter(options);
    writer.visitAny(tree);
    if (sourceMapGenerator) options.sourceMap = sourceMapGenerator.toString();
    return writer.toString();
  }
  var TreeWriter = function TreeWriter() {};
  ($traceurRuntime.createClass)(TreeWriter, {}, {});
  TreeWriter.write = write;
  return {
    get write() {
      return write;
    },
    get TreeWriter() {
      return TreeWriter;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/util/assert", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/util/assert";
  var options = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/options").options;
  function assert(b) {
    if (!b && options.debug) throw Error('Assertion failed');
  }
  return {get assert() {
      return assert;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/ParseTreeValidator", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/ParseTreeValidator";
  var NewExpression = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees").NewExpression;
  var ParseTreeVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/ParseTreeVisitor").ParseTreeVisitor;
  var TreeWriter = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/outputgeneration/TreeWriter").TreeWriter;
  var $__49 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      AMPERSAND = $__49.AMPERSAND,
      AMPERSAND_EQUAL = $__49.AMPERSAND_EQUAL,
      AND = $__49.AND,
      BAR = $__49.BAR,
      BAR_EQUAL = $__49.BAR_EQUAL,
      CARET = $__49.CARET,
      CARET_EQUAL = $__49.CARET_EQUAL,
      CLOSE_ANGLE = $__49.CLOSE_ANGLE,
      EQUAL = $__49.EQUAL,
      EQUAL_EQUAL = $__49.EQUAL_EQUAL,
      EQUAL_EQUAL_EQUAL = $__49.EQUAL_EQUAL_EQUAL,
      GREATER_EQUAL = $__49.GREATER_EQUAL,
      IDENTIFIER = $__49.IDENTIFIER,
      IN = $__49.IN,
      INSTANCEOF = $__49.INSTANCEOF,
      LEFT_SHIFT = $__49.LEFT_SHIFT,
      LEFT_SHIFT_EQUAL = $__49.LEFT_SHIFT_EQUAL,
      LESS_EQUAL = $__49.LESS_EQUAL,
      MINUS = $__49.MINUS,
      MINUS_EQUAL = $__49.MINUS_EQUAL,
      NOT_EQUAL = $__49.NOT_EQUAL,
      NOT_EQUAL_EQUAL = $__49.NOT_EQUAL_EQUAL,
      NUMBER = $__49.NUMBER,
      OPEN_ANGLE = $__49.OPEN_ANGLE,
      OR = $__49.OR,
      PERCENT = $__49.PERCENT,
      PERCENT_EQUAL = $__49.PERCENT_EQUAL,
      PLUS = $__49.PLUS,
      PLUS_EQUAL = $__49.PLUS_EQUAL,
      RIGHT_SHIFT = $__49.RIGHT_SHIFT,
      RIGHT_SHIFT_EQUAL = $__49.RIGHT_SHIFT_EQUAL,
      SLASH = $__49.SLASH,
      SLASH_EQUAL = $__49.SLASH_EQUAL,
      STAR = $__49.STAR,
      STAR_EQUAL = $__49.STAR_EQUAL,
      STRING = $__49.STRING,
      UNSIGNED_RIGHT_SHIFT = $__49.UNSIGNED_RIGHT_SHIFT,
      UNSIGNED_RIGHT_SHIFT_EQUAL = $__49.UNSIGNED_RIGHT_SHIFT_EQUAL;
  var $__49 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      ARRAY_PATTERN = $__49.ARRAY_PATTERN,
      BINDING_ELEMENT = $__49.BINDING_ELEMENT,
      BINDING_IDENTIFIER = $__49.BINDING_IDENTIFIER,
      BLOCK = $__49.BLOCK,
      CASE_CLAUSE = $__49.CASE_CLAUSE,
      CATCH = $__49.CATCH,
      CLASS_DECLARATION = $__49.CLASS_DECLARATION,
      COMPUTED_PROPERTY_NAME = $__49.COMPUTED_PROPERTY_NAME,
      DEFAULT_CLAUSE = $__49.DEFAULT_CLAUSE,
      EXPORT_DECLARATION = $__49.EXPORT_DECLARATION,
      EXPORT_DEFAULT = $__49.EXPORT_DEFAULT,
      EXPORT_SPECIFIER = $__49.EXPORT_SPECIFIER,
      EXPORT_SPECIFIER_SET = $__49.EXPORT_SPECIFIER_SET,
      EXPORT_STAR = $__49.EXPORT_STAR,
      FINALLY = $__49.FINALLY,
      FORMAL_PARAMETER = $__49.FORMAL_PARAMETER,
      FORMAL_PARAMETER_LIST = $__49.FORMAL_PARAMETER_LIST,
      FUNCTION_BODY = $__49.FUNCTION_BODY,
      FUNCTION_DECLARATION = $__49.FUNCTION_DECLARATION,
      GET_ACCESSOR = $__49.GET_ACCESSOR,
      IDENTIFIER_EXPRESSION = $__49.IDENTIFIER_EXPRESSION,
      IMPORT_DECLARATION = $__49.IMPORT_DECLARATION,
      LITERAL_PROPERTY_NAME = $__49.LITERAL_PROPERTY_NAME,
      MODULE_DECLARATION = $__49.MODULE_DECLARATION,
      MODULE_SPECIFIER = $__49.MODULE_SPECIFIER,
      NAMED_EXPORT = $__49.NAMED_EXPORT,
      OBJECT_PATTERN = $__49.OBJECT_PATTERN,
      OBJECT_PATTERN_FIELD = $__49.OBJECT_PATTERN_FIELD,
      PROPERTY_METHOD_ASSIGNMENT = $__49.PROPERTY_METHOD_ASSIGNMENT,
      PROPERTY_NAME_ASSIGNMENT = $__49.PROPERTY_NAME_ASSIGNMENT,
      PROPERTY_NAME_SHORTHAND = $__49.PROPERTY_NAME_SHORTHAND,
      REST_PARAMETER = $__49.REST_PARAMETER,
      SET_ACCESSOR = $__49.SET_ACCESSOR,
      TEMPLATE_LITERAL_PORTION = $__49.TEMPLATE_LITERAL_PORTION,
      TEMPLATE_SUBSTITUTION = $__49.TEMPLATE_SUBSTITUTION,
      VARIABLE_DECLARATION_LIST = $__49.VARIABLE_DECLARATION_LIST,
      VARIABLE_STATEMENT = $__49.VARIABLE_STATEMENT;
  var assert = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/assert").assert;
  var ValidationError = function ValidationError(tree, message) {
    this.tree = tree;
    this.message = message;
  };
  ($traceurRuntime.createClass)(ValidationError, {}, {}, Error);
  var ParseTreeValidator = function ParseTreeValidator() {
    $traceurRuntime.defaultSuperCall(this, $ParseTreeValidator.prototype, arguments);
  };
  var $ParseTreeValidator = ParseTreeValidator;
  ($traceurRuntime.createClass)(ParseTreeValidator, {
    fail_: function(tree, message) {
      throw new ValidationError(tree, message);
    },
    check_: function(condition, tree, message) {
      if (!condition) {
        this.fail_(tree, message);
      }
    },
    checkVisit_: function(condition, tree, message) {
      this.check_(condition, tree, message);
      this.visitAny(tree);
    },
    checkType_: function(type, tree, message) {
      this.checkVisit_(tree.type === type, tree, message);
    },
    visitArgumentList: function(tree) {
      for (var i = 0; i < tree.args.length; i++) {
        var argument = tree.args[i];
        this.checkVisit_(argument.isAssignmentOrSpread(), argument, 'assignment or spread expected');
      }
    },
    visitArrayLiteralExpression: function(tree) {
      for (var i = 0; i < tree.elements.length; i++) {
        var element = tree.elements[i];
        this.checkVisit_(element === null || element.isAssignmentOrSpread(), element, 'assignment or spread expected');
      }
    },
    visitArrayPattern: function(tree) {
      for (var i = 0; i < tree.elements.length; i++) {
        var element = tree.elements[i];
        this.checkVisit_(element === null || element.type === BINDING_ELEMENT || element.type == IDENTIFIER_EXPRESSION || element.isLeftHandSideExpression() || element.isPattern() || element.isSpreadPatternElement(), element, 'null, sub pattern, left hand side expression or spread expected');
        if (element && element.isSpreadPatternElement()) {
          this.check_(i === (tree.elements.length - 1), element, 'spread in array patterns must be the last element');
        }
      }
    },
    visitAwaitStatement: function(tree) {
      this.checkVisit_(tree.expression.isExpression(), tree.expression, 'await must be expression');
    },
    visitBinaryOperator: function(tree) {
      switch (tree.operator.type) {
        case EQUAL:
        case STAR_EQUAL:
        case SLASH_EQUAL:
        case PERCENT_EQUAL:
        case PLUS_EQUAL:
        case MINUS_EQUAL:
        case LEFT_SHIFT_EQUAL:
        case RIGHT_SHIFT_EQUAL:
        case UNSIGNED_RIGHT_SHIFT_EQUAL:
        case AMPERSAND_EQUAL:
        case CARET_EQUAL:
        case BAR_EQUAL:
          this.check_(tree.left.isLeftHandSideExpression() || tree.left.isPattern(), tree.left, 'left hand side expression or pattern expected');
          this.check_(tree.right.isArrowFunctionExpression(), tree.right, 'assignment expression expected');
          break;
        case AND:
        case OR:
        case BAR:
        case CARET:
        case AMPERSAND:
        case EQUAL_EQUAL:
        case NOT_EQUAL:
        case EQUAL_EQUAL_EQUAL:
        case NOT_EQUAL_EQUAL:
        case OPEN_ANGLE:
        case CLOSE_ANGLE:
        case GREATER_EQUAL:
        case LESS_EQUAL:
        case INSTANCEOF:
        case IN:
        case LEFT_SHIFT:
        case RIGHT_SHIFT:
        case UNSIGNED_RIGHT_SHIFT:
        case PLUS:
        case MINUS:
        case STAR:
        case SLASH:
        case PERCENT:
          this.check_(tree.left.isArrowFunctionExpression(), tree.left, 'assignment expression expected');
          this.check_(tree.right.isArrowFunctionExpression(), tree.right, 'assignment expression expected');
          break;
        default:
          this.fail_(tree, 'unexpected binary operator');
      }
      this.visitAny(tree.left);
      this.visitAny(tree.right);
    },
    visitBindingElement: function(tree) {
      var binding = tree.binding;
      this.checkVisit_(binding.type == BINDING_IDENTIFIER || binding.type == OBJECT_PATTERN || binding.type == ARRAY_PATTERN, binding, 'expected valid binding element');
      this.visitAny(tree.initialiser);
    },
    visitBlock: function(tree) {
      for (var i = 0; i < tree.statements.length; i++) {
        var statement = tree.statements[i];
        this.checkVisit_(statement.isStatementListItem(), statement, 'statement or function declaration expected');
      }
    },
    visitCallExpression: function(tree) {
      this.check_(tree.operand.isMemberExpression(), tree.operand, 'member expression expected');
      if (tree.operand instanceof NewExpression) {
        this.check_(tree.operand.args !== null, tree.operand, 'new args expected');
      }
      this.visitAny(tree.operand);
      this.visitAny(tree.args);
    },
    visitCaseClause: function(tree) {
      this.checkVisit_(tree.expression.isExpression(), tree.expression, 'expression expected');
      for (var i = 0; i < tree.statements.length; i++) {
        var statement = tree.statements[i];
        this.checkVisit_(statement.isStatement(), statement, 'statement expected');
      }
    },
    visitCatch: function(tree) {
      this.checkVisit_(tree.binding.isPattern() || tree.binding.type == BINDING_IDENTIFIER, tree.binding, 'binding identifier expected');
      this.checkVisit_(tree.catchBody.type === BLOCK, tree.catchBody, 'block expected');
    },
    visitClassDeclaration: function(tree) {
      for (var i = 0; i < tree.elements.length; i++) {
        var element = tree.elements[i];
        switch (element.type) {
          case GET_ACCESSOR:
          case SET_ACCESSOR:
          case PROPERTY_METHOD_ASSIGNMENT:
            break;
          default:
            this.fail_(element, 'class element expected');
        }
        this.visitAny(element);
      }
    },
    visitCommaExpression: function(tree) {
      for (var i = 0; i < tree.expressions.length; i++) {
        var expression = tree.expressions[i];
        this.checkVisit_(expression.isArrowFunctionExpression(), expression, 'expression expected');
      }
    },
    visitConditionalExpression: function(tree) {
      this.checkVisit_(tree.condition.isArrowFunctionExpression(), tree.condition, 'expression expected');
      this.checkVisit_(tree.left.isArrowFunctionExpression(), tree.left, 'expression expected');
      this.checkVisit_(tree.right.isArrowFunctionExpression(), tree.right, 'expression expected');
    },
    visitCoverFormals: function(tree) {
      this.fail_(tree, 'CoverFormals should have been removed');
    },
    visitCoverInitialisedName: function(tree) {
      this.fail_(tree, 'CoverInitialisedName should have been removed');
    },
    visitDefaultClause: function(tree) {
      for (var i = 0; i < tree.statements.length; i++) {
        var statement = tree.statements[i];
        this.checkVisit_(statement.isStatement(), statement, 'statement expected');
      }
    },
    visitDoWhileStatement: function(tree) {
      this.checkVisit_(tree.body.isStatement(), tree.body, 'statement expected');
      this.checkVisit_(tree.condition.isExpression(), tree.condition, 'expression expected');
    },
    visitExportDeclaration: function(tree) {
      var declType = tree.declaration.type;
      this.checkVisit_(declType == VARIABLE_STATEMENT || declType == FUNCTION_DECLARATION || declType == MODULE_DECLARATION || declType == CLASS_DECLARATION || declType == NAMED_EXPORT || declType == EXPORT_DEFAULT, tree.declaration, 'expected valid export tree');
    },
    visitNamedExport: function(tree) {
      if (tree.moduleSpecifier) {
        this.checkVisit_(tree.moduleSpecifier.type == MODULE_SPECIFIER, tree.moduleSpecifier, 'module expression expected');
      }
      var specifierType = tree.specifierSet.type;
      this.checkVisit_(specifierType == EXPORT_SPECIFIER_SET || specifierType == EXPORT_STAR, tree.specifierSet, 'specifier set or identifier expected');
    },
    visitExportSpecifierSet: function(tree) {
      this.check_(tree.specifiers.length > 0, tree, 'expected at least one identifier');
      for (var i = 0; i < tree.specifiers.length; i++) {
        var specifier = tree.specifiers[i];
        this.checkVisit_(specifier.type == EXPORT_SPECIFIER || specifier.type == IDENTIFIER_EXPRESSION, specifier, 'expected valid export specifier');
      }
    },
    visitExpressionStatement: function(tree) {
      this.checkVisit_(tree.expression.isExpression(), tree.expression, 'expression expected');
    },
    visitFinally: function(tree) {
      this.checkVisit_(tree.block.type === BLOCK, tree.block, 'block expected');
    },
    visitForOfStatement: function(tree) {
      this.checkVisit_(tree.initialiser.isPattern() || tree.initialiser.type === IDENTIFIER_EXPRESSION || tree.initialiser.type === VARIABLE_DECLARATION_LIST && tree.initialiser.declarations.length === 1, tree.initialiser, 'for-each statement may not have more than one variable declaration');
      this.checkVisit_(tree.collection.isExpression(), tree.collection, 'expression expected');
      this.checkVisit_(tree.body.isStatement(), tree.body, 'statement expected');
    },
    visitForInStatement: function(tree) {
      if (tree.initialiser.type === VARIABLE_DECLARATION_LIST) {
        this.checkVisit_(tree.initialiser.declarations.length <= 1, tree.initialiser, 'for-in statement may not have more than one variable declaration');
      } else {
        this.checkVisit_(tree.initialiser.isPattern() || tree.initialiser.isExpression(), tree.initialiser, 'variable declaration, expression or ' + 'pattern expected');
      }
      this.checkVisit_(tree.collection.isExpression(), tree.collection, 'expression expected');
      this.checkVisit_(tree.body.isStatement(), tree.body, 'statement expected');
    },
    visitFormalParameterList: function(tree) {
      for (var i = 0; i < tree.parameters.length; i++) {
        var parameter = tree.parameters[i];
        assert(parameter.type === FORMAL_PARAMETER);
        parameter = parameter.parameter;
        switch (parameter.type) {
          case BINDING_ELEMENT:
            break;
          case REST_PARAMETER:
            this.checkVisit_(i === tree.parameters.length - 1, parameter, 'rest parameters must be the last parameter in a parameter list');
            this.checkType_(BINDING_IDENTIFIER, parameter.identifier, 'binding identifier expected');
            break;
          default:
            this.fail_(parameter, 'parameters must be identifiers or rest' + (" parameters. Found: " + parameter.type));
            break;
        }
        this.visitAny(parameter);
      }
    },
    visitForStatement: function(tree) {
      if (tree.initialiser !== null) {
        this.checkVisit_(tree.initialiser.isExpression() || tree.initialiser.type === VARIABLE_DECLARATION_LIST, tree.initialiser, 'variable declaration list or expression expected');
      }
      if (tree.condition !== null) {
        this.checkVisit_(tree.condition.isExpression(), tree.condition, 'expression expected');
      }
      if (tree.increment !== null) {
        this.checkVisit_(tree.increment.isExpression(), tree.increment, 'expression expected');
      }
      this.checkVisit_(tree.body.isStatement(), tree.body, 'statement expected');
    },
    visitFunctionBody: function(tree) {
      for (var i = 0; i < tree.statements.length; i++) {
        var statement = tree.statements[i];
        this.checkVisit_(statement.isStatementListItem(), statement, 'statement expected');
      }
    },
    visitFunctionDeclaration: function(tree) {
      this.checkType_(BINDING_IDENTIFIER, tree.name, 'binding identifier expected');
      this.visitFunction_(tree);
    },
    visitFunctionExpression: function(tree) {
      if (tree.name !== null) {
        this.checkType_(BINDING_IDENTIFIER, tree.name, 'binding identifier expected');
      }
      this.visitFunction_(tree);
    },
    visitFunction_: function(tree) {
      this.checkType_(FORMAL_PARAMETER_LIST, tree.formalParameterList, 'formal parameters expected');
      this.checkType_(FUNCTION_BODY, tree.functionBody, 'function body expected');
    },
    visitGetAccessor: function(tree) {
      this.checkPropertyName_(tree.name);
      this.checkType_(FUNCTION_BODY, tree.body, 'function body expected');
    },
    visitIfStatement: function(tree) {
      this.checkVisit_(tree.condition.isExpression(), tree.condition, 'expression expected');
      this.checkVisit_(tree.ifClause.isStatement(), tree.ifClause, 'statement expected');
      if (tree.elseClause !== null) {
        this.checkVisit_(tree.elseClause.isStatement(), tree.elseClause, 'statement expected');
      }
    },
    visitLabelledStatement: function(tree) {
      this.checkVisit_(tree.statement.isStatement(), tree.statement, 'statement expected');
    },
    visitMemberExpression: function(tree) {
      this.check_(tree.operand.isMemberExpression(), tree.operand, 'member expression expected');
      if (tree.operand instanceof NewExpression) {
        this.check_(tree.operand.args !== null, tree.operand, 'new args expected');
      }
      this.visitAny(tree.operand);
    },
    visitMemberLookupExpression: function(tree) {
      this.check_(tree.operand.isMemberExpression(), tree.operand, 'member expression expected');
      if (tree.operand instanceof NewExpression) {
        this.check_(tree.operand.args !== null, tree.operand, 'new args expected');
      }
      this.visitAny(tree.operand);
    },
    visitSyntaxErrorTree: function(tree) {
      this.fail_(tree, ("parse tree contains SyntaxError: " + tree.message));
    },
    visitModuleSpecifier: function(tree) {
      this.check_(tree.token.type == STRING || tree.moduleName, 'string or identifier expected');
    },
    visitModuleDeclaration: function(tree) {
      this.checkType_(MODULE_SPECIFIER, tree.expression, 'module expression expected');
    },
    visitNewExpression: function(tree) {
      this.checkVisit_(tree.operand.isMemberExpression(), tree.operand, 'member expression expected');
      this.visitAny(tree.args);
    },
    visitObjectLiteralExpression: function(tree) {
      for (var i = 0; i < tree.propertyNameAndValues.length; i++) {
        var propertyNameAndValue = tree.propertyNameAndValues[i];
        switch (propertyNameAndValue.type) {
          case GET_ACCESSOR:
          case SET_ACCESSOR:
          case PROPERTY_METHOD_ASSIGNMENT:
            this.check_(!propertyNameAndValue.isStatic, propertyNameAndValue, 'static is not allowed in object literal expression');
          case PROPERTY_NAME_ASSIGNMENT:
          case PROPERTY_NAME_SHORTHAND:
            break;
          default:
            this.fail_(propertyNameAndValue, 'accessor, property name ' + 'assignment or property method assigment expected');
        }
        this.visitAny(propertyNameAndValue);
      }
    },
    visitObjectPattern: function(tree) {
      for (var i = 0; i < tree.fields.length; i++) {
        var field = tree.fields[i];
        this.checkVisit_(field.type === OBJECT_PATTERN_FIELD || field.type === BINDING_ELEMENT || field.type === IDENTIFIER_EXPRESSION, field, 'object pattern field expected');
      }
    },
    visitObjectPatternField: function(tree) {
      this.checkPropertyName_(tree.name);
      this.checkVisit_(tree.element.type === BINDING_ELEMENT || tree.element.isPattern() || tree.element.isLeftHandSideExpression(), tree.element, 'binding element expected');
    },
    visitParenExpression: function(tree) {
      if (tree.expression.isPattern()) {
        this.visitAny(tree.expression);
      } else {
        this.checkVisit_(tree.expression.isExpression(), tree.expression, 'expression expected');
      }
    },
    visitPostfixExpression: function(tree) {
      this.checkVisit_(tree.operand.isArrowFunctionExpression(), tree.operand, 'assignment expression expected');
    },
    visitPredefinedType: function(tree) {},
    visitScript: function(tree) {
      for (var i = 0; i < tree.scriptItemList.length; i++) {
        var scriptItemList = tree.scriptItemList[i];
        this.checkVisit_(scriptItemList.isScriptElement(), scriptItemList, 'global script item expected');
      }
    },
    checkPropertyName_: function(tree) {
      this.checkVisit_(tree.type === LITERAL_PROPERTY_NAME || tree.type === COMPUTED_PROPERTY_NAME, tree, 'property name expected');
    },
    visitPropertyNameAssignment: function(tree) {
      this.checkPropertyName_(tree.name);
      this.checkVisit_(tree.value.isArrowFunctionExpression(), tree.value, 'assignment expression expected');
    },
    visitPropertyNameShorthand: function(tree) {
      this.check_(tree.name.type === IDENTIFIER, tree, 'identifier token expected');
    },
    visitLiteralPropertyName: function(tree) {
      var type = tree.literalToken.type;
      this.check_(tree.literalToken.isKeyword() || type === IDENTIFIER || type === NUMBER || type === STRING, tree, 'Unexpected token in literal property name');
    },
    visitTemplateLiteralExpression: function(tree) {
      if (tree.operand) {
        this.checkVisit_(tree.operand.isMemberExpression(), tree.operand, 'member or call expression expected');
      }
      for (var i = 0; i < tree.elements.length; i++) {
        var element = tree.elements[i];
        if (i % 2) {
          this.checkType_(TEMPLATE_SUBSTITUTION, element, 'Template literal substitution expected');
        } else {
          this.checkType_(TEMPLATE_LITERAL_PORTION, element, 'Template literal portion expected');
        }
      }
    },
    visitReturnStatement: function(tree) {
      if (tree.expression !== null) {
        this.checkVisit_(tree.expression.isExpression(), tree.expression, 'expression expected');
      }
    },
    visitSetAccessor: function(tree) {
      this.checkPropertyName_(tree.name);
      this.checkType_(FUNCTION_BODY, tree.body, 'function body expected');
    },
    visitSpreadExpression: function(tree) {
      this.checkVisit_(tree.expression.isArrowFunctionExpression(), tree.expression, 'assignment expression expected');
    },
    visitStateMachine: function(tree) {
      this.fail_(tree, 'State machines are never valid outside of the ' + 'GeneratorTransformer pass.');
    },
    visitSwitchStatement: function(tree) {
      this.checkVisit_(tree.expression.isExpression(), tree.expression, 'expression expected');
      var defaultCount = 0;
      for (var i = 0; i < tree.caseClauses.length; i++) {
        var caseClause = tree.caseClauses[i];
        if (caseClause.type === DEFAULT_CLAUSE) {
          ++defaultCount;
          this.checkVisit_(defaultCount <= 1, caseClause, 'no more than one default clause allowed');
        } else {
          this.checkType_(CASE_CLAUSE, caseClause, 'case or default clause expected');
        }
      }
    },
    visitThrowStatement: function(tree) {
      if (tree.value === null) {
        return;
      }
      this.checkVisit_(tree.value.isExpression(), tree.value, 'expression expected');
    },
    visitTryStatement: function(tree) {
      this.checkType_(BLOCK, tree.body, 'block expected');
      if (tree.catchBlock !== null) {
        this.checkType_(CATCH, tree.catchBlock, 'catch block expected');
      }
      if (tree.finallyBlock !== null) {
        this.checkType_(FINALLY, tree.finallyBlock, 'finally block expected');
      }
      if (tree.catchBlock === null && tree.finallyBlock === null) {
        this.fail_(tree, 'either catch or finally must be present');
      }
    },
    visitTypeName: function(tree) {},
    visitUnaryExpression: function(tree) {
      this.checkVisit_(tree.operand.isArrowFunctionExpression(), tree.operand, 'assignment expression expected');
    },
    visitVariableDeclaration: function(tree) {
      this.checkVisit_(tree.lvalue.isPattern() || tree.lvalue.type == BINDING_IDENTIFIER, tree.lvalue, 'binding identifier expected, found: ' + tree.lvalue.type);
      if (tree.initialiser !== null) {
        this.checkVisit_(tree.initialiser.isArrowFunctionExpression(), tree.initialiser, 'assignment expression expected');
      }
    },
    visitWhileStatement: function(tree) {
      this.checkVisit_(tree.condition.isExpression(), tree.condition, 'expression expected');
      this.checkVisit_(tree.body.isStatement(), tree.body, 'statement expected');
    },
    visitWithStatement: function(tree) {
      this.checkVisit_(tree.expression.isExpression(), tree.expression, 'expression expected');
      this.checkVisit_(tree.body.isStatement(), tree.body, 'statement expected');
    },
    visitYieldExpression: function(tree) {
      if (tree.expression !== null) {
        this.checkVisit_(tree.expression.isExpression(), tree.expression, 'expression expected');
      }
    }
  }, {}, ParseTreeVisitor);
  ParseTreeValidator.validate = function(tree) {
    var validator = new ParseTreeValidator();
    try {
      validator.visitAny(tree);
    } catch (e) {
      if (!(e instanceof ValidationError)) {
        throw e;
      }
      var location = null;
      if (e.tree !== null) {
        location = e.tree.location;
      }
      if (location === null) {
        location = tree.location;
      }
      var locationString = location !== null ? location.start.toString(): '(unknown)';
      throw new Error(("Parse tree validation failure '" + e.message + "' at " + locationString + ":") + '\n\n' + TreeWriter.write(tree, {
        highlighted: e.tree,
        showLineNumbers: true
      }) + '\n');
    }
  };
  return {get ParseTreeValidator() {
      return ParseTreeValidator;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/util/ObjectMap", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/util/ObjectMap";
  var ObjectMap = function ObjectMap() {
    this.keys_ = Object.create(null);
    this.values_ = Object.create(null);
  };
  ($traceurRuntime.createClass)(ObjectMap, {
    set: function(key, value) {
      var uid = key.uid;
      this.keys_[uid] = key;
      this.values_[uid] = value;
    },
    get: function(key) {
      return this.values_[key.uid];
    },
    has: function(key) {
      return key.uid in this.keys_;
    },
    addAll: function(other) {
      for (var uid in other.keys_) {
        this.keys_[uid] = other.keys_[uid];
        this.values_[uid] = other.values_[uid];
      }
    },
    keys: function() {
      var $__50 = this;
      return Object.keys(this.keys_).map((function(uid) {
        return $__50.keys_[uid];
      }));
    },
    values: function() {
      var $__50 = this;
      return Object.keys(this.values_).map((function(uid) {
        return $__50.values_[uid];
      }));
    },
    remove: function(key) {
      var uid = key.uid;
      delete this.keys_[uid];
      delete this.values_[uid];
    }
  }, {});
  return {get ObjectMap() {
      return ObjectMap;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/LiteralToken", function() {
  "use strict";
  var $__53;
  var __moduleName = "traceur@0.0.20/src/syntax/LiteralToken";
  var Token = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Token").Token;
  var $__56 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      NULL = $__56.NULL,
      NUMBER = $__56.NUMBER,
      STRING = $__56.STRING;
  var StringParser = function StringParser(value) {
    this.value = value;
    this.index = 0;
  };
  ($traceurRuntime.createClass)(StringParser, ($__53 = {}, Object.defineProperty($__53, Symbol.iterator, {
    value: function() {
      return this;
    },
    configurable: true,
    enumerable: true,
    writable: true
  }), Object.defineProperty($__53, "next", {
    value: function() {
      if (++this.index >= this.value.length - 1) return {
        value: undefined,
        done: true
      };
      return {
        value: this.value[this.index],
        done: false
      };
    },
    configurable: true,
    enumerable: true,
    writable: true
  }), Object.defineProperty($__53, "parse", {
    value: function() {
      if (this.value.indexOf('\\') === - 1) return this.value.slice(1, - 1);
      var result = '';
      for (var $__54 = this[Symbol.iterator](),
          $__55; !($__55 = $__54.next()).done;) {
        var ch = $__55.value;
        {
          result += ch === '\\' ? this.parseEscapeSequence(): ch;
        }
      }
      return result;
    },
    configurable: true,
    enumerable: true,
    writable: true
  }), Object.defineProperty($__53, "parseEscapeSequence", {
    value: function() {
      var ch = this.next();
      switch (ch) {
        case '\n':
        case '\r':
        case '\u2028':
        case '\u2029':
          return '';
        case '0':
          return '\0';
        case 'b':
          return '\b';
        case 'f':
          return '\f';
        case 'n':
          return '\n';
        case 'r':
          return '\r';
        case 't':
          return '\t';
        case 'v':
          return '\v';
        case 'x':
          return String.fromCharCode(parseInt(this.next() + this.next(), 16));
        case 'u':
          return String.fromCharCode(parseInt(this.next() + this.next() + this.next() + this.next(), 16));
        default:
          if (Number(ch) < 8) throw new Error('Octal literals are not supported');
          return ch;
      }
    },
    configurable: true,
    enumerable: true,
    writable: true
  }), $__53), {});
  var LiteralToken = function LiteralToken(type, value, location) {
    this.type = type;
    this.location = location;
    this.value = value;
  };
  ($traceurRuntime.createClass)(LiteralToken, {
    toString: function() {
      return this.value;
    },
    get processedValue() {
      switch (this.type) {
        case NULL:
          return null;
        case NUMBER:
          var value = this.value;
          if (value.charCodeAt(0) === 48) {
            switch (value.charCodeAt(1)) {
              case 66:
              case 98:
                return parseInt(this.value.slice(2), 2);
              case 79:
              case 111:
                return parseInt(this.value.slice(2), 8);
            }
          }
          return Number(this.value);
        case STRING:
          var parser = new StringParser(this.value);
          return parser.parse();
        default:
          throw new Error('Not implemented');
      }
    }
  }, {}, Token);
  return {get LiteralToken() {
      return LiteralToken;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/ParseTreeFactory", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/ParseTreeFactory";
  var IdentifierToken = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/IdentifierToken").IdentifierToken;
  var LiteralToken = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/LiteralToken").LiteralToken;
  var $__59 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTree"),
      ParseTree = $__59.ParseTree,
      ParseTreeType = $__59.ParseTreeType;
  var $__59 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/PredefinedName"),
      BIND = $__59.BIND,
      CALL = $__59.CALL,
      CREATE = $__59.CREATE,
      DEFINE_PROPERTY = $__59.DEFINE_PROPERTY,
      FREEZE = $__59.FREEZE,
      OBJECT = $__59.OBJECT,
      PREVENT_EXTENSIONS = $__59.PREVENT_EXTENSIONS,
      UNDEFINED = $__59.UNDEFINED,
      getParameterName = $__59.getParameterName;
  var Token = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Token").Token;
  var $__59 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      EQUAL = $__59.EQUAL,
      FALSE = $__59.FALSE,
      NULL = $__59.NULL,
      NUMBER = $__59.NUMBER,
      STRING = $__59.STRING,
      TRUE = $__59.TRUE,
      VOID = $__59.VOID;
  var assert = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/assert").assert;
  var $__59 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      ArgumentList = $__59.ArgumentList,
      ArrayComprehension = $__59.ArrayComprehension,
      ArrayLiteralExpression = $__59.ArrayLiteralExpression,
      ArrayPattern = $__59.ArrayPattern,
      ArrowFunctionExpression = $__59.ArrowFunctionExpression,
      AwaitStatement = $__59.AwaitStatement,
      BinaryOperator = $__59.BinaryOperator,
      BindingElement = $__59.BindingElement,
      BindingIdentifier = $__59.BindingIdentifier,
      Block = $__59.Block,
      BreakStatement = $__59.BreakStatement,
      CallExpression = $__59.CallExpression,
      CaseClause = $__59.CaseClause,
      Catch = $__59.Catch,
      ClassDeclaration = $__59.ClassDeclaration,
      ClassExpression = $__59.ClassExpression,
      CommaExpression = $__59.CommaExpression,
      ComprehensionFor = $__59.ComprehensionFor,
      ComprehensionIf = $__59.ComprehensionIf,
      ComputedPropertyName = $__59.ComputedPropertyName,
      ConditionalExpression = $__59.ConditionalExpression,
      ContinueStatement = $__59.ContinueStatement,
      CoverFormals = $__59.CoverFormals,
      CoverInitialisedName = $__59.CoverInitialisedName,
      DebuggerStatement = $__59.DebuggerStatement,
      DefaultClause = $__59.DefaultClause,
      DoWhileStatement = $__59.DoWhileStatement,
      EmptyStatement = $__59.EmptyStatement,
      ExportDeclaration = $__59.ExportDeclaration,
      ExportSpecifier = $__59.ExportSpecifier,
      ExportSpecifierSet = $__59.ExportSpecifierSet,
      ExportStar = $__59.ExportStar,
      ExpressionStatement = $__59.ExpressionStatement,
      Finally = $__59.Finally,
      ForInStatement = $__59.ForInStatement,
      ForOfStatement = $__59.ForOfStatement,
      ForStatement = $__59.ForStatement,
      FormalParameter = $__59.FormalParameter,
      FormalParameterList = $__59.FormalParameterList,
      FunctionBody = $__59.FunctionBody,
      FunctionDeclaration = $__59.FunctionDeclaration,
      FunctionExpression = $__59.FunctionExpression,
      GeneratorComprehension = $__59.GeneratorComprehension,
      GetAccessor = $__59.GetAccessor,
      IdentifierExpression = $__59.IdentifierExpression,
      IfStatement = $__59.IfStatement,
      ImportDeclaration = $__59.ImportDeclaration,
      ImportSpecifier = $__59.ImportSpecifier,
      ImportSpecifierSet = $__59.ImportSpecifierSet,
      LabelledStatement = $__59.LabelledStatement,
      LiteralExpression = $__59.LiteralExpression,
      LiteralPropertyName = $__59.LiteralPropertyName,
      MemberExpression = $__59.MemberExpression,
      MemberLookupExpression = $__59.MemberLookupExpression,
      Module = $__59.Module,
      ModuleDeclaration = $__59.ModuleDeclaration,
      ModuleSpecifier = $__59.ModuleSpecifier,
      NamedExport = $__59.NamedExport,
      NewExpression = $__59.NewExpression,
      ObjectLiteralExpression = $__59.ObjectLiteralExpression,
      ObjectPattern = $__59.ObjectPattern,
      ObjectPatternField = $__59.ObjectPatternField,
      ParenExpression = $__59.ParenExpression,
      PostfixExpression = $__59.PostfixExpression,
      PredefinedType = $__59.PredefinedType,
      Script = $__59.Script,
      PropertyMethodAssignment = $__59.PropertyMethodAssignment,
      PropertyNameAssignment = $__59.PropertyNameAssignment,
      PropertyNameShorthand = $__59.PropertyNameShorthand,
      RestParameter = $__59.RestParameter,
      ReturnStatement = $__59.ReturnStatement,
      SetAccessor = $__59.SetAccessor,
      SpreadExpression = $__59.SpreadExpression,
      SpreadPatternElement = $__59.SpreadPatternElement,
      SuperExpression = $__59.SuperExpression,
      SwitchStatement = $__59.SwitchStatement,
      SyntaxErrorTree = $__59.SyntaxErrorTree,
      TemplateLiteralExpression = $__59.TemplateLiteralExpression,
      TemplateLiteralPortion = $__59.TemplateLiteralPortion,
      TemplateSubstitution = $__59.TemplateSubstitution,
      ThisExpression = $__59.ThisExpression,
      ThrowStatement = $__59.ThrowStatement,
      TryStatement = $__59.TryStatement,
      TypeName = $__59.TypeName,
      UnaryExpression = $__59.UnaryExpression,
      VariableDeclaration = $__59.VariableDeclaration,
      VariableDeclarationList = $__59.VariableDeclarationList,
      VariableStatement = $__59.VariableStatement,
      WhileStatement = $__59.WhileStatement,
      WithStatement = $__59.WithStatement,
      YieldExpression = $__59.YieldExpression;
  var slice = Array.prototype.slice.call.bind(Array.prototype.slice);
  var map = Array.prototype.map.call.bind(Array.prototype.map);
  function createOperatorToken(operator) {
    return new Token(operator, null);
  }
  function createIdentifierToken(identifier) {
    return new IdentifierToken(null, identifier);
  }
  function createPropertyNameToken(name) {
    return createIdentifierToken(name);
  }
  function createStringLiteralToken(value) {
    return new LiteralToken(STRING, JSON.stringify(value), null);
  }
  function createBooleanLiteralToken(value) {
    return new Token(value ? TRUE: FALSE, null);
  }
  function createNullLiteralToken() {
    return new LiteralToken(NULL, 'null', null);
  }
  function createNumberLiteralToken(value) {
    return new LiteralToken(NUMBER, String(value), null);
  }
  function createEmptyParameters() {
    return [];
  }
  function createStatementList(statementsOrHead) {
    for (var args = [],
        $__57 = 1; $__57 < arguments.length; $__57++) args[$__57 - 1] = arguments[$__57];
    if (statementsOrHead instanceof Array) return $traceurRuntime.spread(statementsOrHead, args);
    return slice(arguments);
  }
  function createBindingElement(arg) {
    var binding = createBindingIdentifier(arg);
    return new BindingElement(null, binding, null);
  }
  function createFormalParameter(arg) {
    return new FormalParameter(null, createBindingElement(arg), null, []);
  }
  function createParameterList(arg0, var_args) {
    if (typeof arg0 == 'string') {
      var parameterList = map(arguments, createFormalParameter);
      return new FormalParameterList(null, parameterList);
    }
    if (typeof arg0 == 'number') return createParameterListHelper(arg0, false);
    if (arg0 instanceof IdentifierToken) {
      return new FormalParameterList(null, [createFormalParameter(arg0)]);
    }
    var builder = arg0.map(createFormalParameter);
    return new FormalParameterList(null, builder);
  }
  function createParameterListHelper(numberOfParameters, hasRestParams) {
    var builder = [];
    for (var index = 0; index < numberOfParameters; index++) {
      var parameterName = getParameterName(index);
      var isRestParameter = index == numberOfParameters - 1 && hasRestParams;
      builder.push(isRestParameter ? new FormalParameter(null, createRestParameter(parameterName), null, []): createFormalParameter(parameterName));
    }
    return new FormalParameterList(null, builder);
  }
  function createParameterListWithRestParams(numberOfParameters) {
    return createParameterListHelper(numberOfParameters, true);
  }
  function createParameterReference(index) {
    return createIdentifierExpression(getParameterName(index));
  }
  function createEmptyParameterList() {
    return new FormalParameterList(null, []);
  }
  function createEmptyList() {
    return [];
  }
  function createArgumentList(numberListOrFirst, var_args) {
    if (typeof numberListOrFirst == 'number') {
      return createArgumentListFromParameterList(createParameterList(numberListOrFirst));
    }
    var list;
    if (numberListOrFirst instanceof Array) list = numberListOrFirst; else list = slice(arguments);
    return new ArgumentList(null, list);
  }
  function createArgumentListFromParameterList(formalParameterList) {
    var builder = formalParameterList.parameters.map(function(parameter) {
      if (parameter.isRestParameter()) {
        return createSpreadExpression(createIdentifierExpression(parameter.identifier));
      } else {
        return parameter;
      }
    });
    return new ArgumentList(null, builder);
  }
  function createEmptyArgumentList() {
    return new ArgumentList(null, createEmptyList());
  }
  function createArrayLiteralExpression(list) {
    return new ArrayLiteralExpression(null, list);
  }
  function createEmptyArrayLiteralExpression() {
    return createArrayLiteralExpression(createEmptyList());
  }
  function createArrayPattern(list) {
    return new ArrayPattern(null, list);
  }
  function createAssignmentExpression(lhs, rhs) {
    return new BinaryOperator(null, lhs, createOperatorToken(EQUAL), rhs);
  }
  function createBinaryOperator(left, operator, right) {
    return new BinaryOperator(null, left, operator, right);
  }
  function createBindingIdentifier(identifier) {
    if (typeof identifier === 'string') identifier = createIdentifierToken(identifier); else if (identifier.type === ParseTreeType.BINDING_IDENTIFIER) return identifier; else if (identifier.type === ParseTreeType.IDENTIFIER_EXPRESSION) return new BindingIdentifier(identifier.location, identifier.identifierToken);
    return new BindingIdentifier(null, identifier);
  }
  function createEmptyStatement() {
    return new EmptyStatement(null);
  }
  function createEmptyBlock() {
    return createBlock(createEmptyList());
  }
  function createBlock(statements) {
    if (statements instanceof ParseTree) statements = slice(arguments);
    return new Block(null, statements);
  }
  function createFunctionBody(statements) {
    return new FunctionBody(null, statements);
  }
  function createScopedExpression(body) {
    var scope = arguments[1] !== (void 0) ? arguments[1]: createThisExpression();
    assert(body.type === 'FUNCTION_BODY');
    return createCallCall(createParenExpression(createFunctionExpression(createEmptyParameterList(), body)), scope);
  }
  function createImmediatelyInvokedFunctionExpression(body) {
    assert(body.type === 'FUNCTION_BODY');
    return createCallExpression(createParenExpression(createFunctionExpression(createEmptyParameterList(), body)));
  }
  function createCallExpression(operand) {
    var args = arguments[1] !== (void 0) ? arguments[1]: createEmptyArgumentList();
    return new CallExpression(null, operand, args);
  }
  function createBoundCall(func, thisTree) {
    return createCallExpression(createMemberExpression(func.type == ParseTreeType.FUNCTION_EXPRESSION ? createParenExpression(func): func, BIND), createArgumentList(thisTree));
  }
  function createBreakStatement() {
    var name = arguments[0] !== (void 0) ? arguments[0]: null;
    return new BreakStatement(null, name);
  }
  function createCallCall(func, thisExpression, args, var_args) {
    var $__60;
    if (args instanceof ParseTree) args = slice(arguments, 2);
    var builder = [thisExpression];
    if (args)($__60 = builder).push.apply($__60, $traceurRuntime.toObject(args));
    return createCallExpression(createMemberExpression(func, CALL), createArgumentList(builder));
  }
  function createCallCallStatement(func, thisExpression) {
    for (var args = [],
        $__58 = 2; $__58 < arguments.length; $__58++) args[$__58 - 2] = arguments[$__58];
    return createExpressionStatement(createCallCall(func, thisExpression, args));
  }
  function createCaseClause(expression, statements) {
    return new CaseClause(null, expression, statements);
  }
  function createCatch(identifier, catchBody) {
    identifier = createBindingIdentifier(identifier);
    return new Catch(null, identifier, catchBody);
  }
  function createClassDeclaration(name, superClass, elements) {
    return new ClassDeclaration(null, name, superClass, elements, []);
  }
  function createCommaExpression(expressions) {
    return new CommaExpression(null, expressions);
  }
  function createConditionalExpression(condition, left, right) {
    return new ConditionalExpression(null, condition, left, right);
  }
  function createContinueStatement() {
    var name = arguments[0] !== (void 0) ? arguments[0]: null;
    return new ContinueStatement(null, name);
  }
  function createDefaultClause(statements) {
    return new DefaultClause(null, statements);
  }
  function createDoWhileStatement(body, condition) {
    return new DoWhileStatement(null, body, condition);
  }
  function createAssignmentStatement(lhs, rhs) {
    return createExpressionStatement(createAssignmentExpression(lhs, rhs));
  }
  function createCallStatement(operand) {
    var args = arguments[1];
    return createExpressionStatement(createCallExpression(operand, args));
  }
  function createExpressionStatement(expression) {
    return new ExpressionStatement(null, expression);
  }
  function createFinally(block) {
    return new Finally(null, block);
  }
  function createForOfStatement(initialiser, collection, body) {
    return new ForOfStatement(null, initialiser, collection, body);
  }
  function createForInStatement(initialiser, collection, body) {
    return new ForInStatement(null, initialiser, collection, body);
  }
  function createForStatement(variables, condition, increment, body) {
    return new ForStatement(null, variables, condition, increment, body);
  }
  function createFunctionExpression(formalParameterList, body) {
    assert(body.type === 'FUNCTION_BODY');
    return new FunctionExpression(null, null, false, formalParameterList, null, [], body);
  }
  function createGetAccessor(name, body) {
    if (typeof name == 'string') name = createPropertyNameToken(name);
    var isStatic = false;
    return new GetAccessor(null, isStatic, name, null, [], body);
  }
  function createIdentifierExpression(identifier) {
    if (typeof identifier == 'string') identifier = createIdentifierToken(identifier); else if (identifier instanceof BindingIdentifier) identifier = identifier.identifierToken;
    return new IdentifierExpression(null, identifier);
  }
  function createUndefinedExpression() {
    return createIdentifierExpression(UNDEFINED);
  }
  function createIfStatement(condition, ifClause) {
    var elseClause = arguments[2] !== (void 0) ? arguments[2]: null;
    return new IfStatement(null, condition, ifClause, elseClause);
  }
  function createLabelledStatement(name, statement) {
    return new LabelledStatement(null, name, statement);
  }
  function createStringLiteral(value) {
    return new LiteralExpression(null, createStringLiteralToken(value));
  }
  function createBooleanLiteral(value) {
    return new LiteralExpression(null, createBooleanLiteralToken(value));
  }
  function createTrueLiteral() {
    return createBooleanLiteral(true);
  }
  function createFalseLiteral() {
    return createBooleanLiteral(false);
  }
  function createNullLiteral() {
    return new LiteralExpression(null, createNullLiteralToken());
  }
  function createNumberLiteral(value) {
    return new LiteralExpression(null, createNumberLiteralToken(value));
  }
  function createMemberExpression(operand, memberName, memberNames) {
    if (typeof operand == 'string' || operand instanceof IdentifierToken) operand = createIdentifierExpression(operand);
    if (typeof memberName == 'string') memberName = createIdentifierToken(memberName);
    if (memberName instanceof LiteralToken) memberName = new LiteralExpression(null, memberName);
    var tree = memberName instanceof LiteralExpression ? new MemberLookupExpression(null, operand, memberName): new MemberExpression(null, operand, memberName);
    for (var i = 2; i < arguments.length; i++) {
      tree = createMemberExpression(tree, arguments[i]);
    }
    return tree;
  }
  function createMemberLookupExpression(operand, memberExpression) {
    return new MemberLookupExpression(null, operand, memberExpression);
  }
  function createThisExpression() {
    var memberName = arguments[0];
    var result = new ThisExpression(null);
    if (memberName) {
      result = createMemberExpression(result, memberName);
    }
    return result;
  }
  function createNewExpression(operand, args) {
    return new NewExpression(null, operand, args);
  }
  function createObjectFreeze(value) {
    return createCallExpression(createMemberExpression(OBJECT, FREEZE), createArgumentList(value));
  }
  function createObjectPreventExtensions(value) {
    return createCallExpression(createMemberExpression(OBJECT, PREVENT_EXTENSIONS), createArgumentList(value));
  }
  function createObjectCreate(protoExpression, descriptors) {
    var argumentList = [protoExpression];
    if (descriptors) argumentList.push(descriptors);
    return createCallExpression(createMemberExpression(OBJECT, CREATE), createArgumentList(argumentList));
  }
  function createPropertyDescriptor(descr) {
    var propertyNameAndValues = Object.keys(descr).map(function(name) {
      var value = descr[name];
      if (!(value instanceof ParseTree)) value = createBooleanLiteral(!!value);
      return createPropertyNameAssignment(name, value);
    });
    return createObjectLiteralExpression(propertyNameAndValues);
  }
  function createDefineProperty(tree, name, descr) {
    if (typeof name === 'string') name = createStringLiteral(name);
    return createCallExpression(createMemberExpression(OBJECT, DEFINE_PROPERTY), createArgumentList(tree, name, createPropertyDescriptor(descr)));
  }
  function createObjectLiteralExpression(propertyNameAndValues) {
    if (propertyNameAndValues instanceof ParseTree) propertyNameAndValues = slice(arguments);
    return new ObjectLiteralExpression(null, propertyNameAndValues);
  }
  function createObjectPattern(list) {
    return new ObjectPattern(null, list);
  }
  function createObjectPatternField(identifier, element) {
    identifier = createBindingIdentifier(identifier);
    return new ObjectPatternField(null, identifier, element);
  }
  function createParenExpression(expression) {
    return new ParenExpression(null, expression);
  }
  function createPostfixExpression(operand, operator) {
    return new PostfixExpression(null, operand, operator);
  }
  function createScript(scriptItemList) {
    return new Script(null, scriptItemList);
  }
  function createPropertyNameAssignment(identifier, value) {
    if (typeof identifier == 'string') identifier = createLiteralPropertyName(identifier);
    return new PropertyNameAssignment(null, identifier, value);
  }
  function createLiteralPropertyName(name) {
    return new LiteralPropertyName(null, createIdentifierToken(name));
  }
  function createRestParameter(identifier) {
    return new RestParameter(null, createBindingIdentifier(identifier));
  }
  function createReturnStatement(expression) {
    return new ReturnStatement(null, expression);
  }
  function createYieldStatement(expression, isYieldFor) {
    return createExpressionStatement(new YieldExpression(null, expression, isYieldFor));
  }
  function createSetAccessor(name, parameter, body) {
    if (typeof name == 'string') name = createPropertyNameToken(name);
    if (typeof parameter == 'string') parameter = createIdentifierToken(parameter);
    var isStatic = false;
    return new SetAccessor(null, isStatic, name, parameter, [], body);
  }
  function createSpreadExpression(expression) {
    return new SpreadExpression(null, expression);
  }
  function createSpreadPatternElement(lvalue) {
    return new SpreadPatternElement(null, lvalue);
  }
  function createSwitchStatement(expression, caseClauses) {
    return new SwitchStatement(null, expression, caseClauses);
  }
  function createThrowStatement(value) {
    return new ThrowStatement(null, value);
  }
  function createTryStatement(body, catchBlock) {
    var finallyBlock = arguments[2] !== (void 0) ? arguments[2]: null;
    return new TryStatement(null, body, catchBlock, finallyBlock);
  }
  function createUnaryExpression(operator, operand) {
    return new UnaryExpression(null, operator, operand);
  }
  function createUseStrictDirective() {
    return createExpressionStatement(createStringLiteral('use strict'));
  }
  function createVariableDeclarationList(binding, identifierOrDeclarations, initialiser) {
    if (identifierOrDeclarations instanceof Array) {
      var declarations = identifierOrDeclarations;
      return new VariableDeclarationList(null, binding, declarations);
    }
    var identifier = identifierOrDeclarations;
    return createVariableDeclarationList(binding, [createVariableDeclaration(identifier, initialiser)]);
  }
  function createVariableDeclaration(identifier, initialiser) {
    if (!(identifier instanceof ParseTree) || identifier.type !== ParseTreeType.BINDING_IDENTIFIER && identifier.type !== ParseTreeType.OBJECT_PATTERN && identifier.type !== ParseTreeType.ARRAY_PATTERN) {
      identifier = createBindingIdentifier(identifier);
    }
    return new VariableDeclaration(null, identifier, null, initialiser);
  }
  function createVariableStatement(listOrBinding, identifier, initialiser) {
    if (listOrBinding instanceof VariableDeclarationList) return new VariableStatement(null, listOrBinding);
    var binding = listOrBinding;
    var list = createVariableDeclarationList(binding, identifier, initialiser);
    return createVariableStatement(list);
  }
  function createVoid0() {
    return createParenExpression(createUnaryExpression(createOperatorToken(VOID), createNumberLiteral(0)));
  }
  function createWhileStatement(condition, body) {
    return new WhileStatement(null, condition, body);
  }
  function createWithStatement(expression, body) {
    return new WithStatement(null, expression, body);
  }
  function createAssignStateStatement(state) {
    return createAssignmentStatement(createMemberExpression('$ctx', 'state'), createNumberLiteral(state));
  }
  return {
    get createOperatorToken() {
      return createOperatorToken;
    },
    get createIdentifierToken() {
      return createIdentifierToken;
    },
    get createPropertyNameToken() {
      return createPropertyNameToken;
    },
    get createStringLiteralToken() {
      return createStringLiteralToken;
    },
    get createBooleanLiteralToken() {
      return createBooleanLiteralToken;
    },
    get createNullLiteralToken() {
      return createNullLiteralToken;
    },
    get createNumberLiteralToken() {
      return createNumberLiteralToken;
    },
    get createEmptyParameters() {
      return createEmptyParameters;
    },
    get createStatementList() {
      return createStatementList;
    },
    get createBindingElement() {
      return createBindingElement;
    },
    get createFormalParameter() {
      return createFormalParameter;
    },
    get createParameterList() {
      return createParameterList;
    },
    get createParameterListWithRestParams() {
      return createParameterListWithRestParams;
    },
    get createParameterReference() {
      return createParameterReference;
    },
    get createEmptyParameterList() {
      return createEmptyParameterList;
    },
    get createEmptyList() {
      return createEmptyList;
    },
    get createArgumentList() {
      return createArgumentList;
    },
    get createArgumentListFromParameterList() {
      return createArgumentListFromParameterList;
    },
    get createEmptyArgumentList() {
      return createEmptyArgumentList;
    },
    get createArrayLiteralExpression() {
      return createArrayLiteralExpression;
    },
    get createEmptyArrayLiteralExpression() {
      return createEmptyArrayLiteralExpression;
    },
    get createArrayPattern() {
      return createArrayPattern;
    },
    get createAssignmentExpression() {
      return createAssignmentExpression;
    },
    get createBinaryOperator() {
      return createBinaryOperator;
    },
    get createBindingIdentifier() {
      return createBindingIdentifier;
    },
    get createEmptyStatement() {
      return createEmptyStatement;
    },
    get createEmptyBlock() {
      return createEmptyBlock;
    },
    get createBlock() {
      return createBlock;
    },
    get createFunctionBody() {
      return createFunctionBody;
    },
    get createScopedExpression() {
      return createScopedExpression;
    },
    get createImmediatelyInvokedFunctionExpression() {
      return createImmediatelyInvokedFunctionExpression;
    },
    get createCallExpression() {
      return createCallExpression;
    },
    get createBoundCall() {
      return createBoundCall;
    },
    get createBreakStatement() {
      return createBreakStatement;
    },
    get createCallCall() {
      return createCallCall;
    },
    get createCallCallStatement() {
      return createCallCallStatement;
    },
    get createCaseClause() {
      return createCaseClause;
    },
    get createCatch() {
      return createCatch;
    },
    get createClassDeclaration() {
      return createClassDeclaration;
    },
    get createCommaExpression() {
      return createCommaExpression;
    },
    get createConditionalExpression() {
      return createConditionalExpression;
    },
    get createContinueStatement() {
      return createContinueStatement;
    },
    get createDefaultClause() {
      return createDefaultClause;
    },
    get createDoWhileStatement() {
      return createDoWhileStatement;
    },
    get createAssignmentStatement() {
      return createAssignmentStatement;
    },
    get createCallStatement() {
      return createCallStatement;
    },
    get createExpressionStatement() {
      return createExpressionStatement;
    },
    get createFinally() {
      return createFinally;
    },
    get createForOfStatement() {
      return createForOfStatement;
    },
    get createForInStatement() {
      return createForInStatement;
    },
    get createForStatement() {
      return createForStatement;
    },
    get createFunctionExpression() {
      return createFunctionExpression;
    },
    get createGetAccessor() {
      return createGetAccessor;
    },
    get createIdentifierExpression() {
      return createIdentifierExpression;
    },
    get createUndefinedExpression() {
      return createUndefinedExpression;
    },
    get createIfStatement() {
      return createIfStatement;
    },
    get createLabelledStatement() {
      return createLabelledStatement;
    },
    get createStringLiteral() {
      return createStringLiteral;
    },
    get createBooleanLiteral() {
      return createBooleanLiteral;
    },
    get createTrueLiteral() {
      return createTrueLiteral;
    },
    get createFalseLiteral() {
      return createFalseLiteral;
    },
    get createNullLiteral() {
      return createNullLiteral;
    },
    get createNumberLiteral() {
      return createNumberLiteral;
    },
    get createMemberExpression() {
      return createMemberExpression;
    },
    get createMemberLookupExpression() {
      return createMemberLookupExpression;
    },
    get createThisExpression() {
      return createThisExpression;
    },
    get createNewExpression() {
      return createNewExpression;
    },
    get createObjectFreeze() {
      return createObjectFreeze;
    },
    get createObjectPreventExtensions() {
      return createObjectPreventExtensions;
    },
    get createObjectCreate() {
      return createObjectCreate;
    },
    get createPropertyDescriptor() {
      return createPropertyDescriptor;
    },
    get createDefineProperty() {
      return createDefineProperty;
    },
    get createObjectLiteralExpression() {
      return createObjectLiteralExpression;
    },
    get createObjectPattern() {
      return createObjectPattern;
    },
    get createObjectPatternField() {
      return createObjectPatternField;
    },
    get createParenExpression() {
      return createParenExpression;
    },
    get createPostfixExpression() {
      return createPostfixExpression;
    },
    get createScript() {
      return createScript;
    },
    get createPropertyNameAssignment() {
      return createPropertyNameAssignment;
    },
    get createLiteralPropertyName() {
      return createLiteralPropertyName;
    },
    get createRestParameter() {
      return createRestParameter;
    },
    get createReturnStatement() {
      return createReturnStatement;
    },
    get createYieldStatement() {
      return createYieldStatement;
    },
    get createSetAccessor() {
      return createSetAccessor;
    },
    get createSpreadExpression() {
      return createSpreadExpression;
    },
    get createSpreadPatternElement() {
      return createSpreadPatternElement;
    },
    get createSwitchStatement() {
      return createSwitchStatement;
    },
    get createThrowStatement() {
      return createThrowStatement;
    },
    get createTryStatement() {
      return createTryStatement;
    },
    get createUnaryExpression() {
      return createUnaryExpression;
    },
    get createUseStrictDirective() {
      return createUseStrictDirective;
    },
    get createVariableDeclarationList() {
      return createVariableDeclarationList;
    },
    get createVariableDeclaration() {
      return createVariableDeclaration;
    },
    get createVariableStatement() {
      return createVariableStatement;
    },
    get createVoid0() {
      return createVoid0;
    },
    get createWhileStatement() {
      return createWhileStatement;
    },
    get createWithStatement() {
      return createWithStatement;
    },
    get createAssignStateStatement() {
      return createAssignStateStatement;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/ParseTreeTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/ParseTreeTransformer";
  var $__62 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      Annotation = $__62.Annotation,
      AnonBlock = $__62.AnonBlock,
      ArgumentList = $__62.ArgumentList,
      ArrayComprehension = $__62.ArrayComprehension,
      ArrayLiteralExpression = $__62.ArrayLiteralExpression,
      ArrayPattern = $__62.ArrayPattern,
      ArrowFunctionExpression = $__62.ArrowFunctionExpression,
      AwaitStatement = $__62.AwaitStatement,
      BinaryOperator = $__62.BinaryOperator,
      BindingElement = $__62.BindingElement,
      BindingIdentifier = $__62.BindingIdentifier,
      Block = $__62.Block,
      BreakStatement = $__62.BreakStatement,
      CallExpression = $__62.CallExpression,
      CaseClause = $__62.CaseClause,
      Catch = $__62.Catch,
      ClassDeclaration = $__62.ClassDeclaration,
      ClassExpression = $__62.ClassExpression,
      CommaExpression = $__62.CommaExpression,
      ComprehensionFor = $__62.ComprehensionFor,
      ComprehensionIf = $__62.ComprehensionIf,
      ComputedPropertyName = $__62.ComputedPropertyName,
      ConditionalExpression = $__62.ConditionalExpression,
      ContinueStatement = $__62.ContinueStatement,
      CoverFormals = $__62.CoverFormals,
      CoverInitialisedName = $__62.CoverInitialisedName,
      DebuggerStatement = $__62.DebuggerStatement,
      DefaultClause = $__62.DefaultClause,
      DoWhileStatement = $__62.DoWhileStatement,
      EmptyStatement = $__62.EmptyStatement,
      ExportDeclaration = $__62.ExportDeclaration,
      ExportDefault = $__62.ExportDefault,
      ExportSpecifier = $__62.ExportSpecifier,
      ExportSpecifierSet = $__62.ExportSpecifierSet,
      ExportStar = $__62.ExportStar,
      ExpressionStatement = $__62.ExpressionStatement,
      Finally = $__62.Finally,
      ForInStatement = $__62.ForInStatement,
      ForOfStatement = $__62.ForOfStatement,
      ForStatement = $__62.ForStatement,
      FormalParameter = $__62.FormalParameter,
      FormalParameterList = $__62.FormalParameterList,
      FunctionBody = $__62.FunctionBody,
      FunctionDeclaration = $__62.FunctionDeclaration,
      FunctionExpression = $__62.FunctionExpression,
      GeneratorComprehension = $__62.GeneratorComprehension,
      GetAccessor = $__62.GetAccessor,
      IdentifierExpression = $__62.IdentifierExpression,
      IfStatement = $__62.IfStatement,
      ImportedBinding = $__62.ImportedBinding,
      ImportDeclaration = $__62.ImportDeclaration,
      ImportSpecifier = $__62.ImportSpecifier,
      ImportSpecifierSet = $__62.ImportSpecifierSet,
      LabelledStatement = $__62.LabelledStatement,
      LiteralExpression = $__62.LiteralExpression,
      LiteralPropertyName = $__62.LiteralPropertyName,
      MemberExpression = $__62.MemberExpression,
      MemberLookupExpression = $__62.MemberLookupExpression,
      Module = $__62.Module,
      ModuleDeclaration = $__62.ModuleDeclaration,
      ModuleSpecifier = $__62.ModuleSpecifier,
      NamedExport = $__62.NamedExport,
      NewExpression = $__62.NewExpression,
      ObjectLiteralExpression = $__62.ObjectLiteralExpression,
      ObjectPattern = $__62.ObjectPattern,
      ObjectPatternField = $__62.ObjectPatternField,
      ParenExpression = $__62.ParenExpression,
      PostfixExpression = $__62.PostfixExpression,
      PredefinedType = $__62.PredefinedType,
      Script = $__62.Script,
      PropertyMethodAssignment = $__62.PropertyMethodAssignment,
      PropertyNameAssignment = $__62.PropertyNameAssignment,
      PropertyNameShorthand = $__62.PropertyNameShorthand,
      RestParameter = $__62.RestParameter,
      ReturnStatement = $__62.ReturnStatement,
      SetAccessor = $__62.SetAccessor,
      SpreadExpression = $__62.SpreadExpression,
      SpreadPatternElement = $__62.SpreadPatternElement,
      SuperExpression = $__62.SuperExpression,
      SwitchStatement = $__62.SwitchStatement,
      SyntaxErrorTree = $__62.SyntaxErrorTree,
      TemplateLiteralExpression = $__62.TemplateLiteralExpression,
      TemplateLiteralPortion = $__62.TemplateLiteralPortion,
      TemplateSubstitution = $__62.TemplateSubstitution,
      ThisExpression = $__62.ThisExpression,
      ThrowStatement = $__62.ThrowStatement,
      TryStatement = $__62.TryStatement,
      TypeName = $__62.TypeName,
      UnaryExpression = $__62.UnaryExpression,
      VariableDeclaration = $__62.VariableDeclaration,
      VariableDeclarationList = $__62.VariableDeclarationList,
      VariableStatement = $__62.VariableStatement,
      WhileStatement = $__62.WhileStatement,
      WithStatement = $__62.WithStatement,
      YieldExpression = $__62.YieldExpression;
  var ParseTreeTransformer = function ParseTreeTransformer() {};
  ($traceurRuntime.createClass)(ParseTreeTransformer, {
    transformAny: function(tree) {
      return tree && tree.transform(this);
    },
    transformList: function(list) {
      var $__63;
      var builder = null;
      for (var index = 0; index < list.length; index++) {
        var element = list[index];
        var transformed = this.transformAny(element);
        if (builder != null || element != transformed) {
          if (builder == null) {
            builder = list.slice(0, index);
          }
          if (transformed instanceof AnonBlock)($__63 = builder).push.apply($__63, $traceurRuntime.toObject(transformed.statements)); else builder.push(transformed);
        }
      }
      return builder || list;
    },
    transformStateMachine: function(tree) {
      throw Error('State machines should not live outside of the GeneratorTransformer.');
    },
    transformAnnotation: function(tree) {
      var name = this.transformAny(tree.name);
      var args = this.transformAny(tree.args);
      if (name === tree.name && args === tree.args) {
        return tree;
      }
      return new Annotation(tree.location, name, args);
    },
    transformAnonBlock: function(tree) {
      var statements = this.transformList(tree.statements);
      if (statements === tree.statements) {
        return tree;
      }
      return new AnonBlock(tree.location, statements);
    },
    transformArgumentList: function(tree) {
      var args = this.transformList(tree.args);
      if (args === tree.args) {
        return tree;
      }
      return new ArgumentList(tree.location, args);
    },
    transformArrayComprehension: function(tree) {
      var comprehensionList = this.transformList(tree.comprehensionList);
      var expression = this.transformAny(tree.expression);
      if (comprehensionList === tree.comprehensionList && expression === tree.expression) {
        return tree;
      }
      return new ArrayComprehension(tree.location, comprehensionList, expression);
    },
    transformArrayLiteralExpression: function(tree) {
      var elements = this.transformList(tree.elements);
      if (elements === tree.elements) {
        return tree;
      }
      return new ArrayLiteralExpression(tree.location, elements);
    },
    transformArrayPattern: function(tree) {
      var elements = this.transformList(tree.elements);
      if (elements === tree.elements) {
        return tree;
      }
      return new ArrayPattern(tree.location, elements);
    },
    transformArrowFunctionExpression: function(tree) {
      var formalParameters = this.transformAny(tree.formalParameters);
      var functionBody = this.transformAny(tree.functionBody);
      if (formalParameters === tree.formalParameters && functionBody === tree.functionBody) {
        return tree;
      }
      return new ArrowFunctionExpression(tree.location, formalParameters, functionBody);
    },
    transformAwaitStatement: function(tree) {
      var expression = this.transformAny(tree.expression);
      if (expression === tree.expression) {
        return tree;
      }
      return new AwaitStatement(tree.location, tree.identifier, expression);
    },
    transformBinaryOperator: function(tree) {
      var left = this.transformAny(tree.left);
      var right = this.transformAny(tree.right);
      if (left === tree.left && right === tree.right) {
        return tree;
      }
      return new BinaryOperator(tree.location, left, tree.operator, right);
    },
    transformBindingElement: function(tree) {
      var binding = this.transformAny(tree.binding);
      var initialiser = this.transformAny(tree.initialiser);
      if (binding === tree.binding && initialiser === tree.initialiser) {
        return tree;
      }
      return new BindingElement(tree.location, binding, initialiser);
    },
    transformBindingIdentifier: function(tree) {
      return tree;
    },
    transformBlock: function(tree) {
      var statements = this.transformList(tree.statements);
      if (statements === tree.statements) {
        return tree;
      }
      return new Block(tree.location, statements);
    },
    transformBreakStatement: function(tree) {
      return tree;
    },
    transformCallExpression: function(tree) {
      var operand = this.transformAny(tree.operand);
      var args = this.transformAny(tree.args);
      if (operand === tree.operand && args === tree.args) {
        return tree;
      }
      return new CallExpression(tree.location, operand, args);
    },
    transformCaseClause: function(tree) {
      var expression = this.transformAny(tree.expression);
      var statements = this.transformList(tree.statements);
      if (expression === tree.expression && statements === tree.statements) {
        return tree;
      }
      return new CaseClause(tree.location, expression, statements);
    },
    transformCatch: function(tree) {
      var binding = this.transformAny(tree.binding);
      var catchBody = this.transformAny(tree.catchBody);
      if (binding === tree.binding && catchBody === tree.catchBody) {
        return tree;
      }
      return new Catch(tree.location, binding, catchBody);
    },
    transformClassDeclaration: function(tree) {
      var name = this.transformAny(tree.name);
      var superClass = this.transformAny(tree.superClass);
      var elements = this.transformList(tree.elements);
      var annotations = this.transformList(tree.annotations);
      if (name === tree.name && superClass === tree.superClass && elements === tree.elements && annotations === tree.annotations) {
        return tree;
      }
      return new ClassDeclaration(tree.location, name, superClass, elements, annotations);
    },
    transformClassExpression: function(tree) {
      var name = this.transformAny(tree.name);
      var superClass = this.transformAny(tree.superClass);
      var elements = this.transformList(tree.elements);
      var annotations = this.transformList(tree.annotations);
      if (name === tree.name && superClass === tree.superClass && elements === tree.elements && annotations === tree.annotations) {
        return tree;
      }
      return new ClassExpression(tree.location, name, superClass, elements, annotations);
    },
    transformCommaExpression: function(tree) {
      var expressions = this.transformList(tree.expressions);
      if (expressions === tree.expressions) {
        return tree;
      }
      return new CommaExpression(tree.location, expressions);
    },
    transformComprehensionFor: function(tree) {
      var left = this.transformAny(tree.left);
      var iterator = this.transformAny(tree.iterator);
      if (left === tree.left && iterator === tree.iterator) {
        return tree;
      }
      return new ComprehensionFor(tree.location, left, iterator);
    },
    transformComprehensionIf: function(tree) {
      var expression = this.transformAny(tree.expression);
      if (expression === tree.expression) {
        return tree;
      }
      return new ComprehensionIf(tree.location, expression);
    },
    transformComputedPropertyName: function(tree) {
      var expression = this.transformAny(tree.expression);
      if (expression === tree.expression) {
        return tree;
      }
      return new ComputedPropertyName(tree.location, expression);
    },
    transformConditionalExpression: function(tree) {
      var condition = this.transformAny(tree.condition);
      var left = this.transformAny(tree.left);
      var right = this.transformAny(tree.right);
      if (condition === tree.condition && left === tree.left && right === tree.right) {
        return tree;
      }
      return new ConditionalExpression(tree.location, condition, left, right);
    },
    transformContinueStatement: function(tree) {
      return tree;
    },
    transformCoverFormals: function(tree) {
      var expressions = this.transformList(tree.expressions);
      if (expressions === tree.expressions) {
        return tree;
      }
      return new CoverFormals(tree.location, expressions);
    },
    transformCoverInitialisedName: function(tree) {
      var initialiser = this.transformAny(tree.initialiser);
      if (initialiser === tree.initialiser) {
        return tree;
      }
      return new CoverInitialisedName(tree.location, tree.name, tree.equalToken, initialiser);
    },
    transformDebuggerStatement: function(tree) {
      return tree;
    },
    transformDefaultClause: function(tree) {
      var statements = this.transformList(tree.statements);
      if (statements === tree.statements) {
        return tree;
      }
      return new DefaultClause(tree.location, statements);
    },
    transformDoWhileStatement: function(tree) {
      var body = this.transformAny(tree.body);
      var condition = this.transformAny(tree.condition);
      if (body === tree.body && condition === tree.condition) {
        return tree;
      }
      return new DoWhileStatement(tree.location, body, condition);
    },
    transformEmptyStatement: function(tree) {
      return tree;
    },
    transformExportDeclaration: function(tree) {
      var declaration = this.transformAny(tree.declaration);
      var annotations = this.transformList(tree.annotations);
      if (declaration === tree.declaration && annotations === tree.annotations) {
        return tree;
      }
      return new ExportDeclaration(tree.location, declaration, annotations);
    },
    transformExportDefault: function(tree) {
      var expression = this.transformAny(tree.expression);
      if (expression === tree.expression) {
        return tree;
      }
      return new ExportDefault(tree.location, expression);
    },
    transformExportSpecifier: function(tree) {
      return tree;
    },
    transformExportSpecifierSet: function(tree) {
      var specifiers = this.transformList(tree.specifiers);
      if (specifiers === tree.specifiers) {
        return tree;
      }
      return new ExportSpecifierSet(tree.location, specifiers);
    },
    transformExportStar: function(tree) {
      return tree;
    },
    transformExpressionStatement: function(tree) {
      var expression = this.transformAny(tree.expression);
      if (expression === tree.expression) {
        return tree;
      }
      return new ExpressionStatement(tree.location, expression);
    },
    transformFinally: function(tree) {
      var block = this.transformAny(tree.block);
      if (block === tree.block) {
        return tree;
      }
      return new Finally(tree.location, block);
    },
    transformForInStatement: function(tree) {
      var initialiser = this.transformAny(tree.initialiser);
      var collection = this.transformAny(tree.collection);
      var body = this.transformAny(tree.body);
      if (initialiser === tree.initialiser && collection === tree.collection && body === tree.body) {
        return tree;
      }
      return new ForInStatement(tree.location, initialiser, collection, body);
    },
    transformForOfStatement: function(tree) {
      var initialiser = this.transformAny(tree.initialiser);
      var collection = this.transformAny(tree.collection);
      var body = this.transformAny(tree.body);
      if (initialiser === tree.initialiser && collection === tree.collection && body === tree.body) {
        return tree;
      }
      return new ForOfStatement(tree.location, initialiser, collection, body);
    },
    transformForStatement: function(tree) {
      var initialiser = this.transformAny(tree.initialiser);
      var condition = this.transformAny(tree.condition);
      var increment = this.transformAny(tree.increment);
      var body = this.transformAny(tree.body);
      if (initialiser === tree.initialiser && condition === tree.condition && increment === tree.increment && body === tree.body) {
        return tree;
      }
      return new ForStatement(tree.location, initialiser, condition, increment, body);
    },
    transformFormalParameter: function(tree) {
      var parameter = this.transformAny(tree.parameter);
      var typeAnnotation = this.transformAny(tree.typeAnnotation);
      var annotations = this.transformList(tree.annotations);
      if (parameter === tree.parameter && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations) {
        return tree;
      }
      return new FormalParameter(tree.location, parameter, typeAnnotation, annotations);
    },
    transformFormalParameterList: function(tree) {
      var parameters = this.transformList(tree.parameters);
      if (parameters === tree.parameters) {
        return tree;
      }
      return new FormalParameterList(tree.location, parameters);
    },
    transformFunctionBody: function(tree) {
      var statements = this.transformList(tree.statements);
      if (statements === tree.statements) {
        return tree;
      }
      return new FunctionBody(tree.location, statements);
    },
    transformFunctionDeclaration: function(tree) {
      var name = this.transformAny(tree.name);
      var formalParameterList = this.transformAny(tree.formalParameterList);
      var typeAnnotation = this.transformAny(tree.typeAnnotation);
      var annotations = this.transformList(tree.annotations);
      var functionBody = this.transformAny(tree.functionBody);
      if (name === tree.name && formalParameterList === tree.formalParameterList && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && functionBody === tree.functionBody) {
        return tree;
      }
      return new FunctionDeclaration(tree.location, name, tree.isGenerator, formalParameterList, typeAnnotation, annotations, functionBody);
    },
    transformFunctionExpression: function(tree) {
      var name = this.transformAny(tree.name);
      var formalParameterList = this.transformAny(tree.formalParameterList);
      var typeAnnotation = this.transformAny(tree.typeAnnotation);
      var annotations = this.transformList(tree.annotations);
      var functionBody = this.transformAny(tree.functionBody);
      if (name === tree.name && formalParameterList === tree.formalParameterList && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && functionBody === tree.functionBody) {
        return tree;
      }
      return new FunctionExpression(tree.location, name, tree.isGenerator, formalParameterList, typeAnnotation, annotations, functionBody);
    },
    transformGeneratorComprehension: function(tree) {
      var comprehensionList = this.transformList(tree.comprehensionList);
      var expression = this.transformAny(tree.expression);
      if (comprehensionList === tree.comprehensionList && expression === tree.expression) {
        return tree;
      }
      return new GeneratorComprehension(tree.location, comprehensionList, expression);
    },
    transformGetAccessor: function(tree) {
      var name = this.transformAny(tree.name);
      var typeAnnotation = this.transformAny(tree.typeAnnotation);
      var annotations = this.transformList(tree.annotations);
      var body = this.transformAny(tree.body);
      if (name === tree.name && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && body === tree.body) {
        return tree;
      }
      return new GetAccessor(tree.location, tree.isStatic, name, typeAnnotation, annotations, body);
    },
    transformIdentifierExpression: function(tree) {
      return tree;
    },
    transformIfStatement: function(tree) {
      var condition = this.transformAny(tree.condition);
      var ifClause = this.transformAny(tree.ifClause);
      var elseClause = this.transformAny(tree.elseClause);
      if (condition === tree.condition && ifClause === tree.ifClause && elseClause === tree.elseClause) {
        return tree;
      }
      return new IfStatement(tree.location, condition, ifClause, elseClause);
    },
    transformImportedBinding: function(tree) {
      var binding = this.transformAny(tree.binding);
      if (binding === tree.binding) {
        return tree;
      }
      return new ImportedBinding(tree.location, binding);
    },
    transformImportDeclaration: function(tree) {
      var importClause = this.transformAny(tree.importClause);
      var moduleSpecifier = this.transformAny(tree.moduleSpecifier);
      if (importClause === tree.importClause && moduleSpecifier === tree.moduleSpecifier) {
        return tree;
      }
      return new ImportDeclaration(tree.location, importClause, moduleSpecifier);
    },
    transformImportSpecifier: function(tree) {
      return tree;
    },
    transformImportSpecifierSet: function(tree) {
      var specifiers = this.transformList(tree.specifiers);
      if (specifiers === tree.specifiers) {
        return tree;
      }
      return new ImportSpecifierSet(tree.location, specifiers);
    },
    transformLabelledStatement: function(tree) {
      var statement = this.transformAny(tree.statement);
      if (statement === tree.statement) {
        return tree;
      }
      return new LabelledStatement(tree.location, tree.name, statement);
    },
    transformLiteralExpression: function(tree) {
      return tree;
    },
    transformLiteralPropertyName: function(tree) {
      return tree;
    },
    transformMemberExpression: function(tree) {
      var operand = this.transformAny(tree.operand);
      if (operand === tree.operand) {
        return tree;
      }
      return new MemberExpression(tree.location, operand, tree.memberName);
    },
    transformMemberLookupExpression: function(tree) {
      var operand = this.transformAny(tree.operand);
      var memberExpression = this.transformAny(tree.memberExpression);
      if (operand === tree.operand && memberExpression === tree.memberExpression) {
        return tree;
      }
      return new MemberLookupExpression(tree.location, operand, memberExpression);
    },
    transformModule: function(tree) {
      var scriptItemList = this.transformList(tree.scriptItemList);
      if (scriptItemList === tree.scriptItemList) {
        return tree;
      }
      return new Module(tree.location, scriptItemList, tree.moduleName);
    },
    transformModuleDeclaration: function(tree) {
      var expression = this.transformAny(tree.expression);
      if (expression === tree.expression) {
        return tree;
      }
      return new ModuleDeclaration(tree.location, tree.identifier, expression);
    },
    transformModuleSpecifier: function(tree) {
      return tree;
    },
    transformNamedExport: function(tree) {
      var moduleSpecifier = this.transformAny(tree.moduleSpecifier);
      var specifierSet = this.transformAny(tree.specifierSet);
      if (moduleSpecifier === tree.moduleSpecifier && specifierSet === tree.specifierSet) {
        return tree;
      }
      return new NamedExport(tree.location, moduleSpecifier, specifierSet);
    },
    transformNewExpression: function(tree) {
      var operand = this.transformAny(tree.operand);
      var args = this.transformAny(tree.args);
      if (operand === tree.operand && args === tree.args) {
        return tree;
      }
      return new NewExpression(tree.location, operand, args);
    },
    transformObjectLiteralExpression: function(tree) {
      var propertyNameAndValues = this.transformList(tree.propertyNameAndValues);
      if (propertyNameAndValues === tree.propertyNameAndValues) {
        return tree;
      }
      return new ObjectLiteralExpression(tree.location, propertyNameAndValues);
    },
    transformObjectPattern: function(tree) {
      var fields = this.transformList(tree.fields);
      if (fields === tree.fields) {
        return tree;
      }
      return new ObjectPattern(tree.location, fields);
    },
    transformObjectPatternField: function(tree) {
      var name = this.transformAny(tree.name);
      var element = this.transformAny(tree.element);
      if (name === tree.name && element === tree.element) {
        return tree;
      }
      return new ObjectPatternField(tree.location, name, element);
    },
    transformParenExpression: function(tree) {
      var expression = this.transformAny(tree.expression);
      if (expression === tree.expression) {
        return tree;
      }
      return new ParenExpression(tree.location, expression);
    },
    transformPostfixExpression: function(tree) {
      var operand = this.transformAny(tree.operand);
      if (operand === tree.operand) {
        return tree;
      }
      return new PostfixExpression(tree.location, operand, tree.operator);
    },
    transformPredefinedType: function(tree) {
      return tree;
    },
    transformScript: function(tree) {
      var scriptItemList = this.transformList(tree.scriptItemList);
      if (scriptItemList === tree.scriptItemList) {
        return tree;
      }
      return new Script(tree.location, scriptItemList, tree.moduleName);
    },
    transformPropertyMethodAssignment: function(tree) {
      var name = this.transformAny(tree.name);
      var formalParameterList = this.transformAny(tree.formalParameterList);
      var typeAnnotation = this.transformAny(tree.typeAnnotation);
      var annotations = this.transformList(tree.annotations);
      var functionBody = this.transformAny(tree.functionBody);
      if (name === tree.name && formalParameterList === tree.formalParameterList && typeAnnotation === tree.typeAnnotation && annotations === tree.annotations && functionBody === tree.functionBody) {
        return tree;
      }
      return new PropertyMethodAssignment(tree.location, tree.isStatic, tree.isGenerator, name, formalParameterList, typeAnnotation, annotations, functionBody);
    },
    transformPropertyNameAssignment: function(tree) {
      var name = this.transformAny(tree.name);
      var value = this.transformAny(tree.value);
      if (name === tree.name && value === tree.value) {
        return tree;
      }
      return new PropertyNameAssignment(tree.location, name, value);
    },
    transformPropertyNameShorthand: function(tree) {
      return tree;
    },
    transformRestParameter: function(tree) {
      var identifier = this.transformAny(tree.identifier);
      if (identifier === tree.identifier) {
        return tree;
      }
      return new RestParameter(tree.location, identifier);
    },
    transformReturnStatement: function(tree) {
      var expression = this.transformAny(tree.expression);
      if (expression === tree.expression) {
        return tree;
      }
      return new ReturnStatement(tree.location, expression);
    },
    transformSetAccessor: function(tree) {
      var name = this.transformAny(tree.name);
      var parameter = this.transformAny(tree.parameter);
      var annotations = this.transformList(tree.annotations);
      var body = this.transformAny(tree.body);
      if (name === tree.name && parameter === tree.parameter && annotations === tree.annotations && body === tree.body) {
        return tree;
      }
      return new SetAccessor(tree.location, tree.isStatic, name, parameter, annotations, body);
    },
    transformSpreadExpression: function(tree) {
      var expression = this.transformAny(tree.expression);
      if (expression === tree.expression) {
        return tree;
      }
      return new SpreadExpression(tree.location, expression);
    },
    transformSpreadPatternElement: function(tree) {
      var lvalue = this.transformAny(tree.lvalue);
      if (lvalue === tree.lvalue) {
        return tree;
      }
      return new SpreadPatternElement(tree.location, lvalue);
    },
    transformSuperExpression: function(tree) {
      return tree;
    },
    transformSwitchStatement: function(tree) {
      var expression = this.transformAny(tree.expression);
      var caseClauses = this.transformList(tree.caseClauses);
      if (expression === tree.expression && caseClauses === tree.caseClauses) {
        return tree;
      }
      return new SwitchStatement(tree.location, expression, caseClauses);
    },
    transformSyntaxErrorTree: function(tree) {
      return tree;
    },
    transformTemplateLiteralExpression: function(tree) {
      var operand = this.transformAny(tree.operand);
      var elements = this.transformList(tree.elements);
      if (operand === tree.operand && elements === tree.elements) {
        return tree;
      }
      return new TemplateLiteralExpression(tree.location, operand, elements);
    },
    transformTemplateLiteralPortion: function(tree) {
      return tree;
    },
    transformTemplateSubstitution: function(tree) {
      var expression = this.transformAny(tree.expression);
      if (expression === tree.expression) {
        return tree;
      }
      return new TemplateSubstitution(tree.location, expression);
    },
    transformThisExpression: function(tree) {
      return tree;
    },
    transformThrowStatement: function(tree) {
      var value = this.transformAny(tree.value);
      if (value === tree.value) {
        return tree;
      }
      return new ThrowStatement(tree.location, value);
    },
    transformTryStatement: function(tree) {
      var body = this.transformAny(tree.body);
      var catchBlock = this.transformAny(tree.catchBlock);
      var finallyBlock = this.transformAny(tree.finallyBlock);
      if (body === tree.body && catchBlock === tree.catchBlock && finallyBlock === tree.finallyBlock) {
        return tree;
      }
      return new TryStatement(tree.location, body, catchBlock, finallyBlock);
    },
    transformTypeName: function(tree) {
      var moduleName = this.transformAny(tree.moduleName);
      if (moduleName === tree.moduleName) {
        return tree;
      }
      return new TypeName(tree.location, moduleName, tree.name);
    },
    transformUnaryExpression: function(tree) {
      var operand = this.transformAny(tree.operand);
      if (operand === tree.operand) {
        return tree;
      }
      return new UnaryExpression(tree.location, tree.operator, operand);
    },
    transformVariableDeclaration: function(tree) {
      var lvalue = this.transformAny(tree.lvalue);
      var typeAnnotation = this.transformAny(tree.typeAnnotation);
      var initialiser = this.transformAny(tree.initialiser);
      if (lvalue === tree.lvalue && typeAnnotation === tree.typeAnnotation && initialiser === tree.initialiser) {
        return tree;
      }
      return new VariableDeclaration(tree.location, lvalue, typeAnnotation, initialiser);
    },
    transformVariableDeclarationList: function(tree) {
      var declarations = this.transformList(tree.declarations);
      if (declarations === tree.declarations) {
        return tree;
      }
      return new VariableDeclarationList(tree.location, tree.declarationType, declarations);
    },
    transformVariableStatement: function(tree) {
      var declarations = this.transformAny(tree.declarations);
      if (declarations === tree.declarations) {
        return tree;
      }
      return new VariableStatement(tree.location, declarations);
    },
    transformWhileStatement: function(tree) {
      var condition = this.transformAny(tree.condition);
      var body = this.transformAny(tree.body);
      if (condition === tree.condition && body === tree.body) {
        return tree;
      }
      return new WhileStatement(tree.location, condition, body);
    },
    transformWithStatement: function(tree) {
      var expression = this.transformAny(tree.expression);
      var body = this.transformAny(tree.body);
      if (expression === tree.expression && body === tree.body) {
        return tree;
      }
      return new WithStatement(tree.location, expression, body);
    },
    transformYieldExpression: function(tree) {
      var expression = this.transformAny(tree.expression);
      if (expression === tree.expression) {
        return tree;
      }
      return new YieldExpression(tree.location, expression, tree.isYieldFor);
    }
  }, {});
  return {get ParseTreeTransformer() {
      return ParseTreeTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/AssignmentPatternTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/AssignmentPatternTransformer";
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var $__65 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      ArrayPattern = $__65.ArrayPattern,
      BindingElement = $__65.BindingElement,
      BindingIdentifier = $__65.BindingIdentifier,
      IdentifierExpression = $__65.IdentifierExpression,
      ObjectPattern = $__65.ObjectPattern,
      ObjectPatternField = $__65.ObjectPatternField,
      SpreadPatternElement = $__65.SpreadPatternElement;
  var EQUAL = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").EQUAL;
  var AssignmentPatternTransformerError = function AssignmentPatternTransformerError() {
    $traceurRuntime.defaultSuperCall(this, $AssignmentPatternTransformerError.prototype, arguments);
  };
  var $AssignmentPatternTransformerError = AssignmentPatternTransformerError;
  ($traceurRuntime.createClass)(AssignmentPatternTransformerError, {}, {}, Error);
  var AssignmentPatternTransformer = function AssignmentPatternTransformer() {
    $traceurRuntime.defaultSuperCall(this, $AssignmentPatternTransformer.prototype, arguments);
  };
  var $AssignmentPatternTransformer = AssignmentPatternTransformer;
  ($traceurRuntime.createClass)(AssignmentPatternTransformer, {
    transformBinaryOperator: function(tree) {
      if (tree.operator.type !== EQUAL) throw new AssignmentPatternTransformerError();
      var bindingElement = this.transformAny(tree.left);
      if (bindingElement instanceof BindingElement) bindingElement = bindingElement.binding;
      return new BindingElement(tree.location, bindingElement, tree.right);
    },
    transformArrayLiteralExpression: function(tree) {
      var elements = this.transformList(tree.elements);
      return new ArrayPattern(tree.location, elements);
    },
    transformCoverInitialisedName: function(tree) {
      return new BindingElement(tree.location, new BindingIdentifier(tree.name.location, tree.name), this.transformAny(tree.initialiser));
    },
    transformObjectLiteralExpression: function(tree) {
      var propertyNameAndValues = this.transformList(tree.propertyNameAndValues);
      return new ObjectPattern(tree.location, propertyNameAndValues);
    },
    transformPropertyNameAssignment: function(tree) {
      return new ObjectPatternField(tree.location, tree.name, this.transformAny(tree.value));
    },
    transformPropertyNameShorthand: function(tree) {
      return new IdentifierExpression(tree.location, tree.name);
    },
    transformSpreadExpression: function(tree) {
      return new SpreadPatternElement(tree.location, tree.expression);
    },
    transformSyntaxErrorTree: function(tree) {
      throw new AssignmentPatternTransformerError();
    }
  }, {}, ParseTreeTransformer);
  return {
    get AssignmentPatternTransformerError() {
      return AssignmentPatternTransformerError;
    },
    get AssignmentPatternTransformer() {
      return AssignmentPatternTransformer;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/CoverFormalsTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/CoverFormalsTransformer";
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var $__67 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      ArrayPattern = $__67.ArrayPattern,
      BindingElement = $__67.BindingElement,
      BindingIdentifier = $__67.BindingIdentifier,
      CommaExpression = $__67.CommaExpression,
      FormalParameter = $__67.FormalParameter,
      FormalParameterList = $__67.FormalParameterList,
      ObjectPattern = $__67.ObjectPattern,
      ObjectPatternField = $__67.ObjectPatternField,
      ParenExpression = $__67.ParenExpression,
      RestParameter = $__67.RestParameter,
      SpreadPatternElement = $__67.SpreadPatternElement;
  var EQUAL = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").EQUAL;
  var IDENTIFIER_EXPRESSION = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType").IDENTIFIER_EXPRESSION;
  var AssignmentPatternTransformerError = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/AssignmentPatternTransformer").AssignmentPatternTransformerError;
  var CoverFormalsTransformerError = function CoverFormalsTransformerError(location, message) {
    this.location = location;
    this.message = message;
  };
  ($traceurRuntime.createClass)(CoverFormalsTransformerError, {}, {}, Error);
  var ToFormalParametersTransformer = function ToFormalParametersTransformer() {
    this.isValid = true;
    this.inArrayPattern_ = false;
  };
  ($traceurRuntime.createClass)(ToFormalParametersTransformer, {
    transformCoverFormals: function(tree) {
      var expressions = this.transformList(tree.expressions).map((function(expression) {
        return new FormalParameter(expression.location, expression, null, []);
      }));
      return new FormalParameterList(tree.location, expressions);
    },
    transformIdentifierExpression: function(tree) {
      return new BindingElement(tree.location, new BindingIdentifier(tree.location, tree.identifierToken), null);
    },
    transformBinaryOperator: function(tree) {
      if (tree.operator.type !== EQUAL) throw new CoverFormalsTransformerError(tree.operator, ("Unexpected token " + tree.operator));
      var bindingElement = this.transformAny(tree.left);
      if (bindingElement instanceof BindingElement) bindingElement = bindingElement.binding;
      return new BindingElement(tree.location, bindingElement, tree.right);
    },
    transformArrayLiteralExpression: function(tree) {
      var wasInArrayPattern = this.inArrayPattern_;
      this.inArrayPattern_ = true;
      var elements = this.transformList(tree.elements);
      this.inArrayPattern_ = wasInArrayPattern;
      var okIndex = elements.length - 1;
      for (var i = 0; i < okIndex; i++) {
        if (elements[i]instanceof SpreadPatternElement) throw new CoverFormalsTransformerError(elements[i].location, 'Unexpected token ...');
      }
      return new BindingElement(tree.location, new ArrayPattern(tree.location, elements), null);
    },
    transformObjectLiteralExpression: function(tree) {
      var propertyNameAndValues = this.transformList(tree.propertyNameAndValues);
      return new BindingElement(tree.location, new ObjectPattern(tree.location, propertyNameAndValues), null);
    },
    transformCoverInitialisedName: function(tree) {
      return new BindingElement(tree.location, new BindingIdentifier(tree.location, tree.name), tree.initialiser);
    },
    transformPropertyNameAssignment: function(tree) {
      return new ObjectPatternField(tree.location, tree.name, this.transformAny(tree.value));
    },
    transformPropertyNameShorthand: function(tree) {
      return new BindingElement(tree.location, new BindingIdentifier(tree.location, tree.name), null);
    },
    transformSpreadExpression: function(tree) {
      if (tree.expression.type !== IDENTIFIER_EXPRESSION) throw new CoverFormalsTransformerError(tree.expression.location, 'identifier expected');
      var bindingIdentifier = new BindingIdentifier(tree.expression.location, tree.expression.identifierToken);
      if (this.inArrayPattern_) return new SpreadPatternElement(tree.location, bindingIdentifier);
      return new RestParameter(tree.location, bindingIdentifier);
    },
    transformSyntaxErrorTree: function(tree) {
      throw new AssignmentPatternTransformerError();
    }
  }, {}, ParseTreeTransformer);
  function toParenExpression(tree) {
    var expressions = tree.expressions;
    var length = expressions.length;
    if (length === 0) throw new CoverFormalsTransformerError(tree.location, 'Unexpected token )');
    for (var i = 0; i < length; i++) {
      if (expressions[i].isRestParameter()) throw new CoverFormalsTransformerError(expressions[i].location, 'Unexpected token ...');
    }
    var expression;
    if (expressions.length > 1) {
      expression = new CommaExpression(expressions[0].location, expressions);
    } else {
      expression = expressions[0];
    }
    return new ParenExpression(tree.location, expression);
  }
  function toFormalParameters(tree) {
    var transformer = new ToFormalParametersTransformer();
    return transformer.transformAny(tree);
  }
  return {
    get CoverFormalsTransformerError() {
      return CoverFormalsTransformerError;
    },
    get toParenExpression() {
      return toParenExpression;
    },
    get toFormalParameters() {
      return toFormalParameters;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/staticsemantics/StrictParams", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/staticsemantics/StrictParams";
  var ParseTreeVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/ParseTreeVisitor").ParseTreeVisitor;
  var isStrictKeyword = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Keywords").isStrictKeyword;
  var StrictParams = function StrictParams(errorReporter) {
    $traceurRuntime.superCall(this, $StrictParams.prototype, "constructor", []);
    this.errorReporter = errorReporter;
  };
  var $StrictParams = StrictParams;
  ($traceurRuntime.createClass)(StrictParams, {visitBindingIdentifier: function(tree) {
      var name = tree.identifierToken.toString();
      if (isStrictKeyword(name)) {
        this.errorReporter.reportError(tree.location.start, (name + " is a reserved identifier"));
      }
    }}, {visit: function(tree, errorReporter) {
      new $StrictParams(errorReporter).visitAny(tree);
    }}, ParseTreeVisitor);
  return {get StrictParams() {
      return StrictParams;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/util/SourceRange", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/util/SourceRange";
  var SourceRange = function SourceRange(start, end) {
    this.start = start;
    this.end = end;
  };
  ($traceurRuntime.createClass)(SourceRange, {}, {});
  return {get SourceRange() {
      return SourceRange;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/util/ErrorReporter", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/util/ErrorReporter";
  var ErrorReporter = function ErrorReporter() {
    this.hadError_ = false;
  };
  ($traceurRuntime.createClass)(ErrorReporter, {
    reportError: function(location, format) {
      for (var args = [],
          $__72 = 2; $__72 < arguments.length; $__72++) args[$__72 - 2] = arguments[$__72];
      this.hadError_ = true;
      this.reportMessageInternal(location, format, args);
    },
    reportMessageInternal: function(location, format, args) {
      var $__73;
      if (location) format = (location + ": " + format);
      ($__73 = console).error.apply($__73, $traceurRuntime.spread([format], args));
    },
    hadError: function() {
      return this.hadError_;
    },
    clearError: function() {
      this.hadError_ = false;
    }
  }, {});
  function format(location, text) {
    var args = arguments[2];
    var i = 0;
    text = text.replace(/%./g, function(s) {
      switch (s) {
        case '%s':
          return args && args[i++];
        case '%%':
          return '%';
      }
      return s;
    });
    if (location) text = (location + ": " + text);
    return text;
  }
  ;
  ErrorReporter.format = format;
  return {
    get ErrorReporter() {
      return ErrorReporter;
    },
    get format() {
      return format;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/util/SyntaxErrorReporter", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/util/SyntaxErrorReporter";
  var format = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/ErrorReporter").format;
  var SyntaxErrorReporter = function SyntaxErrorReporter() {};
  ($traceurRuntime.createClass)(SyntaxErrorReporter, {reportError: function(location, message) {
      for (var args = [],
          $__75 = 2; $__75 < arguments.length; $__75++) args[$__75 - 2] = arguments[$__75];
      var s = format.apply(null, $traceurRuntime.spread([location, message], args));
      throw new SyntaxError(s);
    }}, {});
  return {get SyntaxErrorReporter() {
      return SyntaxErrorReporter;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/KeywordToken", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/KeywordToken";
  var STRICT_KEYWORD = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Keywords").STRICT_KEYWORD;
  var Token = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Token").Token;
  var KeywordToken = function KeywordToken(type, keywordType, location) {
    this.type = type;
    this.location = location;
    this.isStrictKeyword_ = keywordType === STRICT_KEYWORD;
  };
  ($traceurRuntime.createClass)(KeywordToken, {
    isKeyword: function() {
      return true;
    },
    isStrictKeyword: function() {
      return this.isStrictKeyword_;
    }
  }, {}, Token);
  return {get KeywordToken() {
      return KeywordToken;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/unicode-tables", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/unicode-tables";
  var idStartTable = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 442, 443, 443, 444, 447, 448, 451, 452, 659, 660, 660, 661, 687, 688, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 883, 884, 884, 886, 887, 890, 890, 891, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1599, 1600, 1600, 1601, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2417, 2418, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3653, 3654, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4348, 4349, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6210, 6211, 6211, 6212, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7287, 7288, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7467, 7468, 7530, 7531, 7543, 7544, 7544, 7545, 7578, 7579, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8472, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8494, 8494, 8495, 8500, 8501, 8504, 8505, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8578, 8579, 8580, 8581, 8584, 11264, 11310, 11312, 11358, 11360, 11387, 11388, 11389, 11390, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 12293, 12293, 12294, 12294, 12295, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12347, 12347, 12348, 12348, 12353, 12438, 12443, 12444, 12445, 12446, 12447, 12447, 12449, 12538, 12540, 12542, 12543, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 40980, 40981, 40981, 40982, 42124, 42192, 42231, 42232, 42237, 42240, 42507, 42508, 42508, 42512, 42527, 42538, 42539, 42560, 42605, 42606, 42606, 42623, 42623, 42624, 42647, 42656, 42725, 42726, 42735, 42775, 42783, 42786, 42863, 42864, 42864, 42865, 42887, 42888, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43001, 43002, 43002, 43003, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43631, 43632, 43632, 43633, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43740, 43741, 43741, 43744, 43754, 43762, 43762, 43763, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65391, 65392, 65392, 65393, 65437, 65438, 65439, 65440, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66176, 66204, 66208, 66256, 66304, 66334, 66352, 66368, 66369, 66369, 66370, 66377, 66378, 66378, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66639, 66640, 66717, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68096, 68112, 68115, 68117, 68119, 68121, 68147, 68192, 68220, 68352, 68405, 68416, 68437, 68448, 68466, 68608, 68680, 69635, 69687, 69763, 69807, 69840, 69864, 69891, 69926, 70019, 70066, 70081, 70084, 71296, 71338, 73728, 74606, 74752, 74850, 77824, 78894, 92160, 92728, 93952, 94020, 94032, 94032, 94099, 94111, 110592, 110593, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173782, 173824, 177972, 177984, 178205, 194560, 195101];
  var idContinueTable = [183, 183, 768, 879, 903, 903, 1155, 1159, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1552, 1562, 1611, 1631, 1632, 1641, 1648, 1648, 1750, 1756, 1759, 1764, 1767, 1768, 1770, 1773, 1776, 1785, 1809, 1809, 1840, 1866, 1958, 1968, 1984, 1993, 2027, 2035, 2070, 2073, 2075, 2083, 2085, 2087, 2089, 2093, 2137, 2139, 2276, 2302, 2304, 2306, 2307, 2307, 2362, 2362, 2363, 2363, 2364, 2364, 2366, 2368, 2369, 2376, 2377, 2380, 2381, 2381, 2382, 2383, 2385, 2391, 2402, 2403, 2406, 2415, 2433, 2433, 2434, 2435, 2492, 2492, 2494, 2496, 2497, 2500, 2503, 2504, 2507, 2508, 2509, 2509, 2519, 2519, 2530, 2531, 2534, 2543, 2561, 2562, 2563, 2563, 2620, 2620, 2622, 2624, 2625, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2662, 2671, 2672, 2673, 2677, 2677, 2689, 2690, 2691, 2691, 2748, 2748, 2750, 2752, 2753, 2757, 2759, 2760, 2761, 2761, 2763, 2764, 2765, 2765, 2786, 2787, 2790, 2799, 2817, 2817, 2818, 2819, 2876, 2876, 2878, 2878, 2879, 2879, 2880, 2880, 2881, 2884, 2887, 2888, 2891, 2892, 2893, 2893, 2902, 2902, 2903, 2903, 2914, 2915, 2918, 2927, 2946, 2946, 3006, 3007, 3008, 3008, 3009, 3010, 3014, 3016, 3018, 3020, 3021, 3021, 3031, 3031, 3046, 3055, 3073, 3075, 3134, 3136, 3137, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3170, 3171, 3174, 3183, 3202, 3203, 3260, 3260, 3262, 3262, 3263, 3263, 3264, 3268, 3270, 3270, 3271, 3272, 3274, 3275, 3276, 3277, 3285, 3286, 3298, 3299, 3302, 3311, 3330, 3331, 3390, 3392, 3393, 3396, 3398, 3400, 3402, 3404, 3405, 3405, 3415, 3415, 3426, 3427, 3430, 3439, 3458, 3459, 3530, 3530, 3535, 3537, 3538, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3633, 3633, 3636, 3642, 3655, 3662, 3664, 3673, 3761, 3761, 3764, 3769, 3771, 3772, 3784, 3789, 3792, 3801, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3903, 3953, 3966, 3967, 3967, 3968, 3972, 3974, 3975, 3981, 3991, 3993, 4028, 4038, 4038, 4139, 4140, 4141, 4144, 4145, 4145, 4146, 4151, 4152, 4152, 4153, 4154, 4155, 4156, 4157, 4158, 4160, 4169, 4182, 4183, 4184, 4185, 4190, 4192, 4194, 4196, 4199, 4205, 4209, 4212, 4226, 4226, 4227, 4228, 4229, 4230, 4231, 4236, 4237, 4237, 4239, 4239, 4240, 4249, 4250, 4252, 4253, 4253, 4957, 4959, 4969, 4977, 5906, 5908, 5938, 5940, 5970, 5971, 6002, 6003, 6068, 6069, 6070, 6070, 6071, 6077, 6078, 6085, 6086, 6086, 6087, 6088, 6089, 6099, 6109, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6313, 6313, 6432, 6434, 6435, 6438, 6439, 6440, 6441, 6443, 6448, 6449, 6450, 6450, 6451, 6456, 6457, 6459, 6470, 6479, 6576, 6592, 6600, 6601, 6608, 6617, 6618, 6618, 6679, 6680, 6681, 6683, 6741, 6741, 6742, 6742, 6743, 6743, 6744, 6750, 6752, 6752, 6753, 6753, 6754, 6754, 6755, 6756, 6757, 6764, 6765, 6770, 6771, 6780, 6783, 6783, 6784, 6793, 6800, 6809, 6912, 6915, 6916, 6916, 6964, 6964, 6965, 6965, 6966, 6970, 6971, 6971, 6972, 6972, 6973, 6977, 6978, 6978, 6979, 6980, 6992, 7001, 7019, 7027, 7040, 7041, 7042, 7042, 7073, 7073, 7074, 7077, 7078, 7079, 7080, 7081, 7082, 7082, 7083, 7083, 7084, 7085, 7088, 7097, 7142, 7142, 7143, 7143, 7144, 7145, 7146, 7148, 7149, 7149, 7150, 7150, 7151, 7153, 7154, 7155, 7204, 7211, 7212, 7219, 7220, 7221, 7222, 7223, 7232, 7241, 7248, 7257, 7376, 7378, 7380, 7392, 7393, 7393, 7394, 7400, 7405, 7405, 7410, 7411, 7412, 7412, 7616, 7654, 7676, 7679, 8255, 8256, 8276, 8276, 8400, 8412, 8417, 8417, 8421, 8432, 11503, 11505, 11647, 11647, 11744, 11775, 12330, 12333, 12334, 12335, 12441, 12442, 42528, 42537, 42607, 42607, 42612, 42621, 42655, 42655, 42736, 42737, 43010, 43010, 43014, 43014, 43019, 43019, 43043, 43044, 43045, 43046, 43047, 43047, 43136, 43137, 43188, 43203, 43204, 43204, 43216, 43225, 43232, 43249, 43264, 43273, 43302, 43309, 43335, 43345, 43346, 43347, 43392, 43394, 43395, 43395, 43443, 43443, 43444, 43445, 43446, 43449, 43450, 43451, 43452, 43452, 43453, 43456, 43472, 43481, 43561, 43566, 43567, 43568, 43569, 43570, 43571, 43572, 43573, 43574, 43587, 43587, 43596, 43596, 43597, 43597, 43600, 43609, 43643, 43643, 43696, 43696, 43698, 43700, 43703, 43704, 43710, 43711, 43713, 43713, 43755, 43755, 43756, 43757, 43758, 43759, 43765, 43765, 43766, 43766, 44003, 44004, 44005, 44005, 44006, 44007, 44008, 44008, 44009, 44010, 44012, 44012, 44013, 44013, 44016, 44025, 64286, 64286, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65296, 65305, 65343, 65343, 66045, 66045, 66720, 66729, 68097, 68099, 68101, 68102, 68108, 68111, 68152, 68154, 68159, 68159, 69632, 69632, 69633, 69633, 69634, 69634, 69688, 69702, 69734, 69743, 69760, 69761, 69762, 69762, 69808, 69810, 69811, 69814, 69815, 69816, 69817, 69818, 69872, 69881, 69888, 69890, 69927, 69931, 69932, 69932, 69933, 69940, 69942, 69951, 70016, 70017, 70018, 70018, 70067, 70069, 70070, 70078, 70079, 70080, 70096, 70105, 71339, 71339, 71340, 71340, 71341, 71341, 71342, 71343, 71344, 71349, 71350, 71350, 71351, 71351, 71360, 71369, 94033, 94078, 94095, 94098, 119141, 119142, 119143, 119145, 119149, 119154, 119163, 119170, 119173, 119179, 119210, 119213, 119362, 119364, 120782, 120831, 917760, 917999];
  return {
    get idStartTable() {
      return idStartTable;
    },
    get idContinueTable() {
      return idContinueTable;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/Scanner", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/Scanner";
  var IdentifierToken = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/IdentifierToken").IdentifierToken;
  var KeywordToken = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/KeywordToken").KeywordToken;
  var LiteralToken = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/LiteralToken").LiteralToken;
  var Token = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Token").Token;
  var getKeywordType = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Keywords").getKeywordType;
  var $__80 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/unicode-tables"),
      idContinueTable = $__80.idContinueTable,
      idStartTable = $__80.idStartTable;
  var parseOptions = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/options").parseOptions;
  var $__80 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      AMPERSAND = $__80.AMPERSAND,
      AMPERSAND_EQUAL = $__80.AMPERSAND_EQUAL,
      AND = $__80.AND,
      ARROW = $__80.ARROW,
      AT = $__80.AT,
      AWAIT = $__80.AWAIT,
      BACK_QUOTE = $__80.BACK_QUOTE,
      BANG = $__80.BANG,
      BAR = $__80.BAR,
      BAR_EQUAL = $__80.BAR_EQUAL,
      BREAK = $__80.BREAK,
      CARET = $__80.CARET,
      CARET_EQUAL = $__80.CARET_EQUAL,
      CASE = $__80.CASE,
      CATCH = $__80.CATCH,
      CLASS = $__80.CLASS,
      CLOSE_ANGLE = $__80.CLOSE_ANGLE,
      CLOSE_CURLY = $__80.CLOSE_CURLY,
      CLOSE_PAREN = $__80.CLOSE_PAREN,
      CLOSE_SQUARE = $__80.CLOSE_SQUARE,
      COLON = $__80.COLON,
      COMMA = $__80.COMMA,
      CONST = $__80.CONST,
      CONTINUE = $__80.CONTINUE,
      DEBUGGER = $__80.DEBUGGER,
      DEFAULT = $__80.DEFAULT,
      DELETE = $__80.DELETE,
      DO = $__80.DO,
      DOT_DOT_DOT = $__80.DOT_DOT_DOT,
      ELSE = $__80.ELSE,
      END_OF_FILE = $__80.END_OF_FILE,
      ENUM = $__80.ENUM,
      EQUAL = $__80.EQUAL,
      EQUAL_EQUAL = $__80.EQUAL_EQUAL,
      EQUAL_EQUAL_EQUAL = $__80.EQUAL_EQUAL_EQUAL,
      ERROR = $__80.ERROR,
      EXPORT = $__80.EXPORT,
      EXTENDS = $__80.EXTENDS,
      FALSE = $__80.FALSE,
      FINALLY = $__80.FINALLY,
      FOR = $__80.FOR,
      FUNCTION = $__80.FUNCTION,
      GREATER_EQUAL = $__80.GREATER_EQUAL,
      IDENTIFIER = $__80.IDENTIFIER,
      IF = $__80.IF,
      IMPLEMENTS = $__80.IMPLEMENTS,
      IMPORT = $__80.IMPORT,
      IN = $__80.IN,
      INSTANCEOF = $__80.INSTANCEOF,
      INTERFACE = $__80.INTERFACE,
      LEFT_SHIFT = $__80.LEFT_SHIFT,
      LEFT_SHIFT_EQUAL = $__80.LEFT_SHIFT_EQUAL,
      LESS_EQUAL = $__80.LESS_EQUAL,
      LET = $__80.LET,
      MINUS = $__80.MINUS,
      MINUS_EQUAL = $__80.MINUS_EQUAL,
      MINUS_MINUS = $__80.MINUS_MINUS,
      NEW = $__80.NEW,
      NO_SUBSTITUTION_TEMPLATE = $__80.NO_SUBSTITUTION_TEMPLATE,
      NOT_EQUAL = $__80.NOT_EQUAL,
      NOT_EQUAL_EQUAL = $__80.NOT_EQUAL_EQUAL,
      NULL = $__80.NULL,
      NUMBER = $__80.NUMBER,
      OPEN_ANGLE = $__80.OPEN_ANGLE,
      OPEN_CURLY = $__80.OPEN_CURLY,
      OPEN_PAREN = $__80.OPEN_PAREN,
      OPEN_SQUARE = $__80.OPEN_SQUARE,
      OR = $__80.OR,
      PACKAGE = $__80.PACKAGE,
      PERCENT = $__80.PERCENT,
      PERCENT_EQUAL = $__80.PERCENT_EQUAL,
      PERIOD = $__80.PERIOD,
      PLUS = $__80.PLUS,
      PLUS_EQUAL = $__80.PLUS_EQUAL,
      PLUS_PLUS = $__80.PLUS_PLUS,
      PRIVATE = $__80.PRIVATE,
      PROTECTED = $__80.PROTECTED,
      PUBLIC = $__80.PUBLIC,
      QUESTION = $__80.QUESTION,
      REGULAR_EXPRESSION = $__80.REGULAR_EXPRESSION,
      RETURN = $__80.RETURN,
      RIGHT_SHIFT = $__80.RIGHT_SHIFT,
      RIGHT_SHIFT_EQUAL = $__80.RIGHT_SHIFT_EQUAL,
      SEMI_COLON = $__80.SEMI_COLON,
      SLASH = $__80.SLASH,
      SLASH_EQUAL = $__80.SLASH_EQUAL,
      STAR = $__80.STAR,
      STAR_EQUAL = $__80.STAR_EQUAL,
      STATIC = $__80.STATIC,
      STRING = $__80.STRING,
      SUPER = $__80.SUPER,
      SWITCH = $__80.SWITCH,
      TEMPLATE_HEAD = $__80.TEMPLATE_HEAD,
      TEMPLATE_MIDDLE = $__80.TEMPLATE_MIDDLE,
      TEMPLATE_TAIL = $__80.TEMPLATE_TAIL,
      THIS = $__80.THIS,
      THROW = $__80.THROW,
      TILDE = $__80.TILDE,
      TRUE = $__80.TRUE,
      TRY = $__80.TRY,
      TYPEOF = $__80.TYPEOF,
      UNSIGNED_RIGHT_SHIFT = $__80.UNSIGNED_RIGHT_SHIFT,
      UNSIGNED_RIGHT_SHIFT_EQUAL = $__80.UNSIGNED_RIGHT_SHIFT_EQUAL,
      VAR = $__80.VAR,
      VOID = $__80.VOID,
      WHILE = $__80.WHILE,
      WITH = $__80.WITH,
      YIELD = $__80.YIELD;
  var isWhitespaceArray = [];
  for (var i = 0; i < 128; i++) {
    isWhitespaceArray[i] = i >= 9 && i <= 13 || i === 0x20;
  }
  var isWhitespaceArray = [];
  for (var i = 0; i < 128; i++) {
    isWhitespaceArray[i] = i >= 9 && i <= 13 || i === 0x20;
  }
  function isWhitespace(code) {
    if (code < 128) return isWhitespaceArray[code];
    switch (code) {
      case 0xA0:
      case 0xFEFF:
      case 0x2028:
      case 0x2029:
        return true;
    }
    return false;
  }
  function isLineTerminator(code) {
    switch (code) {
      case 10:
      case 13:
      case 0x2028:
      case 0x2029:
        return true;
    }
    return false;
  }
  function isDecimalDigit(code) {
    return code >= 48 && code <= 57;
  }
  var isHexDigitArray = [];
  for (var i = 0; i < 128; i++) {
    isHexDigitArray[i] = i >= 48 && i <= 57 || i >= 65 && i <= 70 || i >= 97 && i <= 102;
  }
  function isHexDigit(code) {
    return code < 128 && isHexDigitArray[code];
  }
  function isBinaryDigit(code) {
    return code === 48 || code === 49;
  }
  function isOctalDigit(code) {
    return code >= 48 && code <= 55;
  }
  var isIdentifierStartArray = [];
  for (var i = 0; i < 128; i++) {
    isIdentifierStartArray[i] = i === 36 || i >= 65 && i <= 90 || i === 95 || i >= 97 && i <= 122;
  }
  function isIdentifierStart(code) {
    return code < 128 ? isIdentifierStartArray[code]: inTable(idStartTable, code);
  }
  var isIdentifierPartArray = [];
  for (var i = 0; i < 128; i++) {
    isIdentifierPartArray[i] = isIdentifierStart(i) || isDecimalDigit(i);
  }
  function isIdentifierPart(code) {
    return code < 128 ? isIdentifierPartArray[code]: inTable(idStartTable, code) || inTable(idContinueTable, code) || code === 8204 || code === 8205;
  }
  function inTable(table, code) {
    for (var i = 0; i < table.length;) {
      if (code < table[i++]) return false;
      if (code <= table[i++]) return true;
    }
    return false;
  }
  function isRegularExpressionChar(code) {
    switch (code) {
      case 47:
        return false;
      case 91:
      case 92:
        return true;
    }
    return !isLineTerminator(code);
  }
  function isRegularExpressionFirstChar(code) {
    return isRegularExpressionChar(code) && code !== 42;
  }
  var index,
      input,
      length,
      token,
      lastToken,
      lookaheadToken,
      currentCharCode,
      lineNumberTable,
      errorReporter,
      currentParser;
  var Scanner = function Scanner(reporter, file, parser) {
    errorReporter = reporter;
    lineNumberTable = file.lineNumberTable;
    input = file.contents;
    length = file.contents.length;
    index = 0;
    lastToken = null;
    token = null;
    lookaheadToken = null;
    updateCurrentCharCode();
    currentParser = parser;
  };
  ($traceurRuntime.createClass)(Scanner, {
    get lastToken() {
      return lastToken;
    },
    getPosition: function() {
      return getPosition(getOffset());
    },
    nextRegularExpressionLiteralToken: function() {
      lastToken = nextRegularExpressionLiteralToken();
      token = scanToken();
      return lastToken;
    },
    nextTemplateLiteralToken: function() {
      var t = nextTemplateLiteralToken();
      token = scanToken();
      return t;
    },
    nextToken: function() {
      return nextToken();
    },
    peekToken: function(opt_index) {
      return opt_index ? peekTokenLookahead(): peekToken();
    },
    peekTokenNoLineTerminator: function() {
      return peekTokenNoLineTerminator();
    },
    isAtEnd: function() {
      return isAtEnd();
    }
  }, {});
  function getPosition(offset) {
    return lineNumberTable.getSourcePosition(offset);
  }
  function getTokenRange(startOffset) {
    return lineNumberTable.getSourceRange(startOffset, index);
  }
  function getOffset() {
    return token ? token.location.start.offset: index;
  }
  function nextRegularExpressionLiteralToken() {
    var beginIndex = index - token.toString().length;
    if (!skipRegularExpressionBody()) {
      return new LiteralToken(REGULAR_EXPRESSION, getTokenString(beginIndex), getTokenRange(beginIndex));
    }
    if (currentCharCode !== 47) {
      reportError('Expected \'/\' in regular expression literal');
      return new LiteralToken(REGULAR_EXPRESSION, getTokenString(beginIndex), getTokenRange(beginIndex));
    }
    next();
    while (isIdentifierPart(currentCharCode)) {
      next();
    }
    return new LiteralToken(REGULAR_EXPRESSION, getTokenString(beginIndex), getTokenRange(beginIndex));
  }
  function skipRegularExpressionBody() {
    if (!isRegularExpressionFirstChar(currentCharCode)) {
      reportError('Expected regular expression first char');
      return false;
    }
    while (!isAtEnd() && isRegularExpressionChar(currentCharCode)) {
      if (!skipRegularExpressionChar()) return false;
    }
    return true;
  }
  function skipRegularExpressionChar() {
    switch (currentCharCode) {
      case 92:
        return skipRegularExpressionBackslashSequence();
      case 91:
        return skipRegularExpressionClass();
      default:
        next();
        return true;
    }
  }
  function skipRegularExpressionBackslashSequence() {
    next();
    if (isLineTerminator(currentCharCode) || isAtEnd()) {
      reportError('New line not allowed in regular expression literal');
      return false;
    }
    next();
    return true;
  }
  function skipRegularExpressionClass() {
    next();
    while (!isAtEnd() && peekRegularExpressionClassChar()) {
      if (!skipRegularExpressionClassChar()) {
        return false;
      }
    }
    if (currentCharCode !== 93) {
      reportError('\']\' expected');
      return false;
    }
    next();
    return true;
  }
  function peekRegularExpressionClassChar() {
    return currentCharCode !== 93 && !isLineTerminator(currentCharCode);
  }
  function skipRegularExpressionClassChar() {
    if (currentCharCode === 92) {
      return skipRegularExpressionBackslashSequence();
    }
    next();
    return true;
  }
  function skipTemplateCharacter() {
    while (!isAtEnd()) {
      switch (currentCharCode) {
        case 96:
          return;
        case 92:
          skipStringLiteralEscapeSequence();
          break;
        case 36:
          var code = input.charCodeAt(index + 1);
          if (code === 123) return;
        default:
          next();
      }
    }
  }
  function scanTemplateStart(beginIndex) {
    if (isAtEnd()) {
      reportError('Unterminated template literal');
      return lastToken = createToken(END_OF_FILE, beginIndex);
    }
    return nextTemplateLiteralTokenShared(NO_SUBSTITUTION_TEMPLATE, TEMPLATE_HEAD);
  }
  function nextTemplateLiteralToken() {
    if (isAtEnd()) {
      reportError('Expected \'}\' after expression in template literal');
      return createToken(END_OF_FILE, index);
    }
    if (token.type !== CLOSE_CURLY) {
      reportError('Expected \'}\' after expression in template literal');
      return createToken(ERROR, index);
    }
    return nextTemplateLiteralTokenShared(TEMPLATE_TAIL, TEMPLATE_MIDDLE);
  }
  function nextTemplateLiteralTokenShared(endType, middleType) {
    var beginIndex = index;
    skipTemplateCharacter();
    if (isAtEnd()) {
      reportError('Unterminated template literal');
      return createToken(ERROR, beginIndex);
    }
    var value = getTokenString(beginIndex);
    switch (currentCharCode) {
      case 96:
        next();
        return lastToken = new LiteralToken(endType, value, getTokenRange(beginIndex - 1));
      case 36:
        next();
        next();
        return lastToken = new LiteralToken(middleType, value, getTokenRange(beginIndex - 1));
    }
  }
  function nextToken() {
    var t = peekToken();
    token = lookaheadToken || scanToken();
    lookaheadToken = null;
    lastToken = t;
    return t;
  }
  function peekTokenNoLineTerminator() {
    var t = peekToken();
    var start = lastToken.location.end.offset;
    var end = t.location.start.offset;
    for (var i = start; i < end; i++) {
      var code = input.charCodeAt(i);
      if (isLineTerminator(code)) return null;
      if (code === 47) {
        code = input.charCodeAt(++i);
        if (code === 47) return null;
        i = input.indexOf('*/', i) + 2;
      }
    }
    return t;
  }
  function peekToken() {
    return token || (token = scanToken());
  }
  function peekTokenLookahead() {
    if (!token) token = scanToken();
    if (!lookaheadToken) lookaheadToken = scanToken();
    return lookaheadToken;
  }
  function skipWhitespace() {
    while (!isAtEnd() && peekWhitespace()) {
      next();
    }
  }
  function peekWhitespace() {
    return isWhitespace(currentCharCode);
  }
  function skipComments() {
    while (skipComment()) {}
  }
  function skipComment() {
    skipWhitespace();
    var code = currentCharCode;
    if (code === 47) {
      code = input.charCodeAt(index + 1);
      switch (code) {
        case 47:
          skipSingleLineComment();
          return true;
        case 42:
          skipMultiLineComment();
          return true;
      }
    }
    return false;
  }
  function skipSingleLineComment() {
    index += 2;
    while (!isAtEnd() && !isLineTerminator(input.charCodeAt(index++))) {}
    updateCurrentCharCode();
  }
  function skipMultiLineComment() {
    var i = input.indexOf('*/', index + 2);
    if (i !== - 1) index = i + 2; else index = length;
    updateCurrentCharCode();
  }
  function scanToken() {
    skipComments();
    var beginIndex = index;
    if (isAtEnd()) return createToken(END_OF_FILE, beginIndex);
    var code = currentCharCode;
    next();
    switch (code) {
      case 123:
        return createToken(OPEN_CURLY, beginIndex);
      case 125:
        return createToken(CLOSE_CURLY, beginIndex);
      case 40:
        return createToken(OPEN_PAREN, beginIndex);
      case 41:
        return createToken(CLOSE_PAREN, beginIndex);
      case 91:
        return createToken(OPEN_SQUARE, beginIndex);
      case 93:
        return createToken(CLOSE_SQUARE, beginIndex);
      case 46:
        switch (currentCharCode) {
          case 46:
            if (input.charCodeAt(index + 1) === 46) {
              next();
              next();
              return createToken(DOT_DOT_DOT, beginIndex);
            }
            break;
          default:
            if (isDecimalDigit(currentCharCode)) return scanNumberPostPeriod(beginIndex);
        }
        return createToken(PERIOD, beginIndex);
      case 59:
        return createToken(SEMI_COLON, beginIndex);
      case 44:
        return createToken(COMMA, beginIndex);
      case 126:
        return createToken(TILDE, beginIndex);
      case 63:
        return createToken(QUESTION, beginIndex);
      case 58:
        return createToken(COLON, beginIndex);
      case 60:
        switch (currentCharCode) {
          case 60:
            next();
            if (currentCharCode === 61) {
              next();
              return createToken(LEFT_SHIFT_EQUAL, beginIndex);
            }
            return createToken(LEFT_SHIFT, beginIndex);
          case 61:
            next();
            return createToken(LESS_EQUAL, beginIndex);
          default:
            return createToken(OPEN_ANGLE, beginIndex);
        }
      case 62:
        switch (currentCharCode) {
          case 62:
            next();
            switch (currentCharCode) {
              case 61:
                next();
                return createToken(RIGHT_SHIFT_EQUAL, beginIndex);
              case 62:
                next();
                if (currentCharCode === 61) {
                  next();
                  return createToken(UNSIGNED_RIGHT_SHIFT_EQUAL, beginIndex);
                }
                return createToken(UNSIGNED_RIGHT_SHIFT, beginIndex);
              default:
                return createToken(RIGHT_SHIFT, beginIndex);
            }
          case 61:
            next();
            return createToken(GREATER_EQUAL, beginIndex);
          default:
            return createToken(CLOSE_ANGLE, beginIndex);
        }
      case 61:
        if (currentCharCode === 61) {
          next();
          if (currentCharCode === 61) {
            next();
            return createToken(EQUAL_EQUAL_EQUAL, beginIndex);
          }
          return createToken(EQUAL_EQUAL, beginIndex);
        }
        if (currentCharCode === 62) {
          next();
          return createToken(ARROW, beginIndex);
        }
        return createToken(EQUAL, beginIndex);
      case 33:
        if (currentCharCode === 61) {
          next();
          if (currentCharCode === 61) {
            next();
            return createToken(NOT_EQUAL_EQUAL, beginIndex);
          }
          return createToken(NOT_EQUAL, beginIndex);
        }
        return createToken(BANG, beginIndex);
      case 42:
        if (currentCharCode === 61) {
          next();
          return createToken(STAR_EQUAL, beginIndex);
        }
        return createToken(STAR, beginIndex);
      case 37:
        if (currentCharCode === 61) {
          next();
          return createToken(PERCENT_EQUAL, beginIndex);
        }
        return createToken(PERCENT, beginIndex);
      case 94:
        if (currentCharCode === 61) {
          next();
          return createToken(CARET_EQUAL, beginIndex);
        }
        return createToken(CARET, beginIndex);
      case 47:
        if (currentCharCode === 61) {
          next();
          return createToken(SLASH_EQUAL, beginIndex);
        }
        return createToken(SLASH, beginIndex);
      case 43:
        switch (currentCharCode) {
          case 43:
            next();
            return createToken(PLUS_PLUS, beginIndex);
          case 61:
            next();
            return createToken(PLUS_EQUAL, beginIndex);
          default:
            return createToken(PLUS, beginIndex);
        }
      case 45:
        switch (currentCharCode) {
          case 45:
            next();
            return createToken(MINUS_MINUS, beginIndex);
          case 61:
            next();
            return createToken(MINUS_EQUAL, beginIndex);
          default:
            return createToken(MINUS, beginIndex);
        }
      case 38:
        switch (currentCharCode) {
          case 38:
            next();
            return createToken(AND, beginIndex);
          case 61:
            next();
            return createToken(AMPERSAND_EQUAL, beginIndex);
          default:
            return createToken(AMPERSAND, beginIndex);
        }
      case 124:
        switch (currentCharCode) {
          case 124:
            next();
            return createToken(OR, beginIndex);
          case 61:
            next();
            return createToken(BAR_EQUAL, beginIndex);
          default:
            return createToken(BAR, beginIndex);
        }
      case 96:
        return scanTemplateStart(beginIndex);
      case 64:
        return createToken(AT, beginIndex);
      case 48:
        return scanPostZero(beginIndex);
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return scanPostDigit(beginIndex);
      case 34:
      case 39:
        return scanStringLiteral(beginIndex, code);
      default:
        return scanIdentifierOrKeyword(beginIndex, code);
    }
  }
  function scanNumberPostPeriod(beginIndex) {
    skipDecimalDigits();
    return scanExponentOfNumericLiteral(beginIndex);
  }
  function scanPostDigit(beginIndex) {
    skipDecimalDigits();
    return scanFractionalNumericLiteral(beginIndex);
  }
  function scanPostZero(beginIndex) {
    switch (currentCharCode) {
      case 46:
        return scanFractionalNumericLiteral(beginIndex);
      case 88:
      case 120:
        next();
        if (!isHexDigit(currentCharCode)) {
          reportError('Hex Integer Literal must contain at least one digit');
        }
        skipHexDigits();
        return new LiteralToken(NUMBER, getTokenString(beginIndex), getTokenRange(beginIndex));
      case 66:
      case 98:
        if (!parseOptions.numericLiterals) break;
        next();
        if (!isBinaryDigit(currentCharCode)) {
          reportError('Binary Integer Literal must contain at least one digit');
        }
        skipBinaryDigits();
        return new LiteralToken(NUMBER, getTokenString(beginIndex), getTokenRange(beginIndex));
      case 79:
      case 111:
        if (!parseOptions.numericLiterals) break;
        next();
        if (!isOctalDigit(currentCharCode)) {
          reportError('Octal Integer Literal must contain at least one digit');
        }
        skipOctalDigits();
        return new LiteralToken(NUMBER, getTokenString(beginIndex), getTokenRange(beginIndex));
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return scanPostDigit(beginIndex);
    }
    return new LiteralToken(NUMBER, getTokenString(beginIndex), getTokenRange(beginIndex));
  }
  function createToken(type, beginIndex) {
    return new Token(type, getTokenRange(beginIndex));
  }
  function readUnicodeEscapeSequence() {
    var beginIndex = index;
    if (currentCharCode === 117) {
      next();
      if (skipHexDigit() && skipHexDigit() && skipHexDigit() && skipHexDigit()) {
        return parseInt(getTokenString(beginIndex + 1), 16);
      }
    }
    reportError('Invalid unicode escape sequence in identifier', beginIndex - 1);
    return 0;
  }
  function scanIdentifierOrKeyword(beginIndex, code) {
    var escapedCharCodes;
    if (code === 92) {
      code = readUnicodeEscapeSequence();
      escapedCharCodes = [code];
    }
    if (!isIdentifierStart(code)) {
      reportError(("Character code '" + code + "' is not a valid identifier start char"), beginIndex);
      return createToken(ERROR, beginIndex);
    }
    for (;;) {
      code = currentCharCode;
      if (isIdentifierPart(code)) {
        next();
      } else if (code === 92) {
        next();
        code = readUnicodeEscapeSequence();
        if (!escapedCharCodes) escapedCharCodes = [];
        escapedCharCodes.push(code);
        if (!isIdentifierPart(code)) return createToken(ERROR, beginIndex);
      } else {
        break;
      }
    }
    var value = input.slice(beginIndex, index);
    var keywordType = getKeywordType(value);
    if (keywordType) return new KeywordToken(value, keywordType, getTokenRange(beginIndex));
    if (escapedCharCodes) {
      var i = 0;
      value = value.replace(/\\u..../g, function(s) {
        return String.fromCharCode(escapedCharCodes[i++]);
      });
    }
    return new IdentifierToken(getTokenRange(beginIndex), value);
  }
  function scanStringLiteral(beginIndex, terminator) {
    while (peekStringLiteralChar(terminator)) {
      if (!skipStringLiteralChar()) {
        return new LiteralToken(STRING, getTokenString(beginIndex), getTokenRange(beginIndex));
      }
    }
    if (currentCharCode !== terminator) {
      reportError('Unterminated String Literal', beginIndex);
    } else {
      next();
    }
    return new LiteralToken(STRING, getTokenString(beginIndex), getTokenRange(beginIndex));
  }
  function getTokenString(beginIndex) {
    return input.substring(beginIndex, index);
  }
  function peekStringLiteralChar(terminator) {
    return !isAtEnd() && currentCharCode !== terminator && !isLineTerminator(currentCharCode);
  }
  function skipStringLiteralChar() {
    if (currentCharCode === 92) {
      return skipStringLiteralEscapeSequence();
    }
    next();
    return true;
  }
  function skipStringLiteralEscapeSequence() {
    next();
    if (isAtEnd()) {
      reportError('Unterminated string literal escape sequence');
      return false;
    }
    if (isLineTerminator(currentCharCode)) {
      skipLineTerminator();
      return true;
    }
    var code = currentCharCode;
    next();
    switch (code) {
      case 39:
      case 34:
      case 92:
      case 98:
      case 102:
      case 110:
      case 114:
      case 116:
      case 118:
      case 48:
        return true;
      case 120:
        return skipHexDigit() && skipHexDigit();
      case 117:
        return skipHexDigit() && skipHexDigit() && skipHexDigit() && skipHexDigit();
      default:
        return true;
    }
  }
  function skipHexDigit() {
    if (!isHexDigit(currentCharCode)) {
      reportError('Hex digit expected');
      return false;
    }
    next();
    return true;
  }
  function skipLineTerminator() {
    var first = currentCharCode;
    next();
    if (first === 13 && currentCharCode === 10) {
      next();
    }
  }
  function scanFractionalNumericLiteral(beginIndex) {
    if (currentCharCode === 46) {
      next();
      skipDecimalDigits();
    }
    return scanExponentOfNumericLiteral(beginIndex);
  }
  function scanExponentOfNumericLiteral(beginIndex) {
    switch (currentCharCode) {
      case 101:
      case 69:
        next();
        switch (currentCharCode) {
          case 43:
          case 45:
            next();
            break;
        }
        if (!isDecimalDigit(currentCharCode)) {
          reportError('Exponent part must contain at least one digit');
        }
        skipDecimalDigits();
        break;
      default:
        break;
    }
    return new LiteralToken(NUMBER, getTokenString(beginIndex), getTokenRange(beginIndex));
  }
  function skipDecimalDigits() {
    while (isDecimalDigit(currentCharCode)) {
      next();
    }
  }
  function skipHexDigits() {
    while (isHexDigit(currentCharCode)) {
      next();
    }
  }
  function skipBinaryDigits() {
    while (isBinaryDigit(currentCharCode)) {
      next();
    }
  }
  function skipOctalDigits() {
    while (isOctalDigit(currentCharCode)) {
      next();
    }
  }
  function isAtEnd() {
    return index === length;
  }
  function next() {
    index++;
    updateCurrentCharCode();
  }
  function updateCurrentCharCode() {
    currentCharCode = input.charCodeAt(index);
  }
  function reportError(message) {
    var indexArg = arguments[1] !== (void 0) ? arguments[1]: index;
    var position = getPosition(indexArg);
    errorReporter.reportError(position, message);
  }
  return {
    get isLineTerminator() {
      return isLineTerminator;
    },
    get Scanner() {
      return Scanner;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/Parser", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/Parser";
  var $__83 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/AssignmentPatternTransformer"),
      AssignmentPatternTransformer = $__83.AssignmentPatternTransformer,
      AssignmentPatternTransformerError = $__83.AssignmentPatternTransformerError;
  var $__83 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/CoverFormalsTransformer"),
      toFormalParameters = $__83.toFormalParameters,
      toParenExpression = $__83.toParenExpression,
      CoverFormalsTransformerError = $__83.CoverFormalsTransformerError;
  var IdentifierToken = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/IdentifierToken").IdentifierToken;
  var $__83 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      ARRAY_LITERAL_EXPRESSION = $__83.ARRAY_LITERAL_EXPRESSION,
      BINARY_OPERATOR = $__83.BINARY_OPERATOR,
      CALL_EXPRESSION = $__83.CALL_EXPRESSION,
      CLASS_DECLARATION = $__83.CLASS_DECLARATION,
      COMMA_EXPRESSION = $__83.COMMA_EXPRESSION,
      COMPUTED_PROPERTY_NAME = $__83.COMPUTED_PROPERTY_NAME,
      COVER_FORMALS = $__83.COVER_FORMALS,
      FORMAL_PARAMETER_LIST = $__83.FORMAL_PARAMETER_LIST,
      FUNCTION_DECLARATION = $__83.FUNCTION_DECLARATION,
      IDENTIFIER_EXPRESSION = $__83.IDENTIFIER_EXPRESSION,
      LITERAL_PROPERTY_NAME = $__83.LITERAL_PROPERTY_NAME,
      MEMBER_EXPRESSION = $__83.MEMBER_EXPRESSION,
      MEMBER_LOOKUP_EXPRESSION = $__83.MEMBER_LOOKUP_EXPRESSION,
      OBJECT_LITERAL_EXPRESSION = $__83.OBJECT_LITERAL_EXPRESSION,
      PAREN_EXPRESSION = $__83.PAREN_EXPRESSION,
      PROPERTY_NAME_ASSIGNMENT = $__83.PROPERTY_NAME_ASSIGNMENT,
      REST_PARAMETER = $__83.REST_PARAMETER,
      SYNTAX_ERROR_TREE = $__83.SYNTAX_ERROR_TREE;
  var $__83 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/PredefinedName"),
      AS = $__83.AS,
      FROM = $__83.FROM,
      GET = $__83.GET,
      MODULE = $__83.MODULE,
      OF = $__83.OF,
      SET = $__83.SET;
  var SyntaxErrorReporter = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/SyntaxErrorReporter").SyntaxErrorReporter;
  var Scanner = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Scanner").Scanner;
  var SourceRange = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/SourceRange").SourceRange;
  var StrictParams = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/staticsemantics/StrictParams").StrictParams;
  var $__83 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Token"),
      Token = $__83.Token,
      isAssignmentOperator = $__83.isAssignmentOperator;
  var $__83 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/options"),
      parseOptions = $__83.parseOptions,
      options = $__83.options;
  var $__83 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      AMPERSAND = $__83.AMPERSAND,
      AMPERSAND_EQUAL = $__83.AMPERSAND_EQUAL,
      AND = $__83.AND,
      ARROW = $__83.ARROW,
      AT = $__83.AT,
      AWAIT = $__83.AWAIT,
      BACK_QUOTE = $__83.BACK_QUOTE,
      BANG = $__83.BANG,
      BAR = $__83.BAR,
      BAR_EQUAL = $__83.BAR_EQUAL,
      BREAK = $__83.BREAK,
      CARET = $__83.CARET,
      CARET_EQUAL = $__83.CARET_EQUAL,
      CASE = $__83.CASE,
      CATCH = $__83.CATCH,
      CLASS = $__83.CLASS,
      CLOSE_ANGLE = $__83.CLOSE_ANGLE,
      CLOSE_CURLY = $__83.CLOSE_CURLY,
      CLOSE_PAREN = $__83.CLOSE_PAREN,
      CLOSE_SQUARE = $__83.CLOSE_SQUARE,
      COLON = $__83.COLON,
      COMMA = $__83.COMMA,
      CONST = $__83.CONST,
      CONTINUE = $__83.CONTINUE,
      DEBUGGER = $__83.DEBUGGER,
      DEFAULT = $__83.DEFAULT,
      DELETE = $__83.DELETE,
      DO = $__83.DO,
      DOT_DOT_DOT = $__83.DOT_DOT_DOT,
      ELSE = $__83.ELSE,
      END_OF_FILE = $__83.END_OF_FILE,
      ENUM = $__83.ENUM,
      EQUAL = $__83.EQUAL,
      EQUAL_EQUAL = $__83.EQUAL_EQUAL,
      EQUAL_EQUAL_EQUAL = $__83.EQUAL_EQUAL_EQUAL,
      ERROR = $__83.ERROR,
      EXPORT = $__83.EXPORT,
      EXTENDS = $__83.EXTENDS,
      FALSE = $__83.FALSE,
      FINALLY = $__83.FINALLY,
      FOR = $__83.FOR,
      FUNCTION = $__83.FUNCTION,
      GREATER_EQUAL = $__83.GREATER_EQUAL,
      IDENTIFIER = $__83.IDENTIFIER,
      IF = $__83.IF,
      IMPLEMENTS = $__83.IMPLEMENTS,
      IMPORT = $__83.IMPORT,
      IN = $__83.IN,
      INSTANCEOF = $__83.INSTANCEOF,
      INTERFACE = $__83.INTERFACE,
      LEFT_SHIFT = $__83.LEFT_SHIFT,
      LEFT_SHIFT_EQUAL = $__83.LEFT_SHIFT_EQUAL,
      LESS_EQUAL = $__83.LESS_EQUAL,
      LET = $__83.LET,
      MINUS = $__83.MINUS,
      MINUS_EQUAL = $__83.MINUS_EQUAL,
      MINUS_MINUS = $__83.MINUS_MINUS,
      NEW = $__83.NEW,
      NO_SUBSTITUTION_TEMPLATE = $__83.NO_SUBSTITUTION_TEMPLATE,
      NOT_EQUAL = $__83.NOT_EQUAL,
      NOT_EQUAL_EQUAL = $__83.NOT_EQUAL_EQUAL,
      NULL = $__83.NULL,
      NUMBER = $__83.NUMBER,
      OPEN_ANGLE = $__83.OPEN_ANGLE,
      OPEN_CURLY = $__83.OPEN_CURLY,
      OPEN_PAREN = $__83.OPEN_PAREN,
      OPEN_SQUARE = $__83.OPEN_SQUARE,
      OR = $__83.OR,
      PACKAGE = $__83.PACKAGE,
      PERCENT = $__83.PERCENT,
      PERCENT_EQUAL = $__83.PERCENT_EQUAL,
      PERIOD = $__83.PERIOD,
      PLUS = $__83.PLUS,
      PLUS_EQUAL = $__83.PLUS_EQUAL,
      PLUS_PLUS = $__83.PLUS_PLUS,
      PRIVATE = $__83.PRIVATE,
      PROTECTED = $__83.PROTECTED,
      PUBLIC = $__83.PUBLIC,
      QUESTION = $__83.QUESTION,
      REGULAR_EXPRESSION = $__83.REGULAR_EXPRESSION,
      RETURN = $__83.RETURN,
      RIGHT_SHIFT = $__83.RIGHT_SHIFT,
      RIGHT_SHIFT_EQUAL = $__83.RIGHT_SHIFT_EQUAL,
      SEMI_COLON = $__83.SEMI_COLON,
      SLASH = $__83.SLASH,
      SLASH_EQUAL = $__83.SLASH_EQUAL,
      STAR = $__83.STAR,
      STAR_EQUAL = $__83.STAR_EQUAL,
      STATIC = $__83.STATIC,
      STRING = $__83.STRING,
      SUPER = $__83.SUPER,
      SWITCH = $__83.SWITCH,
      TEMPLATE_HEAD = $__83.TEMPLATE_HEAD,
      TEMPLATE_MIDDLE = $__83.TEMPLATE_MIDDLE,
      TEMPLATE_TAIL = $__83.TEMPLATE_TAIL,
      THIS = $__83.THIS,
      THROW = $__83.THROW,
      TILDE = $__83.TILDE,
      TRUE = $__83.TRUE,
      TRY = $__83.TRY,
      TYPEOF = $__83.TYPEOF,
      UNSIGNED_RIGHT_SHIFT = $__83.UNSIGNED_RIGHT_SHIFT,
      UNSIGNED_RIGHT_SHIFT_EQUAL = $__83.UNSIGNED_RIGHT_SHIFT_EQUAL,
      VAR = $__83.VAR,
      VOID = $__83.VOID,
      WHILE = $__83.WHILE,
      WITH = $__83.WITH,
      YIELD = $__83.YIELD;
  var $__83 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      ArgumentList = $__83.ArgumentList,
      ArrayComprehension = $__83.ArrayComprehension,
      ArrayLiteralExpression = $__83.ArrayLiteralExpression,
      ArrayPattern = $__83.ArrayPattern,
      ArrowFunctionExpression = $__83.ArrowFunctionExpression,
      AwaitStatement = $__83.AwaitStatement,
      BinaryOperator = $__83.BinaryOperator,
      BindingElement = $__83.BindingElement,
      BindingIdentifier = $__83.BindingIdentifier,
      Block = $__83.Block,
      BreakStatement = $__83.BreakStatement,
      CallExpression = $__83.CallExpression,
      CaseClause = $__83.CaseClause,
      Catch = $__83.Catch,
      ClassDeclaration = $__83.ClassDeclaration,
      ClassExpression = $__83.ClassExpression,
      CommaExpression = $__83.CommaExpression,
      ComprehensionFor = $__83.ComprehensionFor,
      ComprehensionIf = $__83.ComprehensionIf,
      ComputedPropertyName = $__83.ComputedPropertyName,
      ConditionalExpression = $__83.ConditionalExpression,
      ContinueStatement = $__83.ContinueStatement,
      CoverFormals = $__83.CoverFormals,
      CoverInitialisedName = $__83.CoverInitialisedName,
      DebuggerStatement = $__83.DebuggerStatement,
      Annotation = $__83.Annotation,
      DefaultClause = $__83.DefaultClause,
      DoWhileStatement = $__83.DoWhileStatement,
      EmptyStatement = $__83.EmptyStatement,
      ExportDeclaration = $__83.ExportDeclaration,
      ExportDefault = $__83.ExportDefault,
      ExportSpecifier = $__83.ExportSpecifier,
      ExportSpecifierSet = $__83.ExportSpecifierSet,
      ExportStar = $__83.ExportStar,
      ExpressionStatement = $__83.ExpressionStatement,
      Finally = $__83.Finally,
      ForInStatement = $__83.ForInStatement,
      ForOfStatement = $__83.ForOfStatement,
      ForStatement = $__83.ForStatement,
      FormalParameter = $__83.FormalParameter,
      FormalParameterList = $__83.FormalParameterList,
      FunctionBody = $__83.FunctionBody,
      FunctionDeclaration = $__83.FunctionDeclaration,
      FunctionExpression = $__83.FunctionExpression,
      GeneratorComprehension = $__83.GeneratorComprehension,
      GetAccessor = $__83.GetAccessor,
      IdentifierExpression = $__83.IdentifierExpression,
      IfStatement = $__83.IfStatement,
      ImportDeclaration = $__83.ImportDeclaration,
      ImportSpecifier = $__83.ImportSpecifier,
      ImportSpecifierSet = $__83.ImportSpecifierSet,
      ImportedBinding = $__83.ImportedBinding,
      LabelledStatement = $__83.LabelledStatement,
      LiteralExpression = $__83.LiteralExpression,
      LiteralPropertyName = $__83.LiteralPropertyName,
      MemberExpression = $__83.MemberExpression,
      MemberLookupExpression = $__83.MemberLookupExpression,
      Module = $__83.Module,
      ModuleDeclaration = $__83.ModuleDeclaration,
      ModuleSpecifier = $__83.ModuleSpecifier,
      NamedExport = $__83.NamedExport,
      NewExpression = $__83.NewExpression,
      ObjectLiteralExpression = $__83.ObjectLiteralExpression,
      ObjectPattern = $__83.ObjectPattern,
      ObjectPatternField = $__83.ObjectPatternField,
      ParenExpression = $__83.ParenExpression,
      PostfixExpression = $__83.PostfixExpression,
      PredefinedType = $__83.PredefinedType,
      Script = $__83.Script,
      PropertyMethodAssignment = $__83.PropertyMethodAssignment,
      PropertyNameAssignment = $__83.PropertyNameAssignment,
      PropertyNameShorthand = $__83.PropertyNameShorthand,
      RestParameter = $__83.RestParameter,
      ReturnStatement = $__83.ReturnStatement,
      SetAccessor = $__83.SetAccessor,
      SpreadExpression = $__83.SpreadExpression,
      SpreadPatternElement = $__83.SpreadPatternElement,
      SuperExpression = $__83.SuperExpression,
      SwitchStatement = $__83.SwitchStatement,
      SyntaxErrorTree = $__83.SyntaxErrorTree,
      TemplateLiteralExpression = $__83.TemplateLiteralExpression,
      TemplateLiteralPortion = $__83.TemplateLiteralPortion,
      TemplateSubstitution = $__83.TemplateSubstitution,
      ThisExpression = $__83.ThisExpression,
      ThrowStatement = $__83.ThrowStatement,
      TryStatement = $__83.TryStatement,
      TypeName = $__83.TypeName,
      UnaryExpression = $__83.UnaryExpression,
      VariableDeclaration = $__83.VariableDeclaration,
      VariableDeclarationList = $__83.VariableDeclarationList,
      VariableStatement = $__83.VariableStatement,
      WhileStatement = $__83.WhileStatement,
      WithStatement = $__83.WithStatement,
      YieldExpression = $__83.YieldExpression;
  var Expression = {
    NO_IN: 'NO_IN',
    NORMAL: 'NORMAL'
  };
  var DestructuringInitialiser = {
    REQUIRED: 'REQUIRED',
    OPTIONAL: 'OPTIONAL'
  };
  var Initialiser = {
    ALLOWED: 'ALLOWED',
    REQUIRED: 'REQUIRED'
  };
  var Parser = function Parser(file) {
    var errorReporter = arguments[1] !== (void 0) ? arguments[1]: new SyntaxErrorReporter();
    this.errorReporter_ = errorReporter;
    this.scanner_ = new Scanner(errorReporter, file, this);
    this.allowYield_ = options.unstarredGenerators;
    this.strictMode_ = false;
    this.coverInitialisedName_ = null;
    this.annotations_ = [];
  };
  ($traceurRuntime.createClass)(Parser, {
    parseScript: function() {
      this.strictMode_ = false;
      var start = this.getTreeStartLocation_();
      var scriptItemList = this.parseScriptItemList_();
      this.eat_(END_OF_FILE);
      return new Script(this.getTreeLocation_(start), scriptItemList);
    },
    parseScriptItemList_: function() {
      var result = [];
      var type;
      var checkUseStrictDirective = true;
      while ((type = this.peekType_()) !== END_OF_FILE) {
        var scriptItem = this.parseScriptItem_(type, false);
        if (checkUseStrictDirective) {
          if (!scriptItem.isDirectivePrologue()) {
            checkUseStrictDirective = false;
          } else if (scriptItem.isUseStrictDirective()) {
            this.strictMode_ = true;
            checkUseStrictDirective = false;
          }
        }
        result.push(scriptItem);
      }
      return result;
    },
    parseScriptItem_: function(type, allowModuleItem) {
      return this.parseStatement_(type, allowModuleItem, true);
    },
    parseModule: function() {
      var start = this.getTreeStartLocation_();
      var scriptItemList = this.parseModuleItemList_();
      this.eat_(END_OF_FILE);
      return new Module(this.getTreeLocation_(start), scriptItemList);
    },
    parseModuleItemList_: function() {
      this.strictMode_ = true;
      var result = [];
      var type;
      while ((type = this.peekType_()) !== END_OF_FILE) {
        var scriptItem = this.parseScriptItem_(type, true);
        result.push(scriptItem);
      }
      return result;
    },
    parseModuleSpecifier_: function() {
      var start = this.getTreeStartLocation_();
      var token = this.eat_(STRING);
      return new ModuleSpecifier(this.getTreeLocation_(start), token);
    },
    parseImportDeclaration_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(IMPORT);
      var importClause = null;
      if (this.peekImportClause_(this.peekType_())) {
        importClause = this.parseImportClause_();
        this.eatId_(FROM);
      }
      var moduleSpecifier = this.parseModuleSpecifier_();
      this.eatPossibleImplicitSemiColon_();
      return new ImportDeclaration(this.getTreeLocation_(start), importClause, moduleSpecifier);
    },
    peekImportClause_: function(type) {
      return type === OPEN_CURLY || this.peekBindingIdentifier_(type);
    },
    parseImportClause_: function() {
      var start = this.getTreeStartLocation_();
      if (this.eatIf_(OPEN_CURLY)) {
        var specifiers = [];
        while (!this.peek_(CLOSE_CURLY) && !this.isAtEnd()) {
          specifiers.push(this.parseImportSpecifier_());
          if (!this.eatIf_(COMMA)) break;
        }
        this.eat_(CLOSE_CURLY);
        return new ImportSpecifierSet(this.getTreeLocation_(start), specifiers);
      }
      var binding = this.parseBindingIdentifier_();
      return new ImportedBinding(this.getTreeLocation_(start), binding);
    },
    parseImportSpecifier_: function() {
      var start = this.getTreeStartLocation_();
      var token = this.peekToken_();
      var isKeyword = token.isKeyword();
      var lhs = this.eatIdName_();
      var rhs = null;
      if (isKeyword || this.peekPredefinedString_(AS)) {
        this.eatId_(AS);
        rhs = this.eatId_();
      }
      return new ImportSpecifier(this.getTreeLocation_(start), lhs, rhs);
    },
    parseExportDeclaration_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(EXPORT);
      var exportTree;
      var annotations = this.popAnnotations_();
      var type = this.peekType_();
      switch (type) {
        case CONST:
        case LET:
        case VAR:
          exportTree = this.parseVariableStatement_();
          break;
        case FUNCTION:
          exportTree = this.parseFunctionDeclaration_();
          break;
        case CLASS:
          exportTree = this.parseClassDeclaration_();
          break;
        case DEFAULT:
          exportTree = this.parseExportDefault_();
          break;
        case OPEN_CURLY:
        case STAR:
          exportTree = this.parseNamedExport_();
          break;
        default:
          return this.parseUnexpectedToken_(type);
      }
      return new ExportDeclaration(this.getTreeLocation_(start), exportTree, annotations);
    },
    parseExportDefault_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(DEFAULT);
      var expression = this.parseAssignmentExpression();
      this.eatPossibleImplicitSemiColon_();
      return new ExportDefault(this.getTreeLocation_(start), expression);
    },
    parseNamedExport_: function() {
      var start = this.getTreeStartLocation_();
      var specifierSet,
          expression;
      if (this.peek_(OPEN_CURLY)) {
        specifierSet = this.parseExportSpecifierSet_();
        expression = this.parseFromModuleSpecifierOpt_(false);
      } else {
        this.eat_(STAR);
        specifierSet = new ExportStar(this.getTreeLocation_(start));
        expression = this.parseFromModuleSpecifierOpt_(true);
      }
      this.eatPossibleImplicitSemiColon_();
      return new NamedExport(this.getTreeLocation_(start), expression, specifierSet);
    },
    parseFromModuleSpecifierOpt_: function(required) {
      if (required || this.peekPredefinedString_(FROM)) {
        this.eatId_(FROM);
        return this.parseModuleSpecifier_();
      }
      return null;
    },
    parseExportSpecifierSet_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(OPEN_CURLY);
      var specifiers = [this.parseExportSpecifier_()];
      while (this.eatIf_(COMMA)) {
        if (this.peek_(CLOSE_CURLY)) break;
        specifiers.push(this.parseExportSpecifier_());
      }
      this.eat_(CLOSE_CURLY);
      return new ExportSpecifierSet(this.getTreeLocation_(start), specifiers);
    },
    parseExportSpecifier_: function() {
      var start = this.getTreeStartLocation_();
      var lhs = this.eatId_();
      var rhs = null;
      if (this.peekPredefinedString_(AS)) {
        this.eatId_(AS);
        rhs = this.eatIdName_();
      }
      return new ExportSpecifier(this.getTreeLocation_(start), lhs, rhs);
    },
    peekId_: function(type) {
      if (type === IDENTIFIER) return true;
      if (this.strictMode_) return false;
      return this.peekToken_().isStrictKeyword();
    },
    peekIdName_: function(token) {
      return token.type === IDENTIFIER || token.isKeyword();
    },
    parseClassShared_: function(constr) {
      var start = this.getTreeStartLocation_();
      var strictMode = this.strictMode_;
      this.strictMode_ = true;
      this.eat_(CLASS);
      var name = null;
      var annotations = [];
      if (constr == ClassDeclaration || !this.peek_(EXTENDS) && !this.peek_(OPEN_CURLY)) {
        name = this.parseBindingIdentifier_();
        annotations = this.popAnnotations_();
      }
      var superClass = null;
      if (this.eatIf_(EXTENDS)) {
        superClass = this.parseAssignmentExpression();
      }
      this.eat_(OPEN_CURLY);
      var elements = this.parseClassElements_();
      this.eat_(CLOSE_CURLY);
      this.strictMode_ = strictMode;
      return new constr(this.getTreeLocation_(start), name, superClass, elements, annotations);
    },
    parseClassDeclaration_: function() {
      return this.parseClassShared_(ClassDeclaration);
    },
    parseClassExpression_: function() {
      return this.parseClassShared_(ClassExpression);
    },
    parseClassElements_: function() {
      var result = [];
      while (true) {
        var type = this.peekType_();
        if (type === SEMI_COLON) {
          this.nextToken_();
        } else if (this.peekClassElement_(this.peekType_())) {
          result.push(this.parseClassElement_());
        } else {
          break;
        }
      }
      return result;
    },
    peekClassElement_: function(type) {
      return this.peekPropertyName_(type) || type === STAR && parseOptions.generators || type === AT && parseOptions.annotations;
    },
    parsePropertyName_: function() {
      if (this.peek_(OPEN_SQUARE)) return this.parseComputedPropertyName_();
      return this.parseLiteralPropertyName_();
    },
    parseLiteralPropertyName_: function() {
      var start = this.getTreeStartLocation_();
      var token = this.nextToken_();
      return new LiteralPropertyName(this.getTreeLocation_(start), token);
    },
    parseComputedPropertyName_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(OPEN_SQUARE);
      var expression = this.parseAssignmentExpression();
      this.eat_(CLOSE_SQUARE);
      return new ComputedPropertyName(this.getTreeLocation_(start), expression);
    },
    parseStatement: function() {
      return this.parseStatement_(this.peekType_(), false, false);
    },
    parseStatement_: function(type, allowModuleItem, allowScriptItem) {
      switch (type) {
        case RETURN:
          return this.parseReturnStatement_();
        case CONST:
        case LET:
          if (!parseOptions.blockBinding) break;
        case VAR:
          return this.parseVariableStatement_();
        case IF:
          return this.parseIfStatement_();
        case FOR:
          return this.parseForStatement_();
        case BREAK:
          return this.parseBreakStatement_();
        case SWITCH:
          return this.parseSwitchStatement_();
        case THROW:
          return this.parseThrowStatement_();
        case WHILE:
          return this.parseWhileStatement_();
        case FUNCTION:
          return this.parseFunctionDeclaration_();
        case AT:
          if (parseOptions.annotations) return this.parseAnnotatedDeclarations_(allowModuleItem, allowScriptItem);
          break;
        case AWAIT:
          if (parseOptions.deferredFunctions) return this.parseAwaitStatement_();
          break;
        case CLASS:
          if (parseOptions.classes) return this.parseClassDeclaration_();
          break;
        case CONTINUE:
          return this.parseContinueStatement_();
        case DEBUGGER:
          return this.parseDebuggerStatement_();
        case DO:
          return this.parseDoWhileStatement_();
        case EXPORT:
          if (allowModuleItem && parseOptions.modules) return this.parseExportDeclaration_();
          break;
        case IMPORT:
          if (allowScriptItem && parseOptions.modules) return this.parseImportDeclaration_();
          break;
        case OPEN_CURLY:
          return this.parseBlock_();
        case SEMI_COLON:
          return this.parseEmptyStatement_();
        case TRY:
          return this.parseTryStatement_();
        case WITH:
          return this.parseWithStatement_();
      }
      return this.parseFallThroughStatement_(allowScriptItem);
    },
    parseFunctionDeclaration_: function() {
      return this.parseFunction_(FunctionDeclaration);
    },
    parseFunctionExpression_: function() {
      return this.parseFunction_(FunctionExpression);
    },
    parseFunction_: function(ctor) {
      var start = this.getTreeStartLocation_();
      this.eat_(FUNCTION);
      var isGenerator = parseOptions.generators && this.eatIf_(STAR);
      var name = null;
      var annotations = [];
      if (ctor === FunctionDeclaration || this.peekBindingIdentifier_(this.peekType_())) {
        name = this.parseBindingIdentifier_();
        annotations = this.popAnnotations_();
      }
      this.eat_(OPEN_PAREN);
      var formalParameterList = this.parseFormalParameterList_();
      this.eat_(CLOSE_PAREN);
      var typeAnnotation = this.parseTypeAnnotationOpt_();
      var functionBody = this.parseFunctionBody_(isGenerator, formalParameterList);
      return new ctor(this.getTreeLocation_(start), name, isGenerator, formalParameterList, typeAnnotation, annotations, functionBody);
    },
    peekRest_: function(type) {
      return type === DOT_DOT_DOT && parseOptions.restParameters;
    },
    parseFormalParameterList_: function() {
      var start = this.getTreeStartLocation_();
      var formals = [];
      this.pushAnnotations_();
      var type = this.peekType_();
      if (this.peekRest_(type)) {
        formals.push(this.parseFormalRestParameter_());
      } else {
        if (this.peekFormalParameter_(this.peekType_())) formals.push(this.parseFormalParameter_());
        while (this.eatIf_(COMMA)) {
          this.pushAnnotations_();
          if (this.peekRest_(this.peekType_())) {
            formals.push(this.parseFormalRestParameter_());
            break;
          }
          formals.push(this.parseFormalParameter_());
        }
      }
      return new FormalParameterList(this.getTreeLocation_(start), formals);
    },
    peekFormalParameter_: function(type) {
      return this.peekBindingElement_(type);
    },
    parseFormalParameter_: function() {
      var initialiserAllowed = arguments[0];
      var start = this.getTreeStartLocation_();
      var binding = this.parseBindingElementBinding_();
      var typeAnnotation = this.parseTypeAnnotationOpt_();
      var initialiser = this.parseBindingElementInitialiser_(initialiserAllowed);
      return new FormalParameter(this.getTreeLocation_(start), new BindingElement(this.getTreeLocation_(start), binding, initialiser), typeAnnotation, this.popAnnotations_());
    },
    parseFormalRestParameter_: function() {
      var start = this.getTreeStartLocation_();
      var restParameter = this.parseRestParameter_();
      var typeAnnotation = this.parseTypeAnnotationOpt_();
      return new FormalParameter(this.getTreeLocation_(start), restParameter, typeAnnotation, this.popAnnotations_());
    },
    parseRestParameter_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(DOT_DOT_DOT);
      var id = this.parseBindingIdentifier_();
      return new RestParameter(this.getTreeLocation_(start), id);
    },
    parseFunctionBody_: function(isGenerator, params) {
      var start = this.getTreeStartLocation_();
      this.eat_(OPEN_CURLY);
      var allowYield = this.allowYield_;
      var strictMode = this.strictMode_;
      this.allowYield_ = isGenerator || options.unstarredGenerators;
      var result = this.parseStatementList_(!strictMode);
      if (!strictMode && this.strictMode_ && params) StrictParams.visit(params, this.errorReporter_);
      this.strictMode_ = strictMode;
      this.allowYield_ = allowYield;
      this.eat_(CLOSE_CURLY);
      return new FunctionBody(this.getTreeLocation_(start), result);
    },
    parseStatements: function() {
      return this.parseStatementList_(false);
    },
    parseStatementList_: function(checkUseStrictDirective) {
      var result = [];
      var type;
      while ((type = this.peekType_()) !== CLOSE_CURLY && type !== END_OF_FILE) {
        var statement = this.parseStatement_(type, false, false);
        if (checkUseStrictDirective) {
          if (!statement.isDirectivePrologue()) {
            checkUseStrictDirective = false;
          } else if (statement.isUseStrictDirective()) {
            this.strictMode_ = true;
            checkUseStrictDirective = false;
          }
        }
        result.push(statement);
      }
      return result;
    },
    parseSpreadExpression_: function() {
      if (!parseOptions.spread) return this.parseUnexpectedToken_(DOT_DOT_DOT);
      var start = this.getTreeStartLocation_();
      this.eat_(DOT_DOT_DOT);
      var operand = this.parseAssignmentExpression();
      return new SpreadExpression(this.getTreeLocation_(start), operand);
    },
    parseBlock_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(OPEN_CURLY);
      var result = this.parseStatementList_(false);
      this.eat_(CLOSE_CURLY);
      return new Block(this.getTreeLocation_(start), result);
    },
    parseVariableStatement_: function() {
      var start = this.getTreeStartLocation_();
      var declarations = this.parseVariableDeclarationList_();
      this.checkInitialisers_(declarations);
      this.eatPossibleImplicitSemiColon_();
      return new VariableStatement(this.getTreeLocation_(start), declarations);
    },
    parseVariableDeclarationList_: function() {
      var expressionIn = arguments[0] !== (void 0) ? arguments[0]: Expression.NORMAL;
      var initialiser = arguments[1] !== (void 0) ? arguments[1]: DestructuringInitialiser.REQUIRED;
      var type = this.peekType_();
      switch (type) {
        case CONST:
        case LET:
          if (!parseOptions.blockBinding) debugger;
        case VAR:
          this.nextToken_();
          break;
        default:
          throw Error('unreachable');
      }
      var start = this.getTreeStartLocation_();
      var declarations = [];
      declarations.push(this.parseVariableDeclaration_(type, expressionIn, initialiser));
      while (this.eatIf_(COMMA)) {
        declarations.push(this.parseVariableDeclaration_(type, expressionIn, initialiser));
      }
      return new VariableDeclarationList(this.getTreeLocation_(start), type, declarations);
    },
    parseVariableDeclaration_: function(binding, expressionIn) {
      var initialiser = arguments[2] !== (void 0) ? arguments[2]: DestructuringInitialiser.REQUIRED;
      var initRequired = initialiser !== DestructuringInitialiser.OPTIONAL;
      var start = this.getTreeStartLocation_();
      var lvalue;
      var typeAnnotation;
      if (this.peekPattern_(this.peekType_())) {
        lvalue = this.parseBindingPattern_();
        typeAnnotation = null;
      } else {
        lvalue = this.parseBindingIdentifier_();
        typeAnnotation = this.parseTypeAnnotationOpt_();
      }
      var initialiser = null;
      if (this.peek_(EQUAL)) initialiser = this.parseInitialiser_(expressionIn); else if (lvalue.isPattern() && initRequired) this.reportError_('destructuring must have an initialiser');
      return new VariableDeclaration(this.getTreeLocation_(start), lvalue, typeAnnotation, initialiser);
    },
    parseInitialiser_: function(expressionIn) {
      this.eat_(EQUAL);
      return this.parseAssignmentExpression(expressionIn);
    },
    parseEmptyStatement_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(SEMI_COLON);
      return new EmptyStatement(this.getTreeLocation_(start));
    },
    parseFallThroughStatement_: function(allowScriptItem) {
      var start = this.getTreeStartLocation_();
      var expression = this.parseExpression();
      if (expression.type === IDENTIFIER_EXPRESSION) {
        var nameToken = expression.identifierToken;
        if (this.eatIf_(COLON)) {
          var statement = this.parseStatement();
          return new LabelledStatement(this.getTreeLocation_(start), nameToken, statement);
        }
        if (allowScriptItem && nameToken.value === MODULE && parseOptions.modules) {
          var token = this.peekTokenNoLineTerminator_();
          if (token !== null && token.type === IDENTIFIER) {
            var name = this.eatId_();
            this.eatId_(FROM);
            var moduleSpecifier = this.parseModuleSpecifier_();
            this.eatPossibleImplicitSemiColon_();
            return new ModuleDeclaration(this.getTreeLocation_(start), name, moduleSpecifier);
          }
        }
      }
      this.eatPossibleImplicitSemiColon_();
      return new ExpressionStatement(this.getTreeLocation_(start), expression);
    },
    parseIfStatement_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(IF);
      this.eat_(OPEN_PAREN);
      var condition = this.parseExpression();
      this.eat_(CLOSE_PAREN);
      var ifClause = this.parseStatement();
      var elseClause = null;
      if (this.eatIf_(ELSE)) {
        elseClause = this.parseStatement();
      }
      return new IfStatement(this.getTreeLocation_(start), condition, ifClause, elseClause);
    },
    parseDoWhileStatement_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(DO);
      var body = this.parseStatement();
      this.eat_(WHILE);
      this.eat_(OPEN_PAREN);
      var condition = this.parseExpression();
      this.eat_(CLOSE_PAREN);
      this.eatPossibleImplicitSemiColon_();
      return new DoWhileStatement(this.getTreeLocation_(start), body, condition);
    },
    parseWhileStatement_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(WHILE);
      this.eat_(OPEN_PAREN);
      var condition = this.parseExpression();
      this.eat_(CLOSE_PAREN);
      var body = this.parseStatement();
      return new WhileStatement(this.getTreeLocation_(start), condition, body);
    },
    parseForStatement_: function() {
      var $__81 = this;
      var start = this.getTreeStartLocation_();
      this.eat_(FOR);
      this.eat_(OPEN_PAREN);
      var validate = (function(variables, kind) {
        if (variables.declarations.length > 1) {
          $__81.reportError_(kind + ' statement may not have more than one variable declaration');
        }
        var declaration = variables.declarations[0];
        if (declaration.lvalue.isPattern() && declaration.initialiser) {
          $__81.reportError_(declaration.initialiser.location, ("initialiser is not allowed in " + kind + " loop with pattern"));
        }
      });
      var type = this.peekType_();
      if (this.peekVariableDeclarationList_(type)) {
        var variables = this.parseVariableDeclarationList_(Expression.NO_IN, DestructuringInitialiser.OPTIONAL);
        type = this.peekType_();
        if (type === IN) {
          validate(variables, 'for-in');
          var declaration = variables.declarations[0];
          if (parseOptions.blockBinding && (variables.declarationType == LET || variables.declarationType == CONST)) {
            if (declaration.initialiser != null) {
              this.reportError_('let/const in for-in statement may not have initialiser');
            }
          }
          return this.parseForInStatement_(start, variables);
        } else if (this.peekOf_(type)) {
          validate(variables, 'for-of');
          var declaration = variables.declarations[0];
          if (declaration.initialiser != null) {
            this.reportError_('for-of statement may not have initialiser');
          }
          return this.parseForOfStatement_(start, variables);
        } else {
          this.checkInitialisers_(variables);
          return this.parseForStatement2_(start, variables);
        }
      }
      if (type === SEMI_COLON) {
        return this.parseForStatement2_(start, null);
      }
      var initialiser = this.parseExpression(Expression.NO_IN);
      type = this.peekType_();
      if (initialiser.isLeftHandSideExpression() && (type === IN || this.peekOf_(type))) {
        initialiser = this.transformLeftHandSideExpression_(initialiser);
        if (this.peekOf_(type)) return this.parseForOfStatement_(start, initialiser);
        return this.parseForInStatement_(start, initialiser);
      }
      return this.parseForStatement2_(start, initialiser);
    },
    peekOf_: function(type) {
      return type === IDENTIFIER && parseOptions.forOf && this.peekToken_().value === OF;
    },
    parseForOfStatement_: function(start, initialiser) {
      this.eatId_();
      var collection = this.parseExpression();
      this.eat_(CLOSE_PAREN);
      var body = this.parseStatement();
      return new ForOfStatement(this.getTreeLocation_(start), initialiser, collection, body);
    },
    checkInitialisers_: function(variables) {
      if (parseOptions.blockBinding && variables.declarationType == CONST) {
        var type = variables.declarationType;
        for (var i = 0; i < variables.declarations.length; i++) {
          if (!this.checkInitialiser_(type, variables.declarations[i])) {
            break;
          }
        }
      }
    },
    checkInitialiser_: function(type, declaration) {
      if (parseOptions.blockBinding && type == CONST && declaration.initialiser == null) {
        this.reportError_('const variables must have an initialiser');
        return false;
      }
      return true;
    },
    peekVariableDeclarationList_: function(type) {
      switch (type) {
        case VAR:
          return true;
        case CONST:
        case LET:
          return parseOptions.blockBinding;
        default:
          return false;
      }
    },
    parseForStatement2_: function(start, initialiser) {
      this.eat_(SEMI_COLON);
      var condition = null;
      if (!this.peek_(SEMI_COLON)) {
        condition = this.parseExpression();
      }
      this.eat_(SEMI_COLON);
      var increment = null;
      if (!this.peek_(CLOSE_PAREN)) {
        increment = this.parseExpression();
      }
      this.eat_(CLOSE_PAREN);
      var body = this.parseStatement();
      return new ForStatement(this.getTreeLocation_(start), initialiser, condition, increment, body);
    },
    parseForInStatement_: function(start, initialiser) {
      this.eat_(IN);
      var collection = this.parseExpression();
      this.eat_(CLOSE_PAREN);
      var body = this.parseStatement();
      return new ForInStatement(this.getTreeLocation_(start), initialiser, collection, body);
    },
    parseContinueStatement_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(CONTINUE);
      var name = null;
      if (!this.peekImplicitSemiColon_(this.peekType_())) {
        name = this.eatIdOpt_();
      }
      this.eatPossibleImplicitSemiColon_();
      return new ContinueStatement(this.getTreeLocation_(start), name);
    },
    parseBreakStatement_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(BREAK);
      var name = null;
      if (!this.peekImplicitSemiColon_(this.peekType_())) {
        name = this.eatIdOpt_();
      }
      this.eatPossibleImplicitSemiColon_();
      return new BreakStatement(this.getTreeLocation_(start), name);
    },
    parseReturnStatement_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(RETURN);
      var expression = null;
      if (!this.peekImplicitSemiColon_(this.peekType_())) {
        expression = this.parseExpression();
      }
      this.eatPossibleImplicitSemiColon_();
      return new ReturnStatement(this.getTreeLocation_(start), expression);
    },
    parseYieldExpression_: function() {
      if (!this.allowYield_) {
        return this.parseSyntaxError_("'yield' expressions are only allowed inside 'function*'");
      }
      var start = this.getTreeStartLocation_();
      this.eat_(YIELD);
      var expression = null;
      var isYieldFor = this.eatIf_(STAR);
      if (isYieldFor || !this.peekImplicitSemiColon_(this.peekType_())) {
        expression = this.parseAssignmentExpression();
      }
      return new YieldExpression(this.getTreeLocation_(start), expression, isYieldFor);
    },
    parseAwaitStatement_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(AWAIT);
      var identifier = null;
      if (this.peek_(IDENTIFIER) && this.peek_(EQUAL, 1)) {
        identifier = this.eatId_();
        this.eat_(EQUAL);
      }
      var expression = this.parseExpression();
      this.eatPossibleImplicitSemiColon_();
      return new AwaitStatement(this.getTreeLocation_(start), identifier, expression);
    },
    parseWithStatement_: function() {
      if (this.strictMode_) this.reportError_('Strict mode code may not include a with statement');
      var start = this.getTreeStartLocation_();
      this.eat_(WITH);
      this.eat_(OPEN_PAREN);
      var expression = this.parseExpression();
      this.eat_(CLOSE_PAREN);
      var body = this.parseStatement();
      return new WithStatement(this.getTreeLocation_(start), expression, body);
    },
    parseSwitchStatement_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(SWITCH);
      this.eat_(OPEN_PAREN);
      var expression = this.parseExpression();
      this.eat_(CLOSE_PAREN);
      this.eat_(OPEN_CURLY);
      var caseClauses = this.parseCaseClauses_();
      this.eat_(CLOSE_CURLY);
      return new SwitchStatement(this.getTreeLocation_(start), expression, caseClauses);
    },
    parseCaseClauses_: function() {
      var foundDefaultClause = false;
      var result = [];
      while (true) {
        var start = this.getTreeStartLocation_();
        switch (this.peekType_()) {
          case CASE:
            this.nextToken_();
            var expression = this.parseExpression();
            this.eat_(COLON);
            var statements = this.parseCaseStatementsOpt_();
            result.push(new CaseClause(this.getTreeLocation_(start), expression, statements));
            break;
          case DEFAULT:
            if (foundDefaultClause) {
              this.reportError_('Switch statements may have at most one default clause');
            } else {
              foundDefaultClause = true;
            }
            this.nextToken_();
            this.eat_(COLON);
            result.push(new DefaultClause(this.getTreeLocation_(start), this.parseCaseStatementsOpt_()));
            break;
          default:
            return result;
        }
      }
    },
    parseCaseStatementsOpt_: function() {
      var result = [];
      var type;
      while (true) {
        switch (type = this.peekType_()) {
          case CASE:
          case DEFAULT:
          case CLOSE_CURLY:
          case END_OF_FILE:
            return result;
        }
        result.push(this.parseStatement_(type, false, false));
      }
    },
    parseThrowStatement_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(THROW);
      var value = null;
      if (!this.peekImplicitSemiColon_(this.peekType_())) {
        value = this.parseExpression();
      }
      this.eatPossibleImplicitSemiColon_();
      return new ThrowStatement(this.getTreeLocation_(start), value);
    },
    parseTryStatement_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(TRY);
      var body = this.parseBlock_();
      var catchBlock = null;
      if (this.peek_(CATCH)) {
        catchBlock = this.parseCatch_();
      }
      var finallyBlock = null;
      if (this.peek_(FINALLY)) {
        finallyBlock = this.parseFinallyBlock_();
      }
      if (catchBlock == null && finallyBlock == null) {
        this.reportError_("'catch' or 'finally' expected.");
      }
      return new TryStatement(this.getTreeLocation_(start), body, catchBlock, finallyBlock);
    },
    parseCatch_: function() {
      var start = this.getTreeStartLocation_();
      var catchBlock;
      this.eat_(CATCH);
      this.eat_(OPEN_PAREN);
      var binding;
      if (this.peekPattern_(this.peekType_())) binding = this.parseBindingPattern_(); else binding = this.parseBindingIdentifier_();
      this.eat_(CLOSE_PAREN);
      var catchBody = this.parseBlock_();
      catchBlock = new Catch(this.getTreeLocation_(start), binding, catchBody);
      return catchBlock;
    },
    parseFinallyBlock_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(FINALLY);
      var finallyBlock = this.parseBlock_();
      return new Finally(this.getTreeLocation_(start), finallyBlock);
    },
    parseDebuggerStatement_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(DEBUGGER);
      this.eatPossibleImplicitSemiColon_();
      return new DebuggerStatement(this.getTreeLocation_(start));
    },
    parsePrimaryExpression_: function() {
      switch (this.peekType_()) {
        case CLASS:
          return parseOptions.classes ? this.parseClassExpression_(): this.parseSyntaxError_('Unexpected reserved word');
        case SUPER:
          return this.parseSuperExpression_();
        case THIS:
          return this.parseThisExpression_();
        case IDENTIFIER:
          return this.parseIdentifierExpression_();
        case NUMBER:
        case STRING:
        case TRUE:
        case FALSE:
        case NULL:
          return this.parseLiteralExpression_();
        case OPEN_SQUARE:
          return this.parseArrayLiteral_();
        case OPEN_CURLY:
          return this.parseObjectLiteral_();
        case OPEN_PAREN:
          return this.parsePrimaryExpressionStartingWithParen_();
        case SLASH:
        case SLASH_EQUAL:
          return this.parseRegularExpressionLiteral_();
        case NO_SUBSTITUTION_TEMPLATE:
        case TEMPLATE_HEAD:
          return this.parseTemplateLiteral_(null);
        case IMPLEMENTS:
        case INTERFACE:
        case PACKAGE:
        case PRIVATE:
        case PROTECTED:
        case PUBLIC:
        case STATIC:
        case YIELD:
          if (!this.strictMode_) return this.parseIdentifierExpression_();
          this.reportReservedIdentifier_(this.nextToken_());
        case END_OF_FILE:
          return this.parseSyntaxError_('Unexpected end of input');
        default:
          return this.parseUnexpectedToken_(this.peekToken_());
      }
    },
    parseSuperExpression_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(SUPER);
      return new SuperExpression(this.getTreeLocation_(start));
    },
    parseThisExpression_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(THIS);
      return new ThisExpression(this.getTreeLocation_(start));
    },
    peekBindingIdentifier_: function(type) {
      return this.peekId_(type);
    },
    parseBindingIdentifier_: function() {
      var start = this.getTreeStartLocation_();
      var identifier = this.eatId_();
      return new BindingIdentifier(this.getTreeLocation_(start), identifier);
    },
    parseIdentifierExpression_: function() {
      var start = this.getTreeStartLocation_();
      var identifier = this.eatId_();
      return new IdentifierExpression(this.getTreeLocation_(start), identifier);
    },
    parseIdentifierNameExpression_: function() {
      var start = this.getTreeStartLocation_();
      var identifier = this.eatIdName_();
      return new IdentifierExpression(this.getTreeLocation_(start), identifier);
    },
    parseLiteralExpression_: function() {
      var start = this.getTreeStartLocation_();
      var literal = this.nextLiteralToken_();
      return new LiteralExpression(this.getTreeLocation_(start), literal);
    },
    nextLiteralToken_: function() {
      return this.nextToken_();
    },
    parseRegularExpressionLiteral_: function() {
      var start = this.getTreeStartLocation_();
      var literal = this.nextRegularExpressionLiteralToken_();
      return new LiteralExpression(this.getTreeLocation_(start), literal);
    },
    peekSpread_: function(type) {
      return type === DOT_DOT_DOT && parseOptions.spread;
    },
    parseArrayLiteral_: function() {
      var start = this.getTreeStartLocation_();
      var expression;
      var elements = [];
      this.eat_(OPEN_SQUARE);
      var type = this.peekType_();
      if (type === FOR && parseOptions.arrayComprehension) return this.parseArrayComprehension_(start);
      while (true) {
        type = this.peekType_();
        if (type === COMMA) {
          expression = null;
        } else if (this.peekSpread_(type)) {
          expression = this.parseSpreadExpression_();
        } else if (this.peekAssignmentExpression_(type)) {
          expression = this.parseAssignmentExpression();
        } else {
          break;
        }
        elements.push(expression);
        type = this.peekType_();
        if (type !== CLOSE_SQUARE) this.eat_(COMMA);
      }
      this.eat_(CLOSE_SQUARE);
      return new ArrayLiteralExpression(this.getTreeLocation_(start), elements);
    },
    parseArrayComprehension_: function(start) {
      var list = this.parseComprehensionList_();
      var expression = this.parseAssignmentExpression();
      this.eat_(CLOSE_SQUARE);
      return new ArrayComprehension(this.getTreeLocation_(start), list, expression);
    },
    parseComprehensionList_: function() {
      var list = [this.parseComprehensionFor_()];
      while (true) {
        var type = this.peekType_();
        switch (type) {
          case FOR:
            list.push(this.parseComprehensionFor_());
            break;
          case IF:
            list.push(this.parseComprehensionIf_());
            break;
          default:
            return list;
        }
      }
    },
    parseComprehensionFor_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(FOR);
      this.eat_(OPEN_PAREN);
      var left = this.parseForBinding_();
      this.eatId_(OF);
      var iterator = this.parseExpression();
      this.eat_(CLOSE_PAREN);
      return new ComprehensionFor(this.getTreeLocation_(start), left, iterator);
    },
    parseComprehensionIf_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(IF);
      this.eat_(OPEN_PAREN);
      var expression = this.parseExpression();
      this.eat_(CLOSE_PAREN);
      return new ComprehensionIf(this.getTreeLocation_(start), expression);
    },
    parseObjectLiteral_: function() {
      var start = this.getTreeStartLocation_();
      var result = [];
      this.eat_(OPEN_CURLY);
      while (this.peekPropertyDefinition_(this.peekType_())) {
        var propertyDefinition = this.parsePropertyDefinition();
        result.push(propertyDefinition);
        if (!this.eatIf_(COMMA)) break;
      }
      this.eat_(CLOSE_CURLY);
      return new ObjectLiteralExpression(this.getTreeLocation_(start), result);
    },
    parsePropertyDefinition: function() {
      var start = this.getTreeStartLocation_();
      var isGenerator = false;
      var isStatic = false;
      if (parseOptions.generators && parseOptions.propertyMethods && this.peek_(STAR)) {
        return this.parseGeneratorMethod_(start, isStatic, []);
      }
      var token = this.peekToken_();
      var name = this.parsePropertyName_();
      if (parseOptions.propertyMethods && this.peek_(OPEN_PAREN)) return this.parseMethod_(start, isStatic, isGenerator, name, []);
      if (this.eatIf_(COLON)) {
        var value = this.parseAssignmentExpression();
        return new PropertyNameAssignment(this.getTreeLocation_(start), name, value);
      }
      var type = this.peekType_();
      if (name.type === LITERAL_PROPERTY_NAME) {
        var nameLiteral = name.literalToken;
        if (nameLiteral.value === GET && this.peekPropertyName_(type)) {
          return this.parseGetAccessor_(start, isStatic, []);
        }
        if (nameLiteral.value === SET && this.peekPropertyName_(type)) {
          return this.parseSetAccessor_(start, isStatic, []);
        }
        if (parseOptions.propertyNameShorthand && nameLiteral.type === IDENTIFIER) {
          if (this.peek_(EQUAL)) {
            token = this.nextToken_();
            var expr = this.parseAssignmentExpression();
            return this.coverInitialisedName_ = new CoverInitialisedName(this.getTreeLocation_(start), nameLiteral, token, expr);
          }
          return new PropertyNameShorthand(this.getTreeLocation_(start), nameLiteral);
        }
      }
      if (name.type === COMPUTED_PROPERTY_NAME) token = this.peekToken_();
      return this.parseUnexpectedToken_(token);
    },
    parseClassElement_: function() {
      var start = this.getTreeStartLocation_();
      var annotations = this.parseAnnotations_();
      var type = this.peekType_();
      var isStatic = false,
          isGenerator = false;
      switch (type) {
        case STATIC:
          var staticToken = this.nextToken_();
          type = this.peekType_();
          switch (type) {
            case OPEN_PAREN:
              var name = new LiteralPropertyName(start, staticToken);
              return this.parseMethod_(start, isStatic, isGenerator, name, annotations);
            default:
              isStatic = true;
              if (type === STAR && parseOptions.generators) return this.parseGeneratorMethod_(start, true, annotations);
              return this.parseGetSetOrMethod_(start, isStatic, annotations);
          }
          break;
        case STAR:
          return this.parseGeneratorMethod_(start, isStatic, annotations);
        default:
          return this.parseGetSetOrMethod_(start, isStatic, annotations);
      }
    },
    parseGeneratorMethod_: function(start, isStatic, annotations) {
      var isGenerator = true;
      this.eat_(STAR);
      var name = this.parsePropertyName_();
      return this.parseMethod_(start, isStatic, isGenerator, name, annotations);
    },
    parseMethod_: function(start, isStatic, isGenerator, name, annotations) {
      this.eat_(OPEN_PAREN);
      var formalParameterList = this.parseFormalParameterList_();
      this.eat_(CLOSE_PAREN);
      var typeAnnotation = this.parseTypeAnnotationOpt_();
      var functionBody = this.parseFunctionBody_(isGenerator, formalParameterList);
      return new PropertyMethodAssignment(this.getTreeLocation_(start), isStatic, isGenerator, name, formalParameterList, typeAnnotation, annotations, functionBody);
    },
    parseGetSetOrMethod_: function(start, isStatic, annotations) {
      var isGenerator = false;
      var name = this.parsePropertyName_();
      var type = this.peekType_();
      if (name.type === LITERAL_PROPERTY_NAME && name.literalToken.value === GET && this.peekPropertyName_(type)) {
        return this.parseGetAccessor_(start, isStatic, annotations);
      }
      if (name.type === LITERAL_PROPERTY_NAME && name.literalToken.value === SET && this.peekPropertyName_(type)) {
        return this.parseSetAccessor_(start, isStatic, annotations);
      }
      return this.parseMethod_(start, isStatic, isGenerator, name, annotations);
    },
    parseGetAccessor_: function(start, isStatic, annotations) {
      var isGenerator = false;
      var name = this.parsePropertyName_();
      this.eat_(OPEN_PAREN);
      this.eat_(CLOSE_PAREN);
      var typeAnnotation = this.parseTypeAnnotationOpt_();
      var body = this.parseFunctionBody_(isGenerator, null);
      return new GetAccessor(this.getTreeLocation_(start), isStatic, name, typeAnnotation, annotations, body);
    },
    parseSetAccessor_: function(start, isStatic, annotations) {
      var isGenerator = false;
      var name = this.parsePropertyName_();
      this.eat_(OPEN_PAREN);
      var parameter = this.parsePropertySetParameterList_();
      this.eat_(CLOSE_PAREN);
      var body = this.parseFunctionBody_(isGenerator, parameter);
      return new SetAccessor(this.getTreeLocation_(start), isStatic, name, parameter, annotations, body);
    },
    peekPropertyDefinition_: function(type) {
      return this.peekPropertyName_(type) || type == STAR && parseOptions.propertyMethods && parseOptions.generators;
    },
    peekPropertyName_: function(type) {
      switch (type) {
        case IDENTIFIER:
        case STRING:
        case NUMBER:
          return true;
        case OPEN_SQUARE:
          return parseOptions.computedPropertyNames;
        default:
          return this.peekToken_().isKeyword();
      }
    },
    peekPredefinedString_: function(string) {
      var token = this.peekToken_();
      return token.type === IDENTIFIER && token.value === string;
    },
    parsePropertySetParameterList_: function() {
      var start = this.getTreeStartLocation_();
      var binding;
      this.pushAnnotations_();
      if (this.peekPattern_(this.peekType_())) binding = this.parseBindingPattern_(); else binding = this.parseBindingIdentifier_();
      var typeAnnotation = this.parseTypeAnnotationOpt_();
      return new FormalParameter(this.getTreeLocation_(start), new BindingElement(this.getTreeLocation_(start), binding, null), typeAnnotation, this.popAnnotations_());
    },
    parsePrimaryExpressionStartingWithParen_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(OPEN_PAREN);
      if (this.peek_(FOR) && parseOptions.generatorComprehension) return this.parseGeneratorComprehension_(start);
      return this.parseCoverFormals_(start);
    },
    parseSyntaxError_: function(message) {
      var start = this.getTreeStartLocation_();
      this.reportError_(message);
      var token = this.nextToken_();
      return new SyntaxErrorTree(this.getTreeLocation_(start), token, message);
    },
    parseUnexpectedToken_: function(name) {
      return this.parseSyntaxError_(("Unexpected token " + name));
    },
    peekExpression_: function(type) {
      switch (type) {
        case NO_SUBSTITUTION_TEMPLATE:
        case TEMPLATE_HEAD:
          return parseOptions.templateLiterals;
        case BANG:
        case CLASS:
        case DELETE:
        case FALSE:
        case FUNCTION:
        case IDENTIFIER:
        case MINUS:
        case MINUS_MINUS:
        case NEW:
        case NULL:
        case NUMBER:
        case OPEN_CURLY:
        case OPEN_PAREN:
        case OPEN_SQUARE:
        case PLUS:
        case PLUS_PLUS:
        case SLASH:
        case SLASH_EQUAL:
        case STRING:
        case SUPER:
        case THIS:
        case TILDE:
        case TRUE:
        case TYPEOF:
        case VOID:
        case YIELD:
          return true;
        default:
          return false;
      }
    },
    parseExpression: function() {
      var expressionIn = arguments[0] !== (void 0) ? arguments[0]: Expression.IN;
      var start = this.getTreeStartLocation_();
      var result = this.parseAssignmentExpression(expressionIn);
      if (this.peek_(COMMA)) {
        var exprs = [result];
        while (this.eatIf_(COMMA)) {
          exprs.push(this.parseAssignmentExpression(expressionIn));
        }
        return new CommaExpression(this.getTreeLocation_(start), exprs);
      }
      return result;
    },
    peekAssignmentExpression_: function(type) {
      return this.peekExpression_(type);
    },
    parseAssignmentExpression: function() {
      var expressionIn = arguments[0] !== (void 0) ? arguments[0]: Expression.NORMAL;
      var allowCoverGrammar = arguments[1];
      if (this.allowYield_ && this.peek_(YIELD)) return this.parseYieldExpression_();
      var start = this.getTreeStartLocation_();
      var left = this.parseConditional_(expressionIn);
      var type = this.peekType_();
      if (type === ARROW && (left.type === COVER_FORMALS || left.type === IDENTIFIER_EXPRESSION)) {
        return this.parseArrowFunction_(start, left);
      }
      if (this.peekAssignmentOperator_(type)) {
        if (type === EQUAL) left = this.transformLeftHandSideExpression_(left); else left = this.toParenExpression_(left);
        if (!allowCoverGrammar) this.ensureAssignmenExpression_();
        if (!left.isLeftHandSideExpression() && !left.isPattern()) {
          this.reportError_('Left hand side of assignment must be new, call, member, function, primary expressions or destructuring pattern');
        }
        var operator = this.nextToken_();
        var right = this.parseAssignmentExpression(expressionIn);
        return new BinaryOperator(this.getTreeLocation_(start), left, operator, right);
      }
      left = this.toParenExpression_(left);
      if (!allowCoverGrammar) this.ensureAssignmenExpression_();
      return left;
    },
    ensureAssignmenExpression_: function() {
      if (this.coverInitialisedName_) {
        var token = this.coverInitialisedName_.equalToken;
        this.reportError_(token.location, ("Unexpected token '" + token + "'"));
        this.coverInitialisedName_ = null;
      }
    },
    transformLeftHandSideExpression_: function(tree) {
      switch (tree.type) {
        case ARRAY_LITERAL_EXPRESSION:
        case OBJECT_LITERAL_EXPRESSION:
          var transformer = new AssignmentPatternTransformer();
          var transformedTree;
          try {
            transformedTree = transformer.transformAny(tree);
          } catch (ex) {
            if (!(ex instanceof AssignmentPatternTransformerError)) throw ex;
          }
          if (transformedTree) {
            this.coverInitialisedName_ = null;
            return transformedTree;
          }
          break;
        case PAREN_EXPRESSION:
          var expression = this.transformLeftHandSideExpression_(tree.expression);
          if (expression !== tree.expression) return new ParenExpression(tree.location, expression);
      }
      return tree;
    },
    peekAssignmentOperator_: function(type) {
      return isAssignmentOperator(type);
    },
    parseConditional_: function(expressionIn) {
      var start = this.getTreeStartLocation_();
      var condition = this.parseLogicalOR_(expressionIn);
      if (this.eatIf_(QUESTION)) {
        condition = this.toParenExpression_(condition);
        var left = this.parseAssignmentExpression();
        this.eat_(COLON);
        var right = this.parseAssignmentExpression(expressionIn);
        return new ConditionalExpression(this.getTreeLocation_(start), condition, left, right);
      }
      return condition;
    },
    newBinaryOperator_: function(start, left, operator, right) {
      left = this.toParenExpression_(left);
      right = this.toParenExpression_(right);
      return new BinaryOperator(this.getTreeLocation_(start), left, operator, right);
    },
    parseLogicalOR_: function(expressionIn) {
      var start = this.getTreeStartLocation_();
      var left = this.parseLogicalAND_(expressionIn);
      var operator;
      while (operator = this.eatOpt_(OR)) {
        var right = this.parseLogicalAND_(expressionIn);
        left = this.newBinaryOperator_(start, left, operator, right);
      }
      return left;
    },
    parseLogicalAND_: function(expressionIn) {
      var start = this.getTreeStartLocation_();
      var left = this.parseBitwiseOR_(expressionIn);
      var operator;
      while (operator = this.eatOpt_(AND)) {
        var right = this.parseBitwiseOR_(expressionIn);
        left = this.newBinaryOperator_(start, left, operator, right);
      }
      return left;
    },
    parseBitwiseOR_: function(expressionIn) {
      var start = this.getTreeStartLocation_();
      var left = this.parseBitwiseXOR_(expressionIn);
      var operator;
      while (operator = this.eatOpt_(BAR)) {
        var right = this.parseBitwiseXOR_(expressionIn);
        left = this.newBinaryOperator_(start, left, operator, right);
      }
      return left;
    },
    parseBitwiseXOR_: function(expressionIn) {
      var start = this.getTreeStartLocation_();
      var left = this.parseBitwiseAND_(expressionIn);
      var operator;
      while (operator = this.eatOpt_(CARET)) {
        var right = this.parseBitwiseAND_(expressionIn);
        left = this.newBinaryOperator_(start, left, operator, right);
      }
      return left;
    },
    parseBitwiseAND_: function(expressionIn) {
      var start = this.getTreeStartLocation_();
      var left = this.parseEquality_(expressionIn);
      var operator;
      while (operator = this.eatOpt_(AMPERSAND)) {
        var right = this.parseEquality_(expressionIn);
        left = this.newBinaryOperator_(start, left, operator, right);
      }
      return left;
    },
    parseEquality_: function(expressionIn) {
      var start = this.getTreeStartLocation_();
      var left = this.parseRelational_(expressionIn);
      while (this.peekEqualityOperator_(this.peekType_())) {
        var operator = this.nextToken_();
        var right = this.parseRelational_(expressionIn);
        left = this.newBinaryOperator_(start, left, operator, right);
      }
      return left;
    },
    peekEqualityOperator_: function(type) {
      switch (type) {
        case EQUAL_EQUAL:
        case NOT_EQUAL:
        case EQUAL_EQUAL_EQUAL:
        case NOT_EQUAL_EQUAL:
          return true;
      }
      return false;
    },
    parseRelational_: function(expressionIn) {
      var start = this.getTreeStartLocation_();
      var left = this.parseShiftExpression_();
      while (this.peekRelationalOperator_(expressionIn)) {
        var operator = this.nextToken_();
        var right = this.parseShiftExpression_();
        left = this.newBinaryOperator_(start, left, operator, right);
      }
      return left;
    },
    peekRelationalOperator_: function(expressionIn) {
      switch (this.peekType_()) {
        case OPEN_ANGLE:
        case CLOSE_ANGLE:
        case GREATER_EQUAL:
        case LESS_EQUAL:
        case INSTANCEOF:
          return true;
        case IN:
          return expressionIn == Expression.NORMAL;
        default:
          return false;
      }
    },
    parseShiftExpression_: function() {
      var start = this.getTreeStartLocation_();
      var left = this.parseAdditiveExpression_();
      while (this.peekShiftOperator_(this.peekType_())) {
        var operator = this.nextToken_();
        var right = this.parseAdditiveExpression_();
        left = this.newBinaryOperator_(start, left, operator, right);
      }
      return left;
    },
    peekShiftOperator_: function(type) {
      switch (type) {
        case LEFT_SHIFT:
        case RIGHT_SHIFT:
        case UNSIGNED_RIGHT_SHIFT:
          return true;
        default:
          return false;
      }
    },
    parseAdditiveExpression_: function() {
      var start = this.getTreeStartLocation_();
      var left = this.parseMultiplicativeExpression_();
      while (this.peekAdditiveOperator_(this.peekType_())) {
        var operator = this.nextToken_();
        var right = this.parseMultiplicativeExpression_();
        left = this.newBinaryOperator_(start, left, operator, right);
      }
      return left;
    },
    peekAdditiveOperator_: function(type) {
      switch (type) {
        case PLUS:
        case MINUS:
          return true;
        default:
          return false;
      }
    },
    parseMultiplicativeExpression_: function() {
      var start = this.getTreeStartLocation_();
      var left = this.parseUnaryExpression_();
      while (this.peekMultiplicativeOperator_(this.peekType_())) {
        var operator = this.nextToken_();
        var right = this.parseUnaryExpression_();
        left = this.newBinaryOperator_(start, left, operator, right);
      }
      return left;
    },
    peekMultiplicativeOperator_: function(type) {
      switch (type) {
        case STAR:
        case SLASH:
        case PERCENT:
          return true;
        default:
          return false;
      }
    },
    parseUnaryExpression_: function() {
      var start = this.getTreeStartLocation_();
      if (this.peekUnaryOperator_(this.peekType_())) {
        var operator = this.nextToken_();
        var operand = this.parseUnaryExpression_();
        operand = this.toParenExpression_(operand);
        return new UnaryExpression(this.getTreeLocation_(start), operator, operand);
      }
      return this.parsePostfixExpression_();
    },
    peekUnaryOperator_: function(type) {
      switch (type) {
        case DELETE:
        case VOID:
        case TYPEOF:
        case PLUS_PLUS:
        case MINUS_MINUS:
        case PLUS:
        case MINUS:
        case TILDE:
        case BANG:
          return true;
        default:
          return false;
      }
    },
    parsePostfixExpression_: function() {
      var start = this.getTreeStartLocation_();
      var operand = this.parseLeftHandSideExpression_();
      while (this.peekPostfixOperator_(this.peekType_())) {
        operand = this.toParenExpression_(operand);
        var operator = this.nextToken_();
        operand = new PostfixExpression(this.getTreeLocation_(start), operand, operator);
      }
      return operand;
    },
    peekPostfixOperator_: function(type) {
      switch (type) {
        case PLUS_PLUS:
        case MINUS_MINUS:
          var token = this.peekTokenNoLineTerminator_();
          return token !== null;
      }
      return false;
    },
    parseLeftHandSideExpression_: function() {
      var start = this.getTreeStartLocation_();
      var operand = this.parseNewExpression_();
      if (!(operand instanceof NewExpression) || operand.args != null) {
        loop: while (true) {
          switch (this.peekType_()) {
            case OPEN_PAREN:
              operand = this.toParenExpression_(operand);
              var args = this.parseArguments_();
              operand = new CallExpression(this.getTreeLocation_(start), operand, args);
              break;
            case OPEN_SQUARE:
              operand = this.toParenExpression_(operand);
              this.nextToken_();
              var member = this.parseExpression();
              this.eat_(CLOSE_SQUARE);
              operand = new MemberLookupExpression(this.getTreeLocation_(start), operand, member);
              break;
            case PERIOD:
              operand = this.toParenExpression_(operand);
              this.nextToken_();
              var memberName = this.eatIdName_();
              operand = new MemberExpression(this.getTreeLocation_(start), operand, memberName);
              break;
            case NO_SUBSTITUTION_TEMPLATE:
            case TEMPLATE_HEAD:
              if (!parseOptions.templateLiterals) break loop;
              operand = this.toParenExpression_(operand);
              operand = this.parseTemplateLiteral_(operand);
              break;
            default:
              break loop;
          }
        }
      }
      return operand;
    },
    parseMemberExpressionNoNew_: function() {
      var start = this.getTreeStartLocation_();
      var operand;
      if (this.peekType_() === FUNCTION) {
        operand = this.parseFunctionExpression_();
      } else {
        operand = this.parsePrimaryExpression_();
      }
      loop: while (true) {
        switch (this.peekType_()) {
          case OPEN_SQUARE:
            operand = this.toParenExpression_(operand);
            this.nextToken_();
            var member = this.parseExpression();
            this.eat_(CLOSE_SQUARE);
            operand = new MemberLookupExpression(this.getTreeLocation_(start), operand, member);
            break;
          case PERIOD:
            operand = this.toParenExpression_(operand);
            this.nextToken_();
            var name;
            name = this.eatIdName_();
            operand = new MemberExpression(this.getTreeLocation_(start), operand, name);
            break;
          case NO_SUBSTITUTION_TEMPLATE:
          case TEMPLATE_HEAD:
            if (!parseOptions.templateLiterals) break loop;
            operand = this.toParenExpression_(operand);
            operand = this.parseTemplateLiteral_(operand);
            break;
          default:
            break loop;
        }
      }
      return operand;
    },
    parseNewExpression_: function() {
      if (this.peek_(NEW)) {
        var start = this.getTreeStartLocation_();
        this.eat_(NEW);
        var operand = this.parseNewExpression_();
        operand = this.toParenExpression_(operand);
        var args = null;
        if (this.peek_(OPEN_PAREN)) {
          args = this.parseArguments_();
        }
        return new NewExpression(this.getTreeLocation_(start), operand, args);
      } else {
        return this.parseMemberExpressionNoNew_();
      }
    },
    parseArguments_: function() {
      var start = this.getTreeStartLocation_();
      var args = [];
      this.eat_(OPEN_PAREN);
      if (!this.peek_(CLOSE_PAREN)) {
        args.push(this.parseArgument_());
        while (this.eatIf_(COMMA)) {
          args.push(this.parseArgument_());
        }
      }
      this.eat_(CLOSE_PAREN);
      return new ArgumentList(this.getTreeLocation_(start), args);
    },
    parseArgument_: function() {
      if (this.peekSpread_(this.peekType_())) return this.parseSpreadExpression_();
      return this.parseAssignmentExpression();
    },
    parseArrowFunction_: function(start, tree) {
      var formals;
      if (tree.type === IDENTIFIER_EXPRESSION) {
        var id = new BindingIdentifier(tree.location, tree.identifierToken);
        var formals = new FormalParameterList(this.getTreeLocation_(start), [new FormalParameter(id.location, new BindingElement(id.location, id, null), null, [])]);
      } else {
        formals = this.toFormalParameters_(tree);
      }
      this.eat_(ARROW);
      var body = this.parseConciseBody_();
      return new ArrowFunctionExpression(this.getTreeLocation_(start), formals, body);
    },
    parseCoverFormals_: function(start) {
      var expressions = [];
      if (!this.peek_(CLOSE_PAREN)) {
        do {
          var type = this.peekType_();
          if (this.peekRest_(type)) {
            expressions.push(this.parseRestParameter_());
            break;
          } else {
            expressions.push(this.parseAssignmentExpression(Expression.NORMAL, true));
          }
          if (this.eatIf_(COMMA)) continue;
        } while (!this.peek_(CLOSE_PAREN) && !this.isAtEnd());
      }
      this.eat_(CLOSE_PAREN);
      return new CoverFormals(this.getTreeLocation_(start), expressions);
    },
    transformCoverFormals_: function(f, tree) {
      try {
        return f(tree);
      } catch (ex) {
        if (!(ex instanceof CoverFormalsTransformerError)) throw ex;
        this.reportError_(ex.location, ex.message);
        return new SyntaxErrorTree(ex.location, null, ex.message);
      }
    },
    toParenExpression_: function(tree) {
      if (tree.type !== COVER_FORMALS) return tree;
      return this.transformCoverFormals_(toParenExpression, tree);
    },
    toFormalParameters_: function(tree) {
      if (tree.type !== COVER_FORMALS) return tree;
      var transformed = this.transformCoverFormals_(toFormalParameters, tree);
      this.coverInitialisedName_ = null;
      return transformed;
    },
    transformCoverFormalsToArrowFormals_: function(coverFormals) {
      var formals = null;
      try {
        formals = toFormalParameters(coverFormals);
      } catch (ex) {
        if (!(ex instanceof CoverFormalsTransformerError)) throw ex;
      }
      return formals;
    },
    peekArrow_: function(type) {
      return type === ARROW && parseOptions.arrowFunctions;
    },
    parseConciseBody_: function() {
      if (this.peek_(OPEN_CURLY)) return this.parseFunctionBody_();
      return this.parseAssignmentExpression();
    },
    parseGeneratorComprehension_: function(start) {
      var comprehensionList = this.parseComprehensionList_();
      var expression = this.parseAssignmentExpression();
      this.eat_(CLOSE_PAREN);
      return new GeneratorComprehension(this.getTreeLocation_(start), comprehensionList, expression);
    },
    parseForBinding_: function() {
      if (this.peekPattern_(this.peekType_())) return this.parseBindingPattern_();
      return this.parseBindingIdentifier_();
    },
    peekPattern_: function(type) {
      return parseOptions.destructuring && (this.peekObjectPattern_(type) || this.peekArrayPattern_(type));
    },
    peekArrayPattern_: function(type) {
      return type === OPEN_SQUARE;
    },
    peekObjectPattern_: function(type) {
      return type === OPEN_CURLY;
    },
    parseBindingPattern_: function() {
      if (this.peekArrayPattern_(this.peekType_())) return this.parseArrayBindingPattern_();
      return this.parseObjectBindingPattern_();
    },
    parseArrayBindingPattern_: function() {
      var start = this.getTreeStartLocation_();
      var elements = [];
      this.eat_(OPEN_SQUARE);
      var type;
      while ((type = this.peekType_()) === COMMA || this.peekBindingElement_(type) || this.peekRest_(type)) {
        this.parseElisionOpt_(elements);
        if (this.peekRest_(this.peekType_())) {
          elements.push(this.parseBindingRestElement_());
          break;
        } else {
          elements.push(this.parseBindingElement_());
          if (this.peek_(COMMA) && !this.peek_(CLOSE_SQUARE, 1)) {
            this.nextToken_();
          }
        }
      }
      this.eat_(CLOSE_SQUARE);
      return new ArrayPattern(this.getTreeLocation_(start), elements);
    },
    parseBindingElementList_: function(elements) {
      this.parseElisionOpt_(elements);
      elements.push(this.parseBindingElement_());
      while (this.eatIf_(COMMA)) {
        this.parseElisionOpt_(elements);
        elements.push(this.parseBindingElement_());
      }
    },
    parseElisionOpt_: function(elements) {
      while (this.eatIf_(COMMA)) {
        elements.push(null);
      }
    },
    peekBindingElement_: function(type) {
      return this.peekBindingIdentifier_(type) || this.peekPattern_(type);
    },
    parseBindingElement_: function() {
      var initialiser = arguments[0] !== (void 0) ? arguments[0]: Initialiser.OPTIONAL;
      var start = this.getTreeStartLocation_();
      var binding = this.parseBindingElementBinding_();
      var initialiser = this.parseBindingElementInitialiser_(initialiser);
      return new BindingElement(this.getTreeLocation_(start), binding, initialiser);
    },
    parseBindingElementBinding_: function() {
      if (this.peekPattern_(this.peekType_())) return this.parseBindingPattern_();
      return this.parseBindingIdentifier_();
    },
    parseBindingElementInitialiser_: function() {
      var initialiser = arguments[0] !== (void 0) ? arguments[0]: Initialiser.OPTIONAL;
      if (this.peek_(EQUAL) || initialiser === Initialiser.REQUIRED) {
        return this.parseInitialiser_();
      }
      return null;
    },
    parseBindingRestElement_: function() {
      var start = this.getTreeStartLocation_();
      this.eat_(DOT_DOT_DOT);
      var identifier = this.parseBindingIdentifier_();
      return new SpreadPatternElement(this.getTreeLocation_(start), identifier);
    },
    parseObjectBindingPattern_: function() {
      var start = this.getTreeStartLocation_();
      var elements = [];
      this.eat_(OPEN_CURLY);
      while (this.peekBindingProperty_(this.peekType_())) {
        elements.push(this.parseBindingProperty_());
        if (!this.eatIf_(COMMA)) break;
      }
      this.eat_(CLOSE_CURLY);
      return new ObjectPattern(this.getTreeLocation_(start), elements);
    },
    peekBindingProperty_: function(type) {
      return this.peekBindingIdentifier_(type) || this.peekPropertyName_(type);
    },
    parseBindingProperty_: function() {
      var start = this.getTreeStartLocation_();
      var name = this.parsePropertyName_();
      var requireColon = name.type !== LITERAL_PROPERTY_NAME || !name.literalToken.isStrictKeyword() && name.literalToken.type !== IDENTIFIER;
      if (requireColon || this.peek_(COLON)) {
        this.eat_(COLON);
        var binding = this.parseBindingElement_();
        return new ObjectPatternField(this.getTreeLocation_(start), name, binding);
      }
      var token = name.literalToken;
      if (this.strictMode_ && token.isStrictKeyword()) this.reportReservedIdentifier_(token);
      var binding = new BindingIdentifier(name.location, token);
      var initialiser = null;
      if (this.peek_(EQUAL)) initialiser = this.parseInitialiser_();
      return new BindingElement(this.getTreeLocation_(start), binding, initialiser);
    },
    parseTemplateLiteral_: function(operand) {
      if (!parseOptions.templateLiterals) return this.parseUnexpectedToken_('`');
      var start = operand ? operand.location.start: this.getTreeStartLocation_();
      var token = this.nextToken_();
      var elements = [new TemplateLiteralPortion(token.location, token)];
      if (token.type === NO_SUBSTITUTION_TEMPLATE) {
        return new TemplateLiteralExpression(this.getTreeLocation_(start), operand, elements);
      }
      var expression = this.parseExpression();
      elements.push(new TemplateSubstitution(expression.location, expression));
      while (expression.type !== SYNTAX_ERROR_TREE) {
        token = this.nextTemplateLiteralToken_();
        if (token.type === ERROR || token.type === END_OF_FILE) break;
        elements.push(new TemplateLiteralPortion(token.location, token));
        if (token.type === TEMPLATE_TAIL) break;
        expression = this.parseExpression();
        elements.push(new TemplateSubstitution(expression.location, expression));
      }
      return new TemplateLiteralExpression(this.getTreeLocation_(start), operand, elements);
    },
    parseTypeAnnotationOpt_: function() {
      if (parseOptions.types && this.eatOpt_(COLON)) {
        return this.parseType_();
      }
      return null;
    },
    parseType_: function() {
      var start = this.getTreeStartLocation_();
      var elementType;
      switch (this.peekType_()) {
        case IDENTIFIER:
          elementType = this.parseNamedOrPredefinedType_();
          break;
        case NEW:
          elementType = this.parseConstructorType_();
          break;
        case OPEN_CURLY:
          elementType = this.parseObjectType_();
          break;
        case OPEN_PAREN:
          elementType = this.parseFunctionType_();
          break;
        case VOID:
          var token = this.nextToken_();
          return new PredefinedType(this.getTreeLocation_(start), token);
        default:
          return this.parseUnexpectedToken_(this.peekToken_());
      }
      return this.parseArrayTypeSuffix_(start, elementType);
    },
    parseArrayTypeSuffix_: function(start, elementType) {
      return elementType;
    },
    parseConstructorType_: function() {
      throw 'NYI';
    },
    parseObjectType_: function() {
      throw 'NYI';
    },
    parseFunctionType_: function() {
      throw 'NYI';
    },
    parseNamedOrPredefinedType_: function() {
      var start = this.getTreeStartLocation_();
      switch (this.peekToken_().value) {
        case 'any':
        case 'number':
        case 'boolean':
        case 'string':
          var token = this.nextToken_();
          return new PredefinedType(this.getTreeLocation_(start), token);
        default:
          return this.parseTypeName_();
      }
    },
    parseTypeName_: function() {
      var start = this.getTreeStartLocation_();
      var typeName = new TypeName(this.getTreeLocation_(start), null, this.eatId_());
      while (this.eatIf_(PERIOD)) {
        var memberName = this.eatIdName_();
        typeName = new TypeName(this.getTreeLocation_(start), typeName, memberName);
      }
      return typeName;
    },
    parseAnnotatedDeclarations_: function(allowModuleItem, allowScriptItem) {
      this.pushAnnotations_();
      var declaration = this.parseStatement_(this.peekType_(), allowModuleItem, allowScriptItem);
      if (this.annotations_.length > 0) return this.parseSyntaxError_('Unsupported annotated expression');
      return declaration;
    },
    parseAnnotations_: function() {
      var annotations = [];
      while (this.eatIf_(AT)) {
        annotations.push(this.parseAnnotation_());
      }
      return annotations;
    },
    pushAnnotations_: function() {
      this.annotations_ = this.parseAnnotations_();
    },
    popAnnotations_: function() {
      var annotations = this.annotations_;
      this.annotations_ = [];
      return annotations;
    },
    parseAnnotation_: function() {
      var start = this.getTreeStartLocation_();
      var expression = this.parseMemberExpressionNoNew_();
      var args = null;
      if (this.peek_(OPEN_PAREN)) args = this.parseArguments_();
      return new Annotation(this.getTreeLocation_(start), expression, args);
    },
    eatPossibleImplicitSemiColon_: function() {
      var token = this.peekTokenNoLineTerminator_();
      if (!token) return;
      switch (token.type) {
        case SEMI_COLON:
          this.nextToken_();
          return;
        case END_OF_FILE:
        case CLOSE_CURLY:
          return;
      }
      this.reportError_('Semi-colon expected');
    },
    peekImplicitSemiColon_: function() {
      switch (this.peekType_()) {
        case SEMI_COLON:
        case CLOSE_CURLY:
        case END_OF_FILE:
          return true;
      }
      var token = this.peekTokenNoLineTerminator_();
      return token === null;
    },
    eatOpt_: function(expectedTokenType) {
      if (this.peek_(expectedTokenType)) return this.nextToken_();
      return null;
    },
    eatIdOpt_: function() {
      return this.peek_(IDENTIFIER) ? this.eatId_(): null;
    },
    eatId_: function() {
      var expected = arguments[0];
      var token = this.nextToken_();
      if (!token) {
        if (expected) this.reportError_(this.peekToken_(), ("expected '" + expected + "'"));
        return null;
      }
      if (token.type === IDENTIFIER) return token;
      if (token.isStrictKeyword()) {
        if (this.strictMode_) {
          this.reportReservedIdentifier_(token);
        } else {
          return new IdentifierToken(token.location, token.type);
        }
      } else {
        this.reportExpectedError_(token, expected || 'identifier');
      }
      return token;
    },
    eatIdName_: function() {
      var t = this.nextToken_();
      if (t.type != IDENTIFIER) {
        if (!t.isKeyword()) {
          this.reportExpectedError_(t, 'identifier');
          return null;
        }
        return new IdentifierToken(t.location, t.type);
      }
      return t;
    },
    eat_: function(expectedTokenType) {
      var token = this.nextToken_();
      if (token.type != expectedTokenType) {
        this.reportExpectedError_(token, expectedTokenType);
        return null;
      }
      return token;
    },
    eatIf_: function(expectedTokenType) {
      if (this.peek_(expectedTokenType)) {
        this.nextToken_();
        return true;
      }
      return false;
    },
    reportExpectedError_: function(token, expected) {
      this.reportError_(token, "'" + expected + "' expected");
    },
    getTreeStartLocation_: function() {
      return this.peekToken_().location.start;
    },
    getTreeEndLocation_: function() {
      return this.scanner_.lastToken.location.end;
    },
    getTreeLocation_: function(start) {
      return new SourceRange(start, this.getTreeEndLocation_());
    },
    nextToken_: function() {
      return this.scanner_.nextToken();
    },
    nextRegularExpressionLiteralToken_: function() {
      return this.scanner_.nextRegularExpressionLiteralToken();
    },
    nextTemplateLiteralToken_: function() {
      return this.scanner_.nextTemplateLiteralToken();
    },
    isAtEnd: function() {
      return this.scanner_.isAtEnd();
    },
    peek_: function(expectedType, opt_index) {
      return this.peekToken_(opt_index).type === expectedType;
    },
    peekType_: function() {
      return this.peekToken_().type;
    },
    peekToken_: function(opt_index) {
      return this.scanner_.peekToken(opt_index);
    },
    peekTokenNoLineTerminator_: function() {
      return this.scanner_.peekTokenNoLineTerminator();
    },
    reportError_: function(var_args) {
      if (arguments.length == 1) {
        this.errorReporter_.reportError(this.scanner_.getPosition(), arguments[0]);
      } else {
        var location = arguments[0];
        if (location instanceof Token) {
          location = location.location;
        }
        this.errorReporter_.reportError(location.start, arguments[1]);
      }
    },
    reportReservedIdentifier_: function(token) {
      this.reportError_(token, (token.type + " is a reserved identifier"));
    }
  }, {});
  return {get Parser() {
      return Parser;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/util/uid", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/util/uid";
  var uidCounter = 0;
  function getUid() {
    return uidCounter++;
  }
  return {get getUid() {
      return getUid;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/util/SourcePosition", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/util/SourcePosition";
  var SourcePosition = function SourcePosition(source, offset) {
    this.source = source;
    this.offset = offset;
    this.line_ = - 1;
    this.column_ = - 1;
  };
  ($traceurRuntime.createClass)(SourcePosition, {
    get line() {
      if (this.line_ === - 1) this.line_ = this.source.lineNumberTable.getLine(this.offset);
      return this.line_;
    },
    get column() {
      if (this.column_ === - 1) this.column_ = this.source.lineNumberTable.getColumn(this.offset);
      return this.column_;
    },
    toString: function() {
      var name = this.source ? this.source.name: '';
      return (name + ":" + (this.line + 1) + ":" + (this.column + 1));
    }
  }, {});
  return {get SourcePosition() {
      return SourcePosition;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/LineNumberTable", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/LineNumberTable";
  var SourcePosition = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/SourcePosition").SourcePosition;
  var SourceRange = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/SourceRange").SourceRange;
  var isLineTerminator = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Scanner").isLineTerminator;
  var MAX_INT_REPRESENTATION = 9007199254740992;
  function computeLineStartOffsets(source) {
    var lineStartOffsets = [0];
    var k = 1;
    for (var index = 0; index < source.length; index++) {
      var code = source.charCodeAt(index);
      if (isLineTerminator(code)) {
        if (code === 13 && source.charCodeAt(index + 1) === 10) {
          index++;
        }
        lineStartOffsets[k++] = index + 1;
      }
    }
    lineStartOffsets[k++] = MAX_INT_REPRESENTATION;
    return lineStartOffsets;
  }
  var LineNumberTable = function LineNumberTable(sourceFile) {
    this.sourceFile_ = sourceFile;
    this.lineStartOffsets_ = null;
    this.lastLine_ = 0;
    this.lastOffset_ = - 1;
  };
  ($traceurRuntime.createClass)(LineNumberTable, {
    ensureLineStartOffsets_: function() {
      if (!this.lineStartOffsets_) {
        this.lineStartOffsets_ = computeLineStartOffsets(this.sourceFile_.contents);
      }
    },
    getSourcePosition: function(offset) {
      return new SourcePosition(this.sourceFile_, offset);
    },
    getLine: function(offset) {
      if (offset === this.lastOffset_) return this.lastLine_;
      this.ensureLineStartOffsets_();
      if (offset < 0) return 0;
      var line;
      if (offset < this.lastOffset_) {
        for (var i = this.lastLine_; i >= 0; i--) {
          if (this.lineStartOffsets_[i] <= offset) {
            line = i;
            break;
          }
        }
      } else {
        for (var i = this.lastLine_; true; i++) {
          if (this.lineStartOffsets_[i] > offset) {
            line = i - 1;
            break;
          }
        }
      }
      this.lastLine_ = line;
      this.lastOffset_ = offset;
      return line;
    },
    offsetOfLine: function(line) {
      this.ensureLineStartOffsets_();
      return this.lineStartOffsets_[line];
    },
    getColumn: function(offset) {
      var line = this.getLine(offset);
      return offset - this.lineStartOffsets_[line];
    },
    getSourceRange: function(startOffset, endOffset) {
      return new SourceRange(this.getSourcePosition(startOffset), this.getSourcePosition(endOffset));
    }
  }, {});
  return {get LineNumberTable() {
      return LineNumberTable;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/SourceFile", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/SourceFile";
  var LineNumberTable = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/LineNumberTable").LineNumberTable;
  var getUid = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/uid").getUid;
  var SourceFile = function SourceFile(name, contents) {
    this.name = name;
    this.contents = contents;
    this.lineNumberTable = new LineNumberTable(this);
    this.uid = getUid();
  };
  ($traceurRuntime.createClass)(SourceFile, {}, {});
  return {get SourceFile() {
      return SourceFile;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/util/ArrayMap", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/util/ArrayMap";
  var ArrayMap = function ArrayMap() {
    this.values_ = [];
    this.keys_ = [];
  };
  ($traceurRuntime.createClass)(ArrayMap, {
    has: function(key) {
      return this.keys_.indexOf(key) != - 1;
    },
    get: function(key) {
      var index = this.keys_.indexOf(key);
      if (index == - 1) {
        return undefined;
      }
      return this.values_[index];
    },
    set: function(key, value) {
      var index = this.keys_.indexOf(key);
      if (index == - 1) {
        this.keys_.push(key);
        this.values_.push(value);
      } else {
        this.values_[index] = value;
      }
    },
    addAll: function(other) {
      var keys = other.keys();
      var values = other.values();
      for (var i = 0; i < keys.length; i++) {
        this.set(keys[i], values[i]);
      }
    },
    remove: function(key) {
      var index = this.keys_.indexOf(key);
      if (index == - 1) {
        return;
      }
      this.keys_.splice(index, 1);
      this.values_.splice(index, 1);
    },
    keys: function() {
      return this.keys_.concat();
    },
    values: function() {
      return this.values_.concat();
    }
  }, {});
  return {get ArrayMap() {
      return ArrayMap;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/util/MutedErrorReporter", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/util/MutedErrorReporter";
  var ErrorReporter = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/ErrorReporter").ErrorReporter;
  var MutedErrorReporter = function MutedErrorReporter() {
    $traceurRuntime.defaultSuperCall(this, $MutedErrorReporter.prototype, arguments);
  };
  var $MutedErrorReporter = MutedErrorReporter;
  ($traceurRuntime.createClass)(MutedErrorReporter, {reportMessageInternal: function(location, format, args) {}}, {}, ErrorReporter);
  return {get MutedErrorReporter() {
      return MutedErrorReporter;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/PlaceholderParser", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/PlaceholderParser";
  var ArrayMap = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/ArrayMap").ArrayMap;
  var $__97 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      ARGUMENT_LIST = $__97.ARGUMENT_LIST,
      BLOCK = $__97.BLOCK,
      EXPRESSION_STATEMENT = $__97.EXPRESSION_STATEMENT,
      IDENTIFIER_EXPRESSION = $__97.IDENTIFIER_EXPRESSION;
  var IdentifierToken = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/IdentifierToken").IdentifierToken;
  var LiteralToken = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/LiteralToken").LiteralToken;
  var MutedErrorReporter = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/MutedErrorReporter").MutedErrorReporter;
  var ParseTree = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTree").ParseTree;
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var Parser = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Parser").Parser;
  var $__97 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      LiteralExpression = $__97.LiteralExpression,
      LiteralPropertyName = $__97.LiteralPropertyName,
      PropertyMethodAssignment = $__97.PropertyMethodAssignment,
      PropertyNameAssignment = $__97.PropertyNameAssignment,
      PropertyNameShorthand = $__97.PropertyNameShorthand;
  var SourceFile = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/SourceFile").SourceFile;
  var IDENTIFIER = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").IDENTIFIER;
  var $__97 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createArrayLiteralExpression = $__97.createArrayLiteralExpression,
      createBindingIdentifier = $__97.createBindingIdentifier,
      createBlock = $__97.createBlock,
      createBooleanLiteral = $__97.createBooleanLiteral,
      createCommaExpression = $__97.createCommaExpression,
      createExpressionStatement = $__97.createExpressionStatement,
      createFunctionBody = $__97.createFunctionBody,
      createGetAccessor = $__97.createGetAccessor,
      createIdentifierExpression = $__97.createIdentifierExpression,
      createIdentifierToken = $__97.createIdentifierToken,
      createMemberExpression = $__97.createMemberExpression,
      createNullLiteral = $__97.createNullLiteral,
      createNumberLiteral = $__97.createNumberLiteral,
      createParenExpression = $__97.createParenExpression,
      createSetAccessor = $__97.createSetAccessor,
      createStringLiteral = $__97.createStringLiteral,
      createVoid0 = $__97.createVoid0;
  var NOT_FOUND = {};
  var PREFIX = '$__placeholder__';
  var cache = new ArrayMap();
  function parseExpression(sourceLiterals) {
    for (var values = [],
        $__93 = 1; $__93 < arguments.length; $__93++) values[$__93 - 1] = arguments[$__93];
    return parse(sourceLiterals, values, (function() {
      return new PlaceholderParser().parseExpression(sourceLiterals);
    }));
  }
  function parseStatement(sourceLiterals) {
    for (var values = [],
        $__94 = 1; $__94 < arguments.length; $__94++) values[$__94 - 1] = arguments[$__94];
    return parse(sourceLiterals, values, (function() {
      return new PlaceholderParser().parseStatement(sourceLiterals);
    }));
  }
  function parseStatements(sourceLiterals) {
    for (var values = [],
        $__95 = 1; $__95 < arguments.length; $__95++) values[$__95 - 1] = arguments[$__95];
    return parse(sourceLiterals, values, (function() {
      return new PlaceholderParser().parseStatements(sourceLiterals);
    }));
  }
  function parsePropertyDefinition(sourceLiterals) {
    for (var values = [],
        $__96 = 1; $__96 < arguments.length; $__96++) values[$__96 - 1] = arguments[$__96];
    return parse(sourceLiterals, values, (function() {
      return new PlaceholderParser().parsePropertyDefinition(sourceLiterals);
    }));
  }
  function parse(sourceLiterals, values, doParse) {
    var tree = cache.get(sourceLiterals);
    if (!tree) {
      tree = doParse();
      cache.set(sourceLiterals, tree);
    }
    if (!values.length) return tree;
    if (tree instanceof ParseTree) return new PlaceholderTransformer(values).transformAny(tree);
    return new PlaceholderTransformer(values).transformList(tree);
  }
  var counter = 0;
  var PlaceholderParser = function PlaceholderParser() {};
  ($traceurRuntime.createClass)(PlaceholderParser, {
    parseExpression: function(sourceLiterals) {
      return this.parse_(sourceLiterals, (function(p) {
        return p.parseExpression();
      }));
    },
    parseStatement: function(sourceLiterals) {
      return this.parse_(sourceLiterals, (function(p) {
        return p.parseStatement();
      }));
    },
    parseStatements: function(sourceLiterals) {
      return this.parse_(sourceLiterals, (function(p) {
        return p.parseStatements();
      }));
    },
    parsePropertyDefinition: function(sourceLiterals) {
      return this.parse_(sourceLiterals, (function(p) {
        return p.parsePropertyDefinition();
      }));
    },
    parse_: function(sourceLiterals, doParse) {
      var source = sourceLiterals[0];
      for (var i = 1; i < sourceLiterals.length; i++) {
        source += PREFIX + (i - 1) + sourceLiterals[i];
      }
      var file = new SourceFile('@traceur/generated/TemplateParser/' + counter++, source);
      var errorReporter = new MutedErrorReporter();
      var parser = new Parser(file, errorReporter);
      var tree = doParse(parser);
      if (errorReporter.hadError() || !tree || !parser.isAtEnd()) throw new Error(("Internal error trying to parse:\n\n" + source));
      return tree;
    }
  }, {});
  function convertValueToExpression(value) {
    if (value instanceof ParseTree) return value;
    if (value instanceof IdentifierToken) return createIdentifierExpression(value);
    if (value instanceof LiteralToken) return new LiteralExpression(value.location, value);
    if (Array.isArray(value)) {
      if (value[0]instanceof ParseTree) {
        if (value.length === 1) return value[0];
        if (value[0].isStatement()) return createBlock(value); else return createParenExpression(createCommaExpression(value));
      }
      return createArrayLiteralExpression(value.map(convertValueToExpression));
    }
    if (value === null) return createNullLiteral();
    if (value === undefined) return createVoid0();
    switch (typeof value) {
      case 'string':
        return createStringLiteral(value);
      case 'boolean':
        return createBooleanLiteral(value);
      case 'number':
        return createNumberLiteral(value);
    }
    throw new Error('Not implemented');
  }
  function convertValueToIdentifierToken(value) {
    if (value instanceof IdentifierToken) return value;
    return createIdentifierToken(value);
  }
  var PlaceholderTransformer = function PlaceholderTransformer(values) {
    $traceurRuntime.superCall(this, $PlaceholderTransformer.prototype, "constructor", []);
    this.values = values;
  };
  var $PlaceholderTransformer = PlaceholderTransformer;
  ($traceurRuntime.createClass)(PlaceholderTransformer, {
    getValueAt: function(index) {
      return this.values[index];
    },
    getValue_: function(str) {
      if (str.indexOf(PREFIX) !== 0) return NOT_FOUND;
      return this.getValueAt(Number(str.slice(PREFIX.length)));
    },
    transformIdentifierExpression: function(tree) {
      var value = this.getValue_(tree.identifierToken.value);
      if (value === NOT_FOUND) return tree;
      return convertValueToExpression(value);
    },
    transformBindingIdentifier: function(tree) {
      var value = this.getValue_(tree.identifierToken.value);
      if (value === NOT_FOUND) return tree;
      return createBindingIdentifier(value);
    },
    transformExpressionStatement: function(tree) {
      if (tree.expression.type === IDENTIFIER_EXPRESSION) {
        var transformedExpression = this.transformIdentifierExpression(tree.expression);
        if (transformedExpression === tree.expression) return tree;
        if (transformedExpression.isStatement()) return transformedExpression;
        return createExpressionStatement(transformedExpression);
      }
      return $traceurRuntime.superCall(this, $PlaceholderTransformer.prototype, "transformExpressionStatement", [tree]);
    },
    transformBlock: function(tree) {
      if (tree.statements.length === 1 && tree.statements[0].type === EXPRESSION_STATEMENT) {
        var transformedStatement = this.transformExpressionStatement(tree.statements[0]);
        if (transformedStatement === tree.statements[0]) return tree;
        if (transformedStatement.type === BLOCK) return transformedStatement;
      }
      return $traceurRuntime.superCall(this, $PlaceholderTransformer.prototype, "transformBlock", [tree]);
    },
    transformFunctionBody: function(tree) {
      if (tree.statements.length === 1 && tree.statements[0].type === EXPRESSION_STATEMENT) {
        var transformedStatement = this.transformExpressionStatement(tree.statements[0]);
        if (transformedStatement === tree.statements[0]) return tree;
        if (transformedStatement.type === BLOCK) return createFunctionBody(transformedStatement.statements);
      }
      return $traceurRuntime.superCall(this, $PlaceholderTransformer.prototype, "transformFunctionBody", [tree]);
    },
    transformMemberExpression: function(tree) {
      var value = this.getValue_(tree.memberName.value);
      if (value === NOT_FOUND) return $traceurRuntime.superCall(this, $PlaceholderTransformer.prototype, "transformMemberExpression", [tree]);
      var operand = this.transformAny(tree.operand);
      return createMemberExpression(operand, value);
    },
    transformLiteralPropertyName: function(tree) {
      if (tree.literalToken.type === IDENTIFIER) {
        var value = this.getValue_(tree.literalToken.value);
        if (value !== NOT_FOUND) {
          return new LiteralPropertyName(null, convertValueToIdentifierToken(value));
        }
      }
      return $traceurRuntime.superCall(this, $PlaceholderTransformer.prototype, "transformLiteralPropertyName", [tree]);
    },
    transformArgumentList: function(tree) {
      if (tree.args.length === 1 && tree.args[0].type === IDENTIFIER_EXPRESSION) {
        var arg0 = this.transformAny(tree.args[0]);
        if (arg0 === tree.args[0]) return tree;
        if (arg0.type === ARGUMENT_LIST) return arg0;
      }
      return $traceurRuntime.superCall(this, $PlaceholderTransformer.prototype, "transformArgumentList", [tree]);
    }
  }, {}, ParseTreeTransformer);
  return {
    get parseExpression() {
      return parseExpression;
    },
    get parseStatement() {
      return parseStatement;
    },
    get parseStatements() {
      return parseStatements;
    },
    get parsePropertyDefinition() {
      return parsePropertyDefinition;
    },
    get PlaceholderParser() {
      return PlaceholderParser;
    },
    get PlaceholderTransformer() {
      return PlaceholderTransformer;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/PrependStatements", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/PrependStatements";
  var $__99 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      EXPRESSION_STATEMENT = $__99.EXPRESSION_STATEMENT,
      LITERAL_EXPRESSION = $__99.LITERAL_EXPRESSION;
  var STRING = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").STRING;
  function isStringExpressionStatement(tree) {
    return tree.type === EXPRESSION_STATEMENT && tree.expression.type === LITERAL_EXPRESSION && tree.expression.literalToken.type === STRING;
  }
  function prependStatements(statements) {
    for (var statementsToPrepend = [],
        $__98 = 1; $__98 < arguments.length; $__98++) statementsToPrepend[$__98 - 1] = arguments[$__98];
    if (!statements.length) return statementsToPrepend;
    if (!statementsToPrepend.length) return statements;
    var transformed = [];
    var inProlog = true;
    statements.forEach((function(statement) {
      var $__100;
      if (inProlog && !isStringExpressionStatement(statement)) {
        ($__100 = transformed).push.apply($__100, $traceurRuntime.toObject(statementsToPrepend));
        inProlog = false;
      }
      transformed.push(statement);
    }));
    return transformed;
  }
  return {get prependStatements() {
      return prependStatements;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/TempVarTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/TempVarTransformer";
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var $__102 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      Module = $__102.Module,
      Script = $__102.Script;
  var ARGUMENTS = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/PredefinedName").ARGUMENTS;
  var VAR = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").VAR;
  var $__102 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createFunctionBody = $__102.createFunctionBody,
      createThisExpression = $__102.createThisExpression,
      createIdentifierExpression = $__102.createIdentifierExpression,
      createVariableDeclaration = $__102.createVariableDeclaration,
      createVariableDeclarationList = $__102.createVariableDeclarationList,
      createVariableStatement = $__102.createVariableStatement;
  var prependStatements = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PrependStatements").prependStatements;
  function getVars(self) {
    var vars = self.tempVarStack_[self.tempVarStack_.length - 1];
    if (!vars) throw new Error('Invalid use of addTempVar');
    return vars;
  }
  var TempVarStatement = function TempVarStatement(name, initialiser) {
    this.name = name;
    this.initialiser = initialiser;
  };
  ($traceurRuntime.createClass)(TempVarStatement, {}, {});
  var TempScope = function TempScope() {
    this.thisName = null;
    this.argumentName = null;
    this.identifiers = [];
  };
  ($traceurRuntime.createClass)(TempScope, {
    push: function(identifier) {
      this.identifiers.push(identifier);
    },
    pop: function() {
      return this.identifiers.pop();
    },
    release: function(obj) {
      for (var i = this.identifiers.length - 1; i >= 0; i--) {
        obj.release_(this.identifiers[i]);
      }
    }
  }, {});
  var TempVarTransformer = function TempVarTransformer(identifierGenerator) {
    $traceurRuntime.superCall(this, $TempVarTransformer.prototype, "constructor", []);
    this.identifierGenerator = identifierGenerator;
    this.tempVarStack_ = [[]];
    this.tempScopeStack_ = [new TempScope()];
    this.namePool_ = [];
  };
  var $TempVarTransformer = TempVarTransformer;
  ($traceurRuntime.createClass)(TempVarTransformer, {
    transformStatements_: function(statements) {
      this.tempVarStack_.push([]);
      var transformedStatements = this.transformList(statements);
      var vars = this.tempVarStack_.pop();
      if (!vars.length) return transformedStatements;
      var seenNames = Object.create(null);
      vars = vars.filter((function(tempVarStatement) {
        var $__102 = tempVarStatement,
            name = $__102.name,
            initialiser = $__102.initialiser;
        if (name in seenNames) {
          if (seenNames[name].initialiser || initialiser) throw new Error('Invalid use of TempVarTransformer');
          return false;
        }
        seenNames[name] = tempVarStatement;
        return true;
      }));
      var variableStatement = createVariableStatement(createVariableDeclarationList(VAR, vars.map((function($__102) {
        var name = $__102.name,
            initialiser = $__102.initialiser;
        return createVariableDeclaration(name, initialiser);
      }))));
      return prependStatements(transformedStatements, variableStatement);
    },
    transformScript: function(tree) {
      var scriptItemList = this.transformStatements_(tree.scriptItemList);
      if (scriptItemList == tree.scriptItemList) {
        return tree;
      }
      return new Script(tree.location, scriptItemList, tree.moduleName);
    },
    transformModule: function(tree) {
      var scriptItemList = this.transformStatements_(tree.scriptItemList);
      if (scriptItemList == tree.scriptItemList) {
        return tree;
      }
      return new Module(tree.location, scriptItemList, tree.moduleName);
    },
    transformFunctionBody: function(tree) {
      this.pushTempVarState();
      var statements = this.transformStatements_(tree.statements);
      this.popTempVarState();
      if (statements == tree.statements) return tree;
      return createFunctionBody(statements);
    },
    getTempIdentifier: function() {
      var name = this.namePool_.length ? this.namePool_.pop(): this.identifierGenerator.generateUniqueIdentifier();
      this.tempScopeStack_[this.tempScopeStack_.length - 1].push(name);
      return name;
    },
    addTempVar: function() {
      var initialiser = arguments[0] !== (void 0) ? arguments[0]: null;
      var vars = getVars(this);
      var uid = this.getTempIdentifier();
      vars.push(new TempVarStatement(uid, initialiser));
      return uid;
    },
    addTempVarForThis: function() {
      var tempScope = this.tempScopeStack_[this.tempScopeStack_.length - 1];
      return tempScope.thisName || (tempScope.thisName = this.addTempVar(createThisExpression()));
    },
    addTempVarForArguments: function() {
      var tempScope = this.tempScopeStack_[this.tempScopeStack_.length - 1];
      return tempScope.argumentName || (tempScope.argumentName = this.addTempVar(createIdentifierExpression(ARGUMENTS)));
    },
    pushTempVarState: function() {
      this.tempScopeStack_.push(new TempScope());
    },
    popTempVarState: function() {
      this.tempScopeStack_.pop().release(this);
    },
    release_: function(name) {
      this.namePool_.push(name);
    }
  }, {}, ParseTreeTransformer);
  return {get TempVarTransformer() {
      return TempVarTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/semantics/ModuleSymbol", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/semantics/ModuleSymbol";
  var assert = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/assert").assert;
  var ExportsList = function ExportsList(normalizedName) {
    this.exports_ = Object.create(null);
    if (normalizedName !== null) this.normalizedName = normalizedName.replace(/\\/g, '/'); else this.normalizedName = null;
  };
  ($traceurRuntime.createClass)(ExportsList, {
    addExport: function(name, tree) {
      assert(!this.exports_[name]);
      this.exports_[name] = tree;
    },
    getExport: function(name) {
      return this.exports_[name];
    },
    getExports: function() {
      return Object.keys(this.exports_);
    }
  }, {});
  var ModuleDescription = function ModuleDescription(normalizedName, module) {
    var $__103 = this;
    $traceurRuntime.superCall(this, $ModuleDescription.prototype, "constructor", [normalizedName]);
    Object.getOwnPropertyNames(module).forEach((function(name) {
      $__103.addExport(name, true);
    }));
  };
  var $ModuleDescription = ModuleDescription;
  ($traceurRuntime.createClass)(ModuleDescription, {}, {}, ExportsList);
  var ModuleSymbol = function ModuleSymbol(tree, normalizedName) {
    $traceurRuntime.superCall(this, $ModuleSymbol.prototype, "constructor", [normalizedName]);
    this.tree = tree;
    this.imports_ = Object.create(null);
  };
  var $ModuleSymbol = ModuleSymbol;
  ($traceurRuntime.createClass)(ModuleSymbol, {
    addImport: function(name, tree) {
      assert(!this.imports_[name]);
      this.imports_[name] = tree;
    },
    getImport: function(name) {
      return this.imports_[name];
    }
  }, {}, ExportsList);
  return {
    get ModuleDescription() {
      return ModuleDescription;
    },
    get ModuleSymbol() {
      return ModuleSymbol;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/module/ModuleVisitor", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/module/ModuleVisitor";
  var ModuleDescription = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/semantics/ModuleSymbol").ModuleDescription;
  var ParseTree = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTree").ParseTree;
  var ParseTreeVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/ParseTreeVisitor").ParseTreeVisitor;
  var $__108 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      MODULE_DECLARATION = $__108.MODULE_DECLARATION,
      EXPORT_DECLARATION = $__108.EXPORT_DECLARATION,
      IMPORT_DECLARATION = $__108.IMPORT_DECLARATION;
  var ModuleVisitor = function ModuleVisitor(reporter, loader, moduleSymbol) {
    this.reporter = reporter;
    this.loader_ = loader;
    this.moduleSymbol = moduleSymbol;
  };
  ($traceurRuntime.createClass)(ModuleVisitor, {
    getModuleDescriptionFromCodeUnit_: function(name, codeUnitToModuleInfo) {
      var referrer = this.moduleSymbol.normalizedName;
      var codeUnit = this.loader_.getCodeUnitForModuleSpecifier(name, referrer);
      var moduleDescription = codeUnitToModuleInfo(codeUnit);
      if (!moduleDescription) {
        var msg = (name + " is not a module, required by " + referrer);
        this.reportError(codeUnit.metadata.tree, msg);
        return null;
      }
      return moduleDescription;
    },
    getModuleSymbolForModuleSpecifier: function(name) {
      return this.getModuleDescriptionFromCodeUnit_(name, (function(codeUnit) {
        return codeUnit.metadata.moduleSymbol;
      }));
    },
    getModuleDescriptionForModuleSpecifier: function(name) {
      return this.getModuleDescriptionFromCodeUnit_(name, (function(codeUnit) {
        var moduleDescription = codeUnit.metadata.moduleSymbol;
        if (!moduleDescription && codeUnit.result) {
          moduleDescription = new ModuleDescription(codeUnit.normalizedName, codeUnit.result);
        }
        return moduleDescription;
      }));
    },
    visitFunctionDeclaration: function(tree) {},
    visitFunctionExpression: function(tree) {},
    visitFunctionBody: function(tree) {},
    visitBlock: function(tree) {},
    visitClassDeclaration: function(tree) {},
    visitClassExpression: function(tree) {},
    visitModuleElement_: function(element) {
      switch (element.type) {
        case MODULE_DECLARATION:
        case EXPORT_DECLARATION:
        case IMPORT_DECLARATION:
          this.visitAny(element);
      }
    },
    visitScript: function(tree) {
      tree.scriptItemList.forEach(this.visitModuleElement_, this);
    },
    visitModule: function(tree) {
      tree.scriptItemList.forEach(this.visitModuleElement_, this);
    },
    reportError: function(tree, format) {
      var $__109;
      for (var args = [],
          $__107 = 2; $__107 < arguments.length; $__107++) args[$__107 - 2] = arguments[$__107];
      ($__109 = this.reporter).reportError.apply($__109, $traceurRuntime.spread([tree.location.start, format], args));
    }
  }, {}, ParseTreeVisitor);
  return {get ModuleVisitor() {
      return ModuleVisitor;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/module/ExportVisitor", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/module/ExportVisitor";
  var ModuleVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/module/ModuleVisitor").ModuleVisitor;
  var assert = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/assert").assert;
  var ExportVisitor = function ExportVisitor(reporter, loaderHooks, moduleSymbol) {
    $traceurRuntime.superCall(this, $ExportVisitor.prototype, "constructor", [reporter, loaderHooks, moduleSymbol]);
    this.inExport_ = false;
    this.moduleSpecifier = null;
  };
  var $ExportVisitor = ExportVisitor;
  ($traceurRuntime.createClass)(ExportVisitor, {
    addExport_: function(name, tree) {
      assert(typeof name == 'string');
      if (this.inExport_) this.addExport(name, tree);
    },
    addExport: function(name, tree) {
      var moduleSymbol = this.moduleSymbol;
      var existingExport = moduleSymbol.getExport(name);
      if (existingExport) {
        this.reportError(tree, ("Duplicate export. '" + name + "' was previously ") + ("exported at " + existingExport.location.start));
      } else {
        moduleSymbol.addExport(name, tree);
      }
    },
    visitClassDeclaration: function(tree) {
      this.addExport_(tree.name.identifierToken.value, tree);
    },
    visitExportDeclaration: function(tree) {
      this.inExport_ = true;
      this.visitAny(tree.declaration);
      this.inExport_ = false;
    },
    visitNamedExport: function(tree) {
      this.moduleSpecifier = tree.moduleSpecifier;
      this.visitAny(tree.specifierSet);
      this.moduleSpecifier = null;
    },
    visitExportDefault: function(tree) {
      this.addExport_('default', tree);
    },
    visitExportSpecifier: function(tree) {
      this.addExport_((tree.rhs || tree.lhs).value, tree);
    },
    visitExportStar: function(tree) {
      var $__110 = this;
      var name = this.moduleSpecifier.token.processedValue;
      var moduleDescription = this.getModuleDescriptionForModuleSpecifier(name);
      if (moduleDescription) {
        moduleDescription.getExports().forEach((function(name) {
          $__110.addExport(name, tree);
        }));
      }
    },
    visitFunctionDeclaration: function(tree) {
      this.addExport_(tree.name.identifierToken.value, tree);
    },
    visitModuleDeclaration: function(tree) {
      this.addExport_(tree.identifier.value, tree);
    },
    visitVariableDeclaration: function(tree) {
      this.addExport_(tree.lvalue.identifierToken.value, tree);
    }
  }, {}, ModuleVisitor);
  return {get ExportVisitor() {
      return ExportVisitor;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/module/DirectExportVisitor", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/module/DirectExportVisitor";
  var ExportVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/module/ExportVisitor").ExportVisitor;
  var DirectExportVisitor = function DirectExportVisitor() {
    $traceurRuntime.superCall(this, $DirectExportVisitor.prototype, "constructor", [null, null, null]);
    this.namedExports = [];
    this.starExports = [];
  };
  var $DirectExportVisitor = DirectExportVisitor;
  ($traceurRuntime.createClass)(DirectExportVisitor, {
    addExport: function(name, tree) {
      this.namedExports.push({
        name: name,
        tree: tree,
        moduleSpecifier: this.moduleSpecifier
      });
    },
    visitExportStar: function(tree) {
      this.starExports.push(this.moduleSpecifier);
    },
    hasExports: function() {
      return this.namedExports.length != 0 || this.starExports.length != 0;
    }
  }, {}, ExportVisitor);
  return {get DirectExportVisitor() {
      return DirectExportVisitor;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/ModuleTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/ModuleTransformer";
  var $__115 = Object.freeze(Object.defineProperties(["var __moduleName = ", ";"], {raw: {value: Object.freeze(["var __moduleName = ", ";"])}})),
      $__116 = Object.freeze(Object.defineProperties(["function() {\n      ", "\n    }"], {raw: {value: Object.freeze(["function() {\n      ", "\n    }"])}})),
      $__117 = Object.freeze(Object.defineProperties(["$traceurRuntime.ModuleStore.getAnonymousModule(\n              ", ");"], {raw: {value: Object.freeze(["$traceurRuntime.ModuleStore.getAnonymousModule(\n              ", ");"])}})),
      $__118 = Object.freeze(Object.defineProperties(["$traceurRuntime.ModuleStore.registerModule(", ",\n            ", ");"], {raw: {value: Object.freeze(["$traceurRuntime.ModuleStore.registerModule(", ",\n            ", ");"])}})),
      $__119 = Object.freeze(Object.defineProperties(["get ", "() { return ", "; }"], {raw: {value: Object.freeze(["get ", "() { return ", "; }"])}})),
      $__120 = Object.freeze(Object.defineProperties(["return $traceurRuntime.exportStar(", ")"], {raw: {value: Object.freeze(["return $traceurRuntime.exportStar(", ")"])}})),
      $__121 = Object.freeze(Object.defineProperties(["return ", ""], {raw: {value: Object.freeze(["return ", ""])}})),
      $__122 = Object.freeze(Object.defineProperties(["var $__default = ", ""], {raw: {value: Object.freeze(["var $__default = ", ""])}})),
      $__123 = Object.freeze(Object.defineProperties(["$traceurRuntime.ModuleStore.get(", ")"], {raw: {value: Object.freeze(["$traceurRuntime.ModuleStore.get(", ")"])}})),
      $__124 = Object.freeze(Object.defineProperties(["$traceurRuntime.getModuleImpl(", ")"], {raw: {value: Object.freeze(["$traceurRuntime.getModuleImpl(", ")"])}}));
  var $__127 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      BindingElement = $__127.BindingElement,
      BindingIdentifier = $__127.BindingIdentifier,
      EmptyStatement = $__127.EmptyStatement,
      LiteralPropertyName = $__127.LiteralPropertyName,
      ObjectPattern = $__127.ObjectPattern,
      ObjectPatternField = $__127.ObjectPatternField,
      Script = $__127.Script;
  var DirectExportVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/module/DirectExportVisitor").DirectExportVisitor;
  var TempVarTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/TempVarTransformer").TempVarTransformer;
  var $__127 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      EXPORT_DEFAULT = $__127.EXPORT_DEFAULT,
      EXPORT_SPECIFIER = $__127.EXPORT_SPECIFIER;
  var VAR = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").VAR;
  var assert = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/assert").assert;
  var $__127 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createArgumentList = $__127.createArgumentList,
      createBindingIdentifier = $__127.createBindingIdentifier,
      createExpressionStatement = $__127.createExpressionStatement,
      createIdentifierExpression = $__127.createIdentifierExpression,
      createIdentifierToken = $__127.createIdentifierToken,
      createMemberExpression = $__127.createMemberExpression,
      createObjectLiteralExpression = $__127.createObjectLiteralExpression,
      createUseStrictDirective = $__127.createUseStrictDirective,
      createVariableStatement = $__127.createVariableStatement;
  var $__127 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser"),
      parseExpression = $__127.parseExpression,
      parsePropertyDefinition = $__127.parsePropertyDefinition,
      parseStatement = $__127.parseStatement,
      parseStatements = $__127.parseStatements;
  var ModuleTransformer = function ModuleTransformer(identifierGenerator) {
    $traceurRuntime.superCall(this, $ModuleTransformer.prototype, "constructor", [identifierGenerator]);
    this.exportVisitor_ = new DirectExportVisitor();
    this.moduleSpecifierKind_ = null;
    this.moduleName = null;
  };
  var $ModuleTransformer = ModuleTransformer;
  ($traceurRuntime.createClass)(ModuleTransformer, {
    getTempVarNameForModuleName: function(moduleName) {
      return '$__' + moduleName.replace(/[^a-zA-Z0-9$]/g, function(c) {
        return '_' + c.charCodeAt(0) + '_';
      }) + '__';
    },
    getTempVarNameForModuleSpecifier: function(moduleSpecifier) {
      var normalizedName = System.normalize(moduleSpecifier.token.processedValue, this.moduleName);
      return this.getTempVarNameForModuleName(normalizedName);
    },
    transformScript: function(tree) {
      this.moduleName = tree.moduleName;
      return $traceurRuntime.superCall(this, $ModuleTransformer.prototype, "transformScript", [tree]);
    },
    transformModule: function(tree) {
      this.moduleName = tree.moduleName;
      this.pushTempVarState();
      var statements = $traceurRuntime.spread([createUseStrictDirective(), parseStatement($__115, this.moduleName)], this.transformList(tree.scriptItemList), [this.createExportStatement()]);
      this.popTempVarState();
      statements = this.wrapModule(statements);
      return new Script(tree.location, statements);
    },
    wrapModule: function(statements) {
      var functionExpression = parseExpression($__116, statements);
      if (this.moduleName === null) {
        return parseStatements($__117, functionExpression);
      }
      return parseStatements($__118, this.moduleName, functionExpression);
    },
    getGetterExport: function($__127) {
      var name = $__127.name,
          tree = $__127.tree,
          moduleSpecifier = $__127.moduleSpecifier;
      var returnExpression;
      switch (tree.type) {
        case EXPORT_DEFAULT:
          returnExpression = createIdentifierExpression('$__default');
          break;
        case EXPORT_SPECIFIER:
          if (moduleSpecifier) {
            var idName = this.getTempVarNameForModuleSpecifier(moduleSpecifier);
            returnExpression = createMemberExpression(idName, tree.lhs);
          } else {
            returnExpression = createIdentifierExpression(tree.lhs);
          }
          break;
        default:
          returnExpression = createIdentifierExpression(name);
          break;
      }
      return parsePropertyDefinition($__119, name, returnExpression);
    },
    getExportProperties: function() {
      var $__125 = this;
      return this.exportVisitor_.namedExports.map((function(exp) {
        return $__125.getGetterExport(exp);
      }));
    },
    createExportStatement: function() {
      var $__125 = this;
      var object = createObjectLiteralExpression(this.getExportProperties());
      if (this.exportVisitor_.starExports.length) {
        var starExports = this.exportVisitor_.starExports;
        var starIdents = starExports.map((function(moduleSpecifier) {
          return createIdentifierExpression($__125.getTempVarNameForModuleSpecifier(moduleSpecifier));
        }));
        var args = createArgumentList.apply(null, $traceurRuntime.spread([object], starIdents));
        return parseStatement($__120, args);
      }
      return parseStatement($__121, object);
    },
    hasExports: function() {
      return this.exportVisitor_.hasExports();
    },
    transformExportDeclaration: function(tree) {
      this.exportVisitor_.visitAny(tree);
      return this.transformAny(tree.declaration);
    },
    transformExportDefault: function(tree) {
      return parseStatement($__122, tree.expression);
    },
    transformNamedExport: function(tree) {
      var moduleSpecifier = tree.moduleSpecifier;
      if (moduleSpecifier) {
        var expression = this.transformAny(moduleSpecifier);
        var idName = this.getTempVarNameForModuleSpecifier(moduleSpecifier);
        return createVariableStatement(VAR, idName, expression);
      }
      return new EmptyStatement(null);
    },
    transformModuleSpecifier: function(tree) {
      assert(this.moduleName);
      var name = tree.token.processedValue;
      var normalizedName = System.normalize(name, this.moduleName);
      if (this.moduleSpecifierKind_ === 'module') return parseExpression($__123, normalizedName);
      return parseExpression($__124, normalizedName);
    },
    transformModuleDeclaration: function(tree) {
      this.moduleSpecifierKind_ = 'module';
      var initialiser = this.transformAny(tree.expression);
      return createVariableStatement(VAR, tree.identifier, initialiser);
    },
    transformImportedBinding: function(tree) {
      var bindingElement = new BindingElement(tree.location, tree.binding, null);
      var name = new LiteralPropertyName(null, createIdentifierToken('default'));
      return new ObjectPattern(null, [new ObjectPatternField(null, name, bindingElement)]);
    },
    transformImportDeclaration: function(tree) {
      this.moduleSpecifierKind_ = 'import';
      if (!tree.importClause) return createExpressionStatement(this.transformAny(tree.moduleSpecifier));
      var binding = this.transformAny(tree.importClause);
      var initialiser = this.transformAny(tree.moduleSpecifier);
      return createVariableStatement(VAR, binding, initialiser);
    },
    transformImportSpecifierSet: function(tree) {
      var fields = this.transformList(tree.specifiers);
      return new ObjectPattern(null, fields);
    },
    transformImportSpecifier: function(tree) {
      if (tree.rhs) {
        var binding = new BindingIdentifier(tree.location, tree.rhs);
        var bindingElement = new BindingElement(tree.location, binding, null);
        var name = new LiteralPropertyName(tree.lhs.location, tree.lhs);
        return new ObjectPatternField(tree.location, name, bindingElement);
      }
      return new BindingElement(tree.location, createBindingIdentifier(tree.lhs), null);
    }
  }, {}, TempVarTransformer);
  return {get ModuleTransformer() {
      return ModuleTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/globalThis", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/globalThis";
  var $__128 = Object.freeze(Object.defineProperties(["typeof global !== 'undefined' ? global : this"], {raw: {value: Object.freeze(["typeof global !== 'undefined' ? global : this"])}}));
  var parseExpression = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser").parseExpression;
  var expr;
  function globalThis() {
    if (!expr) expr = parseExpression($__128);
    return expr;
  }
  var $__default = globalThis;
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/FindVisitor", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/FindVisitor";
  var ParseTreeVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/ParseTreeVisitor").ParseTreeVisitor;
  var foundSentinel = {};
  var FindVisitor = function FindVisitor(tree) {
    var keepOnGoing = arguments[1];
    this.found_ = false;
    this.keepOnGoing_ = keepOnGoing;
    try {
      this.visitAny(tree);
    } catch (ex) {
      if (ex !== foundSentinel) throw ex;
    }
  };
  ($traceurRuntime.createClass)(FindVisitor, {
    get found() {
      return this.found_;
    },
    set found(v) {
      if (v) {
        this.found_ = true;
        if (!this.keepOnGoing_) throw foundSentinel;
      }
    }
  }, {}, ParseTreeVisitor);
  return {get FindVisitor() {
      return FindVisitor;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/FindInFunctionScope", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/FindInFunctionScope";
  var FindVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/FindVisitor").FindVisitor;
  var FindInFunctionScope = function FindInFunctionScope() {
    $traceurRuntime.defaultSuperCall(this, $FindInFunctionScope.prototype, arguments);
  };
  var $FindInFunctionScope = FindInFunctionScope;
  ($traceurRuntime.createClass)(FindInFunctionScope, {
    visitFunctionDeclaration: function(tree) {},
    visitFunctionExpression: function(tree) {},
    visitSetAccessor: function(tree) {},
    visitGetAccessor: function(tree) {},
    visitPropertyMethodAssignment: function(tree) {}
  }, {}, FindVisitor);
  return {get FindInFunctionScope() {
      return FindInFunctionScope;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/scopeContainsThis", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/scopeContainsThis";
  var FindInFunctionScope = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/FindInFunctionScope").FindInFunctionScope;
  var FindThis = function FindThis() {
    $traceurRuntime.defaultSuperCall(this, $FindThis.prototype, arguments);
  };
  var $FindThis = FindThis;
  ($traceurRuntime.createClass)(FindThis, {visitThisExpression: function(tree) {
      this.found = true;
    }}, {}, FindInFunctionScope);
  function scopeContainsThis(tree) {
    var visitor = new FindThis(tree);
    return visitor.found;
  }
  var $__default = scopeContainsThis;
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/AmdTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/AmdTransformer";
  var $__136 = Object.freeze(Object.defineProperties(["__transpiledModule: true"], {raw: {value: Object.freeze(["__transpiledModule: true"])}})),
      $__137 = Object.freeze(Object.defineProperties(["function(", ") {\n      ", "\n    }"], {raw: {value: Object.freeze(["function(", ") {\n      ", "\n    }"])}})),
      $__138 = Object.freeze(Object.defineProperties(["", ".bind(", ")"], {raw: {value: Object.freeze(["", ".bind(", ")"])}})),
      $__139 = Object.freeze(Object.defineProperties(["define(", ", ", ");"], {raw: {value: Object.freeze(["define(", ", ", ");"])}}));
  var ModuleTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ModuleTransformer").ModuleTransformer;
  var VAR = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").VAR;
  var createBindingIdentifier = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory").createBindingIdentifier;
  var globalThis = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/globalThis").default;
  var $__141 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser"),
      parseExpression = $__141.parseExpression,
      parseStatement = $__141.parseStatement,
      parseStatements = $__141.parseStatements,
      parsePropertyDefinition = $__141.parsePropertyDefinition;
  var scopeContainsThis = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/scopeContainsThis").default;
  var AmdTransformer = function AmdTransformer(identifierGenerator) {
    $traceurRuntime.superCall(this, $AmdTransformer.prototype, "constructor", [identifierGenerator]);
    this.dependencies = [];
  };
  var $AmdTransformer = AmdTransformer;
  ($traceurRuntime.createClass)(AmdTransformer, {
    getExportProperties: function() {
      var properties = $traceurRuntime.superCall(this, $AmdTransformer.prototype, "getExportProperties", []);
      if (this.exportVisitor_.hasExports()) properties.push(parsePropertyDefinition($__136));
      return properties;
    },
    wrapModule: function(statements) {
      var depPaths = this.dependencies.map((function(dep) {
        return dep.path;
      }));
      var depLocals = this.dependencies.map((function(dep) {
        return dep.local;
      }));
      var hasTopLevelThis = statements.some(scopeContainsThis);
      var func = parseExpression($__137, depLocals, statements);
      if (hasTopLevelThis) func = parseExpression($__138, func, globalThis());
      return parseStatements($__139, depPaths, func);
    },
    transformModuleSpecifier: function(tree) {
      var localName = this.getTempIdentifier();
      this.dependencies.push({
        path: tree.token,
        local: localName
      });
      return createBindingIdentifier(localName);
    }
  }, {}, ModuleTransformer);
  return {get AmdTransformer() {
      return AmdTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/staticsemantics/PropName", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/staticsemantics/PropName";
  var $__142 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      COMPUTED_PROPERTY_NAME = $__142.COMPUTED_PROPERTY_NAME,
      GET_ACCESSOR = $__142.GET_ACCESSOR,
      LITERAL_PROPERTY_NAME = $__142.LITERAL_PROPERTY_NAME,
      PROPERTY_METHOD_ASSIGNMENT = $__142.PROPERTY_METHOD_ASSIGNMENT,
      PROPERTY_NAME_ASSIGNMENT = $__142.PROPERTY_NAME_ASSIGNMENT,
      PROPERTY_NAME_SHORTHAND = $__142.PROPERTY_NAME_SHORTHAND,
      SET_ACCESSOR = $__142.SET_ACCESSOR;
  var IDENTIFIER = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").IDENTIFIER;
  function propName(tree) {
    switch (tree.type) {
      case LITERAL_PROPERTY_NAME:
        var token = tree.literalToken;
        if (token.isKeyword() || token.type === IDENTIFIER) return token.toString();
        return String(tree.literalToken.processedValue);
      case COMPUTED_PROPERTY_NAME:
        return '';
      case PROPERTY_NAME_SHORTHAND:
        return tree.name.toString();
      case PROPERTY_METHOD_ASSIGNMENT:
      case PROPERTY_NAME_ASSIGNMENT:
      case GET_ACCESSOR:
      case SET_ACCESSOR:
        return propName(tree.name);
    }
  }
  return {get propName() {
      return propName;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/AnnotationsTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/AnnotationsTransformer";
  var $__143 = Object.freeze(Object.defineProperties(["Object.getOwnPropertyDescriptor(", ")"], {raw: {value: Object.freeze(["Object.getOwnPropertyDescriptor(", ")"])}}));
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var CONSTRUCTOR = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/PredefinedName").CONSTRUCTOR;
  var $__146 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      IDENTIFIER = $__146.IDENTIFIER,
      STRING = $__146.STRING;
  var $__146 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      AnonBlock = $__146.AnonBlock,
      ClassDeclaration = $__146.ClassDeclaration,
      ExportDeclaration = $__146.ExportDeclaration,
      FormalParameter = $__146.FormalParameter,
      FunctionDeclaration = $__146.FunctionDeclaration,
      GetAccessor = $__146.GetAccessor,
      LiteralExpression = $__146.LiteralExpression,
      PropertyMethodAssignment = $__146.PropertyMethodAssignment,
      SetAccessor = $__146.SetAccessor;
  var $__146 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      BINDING_IDENTIFIER = $__146.BINDING_IDENTIFIER,
      IDENTIFIER_EXPRESSION = $__146.IDENTIFIER_EXPRESSION;
  var propName = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/staticsemantics/PropName").propName;
  var $__146 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createArgumentList = $__146.createArgumentList,
      createArrayLiteralExpression = $__146.createArrayLiteralExpression,
      createAssignmentStatement = $__146.createAssignmentStatement,
      createIdentifierExpression = $__146.createIdentifierExpression,
      createMemberExpression = $__146.createMemberExpression,
      createNewExpression = $__146.createNewExpression,
      createStatementList = $__146.createStatementList,
      createStringLiteralToken = $__146.createStringLiteralToken;
  var parseExpression = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser").parseExpression;
  var AnnotationsScope = function AnnotationsScope() {
    this.className = null;
    this.isExport = false;
    this.constructorParameters = [];
    this.annotations = [];
    this.metadata = [];
  };
  ($traceurRuntime.createClass)(AnnotationsScope, {get inClassScope() {
      return this.className !== null;
    }}, {});
  var AnnotationsTransformer = function AnnotationsTransformer() {
    this.stack_ = [new AnnotationsScope()];
  };
  var $AnnotationsTransformer = AnnotationsTransformer;
  ($traceurRuntime.createClass)(AnnotationsTransformer, {
    transformExportDeclaration: function(tree) {
      var $__147;
      var scope = this.pushAnnotationScope_();
      scope.isExport = true;
      ($__147 = scope.annotations).push.apply($__147, $traceurRuntime.toObject(tree.annotations));
      var declaration = this.transformAny(tree.declaration);
      if (declaration !== tree.declaration || tree.annotations.length > 0) tree = new ExportDeclaration(tree.location, declaration, []);
      return this.appendMetadata_(tree);
    },
    transformClassDeclaration: function(tree) {
      var $__147;
      var elementsChanged = false;
      var exportAnnotations = this.scope.isExport ? this.scope.annotations: [];
      var scope = this.pushAnnotationScope_();
      scope.className = tree.name;
      ($__147 = scope.annotations).push.apply($__147, $traceurRuntime.spread(exportAnnotations, tree.annotations));
      tree = $traceurRuntime.superCall(this, $AnnotationsTransformer.prototype, "transformClassDeclaration", [tree]);
      ($__147 = scope.metadata).unshift.apply($__147, $traceurRuntime.toObject(this.transformMetadata_(createIdentifierExpression(tree.name), scope.annotations, scope.constructorParameters)));
      if (tree.annotations.length > 0) {
        tree = new ClassDeclaration(tree.location, tree.name, tree.superClass, tree.elements, []);
      }
      return this.appendMetadata_(tree);
    },
    transformFunctionDeclaration: function(tree) {
      var $__147;
      var exportAnnotations = this.scope.isExport ? this.scope.annotations: [];
      var scope = this.pushAnnotationScope_();
      ($__147 = scope.annotations).push.apply($__147, $traceurRuntime.spread(exportAnnotations, tree.annotations));
      ($__147 = scope.metadata).push.apply($__147, $traceurRuntime.toObject(this.transformMetadata_(createIdentifierExpression(tree.name), scope.annotations, tree.formalParameterList.parameters)));
      tree = $traceurRuntime.superCall(this, $AnnotationsTransformer.prototype, "transformFunctionDeclaration", [tree]);
      if (tree.annotations.length > 0) {
        tree = new FunctionDeclaration(tree.location, tree.name, tree.isGenerator, tree.formalParameterList, tree.typeAnnotation, [], tree.functionBody);
      }
      return this.appendMetadata_(tree);
    },
    transformFormalParameter: function(tree) {
      if (tree.annotations.length > 0) {
        tree = new FormalParameter(tree.location, tree.parameter, tree.typeAnnotation, []);
      }
      return $traceurRuntime.superCall(this, $AnnotationsTransformer.prototype, "transformFormalParameter", [tree]);
    },
    transformGetAccessor: function(tree) {
      var $__147;
      if (!this.scope.inClassScope) return $traceurRuntime.superCall(this, $AnnotationsTransformer.prototype, "transformGetAccessor", [tree]);
      ($__147 = this.scope.metadata).push.apply($__147, $traceurRuntime.toObject(this.transformMetadata_(this.transformAccessor_(tree, this.scope.className, 'get'), tree.annotations, [])));
      if (tree.annotations.length > 0) {
        tree = new GetAccessor(tree.location, tree.isStatic, tree.name, tree.typeAnnotation, [], tree.body);
      }
      return $traceurRuntime.superCall(this, $AnnotationsTransformer.prototype, "transformGetAccessor", [tree]);
    },
    transformSetAccessor: function(tree) {
      var $__147;
      if (!this.scope.inClassScope) return $traceurRuntime.superCall(this, $AnnotationsTransformer.prototype, "transformSetAccessor", [tree]);
      ($__147 = this.scope.metadata).push.apply($__147, $traceurRuntime.toObject(this.transformMetadata_(this.transformAccessor_(tree, this.scope.className, 'set'), tree.annotations, [tree.parameter])));
      var parameter = this.transformAny(tree.parameter);
      if (parameter !== tree.parameter || tree.annotations.length > 0) {
        tree = new SetAccessor(tree.location, tree.isStatic, tree.name, parameter, [], tree.body);
      }
      return $traceurRuntime.superCall(this, $AnnotationsTransformer.prototype, "transformSetAccessor", [tree]);
    },
    transformPropertyMethodAssignment: function(tree) {
      var $__147;
      if (!this.scope.inClassScope) return $traceurRuntime.superCall(this, $AnnotationsTransformer.prototype, "transformPropertyMethodAssignment", [tree]);
      if (!tree.isStatic && propName(tree) === CONSTRUCTOR) {
        ($__147 = this.scope.annotations).push.apply($__147, $traceurRuntime.toObject(tree.annotations));
        this.scope.constructorParameters = tree.formalParameterList.parameters;
      } else {
        ($__147 = this.scope.metadata).push.apply($__147, $traceurRuntime.toObject(this.transformMetadata_(this.transformPropertyMethod_(tree, this.scope.className), tree.annotations, tree.formalParameterList.parameters)));
      }
      var formalParameters = this.transformAny(tree.formalParameterList);
      if (formalParameters !== tree.formalParameterList || tree.annotations.length > 0) {
        tree = new PropertyMethodAssignment(tree.location, tree.isStatic, tree.isGenerator, tree.name, formalParameters, tree.typeAnnotation, [], tree.functionBody);
      }
      return $traceurRuntime.superCall(this, $AnnotationsTransformer.prototype, "transformPropertyMethodAssignment", [tree]);
    },
    appendMetadata_: function(tree) {
      var $__147;
      var metadata = this.stack_.pop().metadata;
      if (metadata.length > 0) {
        if (this.scope.isExport) {
          ($__147 = this.scope.metadata).push.apply($__147, $traceurRuntime.toObject(metadata));
        } else {
          tree = new AnonBlock(null, $traceurRuntime.spread([tree], metadata));
        }
      }
      return tree;
    },
    transformClassReference_: function(tree, className) {
      var parent = createIdentifierExpression(className);
      if (!tree.isStatic) parent = createMemberExpression(parent, 'prototype');
      return parent;
    },
    transformPropertyMethod_: function(tree, className) {
      return createMemberExpression(this.transformClassReference_(tree, className), tree.name.literalToken);
    },
    transformAccessor_: function(tree, className, accessor) {
      var args = createArgumentList([this.transformClassReference_(tree, className), this.createLiteralStringExpression_(tree.name)]);
      var descriptor = parseExpression($__143, args);
      return createMemberExpression(descriptor, accessor);
    },
    transformParameters_: function(parameters) {
      var $__144 = this;
      var hasParameterMetadata = false;
      parameters = parameters.map((function(param) {
        var $__147;
        var metadata = [];
        if (param.typeAnnotation) metadata.push(createIdentifierExpression(param.typeAnnotation.name.value));
        if (param.annotations && param.annotations.length > 0)($__147 = metadata).push.apply($__147, $traceurRuntime.toObject($__144.transformAnnotations_(param.annotations)));
        if (metadata.length > 0) {
          hasParameterMetadata = true;
          return createArrayLiteralExpression(metadata);
        }
        return createArrayLiteralExpression([]);
      }));
      return hasParameterMetadata ? parameters: [];
    },
    transformAnnotations_: function(annotations) {
      return annotations.map((function(annotation) {
        return createNewExpression(annotation.name, annotation.args);
      }));
    },
    transformMetadata_: function(target, annotations, parameters) {
      var metadataStatements = [];
      if (annotations !== null) {
        annotations = this.transformAnnotations_(annotations);
        if (annotations.length > 0) {
          metadataStatements.push(createAssignmentStatement(createMemberExpression(target, 'annotations'), createArrayLiteralExpression(annotations)));
        }
      }
      if (parameters !== null) {
        parameters = this.transformParameters_(parameters);
        if (parameters.length > 0) {
          metadataStatements.push(createAssignmentStatement(createMemberExpression(target, 'parameters'), createArrayLiteralExpression(parameters)));
        }
      }
      return metadataStatements;
    },
    createLiteralStringExpression_: function(tree) {
      var token = tree.literalToken;
      if (tree.literalToken.type !== STRING) token = createStringLiteralToken(tree.literalToken.value);
      return new LiteralExpression(null, token);
    },
    get scope() {
      return this.stack_[this.stack_.length - 1];
    },
    pushAnnotationScope_: function() {
      var scope = new AnnotationsScope();
      this.stack_.push(scope);
      return scope;
    }
  }, {}, ParseTreeTransformer);
  return {get AnnotationsTransformer() {
      return AnnotationsTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/semantics/VariableBinder", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/semantics/VariableBinder";
  var $__149 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      ARRAY_PATTERN = $__149.ARRAY_PATTERN,
      BINDING_ELEMENT = $__149.BINDING_ELEMENT,
      BINDING_IDENTIFIER = $__149.BINDING_IDENTIFIER,
      FORMAL_PARAMETER = $__149.FORMAL_PARAMETER,
      OBJECT_PATTERN = $__149.OBJECT_PATTERN,
      OBJECT_PATTERN_FIELD = $__149.OBJECT_PATTERN_FIELD,
      PAREN_EXPRESSION = $__149.PAREN_EXPRESSION,
      SPREAD_PATTERN_ELEMENT = $__149.SPREAD_PATTERN_ELEMENT;
  var ParseTreeVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/ParseTreeVisitor").ParseTreeVisitor;
  var VAR = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").VAR;
  var assert = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/assert").assert;
  function variablesInBlock(tree, includeFunctionScope) {
    var binder = new VariableBinder(includeFunctionScope, tree);
    binder.visitAny(tree);
    return binder.identifiers_;
  }
  ;
  function variablesInFunction(tree) {
    var binder = new VariableBinder(true, tree.functionBody);
    binder.bindVariablesInFunction_(tree);
    return binder.identifiers_;
  }
  ;
  var VariableBinder = function VariableBinder(includeFunctionScope, scope) {
    $traceurRuntime.superCall(this, $VariableBinder.prototype, "constructor", []);
    this.includeFunctionScope_ = includeFunctionScope;
    this.scope_ = scope || null;
    this.block_ = null;
    this.identifiers_ = Object.create(null);
  };
  var $VariableBinder = VariableBinder;
  ($traceurRuntime.createClass)(VariableBinder, {
    bindVariablesInFunction_: function(tree) {
      var parameters = tree.formalParameterList.parameters;
      for (var i = 0; i < parameters.length; i++) {
        this.bindParameter_(parameters[i]);
      }
      this.visitAny(tree.functionBody);
    },
    visitBlock: function(tree) {
      var parentBlock = this.block_;
      this.block_ = tree;
      this.visitList(tree.statements);
      this.block_ = parentBlock;
    },
    visitFunctionDeclaration: function(tree) {
      if (this.block_ == this.scope_) this.bind_(tree.name.identifierToken);
    },
    visitFunctionExpression: function(tree) {},
    visitVariableDeclarationList: function(tree) {
      if ((tree.declarationType == VAR && this.includeFunctionScope_) || (tree.declarationType != VAR && this.block_ == this.scope_)) {
        $traceurRuntime.superCall(this, $VariableBinder.prototype, "visitVariableDeclarationList", [tree]);
      } else {
        var decls = tree.declarations;
        for (var i = 0; i < decls.length; i++) {
          this.visitAny(decls[i].initialiser);
        }
      }
    },
    visitVariableDeclaration: function(tree) {
      this.bindVariableDeclaration_(tree.lvalue);
      $traceurRuntime.superCall(this, $VariableBinder.prototype, "visitVariableDeclaration", [tree]);
    },
    bind_: function(identifier) {
      assert(typeof identifier.value == 'string');
      this.identifiers_[identifier.value] = true;
    },
    bindParameter_: function(parameter) {
      if (parameter.type === FORMAL_PARAMETER) parameter = parameter.parameter;
      if (parameter.isRestParameter()) {
        this.bind_(parameter.identifier);
      } else {
        this.bindVariableDeclaration_(parameter.binding);
      }
    },
    bindVariableDeclaration_: function(tree) {
      switch (tree.type) {
        case BINDING_ELEMENT:
          this.bindVariableDeclaration_(tree.binding);
          break;
        case BINDING_IDENTIFIER:
          this.bind_(tree.identifierToken);
          break;
        case ARRAY_PATTERN:
          var elements = tree.elements;
          for (var i = 0; i < elements.length; i++) {
            this.bindVariableDeclaration_(elements[i]);
          }
          break;
        case SPREAD_PATTERN_ELEMENT:
          this.bindVariableDeclaration_(tree.lvalue);
          break;
        case OBJECT_PATTERN:
          var fields = tree.fields;
          for (var i = 0; i < fields.length; i++) {
            this.bindVariableDeclaration_(fields[i]);
          }
          break;
        case OBJECT_PATTERN_FIELD:
          var field = tree;
          if (field.element == null) {
            this.bind_(field.name);
          } else {
            this.bindVariableDeclaration_(field.element);
          }
          break;
        case PAREN_EXPRESSION:
          this.bindVariableDeclaration_(tree.expression);
          break;
        default:
          throw new Error('unreachable');
      }
    }
  }, {}, ParseTreeVisitor);
  return {
    get variablesInBlock() {
      return variablesInBlock;
    },
    get variablesInFunction() {
      return variablesInFunction;
    },
    get VariableBinder() {
      return VariableBinder;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/AlphaRenamer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/AlphaRenamer";
  var $__151 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      FunctionDeclaration = $__151.FunctionDeclaration,
      FunctionExpression = $__151.FunctionExpression;
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var $__151 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/PredefinedName"),
      ARGUMENTS = $__151.ARGUMENTS,
      THIS = $__151.THIS;
  var createIdentifierExpression = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory").createIdentifierExpression;
  var $__151 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/semantics/VariableBinder"),
      variablesInBlock = $__151.variablesInBlock,
      variablesInFunction = $__151.variablesInFunction;
  var AlphaRenamer = function AlphaRenamer(oldName, newName) {
    $traceurRuntime.superCall(this, $AlphaRenamer.prototype, "constructor", []);
    this.oldName_ = oldName;
    this.newName_ = newName;
  };
  var $AlphaRenamer = AlphaRenamer;
  ($traceurRuntime.createClass)(AlphaRenamer, {
    transformBlock: function(tree) {
      if (this.oldName_ in variablesInBlock(tree)) {
        return tree;
      } else {
        return $traceurRuntime.superCall(this, $AlphaRenamer.prototype, "transformBlock", [tree]);
      }
    },
    transformIdentifierExpression: function(tree) {
      if (this.oldName_ == tree.identifierToken.value) {
        return createIdentifierExpression(this.newName_);
      } else {
        return tree;
      }
    },
    transformThisExpression: function(tree) {
      if (this.oldName_ !== THIS) return tree;
      return createIdentifierExpression(this.newName_);
    },
    transformFunctionDeclaration: function(tree) {
      if (this.oldName_ === tree.name) {
        tree = new FunctionDeclaration(tree.location, this.newName_, tree.isGenerator, tree.formalParameterList, tree.typeAnnotation, tree.annotations, tree.functionBody);
      }
      if (this.getDoNotRecurse(tree)) return tree;
      return $traceurRuntime.superCall(this, $AlphaRenamer.prototype, "transformFunctionDeclaration", [tree]);
    },
    transformFunctionExpression: function(tree) {
      if (this.oldName_ === tree.name) {
        tree = new FunctionExpression(tree.location, this.newName_, tree.isGenerator, tree.formalParameterList, tree.typeAnnotation, tree.annotations, tree.functionBody);
      }
      if (this.getDoNotRecurse(tree)) return tree;
      return $traceurRuntime.superCall(this, $AlphaRenamer.prototype, "transformFunctionExpression", [tree]);
    },
    getDoNotRecurse: function(tree) {
      return this.oldName_ === ARGUMENTS || this.oldName_ === THIS || this.oldName_ in variablesInFunction(tree);
    },
    transformCatch: function(tree) {
      if (!tree.binding.isPattern() && this.oldName_ === tree.binding.identifierToken.value) {
        return tree;
      }
      return $traceurRuntime.superCall(this, $AlphaRenamer.prototype, "transformCatch", [tree]);
    }
  }, {rename: function(tree, oldName, newName) {
      return new $AlphaRenamer(oldName, newName).transformAny(tree);
    }}, ParseTreeTransformer);
  return {get AlphaRenamer() {
      return AlphaRenamer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/alphaRenameThisAndArguments", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/alphaRenameThisAndArguments";
  var $__153 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/PredefinedName"),
      ARGUMENTS = $__153.ARGUMENTS,
      THIS = $__153.THIS;
  var AlphaRenamer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/AlphaRenamer").AlphaRenamer;
  var FindInFunctionScope = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/FindInFunctionScope").FindInFunctionScope;
  var FindThisOrArguments = function FindThisOrArguments(tree) {
    this.foundThis = false;
    this.foundArguments = false;
    $traceurRuntime.superCall(this, $FindThisOrArguments.prototype, "constructor", [tree]);
  };
  var $FindThisOrArguments = FindThisOrArguments;
  ($traceurRuntime.createClass)(FindThisOrArguments, {
    visitThisExpression: function(tree) {
      this.foundThis = true;
      this.found = this.foundArguments;
    },
    visitIdentifierExpression: function(tree) {
      if (tree.identifierToken.value === ARGUMENTS) {
        this.foundArguments = true;
        this.found = this.foundThis;
      }
    }
  }, {}, FindInFunctionScope);
  var $__default = function alphaRenameThisAndArguments(tempVarTransformer, tree) {
    var finder = new FindThisOrArguments(tree);
    if (finder.foundArguments) {
      var argumentsTempName = tempVarTransformer.addTempVarForArguments();
      tree = AlphaRenamer.rename(tree, ARGUMENTS, argumentsTempName);
    }
    if (finder.foundThis) {
      var thisTempName = tempVarTransformer.addTempVarForThis();
      tree = AlphaRenamer.rename(tree, THIS, thisTempName);
    }
    return tree;
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/ComprehensionTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/ComprehensionTransformer";
  var alphaRenameThisAndArguments = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/alphaRenameThisAndArguments").default;
  var FunctionExpression = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees").FunctionExpression;
  var TempVarTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/TempVarTransformer").TempVarTransformer;
  var $__155 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      LET = $__155.LET,
      VAR = $__155.VAR;
  var $__155 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      COMPREHENSION_FOR = $__155.COMPREHENSION_FOR,
      COMPREHENSION_IF = $__155.COMPREHENSION_IF;
  var $__155 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createCallExpression = $__155.createCallExpression,
      createEmptyParameterList = $__155.createEmptyParameterList,
      createForOfStatement = $__155.createForOfStatement,
      createFunctionBody = $__155.createFunctionBody,
      createIfStatement = $__155.createIfStatement,
      createParenExpression = $__155.createParenExpression,
      createVariableDeclarationList = $__155.createVariableDeclarationList;
  var options = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/options").options;
  var ComprehensionTransformer = function ComprehensionTransformer() {
    $traceurRuntime.defaultSuperCall(this, $ComprehensionTransformer.prototype, arguments);
  };
  var $ComprehensionTransformer = ComprehensionTransformer;
  ($traceurRuntime.createClass)(ComprehensionTransformer, {transformComprehension: function(tree, statement, isGenerator) {
      var prefix = arguments[3];
      var suffix = arguments[4];
      var bindingKind = isGenerator || !options.blockBinding ? VAR: LET;
      var statements = prefix ? [prefix]: [];
      for (var i = tree.comprehensionList.length - 1; i >= 0; i--) {
        var item = tree.comprehensionList[i];
        switch (item.type) {
          case COMPREHENSION_IF:
            var expression = this.transformAny(item.expression);
            statement = createIfStatement(expression, statement);
            break;
          case COMPREHENSION_FOR:
            var left = this.transformAny(item.left);
            var iterator = this.transformAny(item.iterator);
            var initialiser = createVariableDeclarationList(bindingKind, left, null);
            statement = createForOfStatement(initialiser, iterator, statement);
            break;
          default:
            throw new Error('Unreachable.');
        }
      }
      statement = alphaRenameThisAndArguments(this, statement);
      statements.push(statement);
      if (suffix) statements.push(suffix);
      var func = new FunctionExpression(null, null, isGenerator, createEmptyParameterList(), null, [], createFunctionBody(statements));
      return createParenExpression(createCallExpression(func));
    }}, {}, TempVarTransformer);
  return {get ComprehensionTransformer() {
      return ComprehensionTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/ArrayComprehensionTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/ArrayComprehensionTransformer";
  var $__156 = Object.freeze(Object.defineProperties(["var ", " = 0, ", " = [];"], {raw: {value: Object.freeze(["var ", " = 0, ", " = [];"])}})),
      $__157 = Object.freeze(Object.defineProperties(["", "[", "++] = ", ";"], {raw: {value: Object.freeze(["", "[", "++] = ", ";"])}})),
      $__158 = Object.freeze(Object.defineProperties(["return ", ";"], {raw: {value: Object.freeze(["return ", ";"])}}));
  var ComprehensionTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ComprehensionTransformer").ComprehensionTransformer;
  var createIdentifierExpression = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory").createIdentifierExpression;
  var parseStatement = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser").parseStatement;
  var ArrayComprehensionTransformer = function ArrayComprehensionTransformer() {
    $traceurRuntime.defaultSuperCall(this, $ArrayComprehensionTransformer.prototype, arguments);
  };
  var $ArrayComprehensionTransformer = ArrayComprehensionTransformer;
  ($traceurRuntime.createClass)(ArrayComprehensionTransformer, {transformArrayComprehension: function(tree) {
      this.pushTempVarState();
      var expression = this.transformAny(tree.expression);
      var index = createIdentifierExpression(this.getTempIdentifier());
      var result = createIdentifierExpression(this.getTempIdentifier());
      var tempVarsStatatement = parseStatement($__156, index, result);
      var statement = parseStatement($__157, result, index, expression);
      var returnStatement = parseStatement($__158, result);
      var isGenerator = false;
      var result = this.transformComprehension(tree, statement, isGenerator, tempVarsStatatement, returnStatement);
      this.popTempVarState();
      return result;
    }}, {}, ComprehensionTransformer);
  return {get ArrayComprehensionTransformer() {
      return ArrayComprehensionTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/ArrowFunctionTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/ArrowFunctionTransformer";
  var FormalParameterList = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees").FormalParameterList;
  var TempVarTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/TempVarTransformer").TempVarTransformer;
  var $__162 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      FUNCTION_BODY = $__162.FUNCTION_BODY,
      FUNCTION_EXPRESSION = $__162.FUNCTION_EXPRESSION;
  var alphaRenameThisAndArguments = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/alphaRenameThisAndArguments").default;
  var $__162 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createFunctionBody = $__162.createFunctionBody,
      createFunctionExpression = $__162.createFunctionExpression,
      createParenExpression = $__162.createParenExpression,
      createReturnStatement = $__162.createReturnStatement;
  var ArrowFunctionTransformer = function ArrowFunctionTransformer() {
    $traceurRuntime.defaultSuperCall(this, $ArrowFunctionTransformer.prototype, arguments);
  };
  var $ArrowFunctionTransformer = ArrowFunctionTransformer;
  ($traceurRuntime.createClass)(ArrowFunctionTransformer, {transformArrowFunctionExpression: function(tree) {
      var parameters;
      if (tree.formalParameters) {
        parameters = this.transformAny(tree.formalParameters).parameters;
      } else {
        parameters = [];
      }
      var alphaRenamed = alphaRenameThisAndArguments(this, tree);
      var functionBody = this.transformAny(alphaRenamed.functionBody);
      if (functionBody.type != FUNCTION_BODY) {
        functionBody = createFunctionBody([createReturnStatement(functionBody)]);
      }
      return createParenExpression(createFunctionExpression(new FormalParameterList(null, parameters), functionBody));
    }}, {}, TempVarTransformer);
  return {get ArrowFunctionTransformer() {
      return ArrowFunctionTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/BlockBindingTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/BlockBindingTransformer";
  var AlphaRenamer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/AlphaRenamer").AlphaRenamer;
  var $__165 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      BINDING_IDENTIFIER = $__165.BINDING_IDENTIFIER,
      BLOCK = $__165.BLOCK,
      VARIABLE_DECLARATION_LIST = $__165.VARIABLE_DECLARATION_LIST;
  var $__165 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      FunctionDeclaration = $__165.FunctionDeclaration,
      FunctionExpression = $__165.FunctionExpression;
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var $__165 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      CONST = $__165.CONST,
      LET = $__165.LET,
      VAR = $__165.VAR;
  var $__165 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createAssignmentExpression = $__165.createAssignmentExpression,
      createBindingIdentifier = $__165.createBindingIdentifier,
      createBlock = $__165.createBlock,
      createCatch = $__165.createCatch,
      createEmptyStatement = $__165.createEmptyStatement,
      createExpressionStatement = $__165.createExpressionStatement,
      createFinally = $__165.createFinally,
      createForInStatement = $__165.createForInStatement,
      createForStatement = $__165.createForStatement,
      createFunctionBody = $__165.createFunctionBody,
      createIdentifierExpression = $__165.createIdentifierExpression,
      createIdentifierToken = $__165.createIdentifierToken,
      createThrowStatement = $__165.createThrowStatement,
      createTryStatement = $__165.createTryStatement,
      createUndefinedExpression = $__165.createUndefinedExpression,
      createVariableDeclaration = $__165.createVariableDeclaration,
      createVariableDeclarationList = $__165.createVariableDeclarationList,
      createVariableStatement = $__165.createVariableStatement;
  var ScopeType = {
    SCRIPT: 'SCRIPT',
    FUNCTION: 'FUNCTION',
    BLOCK: 'BLOCK'
  };
  var Scope = function Scope(parent, type) {
    this.parent = parent;
    this.type = type;
    this.blockVariables = null;
  };
  ($traceurRuntime.createClass)(Scope, {addBlockScopedVariable: function(value) {
      if (!this.blockVariables) {
        this.blockVariables = Object.create(null);
      }
      this.blockVariables[value] = true;
    }}, {});
  ;
  var Rename = function Rename(oldName, newName) {
    this.oldName = oldName;
    this.newName = newName;
  };
  ($traceurRuntime.createClass)(Rename, {}, {});
  function renameAll(renames, tree) {
    renames.forEach((function(rename) {
      tree = AlphaRenamer.rename(tree, rename.oldName, rename.newName);
    }));
    return tree;
  }
  function toBlock(statement) {
    return statement.type == BLOCK ? statement: createBlock(statement);
  }
  var BlockBindingTransformer = function BlockBindingTransformer(stateAllocator) {
    $traceurRuntime.superCall(this, $BlockBindingTransformer.prototype, "constructor", []);
    this.scope_ = null;
  };
  var $BlockBindingTransformer = BlockBindingTransformer;
  ($traceurRuntime.createClass)(BlockBindingTransformer, {
    createScriptScope_: function() {
      return new Scope(this.scope_, ScopeType.SCRIPT);
    },
    createFunctionScope_: function() {
      if (this.scope_ == null) {
        throw new Error('Top level function scope found.');
      }
      return new Scope(this.scope_, ScopeType.FUNCTION);
    },
    createBlockScope_: function() {
      if (this.scope_ == null) {
        throw new Error('Top level block scope found.');
      }
      return new Scope(this.scope_, ScopeType.BLOCK);
    },
    push_: function(scope) {
      this.scope_ = scope;
      return scope;
    },
    pop_: function(scope) {
      if (this.scope_ != scope) {
        throw new Error('BlockBindingTransformer scope mismatch');
      }
      this.scope_ = scope.parent;
    },
    transformBlock: function(tree) {
      var scope = this.push_(this.createBlockScope_());
      var statements = this.transformList(tree.statements);
      if (scope.blockVariables != null) {
        tree = toBlock(this.rewriteAsCatch_(scope.blockVariables, createBlock(statements)));
      } else if (statements != tree.statements) {
        tree = createBlock(statements);
      }
      this.pop_(scope);
      return tree;
    },
    rewriteAsCatch_: function(blockVariables, statement) {
      for (var variable in blockVariables) {
        statement = createTryStatement(createBlock(createThrowStatement(createUndefinedExpression())), createCatch(createBindingIdentifier(variable), toBlock(statement)), null);
      }
      return statement;
    },
    transformClassDeclaration: function(tree) {
      throw new Error('ClassDeclaration should be transformed away.');
    },
    transformForInStatement: function(tree) {
      var treeBody = tree.body;
      var initialiser;
      if (tree.initialiser != null && tree.initialiser.type == VARIABLE_DECLARATION_LIST) {
        var variables = tree.initialiser;
        if (variables.declarations.length != 1) {
          throw new Error('for .. in has != 1 variables');
        }
        var variable = variables.declarations[0];
        var variableName = this.getVariableName_(variable);
        switch (variables.declarationType) {
          case LET:
          case CONST:
            {
              if (variable.initialiser != null) {
                throw new Error('const/let in for-in may not have an initialiser');
              }
              initialiser = createVariableDeclarationList(VAR, ("$" + variableName), null);
              treeBody = this.prependToBlock_(createVariableStatement(LET, variableName, createIdentifierExpression(("$" + variableName))), treeBody);
              break;
            }
          case VAR:
            initialiser = this.transformVariables_(variables);
            break;
          default:
            throw new Error('Unreachable.');
        }
      } else {
        initialiser = this.transformAny(tree.initialiser);
      }
      var result = tree;
      var collection = this.transformAny(tree.collection);
      var body = this.transformAny(treeBody);
      if (initialiser != tree.initialiser || collection != tree.collection || body != tree.body) {
        result = createForInStatement(initialiser, collection, body);
      }
      return result;
    },
    prependToBlock_: function(statement, body) {
      if (body.type == BLOCK) {
        var block = body;
        var list = $traceurRuntime.spread([statement], block.statements);
        return createBlock(list);
      } else {
        return createBlock(statement, body);
      }
    },
    transformForStatement: function(tree) {
      var initialiser;
      if (tree.initialiser != null && tree.initialiser.type == VARIABLE_DECLARATION_LIST) {
        var variables = tree.initialiser;
        switch (variables.declarationType) {
          case LET:
          case CONST:
            return this.transformForLet_(tree, variables);
          case VAR:
            initialiser = this.transformVariables_(variables);
            break;
          default:
            throw new Error('Reached unreachable.');
        }
      } else {
        initialiser = this.transformAny(tree.initialiser);
      }
      var condition = this.transformAny(tree.condition);
      var increment = this.transformAny(tree.increment);
      var body = this.transformAny(tree.body);
      var result = tree;
      if (initialiser != tree.initialiser || condition != tree.condition || increment != tree.increment || body != tree.body) {
        result = createForStatement(initialiser, condition, increment, body);
      }
      return result;
    },
    transformForLet_: function(tree, variables) {
      var $__163 = this;
      var copyFwd = [];
      var copyBak = [];
      var hoisted = [];
      var renames = [];
      variables.declarations.forEach((function(variable) {
        var variableName = $__163.getVariableName_(variable);
        var hoistedName = ("$" + variableName);
        var initialiser = renameAll(renames, variable.initialiser);
        hoisted.push(createVariableDeclaration(hoistedName, initialiser));
        copyFwd.push(createVariableDeclaration(variableName, createIdentifierExpression(hoistedName)));
        copyBak.push(createExpressionStatement(createAssignmentExpression(createIdentifierExpression(hoistedName), createIdentifierExpression(variableName))));
        renames.push(new Rename(variableName, hoistedName));
      }));
      var condition = renameAll(renames, tree.condition);
      var increment = renameAll(renames, tree.increment);
      var transformedForLoop = createBlock(createVariableStatement(createVariableDeclarationList(LET, hoisted)), createForStatement(null, condition, increment, createBlock(createVariableStatement(createVariableDeclarationList(LET, copyFwd)), createTryStatement(toBlock(tree.body), null, createFinally(createBlock(copyBak))))));
      return this.transformAny(transformedForLoop);
    },
    transformFunctionDeclaration: function(tree) {
      var body = this.transformFunctionBody(tree.functionBody);
      var formalParameterList = this.transformAny(tree.formalParameterList);
      if (this.scope_.type === ScopeType.BLOCK) {
        this.scope_.addBlockScopedVariable(tree.name.identifierToken.value);
        return createExpressionStatement(createAssignmentExpression(createIdentifierExpression(tree.name.identifierToken), new FunctionExpression(tree.location, null, tree.isGenerator, formalParameterList, tree.typeAnnotation, tree.annotations, body)));
      }
      if (body === tree.functionBody && formalParameterList === tree.formalParameterList) {
        return tree;
      }
      return new FunctionDeclaration(tree.location, tree.name, tree.isGenerator, formalParameterList, tree.typeAnnotation, tree.annotations, body);
    },
    transformScript: function(tree) {
      var scope = this.push_(this.createScriptScope_());
      var result = $traceurRuntime.superCall(this, $BlockBindingTransformer.prototype, "transformScript", [tree]);
      this.pop_(scope);
      return result;
    },
    transformVariableDeclaration: function(tree) {
      throw new Error('Should never see variable declaration tree.');
    },
    transformVariableDeclarationList: function(tree) {
      throw new Error('Should never see variable declaration list.');
    },
    transformVariableStatement: function(tree) {
      if (this.scope_.type == ScopeType.BLOCK) {
        switch (tree.declarations.declarationType) {
          case CONST:
          case LET:
            return this.transformBlockVariables_(tree.declarations);
          default:
            break;
        }
      }
      var variables = this.transformVariables_(tree.declarations);
      if (variables != tree.declarations) {
        tree = createVariableStatement(variables);
      }
      return tree;
    },
    transformBlockVariables_: function(tree) {
      var $__163 = this;
      var variables = tree.declarations;
      var comma = [];
      variables.forEach((function(variable) {
        switch (tree.declarationType) {
          case LET:
          case CONST:
            break;
          default:
            throw new Error('Only let/const allowed here.');
        }
        var variableName = $__163.getVariableName_(variable);
        $__163.scope_.addBlockScopedVariable(variableName);
        var initialiser = $__163.transformAny(variable.initialiser);
        if (initialiser != null) {
          comma.push(createAssignmentExpression(createIdentifierExpression(variableName), initialiser));
        }
      }));
      switch (comma.length) {
        case 0:
          return createEmptyStatement();
        case 1:
          return createExpressionStatement(comma[0]);
        default:
          for (var i = 0; i < comma.length; i++) {
            comma[i] = createExpressionStatement(comma[i]);
          }
          return createBlock(comma);
      }
    },
    transformVariables_: function(tree) {
      var variables = tree.declarations;
      var transformed = null;
      for (var index = 0; index < variables.length; index++) {
        var variable = variables[index];
        var variableName = this.getVariableName_(variable);
        var initialiser = this.transformAny(variable.initialiser);
        if (transformed != null || initialiser != variable.initialiser) {
          if (transformed == null) {
            transformed = variables.slice(0, index);
          }
          transformed.push(createVariableDeclaration(createIdentifierToken(variableName), initialiser));
        }
      }
      if (transformed != null || tree.declarationType != VAR) {
        var declarations = transformed != null ? transformed: tree.declarations;
        var declarationType = tree.declarationType != VAR ? VAR: tree.declarationType;
        tree = createVariableDeclarationList(declarationType, declarations);
      }
      return tree;
    },
    transformFunctionBody: function(body) {
      var scope = this.push_(this.createFunctionScope_());
      body = this.transformFunctionBodyStatements_(body);
      this.pop_(scope);
      return body;
    },
    transformFunctionBodyStatements_: function(tree) {
      var statements = this.transformList(tree.statements);
      if (this.scope_.blockVariables != null) {
        tree = this.rewriteAsCatch_(this.scope_.blockVariables, createBlock(statements));
      } else if (statements != tree.statements) {
        tree = createFunctionBody(statements);
      }
      return tree;
    },
    getVariableName_: function(variable) {
      var lvalue = variable.lvalue;
      if (lvalue.type == BINDING_IDENTIFIER) {
        return lvalue.identifierToken.value;
      }
      throw new Error('Unexpected destructuring declaration found.');
    }
  }, {}, ParseTreeTransformer);
  return {get BlockBindingTransformer() {
      return BlockBindingTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/semantics/util", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/semantics/util";
  var $__166 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      IDENTIFIER_EXPRESSION = $__166.IDENTIFIER_EXPRESSION,
      LITERAL_EXPRESSION = $__166.LITERAL_EXPRESSION,
      PAREN_EXPRESSION = $__166.PAREN_EXPRESSION,
      UNARY_EXPRESSION = $__166.UNARY_EXPRESSION;
  var UNDEFINED = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/PredefinedName").UNDEFINED;
  var VOID = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").VOID;
  function hasUseStrict(list) {
    for (var i = 0; i < list.length; i++) {
      if (!list[i].isDirectivePrologue()) return false;
      if (list[i].isUseStrictDirective()) return true;
    }
    return false;
  }
  function isUndefined(tree) {
    if (tree.type === PAREN_EXPRESSION) return isUndefined(tree.expression);
    return tree.type === IDENTIFIER_EXPRESSION && tree.identifierToken.value === UNDEFINED;
  }
  function isVoidExpression(tree) {
    if (tree.type === PAREN_EXPRESSION) return isVoidExpression(tree.expression);
    return tree.type === UNARY_EXPRESSION && tree.operator.type === VOID && isLiteralExpression(tree.operand);
  }
  function isLiteralExpression(tree) {
    if (tree.type === PAREN_EXPRESSION) return isLiteralExpression(tree.expression);
    return tree.type === LITERAL_EXPRESSION;
  }
  return {
    get hasUseStrict() {
      return hasUseStrict;
    },
    get isUndefined() {
      return isUndefined;
    },
    get isVoidExpression() {
      return isVoidExpression;
    },
    get isLiteralExpression() {
      return isLiteralExpression;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/MakeStrictTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/MakeStrictTransformer";
  var $__168 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      FunctionBody = $__168.FunctionBody,
      Script = $__168.Script;
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var createUseStrictDirective = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory").createUseStrictDirective;
  var hasUseStrict = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/semantics/util").hasUseStrict;
  function prepend(statements) {
    return $traceurRuntime.spread([createUseStrictDirective()], statements);
  }
  var MakeStrictTransformer = function MakeStrictTransformer() {
    $traceurRuntime.defaultSuperCall(this, $MakeStrictTransformer.prototype, arguments);
  };
  var $MakeStrictTransformer = MakeStrictTransformer;
  ($traceurRuntime.createClass)(MakeStrictTransformer, {
    transformScript: function(tree) {
      if (hasUseStrict(tree.scriptItemList)) return tree;
      return new Script(tree.location, prepend(tree.scriptItemList));
    },
    transformFunctionBody: function(tree) {
      if (hasUseStrict(tree.statements)) return tree;
      return new FunctionBody(tree.location, prepend(tree.statements));
    }
  }, {transformTree: function(tree) {
      return new $MakeStrictTransformer().transformAny(tree);
    }}, ParseTreeTransformer);
  return {get MakeStrictTransformer() {
      return MakeStrictTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/OperatorExpander", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/OperatorExpander";
  var $__169 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      IDENTIFIER_EXPRESSION = $__169.IDENTIFIER_EXPRESSION,
      SUPER_EXPRESSION = $__169.SUPER_EXPRESSION;
  var $__169 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      AMPERSAND = $__169.AMPERSAND,
      AMPERSAND_EQUAL = $__169.AMPERSAND_EQUAL,
      BAR = $__169.BAR,
      BAR_EQUAL = $__169.BAR_EQUAL,
      CARET = $__169.CARET,
      CARET_EQUAL = $__169.CARET_EQUAL,
      LEFT_SHIFT = $__169.LEFT_SHIFT,
      LEFT_SHIFT_EQUAL = $__169.LEFT_SHIFT_EQUAL,
      MINUS = $__169.MINUS,
      MINUS_EQUAL = $__169.MINUS_EQUAL,
      PERCENT = $__169.PERCENT,
      PERCENT_EQUAL = $__169.PERCENT_EQUAL,
      PLUS = $__169.PLUS,
      PLUS_EQUAL = $__169.PLUS_EQUAL,
      RIGHT_SHIFT = $__169.RIGHT_SHIFT,
      RIGHT_SHIFT_EQUAL = $__169.RIGHT_SHIFT_EQUAL,
      SLASH = $__169.SLASH,
      SLASH_EQUAL = $__169.SLASH_EQUAL,
      STAR = $__169.STAR,
      STAR_EQUAL = $__169.STAR_EQUAL,
      UNSIGNED_RIGHT_SHIFT = $__169.UNSIGNED_RIGHT_SHIFT,
      UNSIGNED_RIGHT_SHIFT_EQUAL = $__169.UNSIGNED_RIGHT_SHIFT_EQUAL;
  var $__169 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createAssignmentExpression = $__169.createAssignmentExpression,
      createBinaryOperator = $__169.createBinaryOperator,
      createCommaExpression = $__169.createCommaExpression,
      createIdentifierExpression = $__169.createIdentifierExpression,
      createMemberExpression = $__169.createMemberExpression,
      createMemberLookupExpression = $__169.createMemberLookupExpression,
      createOperatorToken = $__169.createOperatorToken,
      createParenExpression = $__169.createParenExpression;
  function getBinaryOperator(type) {
    switch (type) {
      case STAR_EQUAL:
        return STAR;
      case SLASH_EQUAL:
        return SLASH;
      case PERCENT_EQUAL:
        return PERCENT;
      case PLUS_EQUAL:
        return PLUS;
      case MINUS_EQUAL:
        return MINUS;
      case LEFT_SHIFT_EQUAL:
        return LEFT_SHIFT;
      case RIGHT_SHIFT_EQUAL:
        return RIGHT_SHIFT;
      case UNSIGNED_RIGHT_SHIFT_EQUAL:
        return UNSIGNED_RIGHT_SHIFT;
      case AMPERSAND_EQUAL:
        return AMPERSAND;
      case CARET_EQUAL:
        return CARET;
      case BAR_EQUAL:
        return BAR;
      default:
        throw Error('unreachable');
    }
  }
  function expandMemberLookupExpression(tree, tempVarTransformer) {
    var tmp1;
    var expressions = [];
    if (tree.left.operand.type == SUPER_EXPRESSION || tree.left.operand.type == IDENTIFIER_EXPRESSION) {
      tmp1 = tree.left.operand;
    } else {
      tmp1 = createIdentifierExpression(tempVarTransformer.addTempVar());
      expressions.push(createAssignmentExpression(tmp1, tree.left.operand));
    }
    var tmp2 = createIdentifierExpression(tempVarTransformer.addTempVar());
    expressions.push(createAssignmentExpression(tmp2, tree.left.memberExpression), createAssignmentExpression(createMemberLookupExpression(tmp1, tmp2), createBinaryOperator(createMemberLookupExpression(tmp1, tmp2), createOperatorToken(getBinaryOperator(tree.operator.type)), tree.right)));
    return createParenExpression(createCommaExpression(expressions));
  }
  function expandMemberExpression(tree, tempVarTransformer) {
    var tmp;
    var expressions = [];
    if (tree.left.operand.type == SUPER_EXPRESSION || tree.left.operand.type == IDENTIFIER_EXPRESSION) {
      tmp = tree.left.operand;
    } else {
      tmp = createIdentifierExpression(tempVarTransformer.addTempVar());
      expressions.push(createAssignmentExpression(tmp, tree.left.operand));
    }
    expressions.push(createAssignmentExpression(createMemberExpression(tmp, tree.left.memberName), createBinaryOperator(createMemberExpression(tmp, tree.left.memberName), createOperatorToken(getBinaryOperator(tree.operator.type)), tree.right)));
    return createParenExpression(createCommaExpression(expressions));
  }
  return {
    get expandMemberLookupExpression() {
      return expandMemberLookupExpression;
    },
    get expandMemberExpression() {
      return expandMemberExpression;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/SuperTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/SuperTransformer";
  var $__170 = Object.freeze(Object.defineProperties(["$traceurRuntime.superCall(", ",\n                                                      ", ",\n                                                      ", ",\n                                                      ", ")"], {raw: {value: Object.freeze(["$traceurRuntime.superCall(", ",\n                                                      ", ",\n                                                      ", ",\n                                                      ", ")"])}})),
      $__171 = Object.freeze(Object.defineProperties(["$traceurRuntime.superGet(", ",\n                                                     ", ",\n                                                     ", ")"], {raw: {value: Object.freeze(["$traceurRuntime.superGet(", ",\n                                                     ", ",\n                                                     ", ")"])}})),
      $__172 = Object.freeze(Object.defineProperties(["$traceurRuntime.superSet(", ",\n                                                       ", ",\n                                                       ", ",\n                                                       ", ")"], {raw: {value: Object.freeze(["$traceurRuntime.superSet(", ",\n                                                       ", ",\n                                                       ", ",\n                                                       ", ")"])}}));
  var $__175 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      FunctionDeclaration = $__175.FunctionDeclaration,
      FunctionExpression = $__175.FunctionExpression;
  var $__175 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      LITERAL_PROPERTY_NAME = $__175.LITERAL_PROPERTY_NAME,
      MEMBER_EXPRESSION = $__175.MEMBER_EXPRESSION,
      MEMBER_LOOKUP_EXPRESSION = $__175.MEMBER_LOOKUP_EXPRESSION,
      SUPER_EXPRESSION = $__175.SUPER_EXPRESSION;
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var EQUAL = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").EQUAL;
  var assert = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/assert").assert;
  var $__175 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createArrayLiteralExpression = $__175.createArrayLiteralExpression,
      createIdentifierExpression = $__175.createIdentifierExpression,
      createStringLiteral = $__175.createStringLiteral,
      createThisExpression = $__175.createThisExpression;
  var $__175 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/OperatorExpander"),
      expandMemberExpression = $__175.expandMemberExpression,
      expandMemberLookupExpression = $__175.expandMemberLookupExpression;
  var parseExpression = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser").parseExpression;
  var SuperTransformer = function SuperTransformer(tempVarTransformer, reporter, protoName, methodTree, thisName) {
    this.tempVarTransformer_ = tempVarTransformer;
    this.reporter_ = reporter;
    this.protoName_ = protoName;
    this.method_ = methodTree;
    this.superCount_ = 0;
    this.thisVar_ = createIdentifierExpression(thisName);
    this.inNestedFunc_ = 0;
    this.nestedSuperCount_ = 0;
  };
  var $SuperTransformer = SuperTransformer;
  ($traceurRuntime.createClass)(SuperTransformer, {
    get hasSuper() {
      return this.superCount_ > 0;
    },
    get nestedSuper() {
      return this.nestedSuperCount_ > 0;
    },
    transformFunctionDeclaration: function(tree) {
      return this.transformFunction_(tree, FunctionDeclaration);
    },
    transformFunctionExpression: function(tree) {
      return this.transformFunction_(tree, FunctionExpression);
    },
    transformFunction_: function(tree, constructor) {
      var oldSuperCount = this.superCount_;
      this.inNestedFunc_++;
      var transformedTree = constructor === FunctionExpression ? $traceurRuntime.superCall(this, $SuperTransformer.prototype, "transformFunctionExpression", [tree]): $traceurRuntime.superCall(this, $SuperTransformer.prototype, "transformFunctionDeclaration", [tree]);
      this.inNestedFunc_--;
      if (oldSuperCount !== this.superCount_) this.nestedSuperCount_ += this.superCount_ - oldSuperCount;
      return transformedTree;
    },
    transformGetAccessor: function(tree) {
      return tree;
    },
    transformSetAccessor: function(tree) {
      return tree;
    },
    transformPropertyMethodAssignMent: function(tree) {
      return tree;
    },
    transformCallExpression: function(tree) {
      if (this.method_ && tree.operand.type == SUPER_EXPRESSION) {
        this.superCount_++;
        assert(this.method_.name.type === LITERAL_PROPERTY_NAME);
        var methodName = this.method_.name.literalToken.value;
        return this.createSuperCallExpression_(methodName, tree);
      }
      if ((tree.operand.type == MEMBER_EXPRESSION || tree.operand.type == MEMBER_LOOKUP_EXPRESSION) && tree.operand.operand.type == SUPER_EXPRESSION) {
        this.superCount_++;
        var name;
        if (tree.operand.type == MEMBER_EXPRESSION) name = tree.operand.memberName.value; else name = tree.operand.memberExpression;
        return this.createSuperCallExpression_(name, tree);
      }
      return $traceurRuntime.superCall(this, $SuperTransformer.prototype, "transformCallExpression", [tree]);
    },
    createSuperCallExpression_: function(methodName, tree) {
      var thisExpr = this.inNestedFunc_ ? this.thisVar_: createThisExpression();
      var args = createArrayLiteralExpression(tree.args.args);
      return this.createSuperCallExpression(thisExpr, this.protoName_, methodName, args);
    },
    createSuperCallExpression: function(thisExpr, protoName, methodName, args) {
      return parseExpression($__170, thisExpr, protoName, methodName, args);
    },
    transformMemberShared_: function(tree, name) {
      var thisExpr = this.inNestedFunc_ ? this.thisVar_: createThisExpression();
      return parseExpression($__171, thisExpr, this.protoName_, name);
    },
    transformMemberExpression: function(tree) {
      if (tree.operand.type === SUPER_EXPRESSION) {
        this.superCount_++;
        return this.transformMemberShared_(tree, createStringLiteral(tree.memberName.value));
      }
      return $traceurRuntime.superCall(this, $SuperTransformer.prototype, "transformMemberExpression", [tree]);
    },
    transformMemberLookupExpression: function(tree) {
      if (tree.operand.type === SUPER_EXPRESSION) return this.transformMemberShared_(tree, tree.memberExpression);
      return $traceurRuntime.superCall(this, $SuperTransformer.prototype, "transformMemberLookupExpression", [tree]);
    },
    transformBinaryOperator: function(tree) {
      if (tree.operator.isAssignmentOperator() && (tree.left.type === MEMBER_EXPRESSION || tree.left.type === MEMBER_LOOKUP_EXPRESSION) && tree.left.operand.type === SUPER_EXPRESSION) {
        if (tree.operator.type !== EQUAL) {
          if (tree.left.type === MEMBER_LOOKUP_EXPRESSION) {
            tree = expandMemberLookupExpression(tree, this.tempVarTransformer_);
          } else {
            tree = expandMemberExpression(tree, this.tempVarTransformer_);
          }
          return this.transformAny(tree);
        }
        this.superCount_++;
        var name = tree.left.type === MEMBER_LOOKUP_EXPRESSION ? tree.left.memberExpression: createStringLiteral(tree.left.memberName.value);
        var thisExpr = this.inNestedFunc_ ? this.thisVar_: createThisExpression();
        var right = this.transformAny(tree.right);
        return parseExpression($__172, thisExpr, this.protoName_, name, right);
      }
      return $traceurRuntime.superCall(this, $SuperTransformer.prototype, "transformBinaryOperator", [tree]);
    },
    transformSuperExpression: function(tree) {
      this.reportError_(tree, '"super" may only be used on the LHS of a member ' + 'access expression before a call (TODO wording)');
      return tree;
    },
    reportError_: function(tree) {
      var $__176;
      for (var args = [],
          $__174 = 1; $__174 < arguments.length; $__174++) args[$__174 - 1] = arguments[$__174];
      ($__176 = this.reporter_).reportError.apply($__176, $traceurRuntime.spread([tree.location.start], args));
    }
  }, {}, ParseTreeTransformer);
  return {get SuperTransformer() {
      return SuperTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/ClassTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/ClassTransformer";
  var $__177 = Object.freeze(Object.defineProperties(["($traceurRuntime.createClass)(", ", ", ", ", ",\n                                       ", ")"], {raw: {value: Object.freeze(["($traceurRuntime.createClass)(", ", ", ", ", ",\n                                       ", ")"])}})),
      $__178 = Object.freeze(Object.defineProperties(["($traceurRuntime.createClass)(", ", ", ", ", ")"], {raw: {value: Object.freeze(["($traceurRuntime.createClass)(", ", ", ", ", ")"])}})),
      $__179 = Object.freeze(Object.defineProperties(["var ", " = ", ""], {raw: {value: Object.freeze(["var ", " = ", ""])}})),
      $__180 = Object.freeze(Object.defineProperties(["var ", " = ", ""], {raw: {value: Object.freeze(["var ", " = ", ""])}})),
      $__181 = Object.freeze(Object.defineProperties(["function($__super) {\n        var ", " = ", ";\n        return ($traceurRuntime.createClass)(", ", ", ",\n                                             ", ", $__super);\n      }(", ")"], {raw: {value: Object.freeze(["function($__super) {\n        var ", " = ", ";\n        return ($traceurRuntime.createClass)(", ", ", ",\n                                             ", ", $__super);\n      }(", ")"])}})),
      $__182 = Object.freeze(Object.defineProperties(["function() {\n        var ", " = ", ";\n        return ($traceurRuntime.createClass)(", ", ", ",\n                                             ", ");\n      }()"], {raw: {value: Object.freeze(["function() {\n        var ", " = ", ";\n        return ($traceurRuntime.createClass)(", ", ", ",\n                                             ", ");\n      }()"])}})),
      $__183 = Object.freeze(Object.defineProperties(["$traceurRuntime.defaultSuperCall(this,\n                ", ".prototype, arguments)"], {raw: {value: Object.freeze(["$traceurRuntime.defaultSuperCall(this,\n                ", ".prototype, arguments)"])}}));
  var AlphaRenamer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/AlphaRenamer").AlphaRenamer;
  var CONSTRUCTOR = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/PredefinedName").CONSTRUCTOR;
  var $__186 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      AnonBlock = $__186.AnonBlock,
      ExportDeclaration = $__186.ExportDeclaration,
      FunctionExpression = $__186.FunctionExpression,
      GetAccessor = $__186.GetAccessor,
      PropertyMethodAssignment = $__186.PropertyMethodAssignment,
      SetAccessor = $__186.SetAccessor;
  var $__186 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      GET_ACCESSOR = $__186.GET_ACCESSOR,
      PROPERTY_METHOD_ASSIGNMENT = $__186.PROPERTY_METHOD_ASSIGNMENT,
      SET_ACCESSOR = $__186.SET_ACCESSOR;
  var SuperTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/SuperTransformer").SuperTransformer;
  var TempVarTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/TempVarTransformer").TempVarTransformer;
  var VAR = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").VAR;
  var MakeStrictTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/MakeStrictTransformer").MakeStrictTransformer;
  var $__186 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createEmptyParameterList = $__186.createEmptyParameterList,
      createExpressionStatement = $__186.createExpressionStatement,
      createFunctionBody = $__186.createFunctionBody,
      id = $__186.createIdentifierExpression,
      createMemberExpression = $__186.createMemberExpression,
      createObjectLiteralExpression = $__186.createObjectLiteralExpression,
      createParenExpression = $__186.createParenExpression,
      createThisExpression = $__186.createThisExpression,
      createVariableStatement = $__186.createVariableStatement;
  var hasUseStrict = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/semantics/util").hasUseStrict;
  var parseOptions = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/options").parseOptions;
  var $__186 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser"),
      parseExpression = $__186.parseExpression,
      parseStatement = $__186.parseStatement,
      parseStatements = $__186.parseStatements;
  var propName = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/staticsemantics/PropName").propName;
  function classCall(func, object, staticObject, superClass) {
    if (superClass) {
      return parseExpression($__177, func, object, staticObject, superClass);
    }
    return parseExpression($__178, func, object, staticObject);
  }
  var ClassTransformer = function ClassTransformer(identifierGenerator, reporter) {
    $traceurRuntime.superCall(this, $ClassTransformer.prototype, "constructor", [identifierGenerator]);
    this.reporter_ = reporter;
    this.strictCount_ = 0;
    this.state_ = null;
  };
  var $ClassTransformer = ClassTransformer;
  ($traceurRuntime.createClass)(ClassTransformer, {
    transformExportDeclaration: function(tree) {
      var transformed = $traceurRuntime.superCall(this, $ClassTransformer.prototype, "transformExportDeclaration", [tree]);
      if (transformed === tree) return tree;
      var declaration = transformed.declaration;
      if (declaration instanceof AnonBlock) {
        var statements = $traceurRuntime.spread([new ExportDeclaration(null, declaration.statements[0], [])], declaration.statements.slice(1));
        return new AnonBlock(null, statements);
      }
      return transformed;
    },
    transformModule: function(tree) {
      this.strictCount_ = 1;
      return $traceurRuntime.superCall(this, $ClassTransformer.prototype, "transformModule", [tree]);
    },
    transformScript: function(tree) {
      this.strictCount_ = + hasUseStrict(tree.scriptItemList);
      return $traceurRuntime.superCall(this, $ClassTransformer.prototype, "transformScript", [tree]);
    },
    transformFunctionBody: function(tree) {
      var useStrict = + hasUseStrict(tree.statements);
      this.strictCount_ += useStrict;
      var result = $traceurRuntime.superCall(this, $ClassTransformer.prototype, "transformFunctionBody", [tree]);
      this.strictCount_ -= useStrict;
      return result;
    },
    makeStrict_: function(tree) {
      if (this.strictCount_) return tree;
      return MakeStrictTransformer.transformTree(tree);
    },
    transformClassElements_: function(tree, internalName) {
      var $__184 = this;
      var oldState = this.state_;
      this.state_ = {hasSuper: false};
      var superClass = this.transformAny(tree.superClass);
      var hasConstructor = false;
      var protoElements = [],
          staticElements = [];
      var constructorBody,
          constructorParams;
      tree.elements.forEach((function(tree) {
        var elements,
            homeObject;
        if (tree.isStatic) {
          elements = staticElements;
          homeObject = internalName;
        } else {
          elements = protoElements;
          homeObject = createMemberExpression(internalName, 'prototype');
        }
        switch (tree.type) {
          case GET_ACCESSOR:
            elements.push($__184.transformGetAccessor_(tree, homeObject));
            break;
          case SET_ACCESSOR:
            elements.push($__184.transformSetAccessor_(tree, homeObject));
            break;
          case PROPERTY_METHOD_ASSIGNMENT:
            var transformed = $__184.transformPropertyMethodAssignment_(tree, homeObject);
            if (!tree.isStatic && propName(tree) === CONSTRUCTOR) {
              hasConstructor = true;
              constructorParams = transformed.formalParameterList;
              constructorBody = transformed.functionBody;
            } else {
              elements.push(transformed);
            }
            break;
          default:
            throw new Error(("Unexpected class element: " + tree.type));
        }
      }));
      var object = createObjectLiteralExpression(protoElements);
      var staticObject = createObjectLiteralExpression(staticElements);
      var func;
      if (!hasConstructor) {
        func = this.getDefaultConstructor_(tree, internalName);
      } else {
        func = new FunctionExpression(tree.location, tree.name, false, constructorParams, null, [], constructorBody);
      }
      var state = this.state_;
      this.state_ = oldState;
      return {
        func: func,
        superClass: superClass,
        object: object,
        staticObject: staticObject,
        hasSuper: state.hasSuper
      };
    },
    transformClassDeclaration: function(tree) {
      var name = tree.name.identifierToken;
      var internalName = id(("$" + name));
      var renamed = AlphaRenamer.rename(tree, name.value, internalName.identifierToken.value);
      var referencesClassName = renamed !== tree;
      var tree = renamed;
      var $__186 = this.transformClassElements_(tree, internalName),
          func = $__186.func,
          hasSuper = $__186.hasSuper,
          object = $__186.object,
          staticObject = $__186.staticObject,
          superClass = $__186.superClass;
      var statements = parseStatements($__179, name, func);
      var expr = classCall(name, object, staticObject, superClass);
      if (hasSuper || referencesClassName) {
        statements.push(parseStatement($__180, internalName, name));
      }
      statements.push(createExpressionStatement(expr));
      var anonBlock = new AnonBlock(null, statements);
      return this.makeStrict_(anonBlock);
    },
    transformClassExpression: function(tree) {
      this.pushTempVarState();
      var name;
      if (tree.name) name = tree.name.identifierToken; else name = id(this.getTempIdentifier());
      var $__186 = this.transformClassElements_(tree, name),
          func = $__186.func,
          hasSuper = $__186.hasSuper,
          object = $__186.object,
          staticObject = $__186.staticObject,
          superClass = $__186.superClass;
      var expression;
      if (hasSuper) {
        expression = parseExpression($__181, name, func, name, object, staticObject, superClass);
      } else if (tree.name) {
        expression = parseExpression($__182, name, func, name, object, staticObject);
      } else {
        expression = classCall(func, object, staticObject, superClass);
      }
      this.popTempVarState();
      return createParenExpression(this.makeStrict_(expression));
    },
    transformPropertyMethodAssignment_: function(tree, internalName) {
      var formalParameterList = this.transformAny(tree.formalParameterList);
      var functionBody = this.transformSuperInFunctionBody_(tree, tree.functionBody, internalName);
      if (!tree.isStatic && formalParameterList === tree.formalParameterList && functionBody === tree.functionBody) {
        return tree;
      }
      var isStatic = false;
      return new PropertyMethodAssignment(tree.location, isStatic, tree.isGenerator, tree.name, formalParameterList, tree.typeAnnotation, tree.annotations, functionBody);
    },
    transformGetAccessor_: function(tree, internalName) {
      var body = this.transformSuperInFunctionBody_(tree, tree.body, internalName);
      if (!tree.isStatic && body === tree.body) return tree;
      return new GetAccessor(tree.location, false, tree.name, tree.typeAnnotation, tree.annotations, body);
    },
    transformSetAccessor_: function(tree, internalName) {
      var parameter = this.transformAny(tree.parameter);
      var body = this.transformSuperInFunctionBody_(tree, tree.body, internalName);
      if (!tree.isStatic && body === tree.body) return tree;
      return new SetAccessor(tree.location, false, tree.name, parameter, tree.annotations, body);
    },
    transformSuperInFunctionBody_: function(methodTree, tree, internalName) {
      this.pushTempVarState();
      var thisName = this.getTempIdentifier();
      var thisDecl = createVariableStatement(VAR, thisName, createThisExpression());
      var superTransformer = new SuperTransformer(this, this.reporter_, internalName, methodTree, thisName);
      var transformedTree = superTransformer.transformFunctionBody(this.transformFunctionBody(tree));
      if (superTransformer.hasSuper) this.state_.hasSuper = true;
      this.popTempVarState();
      if (superTransformer.nestedSuper) return createFunctionBody([thisDecl].concat(transformedTree.statements));
      return transformedTree;
    },
    getDefaultConstructor_: function(tree, internalName) {
      var constructorParams = createEmptyParameterList();
      var constructorBody;
      if (tree.superClass) {
        var statement = parseStatement($__183, internalName);
        constructorBody = createFunctionBody([statement]);
        this.state_.hasSuper = true;
      } else {
        constructorBody = createFunctionBody([]);
      }
      return new FunctionExpression(tree.location, tree.name, false, constructorParams, null, [], constructorBody);
    }
  }, {}, TempVarTransformer);
  return {get ClassTransformer() {
      return ClassTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/CommonJsModuleTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/CommonJsModuleTransformer";
  var $__187 = Object.freeze(Object.defineProperties(["module.exports = function() {\n            ", "\n          }.call(", ");"], {raw: {value: Object.freeze(["module.exports = function() {\n            ", "\n          }.call(", ");"])}})),
      $__188 = Object.freeze(Object.defineProperties(["module.exports = ", ";"], {raw: {value: Object.freeze(["module.exports = ", ";"])}})),
      $__189 = Object.freeze(Object.defineProperties(["require(", ")"], {raw: {value: Object.freeze(["require(", ")"])}}));
  var ModuleTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ModuleTransformer").ModuleTransformer;
  var RETURN_STATEMENT = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType").RETURN_STATEMENT;
  var assert = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/assert").assert;
  var globalThis = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/globalThis").default;
  var $__191 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser"),
      parseExpression = $__191.parseExpression,
      parseStatement = $__191.parseStatement,
      parseStatements = $__191.parseStatements;
  var scopeContainsThis = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/scopeContainsThis").default;
  var CommonJsModuleTransformer = function CommonJsModuleTransformer() {
    $traceurRuntime.defaultSuperCall(this, $CommonJsModuleTransformer.prototype, arguments);
  };
  var $CommonJsModuleTransformer = CommonJsModuleTransformer;
  ($traceurRuntime.createClass)(CommonJsModuleTransformer, {
    wrapModule: function(statements) {
      var needsIife = statements.some(scopeContainsThis);
      if (needsIife) {
        return parseStatements($__187, statements, globalThis());
      }
      var last = statements[statements.length - 1];
      statements = statements.slice(0, - 1);
      assert(last.type === RETURN_STATEMENT);
      var exportObject = last.expression;
      if (this.hasExports()) {
        statements.push(parseStatement($__188, exportObject));
      }
      return statements;
    },
    transformModuleSpecifier: function(tree) {
      return parseExpression($__189, tree.token);
    }
  }, {}, ModuleTransformer);
  return {get CommonJsModuleTransformer() {
      return CommonJsModuleTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/ParameterTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/ParameterTransformer";
  var FunctionBody = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees").FunctionBody;
  var TempVarTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/TempVarTransformer").TempVarTransformer;
  var prependStatements = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PrependStatements").prependStatements;
  var stack = [];
  var ParameterTransformer = function ParameterTransformer() {
    $traceurRuntime.defaultSuperCall(this, $ParameterTransformer.prototype, arguments);
  };
  var $ParameterTransformer = ParameterTransformer;
  ($traceurRuntime.createClass)(ParameterTransformer, {
    transformArrowFunctionExpression: function(tree) {
      stack.push([]);
      return $traceurRuntime.superCall(this, $ParameterTransformer.prototype, "transformArrowFunctionExpression", [tree]);
    },
    transformFunctionDeclaration: function(tree) {
      stack.push([]);
      return $traceurRuntime.superCall(this, $ParameterTransformer.prototype, "transformFunctionDeclaration", [tree]);
    },
    transformFunctionExpression: function(tree) {
      stack.push([]);
      return $traceurRuntime.superCall(this, $ParameterTransformer.prototype, "transformFunctionExpression", [tree]);
    },
    transformGetAccessor: function(tree) {
      stack.push([]);
      return $traceurRuntime.superCall(this, $ParameterTransformer.prototype, "transformGetAccessor", [tree]);
    },
    transformSetAccessor: function(tree) {
      stack.push([]);
      return $traceurRuntime.superCall(this, $ParameterTransformer.prototype, "transformSetAccessor", [tree]);
    },
    transformPropertyMethodAssignment: function(tree) {
      stack.push([]);
      return $traceurRuntime.superCall(this, $ParameterTransformer.prototype, "transformPropertyMethodAssignment", [tree]);
    },
    transformFunctionBody: function(tree) {
      var transformedTree = $traceurRuntime.superCall(this, $ParameterTransformer.prototype, "transformFunctionBody", [tree]);
      var statements = stack.pop();
      if (!statements.length) return transformedTree;
      statements = prependStatements.apply(null, $traceurRuntime.spread([transformedTree.statements], statements));
      return new FunctionBody(transformedTree.location, statements);
    },
    get parameterStatements() {
      return stack[stack.length - 1];
    }
  }, {}, TempVarTransformer);
  return {get ParameterTransformer() {
      return ParameterTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/DefaultParametersTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/DefaultParametersTransformer";
  var $__195 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/semantics/util"),
      isUndefined = $__195.isUndefined,
      isVoidExpression = $__195.isVoidExpression;
  var FormalParameterList = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees").FormalParameterList;
  var ParameterTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParameterTransformer").ParameterTransformer;
  var ARGUMENTS = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/PredefinedName").ARGUMENTS;
  var $__195 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      FORMAL_PARAMETER = $__195.FORMAL_PARAMETER,
      REST_PARAMETER = $__195.REST_PARAMETER;
  var $__195 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      NOT_EQUAL_EQUAL = $__195.NOT_EQUAL_EQUAL,
      VAR = $__195.VAR;
  var $__195 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createBinaryOperator = $__195.createBinaryOperator,
      createConditionalExpression = $__195.createConditionalExpression,
      createIdentifierExpression = $__195.createIdentifierExpression,
      createMemberLookupExpression = $__195.createMemberLookupExpression,
      createNumberLiteral = $__195.createNumberLiteral,
      createOperatorToken = $__195.createOperatorToken,
      createVariableStatement = $__195.createVariableStatement,
      createVoid0 = $__195.createVoid0;
  var prependStatements = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PrependStatements").prependStatements;
  function createDefaultAssignment(index, binding, initialiser) {
    var argumentsExpression = createMemberLookupExpression(createIdentifierExpression(ARGUMENTS), createNumberLiteral(index));
    var assignmentExpression;
    if (initialiser === null || isUndefined(initialiser) || isVoidExpression(initialiser)) {
      assignmentExpression = argumentsExpression;
    } else {
      assignmentExpression = createConditionalExpression(createBinaryOperator(argumentsExpression, createOperatorToken(NOT_EQUAL_EQUAL), createVoid0()), argumentsExpression, initialiser);
    }
    return createVariableStatement(VAR, binding, assignmentExpression);
  }
  var DefaultParametersTransformer = function DefaultParametersTransformer() {
    $traceurRuntime.defaultSuperCall(this, $DefaultParametersTransformer.prototype, arguments);
  };
  var $DefaultParametersTransformer = DefaultParametersTransformer;
  ($traceurRuntime.createClass)(DefaultParametersTransformer, {transformFormalParameterList: function(tree) {
      var parameters = [];
      var changed = false;
      var defaultToUndefined = false;
      for (var i = 0; i < tree.parameters.length; i++) {
        var param = this.transformAny(tree.parameters[i]);
        if (param !== tree.parameters[i]) changed = true;
        if (param.isRestParameter() || !param.parameter.initialiser && !defaultToUndefined) {
          parameters.push(param);
        } else {
          defaultToUndefined = true;
          changed = true;
          this.parameterStatements.push(createDefaultAssignment(i, param.parameter.binding, param.parameter.initialiser));
        }
      }
      if (!changed) return tree;
      return new FormalParameterList(tree.location, parameters);
    }}, {}, ParameterTransformer);
  return {get DefaultParametersTransformer() {
      return DefaultParametersTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/DestructuringTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/DestructuringTransformer";
  var $__198 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/PredefinedName"),
      ARRAY = $__198.ARRAY,
      CALL = $__198.CALL,
      PROTOTYPE = $__198.PROTOTYPE,
      SLICE = $__198.SLICE;
  var $__198 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      ARRAY_LITERAL_EXPRESSION = $__198.ARRAY_LITERAL_EXPRESSION,
      ARRAY_PATTERN = $__198.ARRAY_PATTERN,
      BINDING_ELEMENT = $__198.BINDING_ELEMENT,
      BINDING_IDENTIFIER = $__198.BINDING_IDENTIFIER,
      BLOCK = $__198.BLOCK,
      CALL_EXPRESSION = $__198.CALL_EXPRESSION,
      COMPUTED_PROPERTY_NAME = $__198.COMPUTED_PROPERTY_NAME,
      IDENTIFIER_EXPRESSION = $__198.IDENTIFIER_EXPRESSION,
      LITERAL_EXPRESSION = $__198.LITERAL_EXPRESSION,
      MEMBER_EXPRESSION = $__198.MEMBER_EXPRESSION,
      MEMBER_LOOKUP_EXPRESSION = $__198.MEMBER_LOOKUP_EXPRESSION,
      OBJECT_LITERAL_EXPRESSION = $__198.OBJECT_LITERAL_EXPRESSION,
      OBJECT_PATTERN = $__198.OBJECT_PATTERN,
      OBJECT_PATTERN_FIELD = $__198.OBJECT_PATTERN_FIELD,
      PAREN_EXPRESSION = $__198.PAREN_EXPRESSION,
      VARIABLE_DECLARATION_LIST = $__198.VARIABLE_DECLARATION_LIST;
  var $__198 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      BindingElement = $__198.BindingElement,
      Catch = $__198.Catch,
      ForInStatement = $__198.ForInStatement,
      ForOfStatement = $__198.ForOfStatement,
      LiteralExpression = $__198.LiteralExpression;
  var ParameterTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParameterTransformer").ParameterTransformer;
  var $__198 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      EQUAL = $__198.EQUAL,
      IDENTIFIER = $__198.IDENTIFIER,
      IN = $__198.IN,
      LET = $__198.LET,
      VAR = $__198.VAR;
  var $__198 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createArgumentList = $__198.createArgumentList,
      createAssignmentExpression = $__198.createAssignmentExpression,
      createBinaryOperator = $__198.createBinaryOperator,
      createBindingIdentifier = $__198.createBindingIdentifier,
      createBlock = $__198.createBlock,
      createCallExpression = $__198.createCallExpression,
      createCommaExpression = $__198.createCommaExpression,
      createConditionalExpression = $__198.createConditionalExpression,
      createExpressionStatement = $__198.createExpressionStatement,
      createIdentifierExpression = $__198.createIdentifierExpression,
      createMemberExpression = $__198.createMemberExpression,
      createMemberLookupExpression = $__198.createMemberLookupExpression,
      createNumberLiteral = $__198.createNumberLiteral,
      createOperatorToken = $__198.createOperatorToken,
      createParenExpression = $__198.createParenExpression,
      createStringLiteral = $__198.createStringLiteral,
      createVariableDeclaration = $__198.createVariableDeclaration,
      createVariableDeclarationList = $__198.createVariableDeclarationList,
      createVariableStatement = $__198.createVariableStatement;
  var options = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/options").options;
  var Desugaring = function Desugaring(rvalue) {
    this.rvalue = rvalue;
  };
  ($traceurRuntime.createClass)(Desugaring, {}, {});
  var AssignmentExpressionDesugaring = function AssignmentExpressionDesugaring(rvalue) {
    $traceurRuntime.superCall(this, $AssignmentExpressionDesugaring.prototype, "constructor", [rvalue]);
    this.expressions = [];
  };
  var $AssignmentExpressionDesugaring = AssignmentExpressionDesugaring;
  ($traceurRuntime.createClass)(AssignmentExpressionDesugaring, {assign: function(lvalue, rvalue) {
      lvalue = lvalue instanceof BindingElement ? lvalue.binding: lvalue;
      this.expressions.push(createAssignmentExpression(lvalue, rvalue));
    }}, {}, Desugaring);
  var VariableDeclarationDesugaring = function VariableDeclarationDesugaring(rvalue) {
    $traceurRuntime.superCall(this, $VariableDeclarationDesugaring.prototype, "constructor", [rvalue]);
    this.declarations = [];
  };
  var $VariableDeclarationDesugaring = VariableDeclarationDesugaring;
  ($traceurRuntime.createClass)(VariableDeclarationDesugaring, {assign: function(lvalue, rvalue) {
      if (lvalue instanceof BindingElement) {
        this.declarations.push(createVariableDeclaration(lvalue.binding, rvalue));
        return;
      }
      if (lvalue.type == IDENTIFIER_EXPRESSION) lvalue = createBindingIdentifier(lvalue);
      this.declarations.push(createVariableDeclaration(lvalue, rvalue));
    }}, {}, Desugaring);
  function createConditionalMemberExpression(rvalue, name, initialiser) {
    if (name.type === COMPUTED_PROPERTY_NAME) {
      return createConditionalMemberLookupExpression(rvalue, name.expression, initialiser);
    }
    var token;
    if (name.type == BINDING_IDENTIFIER) {
      token = name.identifierToken;
    } else {
      token = name.literalToken;
      if (!token.isKeyword() && token.type !== IDENTIFIER) {
        return createConditionalMemberLookupExpression(rvalue, new LiteralExpression(null, token), initialiser);
      }
    }
    if (!initialiser) return createMemberExpression(rvalue, token);
    return createConditionalExpression(createBinaryOperator(createStringLiteral(token.toString()), createOperatorToken(IN), rvalue), createMemberExpression(rvalue, token), initialiser);
  }
  function createConditionalMemberLookupExpression(rvalue, index, initialiser) {
    if (!initialiser) return createMemberLookupExpression(rvalue, index);
    return createConditionalExpression(createBinaryOperator(index, createOperatorToken(IN), rvalue), createMemberLookupExpression(rvalue, index), initialiser);
  }
  var DestructuringTransformer = function DestructuringTransformer() {
    $traceurRuntime.defaultSuperCall(this, $DestructuringTransformer.prototype, arguments);
  };
  var $DestructuringTransformer = DestructuringTransformer;
  ($traceurRuntime.createClass)(DestructuringTransformer, {
    transformArrayPattern: function(tree) {
      throw new Error('unreachable');
    },
    transformObjectPattern: function(tree) {
      throw new Error('unreachable');
    },
    transformBinaryOperator: function(tree) {
      if (tree.operator.type == EQUAL && tree.left.isPattern()) {
        return this.transformAny(this.desugarAssignment_(tree.left, tree.right));
      } else {
        return $traceurRuntime.superCall(this, $DestructuringTransformer.prototype, "transformBinaryOperator", [tree]);
      }
    },
    desugarAssignment_: function(lvalue, rvalue) {
      var tempIdent = createIdentifierExpression(this.addTempVar());
      var desugaring = new AssignmentExpressionDesugaring(tempIdent);
      this.desugarPattern_(desugaring, lvalue);
      desugaring.expressions.unshift(createAssignmentExpression(tempIdent, rvalue));
      desugaring.expressions.push(tempIdent);
      return createParenExpression(createCommaExpression(desugaring.expressions));
    },
    transformVariableDeclarationList: function(tree) {
      var $__196 = this;
      if (!this.destructuringInDeclaration_(tree)) {
        return $traceurRuntime.superCall(this, $DestructuringTransformer.prototype, "transformVariableDeclarationList", [tree]);
      }
      this.pushTempVarState();
      var desugaredDeclarations = [];
      tree.declarations.forEach((function(declaration) {
        var $__199;
        if (declaration.lvalue.isPattern()) {
          ($__199 = desugaredDeclarations).push.apply($__199, $traceurRuntime.toObject($__196.desugarVariableDeclaration_(declaration)));
        } else {
          desugaredDeclarations.push(declaration);
        }
      }));
      var transformedTree = this.transformVariableDeclarationList(createVariableDeclarationList(tree.declarationType, desugaredDeclarations));
      this.popTempVarState();
      return transformedTree;
    },
    transformForInStatement: function(tree) {
      return this.transformForInOrOf_(tree, $traceurRuntime.superGet(this, $DestructuringTransformer.prototype, "transformForInStatement"), ForInStatement);
    },
    transformForOfStatement: function(tree) {
      return this.transformForInOrOf_(tree, $traceurRuntime.superGet(this, $DestructuringTransformer.prototype, "transformForOfStatement"), ForOfStatement);
    },
    transformForInOrOf_: function(tree, superMethod, constr) {
      var $__199;
      if (!tree.initialiser.isPattern() && (tree.initialiser.type !== VARIABLE_DECLARATION_LIST || !this.destructuringInDeclaration_(tree.initialiser))) {
        return superMethod.call(this, tree);
      }
      this.pushTempVarState();
      var declarationType,
          lvalue;
      if (tree.initialiser.isPattern()) {
        declarationType = null;
        lvalue = tree.initialiser;
      } else {
        declarationType = tree.initialiser.declarationType;
        lvalue = tree.initialiser.declarations[0].lvalue;
      }
      var statements = [];
      var binding = this.desugarBinding_(lvalue, statements, declarationType);
      var initialiser = createVariableDeclarationList(VAR, binding, null);
      var collection = this.transformAny(tree.collection);
      var body = this.transformAny(tree.body);
      if (body.type !== BLOCK) body = createBlock(body);
      ($__199 = statements).push.apply($__199, $traceurRuntime.toObject(body.statements));
      body = createBlock(statements);
      this.popTempVarState();
      return new constr(tree.location, initialiser, collection, body);
    },
    transformBindingElement: function(tree) {
      if (!tree.binding.isPattern() || tree.initialiser) return tree;
      var statements = this.parameterStatements;
      var binding = this.desugarBinding_(tree.binding, statements, VAR);
      return new BindingElement(null, binding, null);
    },
    transformCatch: function(tree) {
      var $__199;
      if (!tree.binding.isPattern()) return $traceurRuntime.superCall(this, $DestructuringTransformer.prototype, "transformCatch", [tree]);
      var body = this.transformAny(tree.catchBody);
      var statements = [];
      var kind = options.blockBinding ? LET: VAR;
      var binding = this.desugarBinding_(tree.binding, statements, kind);
      ($__199 = statements).push.apply($__199, $traceurRuntime.toObject(body.statements));
      return new Catch(tree.location, binding, createBlock(statements));
    },
    desugarBinding_: function(bindingTree, statements, declarationType) {
      var varName = this.getTempIdentifier();
      var binding = createBindingIdentifier(varName);
      var idExpr = createIdentifierExpression(varName);
      var desugaring;
      if (declarationType === null) desugaring = new AssignmentExpressionDesugaring(idExpr); else desugaring = new VariableDeclarationDesugaring(idExpr);
      this.desugarPattern_(desugaring, bindingTree);
      if (declarationType === null) {
        statements.push(createExpressionStatement(createCommaExpression(desugaring.expressions)));
      } else {
        statements.push(createVariableStatement(this.transformVariableDeclarationList(createVariableDeclarationList(declarationType, desugaring.declarations))));
      }
      return binding;
    },
    destructuringInDeclaration_: function(tree) {
      return tree.declarations.some((function(declaration) {
        return declaration.lvalue.isPattern();
      }));
    },
    desugarVariableDeclaration_: function(tree) {
      var tempRValueName = this.getTempIdentifier();
      var tempRValueIdent = createIdentifierExpression(tempRValueName);
      var desugaring;
      var initialiser;
      switch (tree.initialiser.type) {
        case ARRAY_LITERAL_EXPRESSION:
        case CALL_EXPRESSION:
        case IDENTIFIER_EXPRESSION:
        case LITERAL_EXPRESSION:
        case MEMBER_EXPRESSION:
        case MEMBER_LOOKUP_EXPRESSION:
        case OBJECT_LITERAL_EXPRESSION:
        case PAREN_EXPRESSION:
          initialiser = tree.initialiser;
        default:
          desugaring = new VariableDeclarationDesugaring(tempRValueIdent);
          desugaring.assign(desugaring.rvalue, tree.initialiser);
          var initialiserFound = this.desugarPattern_(desugaring, tree.lvalue);
          if (initialiserFound || desugaring.declarations.length > 2) return desugaring.declarations;
          initialiser = initialiser || createParenExpression(tree.initialiser);
          desugaring = new VariableDeclarationDesugaring(initialiser);
          this.desugarPattern_(desugaring, tree.lvalue);
          return desugaring.declarations;
      }
    },
    desugarPattern_: function(desugaring, tree) {
      var initialiserFound = false;
      switch (tree.type) {
        case ARRAY_PATTERN:
          {
            var pattern = tree;
            for (var i = 0; i < pattern.elements.length; i++) {
              var lvalue = pattern.elements[i];
              if (lvalue === null) {
                continue;
              } else if (lvalue.isSpreadPatternElement()) {
                desugaring.assign(lvalue.lvalue, createCallExpression(createMemberExpression(ARRAY, PROTOTYPE, SLICE, CALL), createArgumentList(desugaring.rvalue, createNumberLiteral(i))));
              } else {
                if (lvalue.initialiser) initialiserFound = true;
                desugaring.assign(lvalue, createConditionalMemberLookupExpression(desugaring.rvalue, createNumberLiteral(i), lvalue.initialiser));
              }
            }
            break;
          }
        case OBJECT_PATTERN:
          {
            var pattern = tree;
            pattern.fields.forEach((function(field) {
              var lookup;
              switch (field.type) {
                case BINDING_ELEMENT:
                  if (field.initialiser) initialiserFound = true;
                  lookup = createConditionalMemberExpression(desugaring.rvalue, field.binding, field.initialiser);
                  desugaring.assign(createIdentifierExpression(field.binding), lookup);
                  break;
                case OBJECT_PATTERN_FIELD:
                  if (field.element.initialiser) initialiserFound = true;
                  var name = field.name;
                  lookup = createConditionalMemberExpression(desugaring.rvalue, name, field.element.initialiser);
                  desugaring.assign(field.element, lookup);
                  break;
                case IDENTIFIER_EXPRESSION:
                  lookup = createMemberExpression(desugaring.rvalue, field.identifierToken);
                  desugaring.assign(field, lookup);
                  break;
                default:
                  throw Error('unreachable');
              }
            }));
            break;
          }
        case PAREN_EXPRESSION:
          return this.desugarPattern_(desugaring, tree.expression);
        default:
          throw new Error('unreachable');
      }
      if (desugaring instanceof VariableDeclarationDesugaring && desugaring.declarations.length === 0) {
        desugaring.assign(createBindingIdentifier(this.getTempIdentifier()), desugaring.rvalue);
      }
      return initialiserFound;
    }
  }, {}, ParameterTransformer);
  return {get DestructuringTransformer() {
      return DestructuringTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/ForOfTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/ForOfTransformer";
  var $__200 = Object.freeze(Object.defineProperties(["", " = ", ".value;"], {raw: {value: Object.freeze(["", " = ", ".value;"])}})),
      $__201 = Object.freeze(Object.defineProperties(["\n        for (var ", " =\n                 ", "[Symbol.iterator](),\n                 ", ";\n             !(", " = ", ".next()).done; ) {\n          ", ";\n          ", ";\n        }"], {raw: {value: Object.freeze(["\n        for (var ", " =\n                 ", "[Symbol.iterator](),\n                 ", ";\n             !(", " = ", ".next()).done; ) {\n          ", ";\n          ", ";\n        }"])}}));
  var VARIABLE_DECLARATION_LIST = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType").VARIABLE_DECLARATION_LIST;
  var TempVarTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/TempVarTransformer").TempVarTransformer;
  var $__203 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      id = $__203.createIdentifierExpression,
      createMemberExpression = $__203.createMemberExpression,
      createVariableStatement = $__203.createVariableStatement;
  var parseStatement = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser").parseStatement;
  var ForOfTransformer = function ForOfTransformer() {
    $traceurRuntime.defaultSuperCall(this, $ForOfTransformer.prototype, arguments);
  };
  var $ForOfTransformer = ForOfTransformer;
  ($traceurRuntime.createClass)(ForOfTransformer, {transformForOfStatement: function(original) {
      var tree = $traceurRuntime.superCall(this, $ForOfTransformer.prototype, "transformForOfStatement", [original]);
      var iter = id(this.getTempIdentifier());
      var result = id(this.getTempIdentifier());
      var assignment;
      if (tree.initialiser.type === VARIABLE_DECLARATION_LIST) {
        assignment = createVariableStatement(tree.initialiser.declarationType, tree.initialiser.declarations[0].lvalue, createMemberExpression(result, 'value'));
      } else {
        assignment = parseStatement($__200, tree.initialiser, result);
      }
      return parseStatement($__201, iter, tree.collection, result, result, iter, assignment, tree.body);
    }}, {}, TempVarTransformer);
  return {get ForOfTransformer() {
      return ForOfTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/GeneratorComprehensionTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/GeneratorComprehensionTransformer";
  var ComprehensionTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ComprehensionTransformer").ComprehensionTransformer;
  var createYieldStatement = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory").createYieldStatement;
  var GeneratorComprehensionTransformer = function GeneratorComprehensionTransformer() {
    $traceurRuntime.defaultSuperCall(this, $GeneratorComprehensionTransformer.prototype, arguments);
  };
  var $GeneratorComprehensionTransformer = GeneratorComprehensionTransformer;
  ($traceurRuntime.createClass)(GeneratorComprehensionTransformer, {transformGeneratorComprehension: function(tree) {
      var expression = this.transformAny(tree.expression);
      var statement = createYieldStatement(expression);
      var isGenerator = true;
      return this.transformComprehension(tree, statement, isGenerator);
    }}, {}, ComprehensionTransformer);
  return {get GeneratorComprehensionTransformer() {
      return GeneratorComprehensionTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/State", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/State";
  var $__206 = Object.freeze(Object.defineProperties(["$ctx.finallyFallThrough = ", ""], {raw: {value: Object.freeze(["$ctx.finallyFallThrough = ", ""])}}));
  var $__208 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createAssignStateStatement = $__208.createAssignStateStatement,
      createAssignmentStatement = $__208.createAssignmentStatement,
      createBreakStatement = $__208.createBreakStatement,
      createCaseClause = $__208.createCaseClause,
      createIdentifierExpression = $__208.createIdentifierExpression,
      createNumberLiteral = $__208.createNumberLiteral,
      createStatementList = $__208.createStatementList;
  var parseStatement = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser").parseStatement;
  var State = function State(id) {
    this.id = id;
  };
  ($traceurRuntime.createClass)(State, {
    transformMachineState: function(enclosingFinally, machineEndState, reporter) {
      return createCaseClause(createNumberLiteral(this.id), this.transform(enclosingFinally, machineEndState, reporter));
    },
    transformBreak: function(labelSet, breakState) {
      return this;
    },
    transformBreakOrContinue: function(labelSet, breakState, continueState) {
      return this;
    }
  }, {});
  State.START_STATE = 0;
  State.INVALID_STATE = - 1;
  State.END_STATE = - 2;
  State.RETHROW_STATE = - 3;
  State.generateJump = function(enclosingFinally, fallThroughState) {
    return createStatementList(State.generateAssignState(enclosingFinally, fallThroughState), createBreakStatement());
  };
  State.generateAssignState = function(enclosingFinally, fallThroughState) {
    var assignState;
    if (isFinallyExit(enclosingFinally, fallThroughState)) {
      assignState = State.generateAssignStateOutOfFinally(enclosingFinally, fallThroughState);
    } else {
      assignState = createStatementList(createAssignStateStatement(fallThroughState));
    }
    return assignState;
  };
  function isFinallyExit(enclosingFinally, destination) {
    return enclosingFinally != null && enclosingFinally.tryStates.indexOf(destination) < 0;
  }
  State.generateAssignStateOutOfFinally = function(enclosingFinally, destination) {
    return State.generateAssignStateOutOfFinally_(destination, enclosingFinally.finallyState);
  };
  State.generateAssignStateOutOfFinally_ = function(destination, finallyState) {
    return createStatementList(createAssignStateStatement(finallyState), parseStatement($__206, destination));
  };
  State.replaceStateList = function(oldStates, oldState, newState) {
    var states = [];
    for (var i = 0; i < oldStates.length; i++) {
      states.push(State.replaceStateId(oldStates[i], oldState, newState));
    }
    return states;
  };
  State.replaceStateId = function(current, oldState, newState) {
    return current == oldState ? newState: current;
  };
  State.replaceAllStates = function(exceptionBlocks, oldState, newState) {
    var result = [];
    for (var i = 0; i < exceptionBlocks.length; i++) {
      result.push(exceptionBlocks[i].replaceState(oldState, newState));
    }
    return result;
  };
  return {get State() {
      return State;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/TryState", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/TryState";
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var Kind = {
    CATCH: 'catch',
    FINALLY: 'finally'
  };
  var TryState = function TryState(kind, tryStates, nestedTrys) {
    this.kind = kind;
    this.tryStates = tryStates;
    this.nestedTrys = nestedTrys;
  };
  ($traceurRuntime.createClass)(TryState, {
    replaceAllStates: function(oldState, newState) {
      return State.replaceStateList(this.tryStates, oldState, newState);
    },
    replaceNestedTrys: function(oldState, newState) {
      var states = [];
      for (var i = 0; i < this.nestedTrys.length; i++) {
        states.push(this.nestedTrys[i].replaceState(oldState, newState));
      }
      return states;
    }
  }, {});
  TryState.Kind = Kind;
  return {get TryState() {
      return TryState;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/syntax/trees/StateMachine", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/syntax/trees/StateMachine";
  var ParseTree = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTree").ParseTree;
  var STATE_MACHINE = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType").STATE_MACHINE;
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var TryState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/TryState").TryState;
  function addCatchOrFinallyStates(kind, enclosingMap, tryStates) {
    for (var i = 0; i < tryStates.length; i++) {
      var tryState = tryStates[i];
      if (tryState.kind == kind) {
        for (var j = 0; j < tryState.tryStates.length; j++) {
          var id = tryState.tryStates[j];
          enclosingMap[id] = tryState;
        }
      }
      addCatchOrFinallyStates(kind, enclosingMap, tryState.nestedTrys);
    }
  }
  function addAllCatchStates(tryStates, catches) {
    for (var i = 0; i < tryStates.length; i++) {
      var tryState = tryStates[i];
      if (tryState.kind == TryState.Kind.CATCH) {
        catches.push(tryState);
      }
      addAllCatchStates(tryState.nestedTrys, catches);
    }
  }
  var StateMachine = function StateMachine(startState, fallThroughState, states, exceptionBlocks) {
    this.location = null;
    this.startState = startState;
    this.fallThroughState = fallThroughState;
    this.states = states;
    this.exceptionBlocks = exceptionBlocks;
  };
  var $StateMachine = StateMachine;
  ($traceurRuntime.createClass)(StateMachine, {
    get type() {
      return STATE_MACHINE;
    },
    transform: function(transformer) {
      return transformer.transformStateMachine(this);
    },
    visit: function(visitor) {
      visitor.visitStateMachine(this);
    },
    getAllStateIDs: function() {
      var result = [];
      for (var i = 0; i < this.states.length; i++) {
        result.push(this.states[i].id);
      }
      return result;
    },
    getEnclosingFinallyMap: function() {
      var enclosingMap = Object.create(null);
      addCatchOrFinallyStates(TryState.Kind.FINALLY, enclosingMap, this.exceptionBlocks);
      return enclosingMap;
    },
    allCatchStates: function() {
      var catches = [];
      addAllCatchStates(this.exceptionBlocks, catches);
      return catches;
    },
    replaceStateId: function(oldState, newState) {
      return new $StateMachine(State.replaceStateId(this.startState, oldState, newState), State.replaceStateId(this.fallThroughState, oldState, newState), State.replaceAllStates(this.states, oldState, newState), State.replaceAllStates(this.exceptionBlocks, oldState, newState));
    },
    append: function(nextMachine) {
      var states = $traceurRuntime.spread(this.states);
      for (var i = 0; i < nextMachine.states.length; i++) {
        var otherState = nextMachine.states[i];
        states.push(otherState.replaceState(nextMachine.startState, this.fallThroughState));
      }
      var exceptionBlocks = $traceurRuntime.spread(this.exceptionBlocks);
      for (var i = 0; i < nextMachine.exceptionBlocks.length; i++) {
        var tryState = nextMachine.exceptionBlocks[i];
        exceptionBlocks.push(tryState.replaceState(nextMachine.startState, this.fallThroughState));
      }
      return new $StateMachine(this.startState, nextMachine.fallThroughState, states, exceptionBlocks);
    }
  }, {}, ParseTree);
  return {get StateMachine() {
      return StateMachine;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/AwaitState", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/AwaitState";
  var $__213 = Object.freeze(Object.defineProperties(["(", ").then($ctx.createCallback(", "),\n                                     $ctx.createErrback(", "));\n          return"], {raw: {value: Object.freeze(["(", ").then($ctx.createCallback(", "),\n                                     $ctx.createErrback(", "));\n          return"])}}));
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var parseStatements = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser").parseStatements;
  var AwaitState = function AwaitState(id, callbackState, errbackState, expression) {
    $traceurRuntime.superCall(this, $AwaitState.prototype, "constructor", [id]), this.callbackState = callbackState;
    this.errbackState = errbackState;
    this.expression = expression;
    this.statements_ = null;
  };
  var $AwaitState = AwaitState;
  ($traceurRuntime.createClass)(AwaitState, {
    get statements() {
      if (!this.statements_) {
        this.statements_ = parseStatements($__213, this.expression, this.callbackState, this.errbackState);
      }
      return this.statements_;
    },
    replaceState: function(oldState, newState) {
      return new $AwaitState(State.replaceStateId(this.id, oldState, newState), State.replaceStateId(this.callbackState, oldState, newState), State.replaceStateId(this.errbackState, oldState, newState), this.expression);
    },
    transform: function(enclosingFinally, machineEndState, reporter) {
      return this.statements;
    }
  }, {}, State);
  return {get AwaitState() {
      return AwaitState;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/FallThroughState", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/FallThroughState";
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var FallThroughState = function FallThroughState(id, fallThroughState, statements) {
    $traceurRuntime.superCall(this, $FallThroughState.prototype, "constructor", [id]);
    this.fallThroughState = fallThroughState;
    this.statements = statements;
  };
  var $FallThroughState = FallThroughState;
  ($traceurRuntime.createClass)(FallThroughState, {
    replaceState: function(oldState, newState) {
      return new $FallThroughState(State.replaceStateId(this.id, oldState, newState), State.replaceStateId(this.fallThroughState, oldState, newState), this.statements);
    },
    transform: function(enclosingFinally, machineEndState, reporter) {
      return $traceurRuntime.spread(this.statements, State.generateJump(enclosingFinally, this.fallThroughState));
    }
  }, {}, State);
  return {get FallThroughState() {
      return FallThroughState;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/BreakState", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/BreakState";
  var FallThroughState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/FallThroughState").FallThroughState;
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var createStatementList = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory").createStatementList;
  var BreakState = function BreakState(id, label) {
    $traceurRuntime.superCall(this, $BreakState.prototype, "constructor", [id]);
    this.label = label;
  };
  var $BreakState = BreakState;
  ($traceurRuntime.createClass)(BreakState, {
    replaceState: function(oldState, newState) {
      return new $BreakState(State.replaceStateId(this.id, oldState, newState), this.label);
    },
    transform: function(enclosingFinally, machineEndState, reporter) {
      throw new Error('These should be removed before the transform step');
    },
    transformBreak: function(labelSet, breakState) {
      if (this.label == null) return new FallThroughState(this.id, breakState, []);
      if (this.label in labelSet) {
        return new FallThroughState(this.id, labelSet[this.label].fallThroughState, []);
      }
      return this;
    },
    transformBreakOrContinue: function(labelSet, breakState, continueState) {
      return this.transformBreak(labelSet, breakState);
    }
  }, {}, State);
  return {get BreakState() {
      return BreakState;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/ContinueState", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/ContinueState";
  var FallThroughState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/FallThroughState").FallThroughState;
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var createStatementList = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory").createStatementList;
  var ContinueState = function ContinueState(id, label) {
    $traceurRuntime.superCall(this, $ContinueState.prototype, "constructor", [id]);
    this.label = label;
  };
  var $ContinueState = ContinueState;
  ($traceurRuntime.createClass)(ContinueState, {
    replaceState: function(oldState, newState) {
      return new $ContinueState(State.replaceStateId(this.id, oldState, newState), this.label);
    },
    transform: function(enclosingFinally, machineEndState, reporter) {
      throw new Error('These should be removed before the transform step');
    },
    transformBreakOrContinue: function(labelSet, breakState, continueState) {
      if (this.label == null) return new FallThroughState(this.id, continueState, []);
      if (this.label in labelSet) {
        return new FallThroughState(this.id, labelSet[this.label].continueState, []);
      }
      return this;
    }
  }, {}, State);
  return {get ContinueState() {
      return ContinueState;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/BreakContinueTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/BreakContinueTransformer";
  var BreakState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/BreakState").BreakState;
  var ContinueState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/ContinueState").ContinueState;
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var StateMachine = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/StateMachine").StateMachine;
  function safeGetLabel(tree) {
    return tree.name ? tree.name.value: null;
  }
  var BreakContinueTransformer = function BreakContinueTransformer(stateAllocator) {
    $traceurRuntime.superCall(this, $BreakContinueTransformer.prototype, "constructor", []);
    this.transformBreaks_ = true;
    this.stateAllocator_ = stateAllocator;
  };
  var $BreakContinueTransformer = BreakContinueTransformer;
  ($traceurRuntime.createClass)(BreakContinueTransformer, {
    allocateState_: function() {
      return this.stateAllocator_.allocateState();
    },
    stateToStateMachine_: function(newState) {
      var fallThroughState = this.allocateState_();
      return new StateMachine(newState.id, fallThroughState, [newState], []);
    },
    transformBreakStatement: function(tree) {
      return this.transformBreaks_ || tree.name ? this.stateToStateMachine_(new BreakState(this.allocateState_(), safeGetLabel(tree))): tree;
    },
    transformContinueStatement: function(tree) {
      return this.stateToStateMachine_(new ContinueState(this.allocateState_(), safeGetLabel(tree)));
    },
    transformDoWhileStatement: function(tree) {
      return tree;
    },
    transformForOfStatement: function(tree) {
      return tree;
    },
    transformForStatement: function(tree) {
      return tree;
    },
    transformFunctionDeclaration: function(tree) {
      return tree;
    },
    transformFunctionExpression: function(tree) {
      return tree;
    },
    transformStateMachine: function(tree) {
      return tree;
    },
    transformSwitchStatement: function(tree) {
      var oldState = this.transformBreaks_;
      this.transformBreaks_ = false;
      var result = $traceurRuntime.superCall(this, $BreakContinueTransformer.prototype, "transformSwitchStatement", [tree]);
      this.transformBreaks_ = oldState;
      return result;
    },
    transformWhileStatement: function(tree) {
      return tree;
    }
  }, {}, ParseTreeTransformer);
  return {get BreakContinueTransformer() {
      return BreakContinueTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/CatchState", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/CatchState";
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var TryState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/TryState").TryState;
  var CatchState = function CatchState(identifier, catchState, fallThroughState, allStates, nestedTrys) {
    $traceurRuntime.superCall(this, $CatchState.prototype, "constructor", [TryState.Kind.CATCH, allStates, nestedTrys]);
    this.identifier = identifier;
    this.catchState = catchState;
    this.fallThroughState = fallThroughState;
  };
  var $CatchState = CatchState;
  ($traceurRuntime.createClass)(CatchState, {replaceState: function(oldState, newState) {
      return new $CatchState(this.identifier, State.replaceStateId(this.catchState, oldState, newState), State.replaceStateId(this.fallThroughState, oldState, newState), this.replaceAllStates(oldState, newState), this.replaceNestedTrys(oldState, newState));
    }}, {}, TryState);
  return {get CatchState() {
      return CatchState;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/ConditionalState", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/ConditionalState";
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var $__227 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createBlock = $__227.createBlock,
      createIfStatement = $__227.createIfStatement;
  var ConditionalState = function ConditionalState(id, ifState, elseState, condition) {
    $traceurRuntime.superCall(this, $ConditionalState.prototype, "constructor", [id]);
    this.ifState = ifState;
    this.elseState = elseState;
    this.condition = condition;
  };
  var $ConditionalState = ConditionalState;
  ($traceurRuntime.createClass)(ConditionalState, {
    replaceState: function(oldState, newState) {
      return new $ConditionalState(State.replaceStateId(this.id, oldState, newState), State.replaceStateId(this.ifState, oldState, newState), State.replaceStateId(this.elseState, oldState, newState), this.condition);
    },
    transform: function(enclosingFinally, machineEndState, reporter) {
      return [createIfStatement(this.condition, createBlock(State.generateJump(enclosingFinally, this.ifState)), createBlock(State.generateJump(enclosingFinally, this.elseState)))];
    }
  }, {}, State);
  return {get ConditionalState() {
      return ConditionalState;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/FinallyFallThroughState", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/FinallyFallThroughState";
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var FinallyFallThroughState = function FinallyFallThroughState() {
    $traceurRuntime.defaultSuperCall(this, $FinallyFallThroughState.prototype, arguments);
  };
  var $FinallyFallThroughState = FinallyFallThroughState;
  ($traceurRuntime.createClass)(FinallyFallThroughState, {
    replaceState: function(oldState, newState) {
      return new $FinallyFallThroughState(State.replaceStateId(this.id, oldState, newState));
    },
    transformMachineState: function(enclosingFinally, machineEndState, reporter) {
      return null;
    },
    transform: function(enclosingFinally, machineEndState, reporter) {
      throw new Error('these are generated in addFinallyFallThroughDispatches');
    }
  }, {}, State);
  return {get FinallyFallThroughState() {
      return FinallyFallThroughState;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/FinallyState", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/FinallyState";
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var TryState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/TryState").TryState;
  var FinallyState = function FinallyState(finallyState, fallThroughState, allStates, nestedTrys) {
    $traceurRuntime.superCall(this, $FinallyState.prototype, "constructor", [TryState.Kind.FINALLY, allStates, nestedTrys]);
    this.finallyState = finallyState;
    this.fallThroughState = fallThroughState;
  };
  var $FinallyState = FinallyState;
  ($traceurRuntime.createClass)(FinallyState, {replaceState: function(oldState, newState) {
      return new $FinallyState(State.replaceStateId(this.finallyState, oldState, newState), State.replaceStateId(this.fallThroughState, oldState, newState), this.replaceAllStates(oldState, newState), this.replaceNestedTrys(oldState, newState));
    }}, {}, TryState);
  return {get FinallyState() {
      return FinallyState;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/StateAllocator", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/StateAllocator";
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var StateAllocator = function StateAllocator() {
    this.nextState_ = State.START_STATE + 1;
  };
  ($traceurRuntime.createClass)(StateAllocator, {allocateState: function() {
      return this.nextState_++;
    }}, {});
  return {get StateAllocator() {
      return StateAllocator;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/SwitchState", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/SwitchState";
  var $__235 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      CaseClause = $__235.CaseClause,
      DefaultClause = $__235.DefaultClause,
      SwitchStatement = $__235.SwitchStatement;
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var $__235 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createBreakStatement = $__235.createBreakStatement,
      createStatementList = $__235.createStatementList;
  var SwitchClause = function SwitchClause(first, second) {
    this.first = first;
    this.second = second;
  };
  ($traceurRuntime.createClass)(SwitchClause, {}, {});
  var SwitchState = function SwitchState(id, expression, clauses) {
    $traceurRuntime.superCall(this, $SwitchState.prototype, "constructor", [id]);
    this.expression = expression;
    this.clauses = clauses;
  };
  var $SwitchState = SwitchState;
  ($traceurRuntime.createClass)(SwitchState, {
    replaceState: function(oldState, newState) {
      var clauses = this.clauses.map((function(clause) {
        return new SwitchClause(clause.first, State.replaceStateId(clause.second, oldState, newState));
      }));
      return new $SwitchState(State.replaceStateId(this.id, oldState, newState), this.expression, clauses);
    },
    transform: function(enclosingFinally, machineEndState, reporter) {
      var clauses = [];
      for (var i = 0; i < this.clauses.length; i++) {
        var clause = this.clauses[i];
        if (clause.first == null) {
          clauses.push(new DefaultClause(null, State.generateJump(enclosingFinally, clause.second)));
        } else {
          clauses.push(new CaseClause(null, clause.first, State.generateJump(enclosingFinally, clause.second)));
        }
      }
      return createStatementList(new SwitchStatement(null, this.expression, clauses), createBreakStatement());
    }
  }, {}, State);
  return {
    get SwitchClause() {
      return SwitchClause;
    },
    get SwitchState() {
      return SwitchState;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/CPSTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/CPSTransformer";
  var $__236 = Object.freeze(Object.defineProperties(["$ctx.pushTry(\n            ", ",\n            ", ");"], {raw: {value: Object.freeze(["$ctx.pushTry(\n            ", ",\n            ", ");"])}})),
      $__237 = Object.freeze(Object.defineProperties(["$ctx.popTry();"], {raw: {value: Object.freeze(["$ctx.popTry();"])}})),
      $__238 = Object.freeze(Object.defineProperties(["\n              $ctx.popTry();\n              ", " = $ctx.storedException;"], {raw: {value: Object.freeze(["\n              $ctx.popTry();\n              ", " = $ctx.storedException;"])}})),
      $__239 = Object.freeze(Object.defineProperties(["$ctx.popTry();"], {raw: {value: Object.freeze(["$ctx.popTry();"])}})),
      $__240 = Object.freeze(Object.defineProperties(["function($ctx) {\n      while (true) ", "\n    }"], {raw: {value: Object.freeze(["function($ctx) {\n      while (true) ", "\n    }"])}})),
      $__241 = Object.freeze(Object.defineProperties(["var $arguments = arguments;"], {raw: {value: Object.freeze(["var $arguments = arguments;"])}})),
      $__242 = Object.freeze(Object.defineProperties(["return ", "(\n            ", ",\n            this);"], {raw: {value: Object.freeze(["return ", "(\n            ", ",\n            this);"])}})),
      $__243 = Object.freeze(Object.defineProperties(["throw 'traceur compiler bug: invalid state in state machine: ' +\n            $ctx.state;"], {raw: {value: Object.freeze(["throw 'traceur compiler bug: invalid state in state machine: ' +\n            $ctx.state;"])}})),
      $__244 = Object.freeze(Object.defineProperties(["\n                  $ctx.state = $ctx.finallyFallThrough;\n                  $ctx.finallyFallThrough = ", ";\n                  break;"], {raw: {value: Object.freeze(["\n                  $ctx.state = $ctx.finallyFallThrough;\n                  $ctx.finallyFallThrough = ", ";\n                  break;"])}})),
      $__245 = Object.freeze(Object.defineProperties(["\n                      $ctx.state = $ctx.finallyFallThrough;\n                      break;"], {raw: {value: Object.freeze(["\n                      $ctx.state = $ctx.finallyFallThrough;\n                      break;"])}}));
  var AlphaRenamer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/AlphaRenamer").AlphaRenamer;
  var BreakContinueTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/BreakContinueTransformer").BreakContinueTransformer;
  var $__247 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      BREAK_STATEMENT = $__247.BREAK_STATEMENT,
      CASE_CLAUSE = $__247.CASE_CLAUSE,
      CONTINUE_STATEMENT = $__247.CONTINUE_STATEMENT,
      STATE_MACHINE = $__247.STATE_MACHINE,
      VARIABLE_DECLARATION_LIST = $__247.VARIABLE_DECLARATION_LIST,
      VARIABLE_STATEMENT = $__247.VARIABLE_STATEMENT;
  var $__247 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      CaseClause = $__247.CaseClause,
      SwitchStatement = $__247.SwitchStatement;
  var CatchState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/CatchState").CatchState;
  var ConditionalState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/ConditionalState").ConditionalState;
  var FallThroughState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/FallThroughState").FallThroughState;
  var FinallyFallThroughState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/FinallyFallThroughState").FinallyFallThroughState;
  var FinallyState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/FinallyState").FinallyState;
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var assert = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/assert").assert;
  var $__247 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser"),
      parseExpression = $__247.parseExpression,
      parseStatement = $__247.parseStatement,
      parseStatements = $__247.parseStatements;
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var StateAllocator = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/StateAllocator").StateAllocator;
  var StateMachine = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/StateMachine").StateMachine;
  var $__247 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/SwitchState"),
      SwitchClause = $__247.SwitchClause,
      SwitchState = $__247.SwitchState;
  var VAR = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").VAR;
  var TryState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/TryState").TryState;
  var $__247 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createAssignStateStatement = $__247.createAssignStateStatement,
      createAssignmentExpression = $__247.createAssignmentExpression,
      createBreakStatement = $__247.createBreakStatement,
      createCaseClause = $__247.createCaseClause,
      createCommaExpression = $__247.createCommaExpression,
      createDefaultClause = $__247.createDefaultClause,
      createEmptyStatement = $__247.createEmptyStatement,
      createExpressionStatement = $__247.createExpressionStatement,
      createFunctionBody = $__247.createFunctionBody,
      id = $__247.createIdentifierExpression,
      createMemberExpression = $__247.createMemberExpression,
      createNumberLiteral = $__247.createNumberLiteral,
      createStatementList = $__247.createStatementList,
      createSwitchStatement = $__247.createSwitchStatement,
      createVariableDeclaration = $__247.createVariableDeclaration,
      createVariableDeclarationList = $__247.createVariableDeclarationList,
      createVariableStatement = $__247.createVariableStatement;
  var variablesInBlock = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/semantics/VariableBinder").variablesInBlock;
  var LabelState = function LabelState(name, continueState, fallThroughState) {
    this.name = name;
    this.continueState = continueState;
    this.fallThroughState = fallThroughState;
  };
  ($traceurRuntime.createClass)(LabelState, {}, {});
  var CPSTransformer = function CPSTransformer(reporter) {
    $traceurRuntime.superCall(this, $CPSTransformer.prototype, "constructor", []);
    this.reporter = reporter;
    this.stateAllocator_ = new StateAllocator();
    this.labelSet_ = Object.create(null);
    this.currentLabel_ = null;
  };
  var $CPSTransformer = CPSTransformer;
  ($traceurRuntime.createClass)(CPSTransformer, {
    allocateState: function() {
      return this.stateAllocator_.allocateState();
    },
    transformBlock: function(tree) {
      var transformedTree = $traceurRuntime.superCall(this, $CPSTransformer.prototype, "transformBlock", [tree]);
      var machine = this.transformStatementList_(transformedTree.statements);
      return machine == null ? transformedTree: machine;
    },
    transformFunctionBody: function(tree) {
      var oldLabels = this.clearLabels_();
      var transformedTree = $traceurRuntime.superCall(this, $CPSTransformer.prototype, "transformFunctionBody", [tree]);
      var machine = this.transformStatementList_(transformedTree.statements);
      this.restoreLabels_(oldLabels);
      return machine == null ? transformedTree: machine;
    },
    transformStatementList_: function(someTransformed) {
      if (!this.needsStateMachine_(someTransformed)) {
        return null;
      }
      var currentMachine = this.ensureTransformed_(someTransformed[0]);
      for (var index = 1; index < someTransformed.length; index++) {
        currentMachine = currentMachine.append(this.ensureTransformed_(someTransformed[index]));
      }
      return currentMachine;
    },
    needsStateMachine_: function(statements) {
      if (statements instanceof Array) {
        for (var i = 0; i < statements.length; i++) {
          switch (statements[i].type) {
            case STATE_MACHINE:
              return true;
            case BREAK_STATEMENT:
            case CONTINUE_STATEMENT:
              if (statements[i].name) return true;
              break;
          }
        }
        return false;
      }
      assert(statements instanceof SwitchStatement);
      for (var i = 0; i < statements.caseClauses.length; i++) {
        var clause = statements.caseClauses[i];
        if (this.needsStateMachine_(clause.statements)) {
          return true;
        }
      }
      return false;
    },
    transformCaseClause: function(tree) {
      var result = $traceurRuntime.superCall(this, $CPSTransformer.prototype, "transformCaseClause", [tree]);
      var machine = this.transformStatementList_(result.statements);
      return machine == null ? result: new CaseClause(null, result.expression, createStatementList(machine));
    },
    transformDoWhileStatement: function(tree) {
      var labels = this.getLabels_();
      var label = this.clearCurrentLabel_();
      var result = $traceurRuntime.superCall(this, $CPSTransformer.prototype, "transformDoWhileStatement", [tree]);
      if (result.body.type != STATE_MACHINE) return result;
      var loopBodyMachine = result.body;
      var startState = loopBodyMachine.startState;
      var conditionState = loopBodyMachine.fallThroughState;
      var fallThroughState = this.allocateState();
      var states = [];
      this.addLoopBodyStates_(loopBodyMachine, conditionState, fallThroughState, labels, states);
      states.push(new ConditionalState(conditionState, startState, fallThroughState, result.condition));
      var machine = new StateMachine(startState, fallThroughState, states, loopBodyMachine.exceptionBlocks);
      if (label) machine = machine.replaceStateId(conditionState, label.continueState);
      return machine;
    },
    addLoopBodyStates_: function(loopBodyMachine, continueState, breakState, labels, states) {
      for (var i = 0; i < loopBodyMachine.states.length; i++) {
        var state = loopBodyMachine.states[i];
        states.push(state.transformBreakOrContinue(labels, breakState, continueState));
      }
    },
    transformForStatement: function(tree) {
      var labels = this.getLabels_();
      var label = this.clearCurrentLabel_();
      var result = $traceurRuntime.superCall(this, $CPSTransformer.prototype, "transformForStatement", [tree]);
      if (result.body.type != STATE_MACHINE) return result;
      var loopBodyMachine = result.body;
      var incrementState = loopBodyMachine.fallThroughState;
      var conditionState = result.increment == null && result.condition != null ? incrementState: this.allocateState();
      var startState = result.initialiser == null ? (result.condition == null ? loopBodyMachine.startState: conditionState): this.allocateState();
      var fallThroughState = this.allocateState();
      var states = [];
      if (result.initialiser != null) {
        states.push(new FallThroughState(startState, conditionState, createStatementList(createExpressionStatement(result.initialiser))));
      }
      if (result.condition != null) {
        states.push(new ConditionalState(conditionState, loopBodyMachine.startState, fallThroughState, result.condition));
      } else {
        states.push(new FallThroughState(conditionState, loopBodyMachine.startState, createStatementList()));
      }
      if (result.increment != null) {
        states.push(new FallThroughState(incrementState, conditionState, createStatementList(createExpressionStatement(result.increment))));
      }
      this.addLoopBodyStates_(loopBodyMachine, incrementState, fallThroughState, labels, states);
      var machine = new StateMachine(startState, fallThroughState, states, loopBodyMachine.exceptionBlocks);
      if (label) machine = machine.replaceStateId(incrementState, label.continueState);
      return machine;
    },
    transformForInStatement: function(tree) {
      return tree;
    },
    transformForOfStatement: function(tree) {
      throw new Error('for of statements should be transformed before this pass');
    },
    transformIfStatement: function(tree) {
      var $__248;
      var result = $traceurRuntime.superCall(this, $CPSTransformer.prototype, "transformIfStatement", [tree]);
      if (result.ifClause.type != STATE_MACHINE && (result.elseClause == null || result.elseClause.type != STATE_MACHINE)) {
        return result;
      }
      var ifClause = this.ensureTransformed_(result.ifClause);
      var elseClause = this.ensureTransformed_(result.elseClause);
      var startState = this.allocateState();
      var fallThroughState = ifClause.fallThroughState;
      var ifState = ifClause.startState;
      var elseState = elseClause == null ? fallThroughState: elseClause.startState;
      var states = [];
      var exceptionBlocks = [];
      states.push(new ConditionalState(startState, ifState, elseState, result.condition));
      ($__248 = states).push.apply($__248, $traceurRuntime.toObject(ifClause.states));
      ($__248 = exceptionBlocks).push.apply($__248, $traceurRuntime.toObject(ifClause.exceptionBlocks));
      if (elseClause != null) {
        this.replaceAndAddStates_(elseClause.states, elseClause.fallThroughState, fallThroughState, states);
        ($__248 = exceptionBlocks).push.apply($__248, $traceurRuntime.toObject(State.replaceAllStates(elseClause.exceptionBlocks, elseClause.fallThroughState, fallThroughState)));
      }
      return new StateMachine(startState, fallThroughState, states, exceptionBlocks);
    },
    removeEmptyStates: function(oldStates) {
      var emptyStates = [],
          newStates = [];
      for (var i = 0; i < oldStates.length; i++) {
        if (oldStates[i]instanceof FallThroughState && oldStates[i].statements.length === 0) {
          emptyStates.push(oldStates[i]);
        } else {
          newStates.push(oldStates[i]);
        }
      }
      for (i = 0; i < newStates.length; i++) {
        newStates[i] = emptyStates.reduce((function(state, $__247) {
          var id = $__247.id,
              fallThroughState = $__247.fallThroughState;
          return state.replaceState(id, fallThroughState);
        }), newStates[i]);
      }
      return newStates;
    },
    replaceAndAddStates_: function(oldStates, oldState, newState, newStates) {
      for (var i = 0; i < oldStates.length; i++) {
        newStates.push(oldStates[i].replaceState(oldState, newState));
      }
    },
    transformLabelledStatement: function(tree) {
      var startState = this.allocateState();
      var continueState = this.allocateState();
      var fallThroughState = this.allocateState();
      var label = new LabelState(tree.name.value, continueState, fallThroughState);
      var oldLabels = this.addLabel_(label);
      this.currentLabel_ = label;
      var result = this.transformAny(tree.statement);
      if (result === tree.statement) {
        result = tree;
      } else if (result.type === STATE_MACHINE) {
        result = result.replaceStateId(result.startState, startState);
        result = result.replaceStateId(result.fallThroughState, fallThroughState);
      }
      this.restoreLabels_(oldLabels);
      return result;
    },
    getLabels_: function() {
      return this.labelSet_;
    },
    restoreLabels_: function(oldLabels) {
      this.labelSet_ = oldLabels;
    },
    addLabel_: function(label) {
      var oldLabels = this.labelSet_;
      var labelSet = Object.create(null);
      for (var k in this.labelSet_) {
        labelSet[k] = this.labelSet_[k];
      }
      labelSet[label.name] = label;
      this.labelSet_ = labelSet;
      return oldLabels;
    },
    clearLabels_: function() {
      var result = this.labelSet_;
      this.labelSet_ = Object.create(null);
      return result;
    },
    clearCurrentLabel_: function() {
      var result = this.currentLabel_;
      this.currentLabel_ = null;
      return result;
    },
    transformSwitchStatement: function(tree) {
      var labels = this.getLabels_();
      var result = $traceurRuntime.superCall(this, $CPSTransformer.prototype, "transformSwitchStatement", [tree]);
      if (!this.needsStateMachine_(result)) return result;
      var startState = this.allocateState();
      var fallThroughState = this.allocateState();
      var nextState = fallThroughState;
      var states = [];
      var clauses = [];
      var tryStates = [];
      var hasDefault = false;
      for (var index = result.caseClauses.length - 1; index >= 0; index--) {
        var clause = result.caseClauses[index];
        if (clause.type == CASE_CLAUSE) {
          var caseClause = clause;
          nextState = this.addSwitchClauseStates_(nextState, fallThroughState, labels, caseClause.statements, states, tryStates);
          clauses.push(new SwitchClause(caseClause.expression, nextState));
        } else {
          hasDefault = true;
          var defaultClause = clause;
          nextState = this.addSwitchClauseStates_(nextState, fallThroughState, labels, defaultClause.statements, states, tryStates);
          clauses.push(new SwitchClause(null, nextState));
        }
      }
      if (!hasDefault) {
        clauses.push(new SwitchClause(null, fallThroughState));
      }
      states.push(new SwitchState(startState, result.expression, clauses.reverse()));
      return new StateMachine(startState, fallThroughState, states.reverse(), tryStates);
    },
    addSwitchClauseStates_: function(nextState, fallThroughState, labels, statements, states, tryStates) {
      var $__248;
      var machine = this.ensureTransformedList_(statements);
      for (var i = 0; i < machine.states.length; i++) {
        var state = machine.states[i];
        var transformedState = state.transformBreak(labels, fallThroughState);
        states.push(transformedState.replaceState(machine.fallThroughState, nextState));
      }
      ($__248 = tryStates).push.apply($__248, $traceurRuntime.toObject(machine.exceptionBlocks));
      return machine.startState;
    },
    transformTryStatement: function(tree) {
      var result = $traceurRuntime.superCall(this, $CPSTransformer.prototype, "transformTryStatement", [tree]);
      if (result.body.type != STATE_MACHINE && (result.catchBlock == null || result.catchBlock.catchBody.type != STATE_MACHINE)) {
        return result;
      }
      var outerCatchState = this.allocateState();
      var outerFinallyState = this.allocateState();
      var pushTryState = this.statementToStateMachine_(parseStatement($__236, (result.catchBlock && outerCatchState), (result.finallyBlock && outerFinallyState)));
      var tryMachine = this.ensureTransformed_(result.body);
      tryMachine = pushTryState.append(tryMachine);
      if (result.catchBlock !== null) {
        var popTry = this.statementToStateMachine_(parseStatement($__237));
        tryMachine = tryMachine.append(popTry);
        var catchBlock = result.catchBlock;
        var exceptionName = catchBlock.binding.identifierToken.value;
        var catchMachine = this.ensureTransformed_(catchBlock.catchBody);
        var catchStart = this.allocateState();
        var states = $traceurRuntime.spread(tryMachine.states, [new FallThroughState(catchStart, catchMachine.startState, parseStatements($__238, id(exceptionName)))]);
        this.replaceAndAddStates_(catchMachine.states, catchMachine.fallThroughState, tryMachine.fallThroughState, states);
        tryMachine = new StateMachine(tryMachine.startState, tryMachine.fallThroughState, states, [new CatchState(exceptionName, catchStart, tryMachine.fallThroughState, tryMachine.getAllStateIDs(), tryMachine.exceptionBlocks)]);
        tryMachine = tryMachine.replaceStateId(catchStart, outerCatchState);
      }
      if (result.finallyBlock != null) {
        var finallyBlock = result.finallyBlock;
        var finallyMachine = this.ensureTransformed_(finallyBlock.block);
        var popTry = this.statementToStateMachine_(parseStatement($__239));
        finallyMachine = popTry.append(finallyMachine);
        var states = $traceurRuntime.spread(tryMachine.states, finallyMachine.states, [new FinallyFallThroughState(finallyMachine.fallThroughState)]);
        tryMachine = new StateMachine(tryMachine.startState, tryMachine.fallThroughState, states, [new FinallyState(finallyMachine.startState, finallyMachine.fallThroughState, tryMachine.getAllStateIDs(), tryMachine.exceptionBlocks)]);
        tryMachine = tryMachine.replaceStateId(finallyMachine.startState, outerFinallyState);
      }
      return tryMachine;
    },
    transformVariableStatement: function(tree) {
      var declarations = this.transformVariableDeclarationList(tree.declarations);
      if (declarations == tree.declarations) {
        return tree;
      }
      if (declarations == null) {
        return createEmptyStatement();
      }
      if (declarations.type == VARIABLE_DECLARATION_LIST) {
        return createVariableStatement(declarations);
      }
      return createExpressionStatement(declarations);
    },
    transformVariableDeclarationList: function(tree) {
      if (tree.declarationType == VAR) {
        var expressions = [];
        for (var i = 0; i < tree.declarations.length; i++) {
          var declaration = tree.declarations[i];
          if (declaration.initialiser != null) {
            expressions.push(createAssignmentExpression(id(this.transformAny(declaration.lvalue)), this.transformAny(declaration.initialiser)));
          }
        }
        var list = expressions;
        if (list.length == 0) {
          return null;
        } else if (list.length == 1) {
          return list[0];
        } else {
          return createCommaExpression(expressions);
        }
      }
      return $traceurRuntime.superCall(this, $CPSTransformer.prototype, "transformVariableDeclarationList", [tree]);
    },
    transformWhileStatement: function(tree) {
      var labels = this.getLabels_();
      var label = this.clearCurrentLabel_();
      var result = $traceurRuntime.superCall(this, $CPSTransformer.prototype, "transformWhileStatement", [tree]);
      if (result.body.type != STATE_MACHINE) return result;
      var loopBodyMachine = result.body;
      var startState = loopBodyMachine.fallThroughState;
      var fallThroughState = this.allocateState();
      var states = [];
      states.push(new ConditionalState(startState, loopBodyMachine.startState, fallThroughState, result.condition));
      this.addLoopBodyStates_(loopBodyMachine, startState, fallThroughState, labels, states);
      var machine = new StateMachine(startState, fallThroughState, states, loopBodyMachine.exceptionBlocks);
      if (label) machine = machine.replaceStateId(startState, label.continueState);
      return machine;
    },
    transformWithStatement: function(tree) {
      var result = $traceurRuntime.superCall(this, $CPSTransformer.prototype, "transformWithStatement", [tree]);
      if (result.body.type != STATE_MACHINE) {
        return result;
      }
      throw new Error('Unreachable - with statement not allowed in strict mode/harmony');
    },
    generateMachineInnerFunction: function(machine) {
      var enclosingFinallyState = machine.getEnclosingFinallyMap();
      var SwitchStatement = createSwitchStatement(createMemberExpression('$ctx', 'state'), this.transformMachineStates(machine, State.END_STATE, State.RETHROW_STATE, enclosingFinallyState));
      return parseExpression($__240, SwitchStatement);
    },
    getMachineVariables: function(tree, machine) {
      var liftedIdentifiers = variablesInBlock(tree, true);
      var allCatchStates = machine.allCatchStates();
      for (var i = 0; i < allCatchStates.length; i++) {
        liftedIdentifiers[allCatchStates[i].identifier] = true;
      }
      var liftedIdentifierList = Object.keys(liftedIdentifiers).sort();
      if (liftedIdentifierList.length === 0) return [];
      var declarations = liftedIdentifierList.map((function(liftedIdentifier) {
        return createVariableDeclaration(liftedIdentifier, null);
      }));
      return [createVariableStatement(createVariableDeclarationList(VAR, declarations))];
    },
    transformCpsFunctionBody: function(tree, runtimeMethod) {
      var alphaRenamedTree = AlphaRenamer.rename(tree, 'arguments', '$arguments');
      var hasArguments = alphaRenamedTree !== tree;
      var maybeMachine = this.transformAny(alphaRenamedTree);
      if (this.reporter.hadError()) return tree;
      var machine;
      if (maybeMachine.type !== STATE_MACHINE) {
        machine = this.statementsToStateMachine_(maybeMachine.statements);
      } else {
        machine = new StateMachine(maybeMachine.startState, maybeMachine.fallThroughState, this.removeEmptyStates(maybeMachine.states), maybeMachine.exceptionBlocks);
      }
      machine = machine.replaceStateId(machine.fallThroughState, State.END_STATE).replaceStateId(machine.startState, State.START_STATE);
      var statements = this.getMachineVariables(tree, machine);
      if (hasArguments) statements.push(parseStatement($__241));
      statements.push(parseStatement($__242, runtimeMethod, this.generateMachineInnerFunction(machine)));
      return createFunctionBody(statements);
    },
    transformFunctionDeclaration: function(tree) {
      return tree;
    },
    transformFunctionExpression: function(tree) {
      return tree;
    },
    transformGetAccessor: function(tree) {
      return tree;
    },
    transformSetAccessor: function(tree) {
      return tree;
    },
    transformStateMachine: function(tree) {
      return tree;
    },
    statementToStateMachine_: function(statement) {
      return this.statementsToStateMachine_([statement]);
    },
    statementsToStateMachine_: function(statements) {
      var startState = this.allocateState();
      var fallThroughState = this.allocateState();
      return this.stateToStateMachine_(new FallThroughState(startState, fallThroughState, statements), fallThroughState);
    },
    stateToStateMachine_: function(newState, fallThroughState) {
      return new StateMachine(newState.id, fallThroughState, [newState], []);
    },
    transformMachineStates: function(machine, machineEndState, rethrowState, enclosingFinallyState) {
      var cases = [];
      for (var i = 0; i < machine.states.length; i++) {
        var state = machine.states[i];
        var stateCase = state.transformMachineState(enclosingFinallyState[state.id], machineEndState, this.reporter);
        if (stateCase != null) {
          cases.push(stateCase);
        }
      }
      this.addFinallyFallThroughDispatches(null, machine.exceptionBlocks, cases);
      cases.push(createCaseClause(createNumberLiteral(machineEndState), this.machineEndStatements()));
      cases.push(createCaseClause(createNumberLiteral(rethrowState), this.machineRethrowStatements(machineEndState)));
      cases.push(createDefaultClause(parseStatements($__243)));
      return cases;
    },
    addFinallyFallThroughDispatches: function(enclosingFinallyState, tryStates, cases) {
      for (var i = 0; i < tryStates.length; i++) {
        var tryState = tryStates[i];
        if (tryState.kind == TryState.Kind.FINALLY) {
          var finallyState = tryState;
          if (enclosingFinallyState != null) {
            var caseClauses = [];
            var index = 0;
            for (var j = 0; j < enclosingFinallyState.tryStates.length; j++) {
              var destination = enclosingFinallyState.tryStates[j];
              index++;
              var statements;
              if (index < enclosingFinallyState.tryStates.length) {
                statements = createStatementList();
              } else {
                statements = parseStatements($__244, State.INVALID_STATE);
              }
              caseClauses.push(createCaseClause(createNumberLiteral(destination), statements));
            }
            caseClauses.push(createDefaultClause(createStatementList(createAssignStateStatement(enclosingFinallyState.finallyState), createBreakStatement())));
            cases.push(createCaseClause(createNumberLiteral(finallyState.fallThroughState), createStatementList(createSwitchStatement(createMemberExpression('$ctx', 'finallyFallThrough'), caseClauses), createBreakStatement())));
          } else {
            cases.push(createCaseClause(createNumberLiteral(finallyState.fallThroughState), parseStatements($__245)));
          }
          this.addFinallyFallThroughDispatches(finallyState, finallyState.nestedTrys, cases);
        } else {
          this.addFinallyFallThroughDispatches(enclosingFinallyState, tryState.nestedTrys, cases);
        }
      }
    },
    maybeTransformStatement_: function(maybeTransformedStatement) {
      if (maybeTransformedStatement.type == VARIABLE_STATEMENT && maybeTransformedStatement.declarations.declarationType != VAR) {
        this.reporter.reportError(maybeTransformedStatement.location != null ? maybeTransformedStatement.location.start: null, 'traceur: const/let declaration may not be ' + 'in a block containing a yield.');
      }
      var breakContinueTransformed = new BreakContinueTransformer(this.stateAllocator_).transformAny(maybeTransformedStatement);
      if (breakContinueTransformed != maybeTransformedStatement) {
        breakContinueTransformed = this.transformAny(breakContinueTransformed);
      }
      return breakContinueTransformed;
    },
    ensureTransformed_: function(statement) {
      if (statement == null) {
        return null;
      }
      var maybeTransformed = this.maybeTransformStatement_(statement);
      return maybeTransformed.type == STATE_MACHINE ? maybeTransformed: this.statementToStateMachine_(maybeTransformed);
    },
    ensureTransformedList_: function(statements) {
      var maybeTransformedStatements = [];
      var foundMachine = false;
      for (var i = 0; i < statements.length; i++) {
        var statement = statements[i];
        var maybeTransformedStatement = this.maybeTransformStatement_(statement);
        maybeTransformedStatements.push(maybeTransformedStatement);
        if (maybeTransformedStatement.type == STATE_MACHINE) {
          foundMachine = true;
        }
      }
      if (!foundMachine) {
        return this.statementsToStateMachine_(statements);
      }
      return this.transformStatementList_(maybeTransformedStatements);
    }
  }, {}, ParseTreeTransformer);
  return {get CPSTransformer() {
      return CPSTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/EndState", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/EndState";
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var EndState = function EndState() {
    $traceurRuntime.defaultSuperCall(this, $EndState.prototype, arguments);
  };
  var $EndState = EndState;
  ($traceurRuntime.createClass)(EndState, {
    replaceState: function(oldState, newState) {
      return new $EndState(State.replaceStateId(this.id, oldState, newState));
    },
    transform: function(enclosingFinally, machineEndState, reporter) {
      return State.generateJump(enclosingFinally, machineEndState);
    }
  }, {}, State);
  return {get EndState() {
      return EndState;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/AsyncTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/AsyncTransformer";
  var $__251 = Object.freeze(Object.defineProperties(["", " = $ctx.value"], {raw: {value: Object.freeze(["", " = $ctx.value"])}})),
      $__252 = Object.freeze(Object.defineProperties(["throw $ctx.err"], {raw: {value: Object.freeze(["throw $ctx.err"])}})),
      $__253 = Object.freeze(Object.defineProperties(["$ctx.resolve(", ")"], {raw: {value: Object.freeze(["$ctx.resolve(", ")"])}})),
      $__254 = Object.freeze(Object.defineProperties(["$traceurRuntime.asyncWrap"], {raw: {value: Object.freeze(["$traceurRuntime.asyncWrap"])}})),
      $__255 = Object.freeze(Object.defineProperties(["$ctx.reject($ctx.storedException)"], {raw: {value: Object.freeze(["$ctx.reject($ctx.storedException)"])}}));
  var AwaitState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/AwaitState").AwaitState;
  var CPSTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/CPSTransformer").CPSTransformer;
  var EndState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/EndState").EndState;
  var FallThroughState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/FallThroughState").FallThroughState;
  var STATE_MACHINE = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType").STATE_MACHINE;
  var $__257 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser"),
      parseExpression = $__257.parseExpression,
      parseStatement = $__257.parseStatement,
      parseStatements = $__257.parseStatements;
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var StateMachine = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/StateMachine").StateMachine;
  var VAR = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").VAR;
  var $__257 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createAssignStateStatement = $__257.createAssignStateStatement,
      createBreakStatement = $__257.createBreakStatement,
      createReturnStatement = $__257.createReturnStatement,
      createStatementList = $__257.createStatementList,
      createUndefinedExpression = $__257.createUndefinedExpression;
  var AsyncTransformer = function AsyncTransformer() {
    $traceurRuntime.defaultSuperCall(this, $AsyncTransformer.prototype, arguments);
  };
  var $AsyncTransformer = AsyncTransformer;
  ($traceurRuntime.createClass)(AsyncTransformer, {
    transformYieldExpression: function(tree) {
      this.reporter.reportError(tree.location.start, 'Async function may not have a yield expression.');
      return tree;
    },
    transformAwaitStatement: function(tree) {
      var createTaskState = this.allocateState();
      var callbackState = this.allocateState();
      var errbackState = this.allocateState();
      var fallThroughState = this.allocateState();
      var states = [];
      var expression = this.transformAny(tree.expression);
      states.push(new AwaitState(createTaskState, callbackState, errbackState, expression));
      var assignment;
      if (tree.identifier != null) assignment = parseStatements($__251, tree.identifier); else assignment = createStatementList();
      states.push(new FallThroughState(callbackState, fallThroughState, assignment));
      states.push(new FallThroughState(errbackState, fallThroughState, createStatementList(parseStatement($__252))));
      return new StateMachine(createTaskState, fallThroughState, states, []);
    },
    transformFinally: function(tree) {
      var result = $traceurRuntime.superCall(this, $AsyncTransformer.prototype, "transformFinally", [tree]);
      if (result.block.type != STATE_MACHINE) {
        return result;
      }
      this.reporter.reportError(tree.location.start, 'await not permitted within a finally block.');
      return result;
    },
    transformReturnStatement: function(tree) {
      var result = tree.expression;
      if (result == null) {
        result = createUndefinedExpression();
      }
      var startState = this.allocateState();
      var endState = this.allocateState();
      var completeState = new FallThroughState(startState, endState, createStatementList(this.createCompleteTask_(result)));
      var end = new EndState(endState);
      return new StateMachine(startState, this.allocateState(), [completeState, end], []);
    },
    createCompleteTask_: function(result) {
      return parseStatement($__253, result);
    },
    transformAsyncBody: function(tree) {
      var runtimeFunction = parseExpression($__254);
      return this.transformCpsFunctionBody(tree, runtimeFunction);
    },
    machineEndStatements: function() {
      return createStatementList(createReturnStatement(null));
    },
    machineFallThroughStatements: function(machineEndState) {
      return createStatementList(this.createCompleteTask_(createUndefinedExpression()), createAssignStateStatement(machineEndState), createBreakStatement());
    },
    machineRethrowStatements: function(machineEndState) {
      return createStatementList(parseStatement($__255), createAssignStateStatement(machineEndState), createBreakStatement());
    }
  }, {}, CPSTransformer);
  AsyncTransformer.transformAsyncBody = function(reporter, body) {
    return new AsyncTransformer(reporter).transformAsyncBody(body);
  };
  return {get AsyncTransformer() {
      return AsyncTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/ForInTransformPass", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/ForInTransformPass";
  var $__259 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      BLOCK = $__259.BLOCK,
      VARIABLE_DECLARATION_LIST = $__259.VARIABLE_DECLARATION_LIST,
      IDENTIFIER_EXPRESSION = $__259.IDENTIFIER_EXPRESSION;
  var $__259 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/PredefinedName"),
      LENGTH = $__259.LENGTH,
      PUSH = $__259.PUSH;
  var TempVarTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/TempVarTransformer").TempVarTransformer;
  var $__259 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      BANG = $__259.BANG,
      IN = $__259.IN,
      OPEN_ANGLE = $__259.OPEN_ANGLE,
      PLUS_PLUS = $__259.PLUS_PLUS,
      VAR = $__259.VAR;
  var $__259 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createArgumentList = $__259.createArgumentList,
      createAssignmentStatement = $__259.createAssignmentStatement,
      createBinaryOperator = $__259.createBinaryOperator,
      createBlock = $__259.createBlock,
      createCallStatement = $__259.createCallStatement,
      createContinueStatement = $__259.createContinueStatement,
      createEmptyArrayLiteralExpression = $__259.createEmptyArrayLiteralExpression,
      createForInStatement = $__259.createForInStatement,
      createForStatement = $__259.createForStatement,
      createIdentifierExpression = $__259.createIdentifierExpression,
      createIfStatement = $__259.createIfStatement,
      createMemberExpression = $__259.createMemberExpression,
      createMemberLookupExpression = $__259.createMemberLookupExpression,
      createNumberLiteral = $__259.createNumberLiteral,
      createOperatorToken = $__259.createOperatorToken,
      createParenExpression = $__259.createParenExpression,
      createPostfixExpression = $__259.createPostfixExpression,
      createUnaryExpression = $__259.createUnaryExpression,
      createVariableDeclarationList = $__259.createVariableDeclarationList,
      createVariableStatement = $__259.createVariableStatement;
  var ForInTransformPass = function ForInTransformPass() {
    $traceurRuntime.defaultSuperCall(this, $ForInTransformPass.prototype, arguments);
  };
  var $ForInTransformPass = ForInTransformPass;
  ($traceurRuntime.createClass)(ForInTransformPass, {transformForInStatement: function(original) {
      var $__260;
      var tree = original;
      var bodyStatements = [];
      var body = this.transformAny(tree.body);
      if (body.type == BLOCK) {
        ($__260 = bodyStatements).push.apply($__260, $traceurRuntime.toObject(body.statements));
      } else {
        bodyStatements.push(body);
      }
      var elements = [];
      var keys = this.getTempIdentifier();
      elements.push(createVariableStatement(VAR, keys, createEmptyArrayLiteralExpression()));
      var collection = this.getTempIdentifier();
      elements.push(createVariableStatement(VAR, collection, tree.collection));
      var p = this.getTempIdentifier();
      elements.push(createForInStatement(createVariableDeclarationList(VAR, p, null), createIdentifierExpression(collection), createCallStatement(createMemberExpression(keys, PUSH), createArgumentList(createIdentifierExpression(p)))));
      var i = this.getTempIdentifier();
      var lookup = createMemberLookupExpression(createIdentifierExpression(keys), createIdentifierExpression(i));
      var originalKey,
          assignOriginalKey;
      if (tree.initialiser.type == VARIABLE_DECLARATION_LIST) {
        var decList = tree.initialiser;
        originalKey = createIdentifierExpression(decList.declarations[0].lvalue);
        assignOriginalKey = createVariableStatement(decList.declarationType, originalKey.identifierToken, lookup);
      } else if (tree.initialiser.type == IDENTIFIER_EXPRESSION) {
        originalKey = tree.initialiser;
        assignOriginalKey = createAssignmentStatement(tree.initialiser, lookup);
      } else {
        throw new Error('Invalid left hand side of for in loop');
      }
      var innerBlock = [];
      innerBlock.push(assignOriginalKey);
      innerBlock.push(createIfStatement(createUnaryExpression(createOperatorToken(BANG), createParenExpression(createBinaryOperator(originalKey, createOperatorToken(IN), createIdentifierExpression(collection)))), createContinueStatement(), null));
      ($__260 = innerBlock).push.apply($__260, $traceurRuntime.toObject(bodyStatements));
      elements.push(createForStatement(createVariableDeclarationList(VAR, i, createNumberLiteral(0)), createBinaryOperator(createIdentifierExpression(i), createOperatorToken(OPEN_ANGLE), createMemberExpression(keys, LENGTH)), createPostfixExpression(createIdentifierExpression(i), createOperatorToken(PLUS_PLUS)), createBlock(innerBlock)));
      return createBlock(elements);
    }}, {}, TempVarTransformer);
  return {get ForInTransformPass() {
      return ForInTransformPass;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/YieldState", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/YieldState";
  var $__261 = Object.freeze(Object.defineProperties(["return ", ""], {raw: {value: Object.freeze(["return ", ""])}}));
  var CURRENT = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/PredefinedName").CURRENT;
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var $__263 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createAssignmentStatement = $__263.createAssignmentStatement,
      createIdentifierExpression = $__263.createIdentifierExpression,
      createMemberExpression = $__263.createMemberExpression,
      createReturnStatement = $__263.createReturnStatement,
      createThisExpression = $__263.createThisExpression,
      createTrueLiteral = $__263.createTrueLiteral;
  var parseStatement = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser").parseStatement;
  var YieldState = function YieldState(id, fallThroughState, expression) {
    $traceurRuntime.superCall(this, $YieldState.prototype, "constructor", [id]);
    this.fallThroughState = fallThroughState;
    this.expression = expression;
  };
  var $YieldState = YieldState;
  ($traceurRuntime.createClass)(YieldState, {
    replaceState: function(oldState, newState) {
      return new this.constructor(State.replaceStateId(this.id, oldState, newState), State.replaceStateId(this.fallThroughState, oldState, newState), this.expression);
    },
    transform: function(enclosingFinally, machineEndState, reporter) {
      return $traceurRuntime.spread(State.generateAssignState(enclosingFinally, this.fallThroughState), [parseStatement($__261, this.expression)]);
    }
  }, {}, State);
  return {get YieldState() {
      return YieldState;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/ReturnState", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/ReturnState";
  var $__264 = Object.freeze(Object.defineProperties(["$ctx.returnValue = ", ""], {raw: {value: Object.freeze(["$ctx.returnValue = ", ""])}}));
  var $__266 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/semantics/util"),
      isUndefined = $__266.isUndefined,
      isVoidExpression = $__266.isVoidExpression;
  var YieldState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/YieldState").YieldState;
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var $__266 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createAssignmentStatement = $__266.createAssignmentStatement,
      createMemberExpression = $__266.createMemberExpression,
      createThisExpression = $__266.createThisExpression;
  var parseStatement = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser").parseStatement;
  var ReturnState = function ReturnState() {
    $traceurRuntime.defaultSuperCall(this, $ReturnState.prototype, arguments);
  };
  var $ReturnState = ReturnState;
  ($traceurRuntime.createClass)(ReturnState, {transform: function(enclosingFinally, machineEndState, reporter) {
      var $__267;
      var e = this.expression;
      var statements = [];
      if (e && !isUndefined(e) && !isVoidExpression(e)) statements.push(parseStatement($__264, this.expression));
      ($__267 = statements).push.apply($__267, $traceurRuntime.toObject(State.generateJump(enclosingFinally, machineEndState)));
      return statements;
    }}, {}, YieldState);
  return {get ReturnState() {
      return ReturnState;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/generator/GeneratorTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/generator/GeneratorTransformer";
  var $__268 = Object.freeze(Object.defineProperties(["$traceurRuntime.generatorWrap"], {raw: {value: Object.freeze(["$traceurRuntime.generatorWrap"])}})),
      $__269 = Object.freeze(Object.defineProperties(["throw $ctx.storedException"], {raw: {value: Object.freeze(["throw $ctx.storedException"])}})),
      $__270 = Object.freeze(Object.defineProperties(["return $ctx"], {raw: {value: Object.freeze(["return $ctx"])}}));
  var CPSTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/CPSTransformer").CPSTransformer;
  var $__272 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      STATE_MACHINE = $__272.STATE_MACHINE,
      YIELD_EXPRESSION = $__272.YIELD_EXPRESSION;
  var $__272 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser"),
      parseExpression = $__272.parseExpression,
      parseStatement = $__272.parseStatement,
      parseStatements = $__272.parseStatements;
  var FallThroughState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/FallThroughState").FallThroughState;
  var ReturnState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/ReturnState").ReturnState;
  var State = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/State").State;
  var StateMachine = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/StateMachine").StateMachine;
  var YieldState = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/YieldState").YieldState;
  var $__272 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createAssignStateStatement = $__272.createAssignStateStatement,
      createFunctionBody = $__272.createFunctionBody,
      createStatementList = $__272.createStatementList,
      createUndefinedExpression = $__272.createUndefinedExpression;
  var GeneratorTransformer = function GeneratorTransformer() {
    $traceurRuntime.defaultSuperCall(this, $GeneratorTransformer.prototype, arguments);
  };
  var $GeneratorTransformer = GeneratorTransformer;
  ($traceurRuntime.createClass)(GeneratorTransformer, {
    transformYieldExpression_: function(tree) {
      var e = tree.expression || createUndefinedExpression();
      var startState = this.allocateState();
      var fallThroughState = this.allocateState();
      return this.stateToStateMachine_(new YieldState(startState, fallThroughState, this.transformAny(e)), fallThroughState);
    },
    transformYieldExpression: function(tree) {
      this.reporter.reportError(tree.location.start, 'Only \'a = yield b\' and \'var a = yield b\' currently supported.');
      return tree;
    },
    transformExpressionStatement: function(tree) {
      var e = tree.expression;
      if (e.type === YIELD_EXPRESSION) return this.transformYieldExpression_(e);
      return $traceurRuntime.superCall(this, $GeneratorTransformer.prototype, "transformExpressionStatement", [tree]);
    },
    transformAwaitStatement: function(tree) {
      this.reporter.reportError(tree.location.start, 'Generator function may not have an await statement.');
      return tree;
    },
    transformFinally: function(tree) {
      var result = $traceurRuntime.superCall(this, $GeneratorTransformer.prototype, "transformFinally", [tree]);
      if (result.block.type != STATE_MACHINE) {
        return result;
      }
      this.reporter.reportError(tree.location.start, 'yield or return not permitted from within a finally block.');
      return result;
    },
    transformReturnStatement: function(tree) {
      var startState = this.allocateState();
      var fallThroughState = this.allocateState();
      return this.stateToStateMachine_(new ReturnState(startState, fallThroughState, this.transformAny(tree.expression)), fallThroughState);
    },
    transformGeneratorBody: function(tree) {
      var runtimeFunction = parseExpression($__268);
      return this.transformCpsFunctionBody(tree, runtimeFunction);
    },
    machineRethrowStatements: function(machineEndState) {
      return parseStatements($__269);
    },
    machineFallThroughStatements: function(machineEndState) {
      return createStatementList(createAssignStateStatement(machineEndState));
    },
    machineEndStatements: function() {
      return parseStatements($__270);
    }
  }, {transformGeneratorBody: function(reporter, body) {
      return new $GeneratorTransformer(reporter).transformGeneratorBody(body);
    }}, CPSTransformer);
  ;
  return {get GeneratorTransformer() {
      return GeneratorTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/GeneratorTransformPass", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/GeneratorTransformPass";
  var $__273 = Object.freeze(Object.defineProperties(["\n          if ($ctx.action === 'throw') {\n            $ctx.action = 'next';\n            throw $ctx.sent;\n          }"], {raw: {value: Object.freeze(["\n          if ($ctx.action === 'throw') {\n            $ctx.action = 'next';\n            throw $ctx.sent;\n          }"])}})),
      $__274 = Object.freeze(Object.defineProperties(["\n        {\n          var ", " = ", "[Symbol.iterator]();\n          var ", ";\n\n          // TODO: Should 'yield *' handle non-generator iterators? A strict\n          // interpretation of harmony:generators would indicate 'no', but\n          // 'yes' seems makes more sense from a language-user's perspective.\n\n          // received = void 0;\n          $ctx.sent = void 0;\n          // send = true; // roughly equivalent\n          $ctx.action = 'next';\n\n          while (true) {\n            ", " = ", "[$ctx.action]($ctx.sent);\n            if (", ".done) {\n              $ctx.sent = ", ".value;\n              break;\n            }\n            // Normally, this would go through transformYieldForExpression_\n            // which would rethrow and we would catch it and set up the states\n            // again.\n            ", ";\n          }\n        }"], {raw: {value: Object.freeze(["\n        {\n          var ", " = ", "[Symbol.iterator]();\n          var ", ";\n\n          // TODO: Should 'yield *' handle non-generator iterators? A strict\n          // interpretation of harmony:generators would indicate 'no', but\n          // 'yes' seems makes more sense from a language-user's perspective.\n\n          // received = void 0;\n          $ctx.sent = void 0;\n          // send = true; // roughly equivalent\n          $ctx.action = 'next';\n\n          while (true) {\n            ", " = ", "[$ctx.action]($ctx.sent);\n            if (", ".done) {\n              $ctx.sent = ", ".value;\n              break;\n            }\n            // Normally, this would go through transformYieldForExpression_\n            // which would rethrow and we would catch it and set up the states\n            // again.\n            ", ";\n          }\n        }"])}}));
  var AsyncTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/AsyncTransformer").AsyncTransformer;
  var ForInTransformPass = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/ForInTransformPass").ForInTransformPass;
  var $__276 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      GetAccessor = $__276.GetAccessor,
      SetAccessor = $__276.SetAccessor;
  var GeneratorTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/generator/GeneratorTransformer").GeneratorTransformer;
  var ParseTreeVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/ParseTreeVisitor").ParseTreeVisitor;
  var parseStatement = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser").parseStatement;
  var TempVarTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/TempVarTransformer").TempVarTransformer;
  var EQUAL = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").EQUAL;
  var $__276 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      BINARY_OPERATOR = $__276.BINARY_OPERATOR,
      COMMA_EXPRESSION = $__276.COMMA_EXPRESSION,
      PAREN_EXPRESSION = $__276.PAREN_EXPRESSION,
      YIELD_EXPRESSION = $__276.YIELD_EXPRESSION;
  var $__276 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      FunctionDeclaration = $__276.FunctionDeclaration,
      FunctionExpression = $__276.FunctionExpression;
  var $__276 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createAssignmentExpression = $__276.createAssignmentExpression,
      createAssignmentStatement = $__276.createAssignmentStatement,
      createBlock = $__276.createBlock,
      createCommaExpression = $__276.createCommaExpression,
      createExpressionStatement = $__276.createExpressionStatement,
      createIdentifierExpression = $__276.createIdentifierExpression,
      createReturnStatement = $__276.createReturnStatement,
      createMemberExpression = $__276.createMemberExpression,
      createVariableDeclaration = $__276.createVariableDeclaration,
      createVariableDeclarationList = $__276.createVariableDeclarationList,
      createVariableStatement = $__276.createVariableStatement,
      createYieldStatement = $__276.createYieldStatement;
  var $__276 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/options"),
      transformOptions = $__276.transformOptions,
      options = $__276.options;
  function isYieldAssign(tree) {
    return tree.operator.type === EQUAL && tree.right.type === YIELD_EXPRESSION && tree.left.isLeftHandSideExpression();
  }
  var id = createIdentifierExpression;
  var YieldFinder = function YieldFinder(tree) {
    this.hasYield = false;
    this.hasYieldFor = false;
    this.hasForIn = false;
    this.hasAwait = false;
    this.visitAny(tree);
  };
  var $YieldFinder = YieldFinder;
  ($traceurRuntime.createClass)(YieldFinder, {
    hasAnyGenerator: function() {
      return this.hasYield || this.hasAwait;
    },
    visitYieldExpression: function(tree) {
      this.hasYield = true;
      this.hasYieldFor = tree.isYieldFor;
    },
    visitAwaitStatement: function(tree) {
      this.hasAwait = true;
    },
    visitForInStatement: function(tree) {
      this.hasForIn = true;
      $traceurRuntime.superCall(this, $YieldFinder.prototype, "visitForInStatement", [tree]);
    },
    visitFunctionDeclaration: function(tree) {},
    visitFunctionExpression: function(tree) {},
    visitSetAccessor: function(tree) {},
    visitGetAccessor: function(tree) {}
  }, {}, ParseTreeVisitor);
  var throwClose;
  var YieldExpressionTransformer = function YieldExpressionTransformer(identifierGenerator, reporter) {
    $traceurRuntime.superCall(this, $YieldExpressionTransformer.prototype, "constructor", [identifierGenerator]);
  };
  var $YieldExpressionTransformer = YieldExpressionTransformer;
  ($traceurRuntime.createClass)(YieldExpressionTransformer, {
    get throwClose() {
      if (!throwClose) {
        throwClose = parseStatement($__273);
      }
      return throwClose;
    },
    transformExpressionStatement: function(tree) {
      var e = tree.expression,
          ex;
      while (e.type === PAREN_EXPRESSION) {
        e = e.expression;
      }
      function commaWrap(lhs, rhs) {
        return createExpressionStatement(createCommaExpression($traceurRuntime.spread([createAssignmentExpression(lhs, rhs)], ex.slice(1))));
      }
      switch (e.type) {
        case BINARY_OPERATOR:
          if (isYieldAssign(e)) return this.factorAssign_(e.left, e.right, createAssignmentStatement);
          break;
        case COMMA_EXPRESSION:
          ex = e.expressions;
          if (ex[0].type === BINARY_OPERATOR && isYieldAssign(ex[0])) return this.factorAssign_(ex[0].left, ex[0].right, commaWrap);
        case YIELD_EXPRESSION:
          if (e.isYieldFor) return this.transformYieldForExpression_(e);
          return createBlock(tree, this.throwClose);
      }
      return tree;
    },
    transformVariableStatement: function(tree) {
      var tdd = tree.declarations.declarations;
      function isYieldVarAssign(tree) {
        return tree.initialiser && tree.initialiser.type === YIELD_EXPRESSION;
      }
      function varWrap(lhs, rhs) {
        return createVariableStatement(createVariableDeclarationList(tree.declarations.declarationType, $traceurRuntime.spread([createVariableDeclaration(lhs, rhs)], tdd.slice(1))));
      }
      if (isYieldVarAssign(tdd[0])) return this.factorAssign_(tdd[0].lvalue, tdd[0].initialiser, varWrap);
      return tree;
    },
    transformReturnStatement: function(tree) {
      if (tree.expression && tree.expression.type === YIELD_EXPRESSION) return this.factor_(tree.expression, createReturnStatement);
      return tree;
    },
    factorAssign_: function(lhs, rhs, wrap) {
      return this.factor_(rhs, (function(ident) {
        return wrap(lhs, ident);
      }));
    },
    factor_: function(expression, wrap) {
      if (expression.isYieldFor) return createBlock(this.transformYieldForExpression_(expression), wrap(createMemberExpression('$ctx', 'sent')));
      return createBlock([createExpressionStatement(expression), this.throwClose, wrap(createMemberExpression('$ctx', 'sent'))]);
    },
    transformYieldForExpression_: function(tree) {
      var g = id(this.getTempIdentifier());
      var next = id(this.getTempIdentifier());
      return parseStatement($__274, g, tree.expression, next, next, g, next, next, createYieldStatement(createMemberExpression(next, 'value')));
    }
  }, {}, TempVarTransformer);
  var GeneratorTransformPass = function GeneratorTransformPass(identifierGenerator, reporter) {
    $traceurRuntime.superCall(this, $GeneratorTransformPass.prototype, "constructor", [identifierGenerator]);
    this.reporter_ = reporter;
  };
  var $GeneratorTransformPass = GeneratorTransformPass;
  ($traceurRuntime.createClass)(GeneratorTransformPass, {
    transformFunctionDeclaration: function(tree) {
      return this.transformFunction_(tree, FunctionDeclaration);
    },
    transformFunctionExpression: function(tree) {
      return this.transformFunction_(tree, FunctionExpression);
    },
    transformFunction_: function(tree, constructor) {
      var body = this.transformBody_(tree.functionBody, tree.isGenerator);
      if (body === tree.functionBody) return tree;
      var isGenerator = false;
      return new constructor(null, tree.name, isGenerator, tree.formalParameterList, tree.typeAnnotation, tree.annotations, body);
    },
    transformBody_: function(tree, isGenerator) {
      var finder;
      var body = $traceurRuntime.superCall(this, $GeneratorTransformPass.prototype, "transformFunctionBody", [tree]);
      if (isGenerator || (options.unstarredGenerators || transformOptions.deferredFunctions)) {
        finder = new YieldFinder(tree);
        if (!(finder.hasYield || isGenerator || finder.hasAwait)) return body;
      } else if (!isGenerator) {
        return body;
      }
      if (finder.hasForIn && (transformOptions.generators || transformOptions.deferredFunctions)) {
        body = new ForInTransformPass(this.identifierGenerator).transformAny(body);
      }
      if (finder.hasYield || isGenerator) {
        if (transformOptions.generators) {
          body = new YieldExpressionTransformer(this.identifierGenerator, this.reporter_).transformAny(body);
          body = GeneratorTransformer.transformGeneratorBody(this.reporter_, body);
        }
      } else if (transformOptions.deferredFunctions) {
        body = AsyncTransformer.transformAsyncBody(this.reporter_, body);
      }
      return body;
    },
    transformGetAccessor: function(tree) {
      var body = this.transformBody_(tree.body);
      if (body === tree.body) return tree;
      return new GetAccessor(tree.location, tree.isStatic, tree.name, tree.typeAnnotation, tree.annotations, body);
    },
    transformSetAccessor: function(tree) {
      var body = this.transformBody_(tree.body);
      if (body === tree.body) return tree;
      return new SetAccessor(tree.location, tree.isStatic, tree.name, tree.parameter, tree.annotations, body);
    }
  }, {}, TempVarTransformer);
  return {get GeneratorTransformPass() {
      return GeneratorTransformPass;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/InlineModuleTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/InlineModuleTransformer";
  var VAR = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").VAR;
  var assert = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/assert").assert;
  var ModuleTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ModuleTransformer").ModuleTransformer;
  var $__278 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createBindingIdentifier = $__278.createBindingIdentifier,
      createEmptyStatement = $__278.createEmptyStatement,
      createFunctionBody = $__278.createFunctionBody,
      createImmediatelyInvokedFunctionExpression = $__278.createImmediatelyInvokedFunctionExpression,
      createScopedExpression = $__278.createScopedExpression,
      createVariableStatement = $__278.createVariableStatement;
  var globalThis = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/globalThis").default;
  var scopeContainsThis = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/scopeContainsThis").default;
  var InlineModuleTransformer = function InlineModuleTransformer() {
    $traceurRuntime.defaultSuperCall(this, $InlineModuleTransformer.prototype, arguments);
  };
  var $InlineModuleTransformer = InlineModuleTransformer;
  ($traceurRuntime.createClass)(InlineModuleTransformer, {
    wrapModule: function(statements) {
      assert(this.moduleName);
      var idName = this.getTempVarNameForModuleName(this.moduleName);
      var body = createFunctionBody(statements);
      var moduleExpression;
      if (statements.some(scopeContainsThis)) {
        moduleExpression = createScopedExpression(body, globalThis());
      } else {
        moduleExpression = createImmediatelyInvokedFunctionExpression(body);
      }
      return [createVariableStatement(VAR, idName, moduleExpression)];
    },
    transformNamedExport: function(tree) {
      return createEmptyStatement();
    },
    transformModuleSpecifier: function(tree) {
      return createBindingIdentifier(this.getTempVarNameForModuleSpecifier(tree));
    }
  }, {}, ModuleTransformer);
  return {get InlineModuleTransformer() {
      return InlineModuleTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/MultiTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/MultiTransformer";
  var ParseTreeValidator = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/ParseTreeValidator").ParseTreeValidator;
  var MultiTransformer = function MultiTransformer(reporter, validate) {
    this.reporter_ = reporter;
    this.validate_ = validate;
    this.treeTransformers_ = [];
  };
  ($traceurRuntime.createClass)(MultiTransformer, {
    append: function(treeTransformer) {
      this.treeTransformers_.push(treeTransformer);
    },
    transform: function(tree) {
      var reporter = this.reporter_;
      var validate = this.validate_;
      this.treeTransformers_.every((function(transformTree) {
        tree = transformTree(tree);
        if (reporter.hadError()) return false;
        if (validate) ParseTreeValidator.validate(tree);
        return true;
      }));
      return tree;
    }
  }, {});
  return {get MultiTransformer() {
      return MultiTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/NumericLiteralTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/NumericLiteralTransformer";
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var $__282 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      LiteralExpression = $__282.LiteralExpression,
      LiteralPropertyName = $__282.LiteralPropertyName;
  var LiteralToken = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/LiteralToken").LiteralToken;
  var NUMBER = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").NUMBER;
  function needsTransform(token) {
    return token.type === NUMBER && /^0[bBoO]/.test(token.value);
  }
  function transformToken(token) {
    return new LiteralToken(NUMBER, String(token.processedValue), token.location);
  }
  var NumericLiteralTransformer = function NumericLiteralTransformer() {
    $traceurRuntime.defaultSuperCall(this, $NumericLiteralTransformer.prototype, arguments);
  };
  var $NumericLiteralTransformer = NumericLiteralTransformer;
  ($traceurRuntime.createClass)(NumericLiteralTransformer, {
    transformLiteralExpression: function(tree) {
      var token = tree.literalToken;
      if (needsTransform(token)) return new LiteralExpression(tree.location, transformToken(token));
      return tree;
    },
    transformLiteralPropertyName: function(tree) {
      var token = tree.literalToken;
      if (needsTransform(token)) return new LiteralPropertyName(tree.location, transformToken(token));
      return tree;
    }
  }, {}, ParseTreeTransformer);
  return {get NumericLiteralTransformer() {
      return NumericLiteralTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/ObjectLiteralTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/ObjectLiteralTransformer";
  var FindVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/FindVisitor").FindVisitor;
  var $__284 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      FormalParameterList = $__284.FormalParameterList,
      FunctionExpression = $__284.FunctionExpression,
      IdentifierExpression = $__284.IdentifierExpression,
      LiteralExpression = $__284.LiteralExpression;
  var TempVarTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/TempVarTransformer").TempVarTransformer;
  var $__284 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      IDENTIFIER = $__284.IDENTIFIER,
      STRING = $__284.STRING;
  var $__284 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      COMPUTED_PROPERTY_NAME = $__284.COMPUTED_PROPERTY_NAME,
      LITERAL_PROPERTY_NAME = $__284.LITERAL_PROPERTY_NAME;
  var $__284 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createAssignmentExpression = $__284.createAssignmentExpression,
      createCommaExpression = $__284.createCommaExpression,
      createDefineProperty = $__284.createDefineProperty,
      createEmptyParameterList = $__284.createEmptyParameterList,
      createFunctionExpression = $__284.createFunctionExpression,
      createIdentifierExpression = $__284.createIdentifierExpression,
      createObjectCreate = $__284.createObjectCreate,
      createObjectLiteralExpression = $__284.createObjectLiteralExpression,
      createParenExpression = $__284.createParenExpression,
      createPropertyNameAssignment = $__284.createPropertyNameAssignment,
      createStringLiteral = $__284.createStringLiteral;
  var propName = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/staticsemantics/PropName").propName;
  var transformOptions = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/options").transformOptions;
  var FindAdvancedProperty = function FindAdvancedProperty(tree) {
    this.protoExpression = null;
    $traceurRuntime.superCall(this, $FindAdvancedProperty.prototype, "constructor", [tree, true]);
  };
  var $FindAdvancedProperty = FindAdvancedProperty;
  ($traceurRuntime.createClass)(FindAdvancedProperty, {
    visitPropertyNameAssignment: function(tree) {
      if (isProtoName(tree.name)) this.protoExpression = tree.value; else $traceurRuntime.superCall(this, $FindAdvancedProperty.prototype, "visitPropertyNameAssignment", [tree]);
    },
    visitComputedPropertyName: function(tree) {
      if (transformOptions.computedPropertyNames) this.found = true;
    }
  }, {}, FindVisitor);
  function isProtoName(tree) {
    return propName(tree) === '__proto__';
  }
  var ObjectLiteralTransformer = function ObjectLiteralTransformer(identifierGenerator) {
    $traceurRuntime.superCall(this, $ObjectLiteralTransformer.prototype, "constructor", [identifierGenerator]);
    this.protoExpression = null;
    this.needsAdvancedTransform = false;
    this.seenAccessors = null;
  };
  var $ObjectLiteralTransformer = ObjectLiteralTransformer;
  ($traceurRuntime.createClass)(ObjectLiteralTransformer, {
    findSeenAccessor_: function(name) {
      if (name.type === COMPUTED_PROPERTY_NAME) return null;
      var s = propName(name);
      return this.seenAccessors[s];
    },
    removeSeenAccessor_: function(name) {
      if (name.type === COMPUTED_PROPERTY_NAME) return;
      var s = propName(name);
      delete this.seenAccessors[s];
    },
    addSeenAccessor_: function(name, descr) {
      if (name.type === COMPUTED_PROPERTY_NAME) return;
      var s = propName(name);
      this.seenAccessors[s] = descr;
    },
    createProperty_: function(name, descr) {
      var expression;
      if (name.type === LITERAL_PROPERTY_NAME) {
        if (this.needsAdvancedTransform) expression = this.getPropertyName_(name); else expression = name;
      } else {
        expression = name.expression;
      }
      if (descr.get || descr.set) {
        var oldAccessor = this.findSeenAccessor_(name);
        if (oldAccessor) {
          oldAccessor.get = descr.get || oldAccessor.get;
          oldAccessor.set = descr.set || oldAccessor.set;
          this.removeSeenAccessor_(name);
          return null;
        } else {
          this.addSeenAccessor_(name, descr);
        }
      }
      return [expression, descr];
    },
    getPropertyName_: function(nameTree) {
      var token = nameTree.literalToken;
      switch (token.type) {
        case IDENTIFIER:
          return createStringLiteral(token.value);
        default:
          if (token.isKeyword()) return createStringLiteral(token.type);
          return new LiteralExpression(token.location, token);
      }
    },
    transformClassDeclaration: function(tree) {
      return tree;
    },
    transformClassExpression: function(tree) {
      return tree;
    },
    transformObjectLiteralExpression: function(tree) {
      var oldNeedsTransform = this.needsAdvancedTransform;
      var oldSeenAccessors = this.seenAccessors;
      try {
        var finder = new FindAdvancedProperty(tree);
        if (!finder.found) {
          this.needsAdvancedTransform = false;
          return $traceurRuntime.superCall(this, $ObjectLiteralTransformer.prototype, "transformObjectLiteralExpression", [tree]);
        }
        this.needsAdvancedTransform = true;
        this.seenAccessors = Object.create(null);
        var properties = this.transformList(tree.propertyNameAndValues);
        properties = properties.filter((function(tree) {
          return tree;
        }));
        var tempVar = this.addTempVar();
        var tempVarIdentifierExpression = createIdentifierExpression(tempVar);
        var expressions = properties.map((function(property) {
          var expression = property[0];
          var descr = property[1];
          return createDefineProperty(tempVarIdentifierExpression, expression, descr);
        }));
        var protoExpression = this.transformAny(finder.protoExpression);
        var objectExpression;
        if (protoExpression) objectExpression = createObjectCreate(protoExpression); else objectExpression = createObjectLiteralExpression([]);
        expressions.unshift(createAssignmentExpression(tempVarIdentifierExpression, objectExpression));
        expressions.push(tempVarIdentifierExpression);
        return createParenExpression(createCommaExpression(expressions));
      } finally {
        this.needsAdvancedTransform = oldNeedsTransform;
        this.seenAccessors = oldSeenAccessors;
      }
    },
    transformPropertyNameAssignment: function(tree) {
      if (!this.needsAdvancedTransform) return $traceurRuntime.superCall(this, $ObjectLiteralTransformer.prototype, "transformPropertyNameAssignment", [tree]);
      if (isProtoName(tree.name)) return null;
      return this.createProperty_(tree.name, {
        value: this.transformAny(tree.value),
        configurable: true,
        enumerable: true,
        writable: true
      });
    },
    transformGetAccessor: function(tree) {
      if (!this.needsAdvancedTransform) return $traceurRuntime.superCall(this, $ObjectLiteralTransformer.prototype, "transformGetAccessor", [tree]);
      var body = this.transformAny(tree.body);
      var func = createFunctionExpression(createEmptyParameterList(), body);
      return this.createProperty_(tree.name, {
        get: func,
        configurable: true,
        enumerable: true
      });
    },
    transformSetAccessor: function(tree) {
      if (!this.needsAdvancedTransform) return $traceurRuntime.superCall(this, $ObjectLiteralTransformer.prototype, "transformSetAccessor", [tree]);
      var body = this.transformAny(tree.body);
      var parameter = this.transformAny(tree.parameter);
      var parameterList = new FormalParameterList(parameter.location, [parameter]);
      var func = createFunctionExpression(parameterList, body);
      return this.createProperty_(tree.name, {
        set: func,
        configurable: true,
        enumerable: true
      });
    },
    transformPropertyMethodAssignment: function(tree) {
      var func = new FunctionExpression(tree.location, null, tree.isGenerator, this.transformAny(tree.formalParameterList), tree.typeAnnotation, [], this.transformAny(tree.functionBody));
      if (!this.needsAdvancedTransform) {
        return createPropertyNameAssignment(tree.name, func);
      }
      var expression = this.transformAny(tree.name);
      return this.createProperty_(tree.name, {
        value: func,
        configurable: true,
        enumerable: true,
        writable: true
      });
    },
    transformPropertyNameShorthand: function(tree) {
      if (!this.needsAdvancedTransform) return $traceurRuntime.superCall(this, $ObjectLiteralTransformer.prototype, "transformPropertyNameShorthand", [tree]);
      var expression = this.transformAny(tree.name);
      return this.createProperty_(tree.name, {
        value: new IdentifierExpression(tree.location, tree.name.identifierToken),
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
  }, {}, TempVarTransformer);
  return {get ObjectLiteralTransformer() {
      return ObjectLiteralTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/PropertyNameShorthandTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/PropertyNameShorthandTransformer";
  var $__286 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      IdentifierExpression = $__286.IdentifierExpression,
      LiteralPropertyName = $__286.LiteralPropertyName,
      PropertyNameAssignment = $__286.PropertyNameAssignment;
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var PropertyNameShorthandTransformer = function PropertyNameShorthandTransformer() {
    $traceurRuntime.defaultSuperCall(this, $PropertyNameShorthandTransformer.prototype, arguments);
  };
  var $PropertyNameShorthandTransformer = PropertyNameShorthandTransformer;
  ($traceurRuntime.createClass)(PropertyNameShorthandTransformer, {transformPropertyNameShorthand: function(tree) {
      return new PropertyNameAssignment(tree.location, new LiteralPropertyName(tree.location, tree.name), new IdentifierExpression(tree.location, tree.name));
    }}, {}, ParseTreeTransformer);
  return {get PropertyNameShorthandTransformer() {
      return PropertyNameShorthandTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/RestParameterTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/RestParameterTransformer";
  var $__287 = Object.freeze(Object.defineProperties(["\n            for (var ", " = [], ", " = ", ";\n                 ", " < arguments.length; ", "++)\n              ", "[", " - ", "] = arguments[", "];"], {raw: {value: Object.freeze(["\n            for (var ", " = [], ", " = ", ";\n                 ", " < arguments.length; ", "++)\n              ", "[", " - ", "] = arguments[", "];"])}})),
      $__288 = Object.freeze(Object.defineProperties(["\n            for (var ", " = [], ", " = 0;\n                 ", " < arguments.length; ", "++)\n              ", "[", "] = arguments[", "];"], {raw: {value: Object.freeze(["\n            for (var ", " = [], ", " = 0;\n                 ", " < arguments.length; ", "++)\n              ", "[", "] = arguments[", "];"])}}));
  var FormalParameterList = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees").FormalParameterList;
  var ParameterTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParameterTransformer").ParameterTransformer;
  var createIdentifierToken = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory").createIdentifierToken;
  var parseStatement = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser").parseStatement;
  function hasRestParameter(formalParameterList) {
    var parameters = formalParameterList.parameters;
    return parameters.length > 0 && parameters[parameters.length - 1].isRestParameter();
  }
  function getRestParameterLiteralToken(formalParameterList) {
    var parameters = formalParameterList.parameters;
    return parameters[parameters.length - 1].parameter.identifier.identifierToken;
  }
  var RestParameterTransformer = function RestParameterTransformer() {
    $traceurRuntime.defaultSuperCall(this, $RestParameterTransformer.prototype, arguments);
  };
  var $RestParameterTransformer = RestParameterTransformer;
  ($traceurRuntime.createClass)(RestParameterTransformer, {transformFormalParameterList: function(tree) {
      var transformed = $traceurRuntime.superCall(this, $RestParameterTransformer.prototype, "transformFormalParameterList", [tree]);
      if (hasRestParameter(transformed)) {
        var parametersWithoutRestParam = new FormalParameterList(transformed.location, transformed.parameters.slice(0, - 1));
        var startIndex = transformed.parameters.length - 1;
        var i = createIdentifierToken(this.getTempIdentifier());
        var name = getRestParameterLiteralToken(transformed);
        var loop;
        if (startIndex) {
          loop = parseStatement($__287, name, i, startIndex, i, i, name, i, startIndex, i);
        } else {
          loop = parseStatement($__288, name, i, i, i, name, i, i);
        }
        this.parameterStatements.push(loop);
        return parametersWithoutRestParam;
      }
      return transformed;
    }}, {}, ParameterTransformer);
  return {get RestParameterTransformer() {
      return RestParameterTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/SpreadTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/SpreadTransformer";
  var $__291 = Object.freeze(Object.defineProperties(["$traceurRuntime.toObject(", ")"], {raw: {value: Object.freeze(["$traceurRuntime.toObject(", ")"])}})),
      $__292 = Object.freeze(Object.defineProperties(["$traceurRuntime.spread(", ")"], {raw: {value: Object.freeze(["$traceurRuntime.spread(", ")"])}}));
  var $__294 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/PredefinedName"),
      APPLY = $__294.APPLY,
      BIND = $__294.BIND,
      FUNCTION = $__294.FUNCTION,
      PROTOTYPE = $__294.PROTOTYPE;
  var $__294 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      MEMBER_EXPRESSION = $__294.MEMBER_EXPRESSION,
      MEMBER_LOOKUP_EXPRESSION = $__294.MEMBER_LOOKUP_EXPRESSION,
      SPREAD_EXPRESSION = $__294.SPREAD_EXPRESSION;
  var TempVarTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/TempVarTransformer").TempVarTransformer;
  var $__294 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createArgumentList = $__294.createArgumentList,
      createArrayLiteralExpression = $__294.createArrayLiteralExpression,
      createAssignmentExpression = $__294.createAssignmentExpression,
      createCallExpression = $__294.createCallExpression,
      createEmptyArgumentList = $__294.createEmptyArgumentList,
      createIdentifierExpression = $__294.createIdentifierExpression,
      createMemberExpression = $__294.createMemberExpression,
      createMemberLookupExpression = $__294.createMemberLookupExpression,
      createNewExpression = $__294.createNewExpression,
      createNullLiteral = $__294.createNullLiteral,
      createParenExpression = $__294.createParenExpression;
  var parseExpression = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser").parseExpression;
  function hasSpreadMember(trees) {
    return trees.some((function(tree) {
      return tree && tree.type == SPREAD_EXPRESSION;
    }));
  }
  var SpreadTransformer = function SpreadTransformer() {
    $traceurRuntime.defaultSuperCall(this, $SpreadTransformer.prototype, arguments);
  };
  var $SpreadTransformer = SpreadTransformer;
  ($traceurRuntime.createClass)(SpreadTransformer, {
    createArrayFromElements_: function(elements, needsNewArray) {
      var length = elements.length;
      if (length === 1 && !needsNewArray) {
        var args = createArgumentList(this.transformAny(elements[0].expression));
        return parseExpression($__291, args);
      }
      var args = [];
      var lastArray;
      for (var i = 0; i < length; i++) {
        if (elements[i] && elements[i].type === SPREAD_EXPRESSION) {
          if (lastArray) {
            args.push(createArrayLiteralExpression(lastArray));
            lastArray = null;
          }
          args.push(this.transformAny(elements[i].expression));
        } else {
          if (!lastArray) lastArray = [];
          lastArray.push(this.transformAny(elements[i]));
        }
      }
      if (lastArray) args.push(createArrayLiteralExpression(lastArray));
      return parseExpression($__292, createArgumentList(args));
    },
    desugarCallSpread_: function(tree) {
      var operand = this.transformAny(tree.operand);
      var functionObject,
          contextObject;
      this.pushTempVarState();
      if (operand.type == MEMBER_EXPRESSION) {
        var tempIdent = createIdentifierExpression(this.addTempVar());
        var parenExpression = createParenExpression(createAssignmentExpression(tempIdent, operand.operand));
        var memberName = operand.memberName;
        contextObject = tempIdent;
        functionObject = createMemberExpression(parenExpression, memberName);
      } else if (tree.operand.type == MEMBER_LOOKUP_EXPRESSION) {
        var tempIdent = createIdentifierExpression(this.addTempVar());
        var parenExpression = createParenExpression(createAssignmentExpression(tempIdent, operand.operand));
        var memberExpression = this.transformAny(operand.memberExpression);
        contextObject = tempIdent;
        functionObject = createMemberLookupExpression(parenExpression, memberExpression);
      } else {
        contextObject = createNullLiteral();
        functionObject = operand;
      }
      this.popTempVarState();
      var arrayExpression = this.createArrayFromElements_(tree.args.args, false);
      return createCallExpression(createMemberExpression(functionObject, APPLY), createArgumentList(contextObject, arrayExpression));
    },
    desugarNewSpread_: function(tree) {
      var arrayExpression = $traceurRuntime.spread([createNullLiteral()], tree.args.args);
      arrayExpression = this.createArrayFromElements_(arrayExpression, false);
      return createNewExpression(createParenExpression(createCallExpression(createMemberExpression(FUNCTION, PROTOTYPE, BIND, APPLY), createArgumentList(this.transformAny(tree.operand), arrayExpression))), createEmptyArgumentList());
    },
    transformArrayLiteralExpression: function(tree) {
      if (hasSpreadMember(tree.elements)) {
        return this.createArrayFromElements_(tree.elements, true);
      }
      return $traceurRuntime.superCall(this, $SpreadTransformer.prototype, "transformArrayLiteralExpression", [tree]);
    },
    transformCallExpression: function(tree) {
      if (hasSpreadMember(tree.args.args)) {
        return this.desugarCallSpread_(tree);
      }
      return $traceurRuntime.superCall(this, $SpreadTransformer.prototype, "transformCallExpression", [tree]);
    },
    transformNewExpression: function(tree) {
      if (tree.args != null && hasSpreadMember(tree.args.args)) {
        return this.desugarNewSpread_(tree);
      }
      return $traceurRuntime.superCall(this, $SpreadTransformer.prototype, "transformNewExpression", [tree]);
    }
  }, {}, TempVarTransformer);
  return {get SpreadTransformer() {
      return SpreadTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/SymbolTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/SymbolTransformer";
  var $__295 = Object.freeze(Object.defineProperties(["$traceurRuntime.toProperty(", ") in ", ""], {raw: {value: Object.freeze(["$traceurRuntime.toProperty(", ") in ", ""])}})),
      $__296 = Object.freeze(Object.defineProperties(["$traceurRuntime.setProperty(", ",\n          ", ", ", ")"], {raw: {value: Object.freeze(["$traceurRuntime.setProperty(", ",\n          ", ", ", ")"])}})),
      $__297 = Object.freeze(Object.defineProperties(["", "[$traceurRuntime.toProperty(", ")]"], {raw: {value: Object.freeze(["", "[$traceurRuntime.toProperty(", ")]"])}}));
  var MEMBER_LOOKUP_EXPRESSION = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType").MEMBER_LOOKUP_EXPRESSION;
  var TempVarTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/TempVarTransformer").TempVarTransformer;
  var $__299 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      DELETE = $__299.DELETE,
      EQUAL = $__299.EQUAL,
      IN = $__299.IN;
  var $__299 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createArgumentList = $__299.createArgumentList,
      createIdentifierExpression = $__299.createIdentifierExpression;
  var expandMemberLookupExpression = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/OperatorExpander").expandMemberLookupExpression;
  var parseExpression = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser").parseExpression;
  var SymbolTransformer = function SymbolTransformer() {
    $traceurRuntime.defaultSuperCall(this, $SymbolTransformer.prototype, arguments);
  };
  var $SymbolTransformer = SymbolTransformer;
  ($traceurRuntime.createClass)(SymbolTransformer, {
    transformBinaryOperator: function(tree) {
      if (tree.operator.type === IN) {
        var name = this.transformAny(tree.left);
        var object = this.transformAny(tree.right);
        return parseExpression($__295, name, object);
      }
      if (tree.left.type === MEMBER_LOOKUP_EXPRESSION && tree.operator.isAssignmentOperator()) {
        if (tree.operator.type !== EQUAL) {
          tree = expandMemberLookupExpression(tree, this);
          return this.transformAny(tree);
        }
        var operand = this.transformAny(tree.left.operand);
        var memberExpression = this.transformAny(tree.left.memberExpression);
        var value = this.transformAny(tree.right);
        return parseExpression($__296, operand, memberExpression, value);
      }
      return $traceurRuntime.superCall(this, $SymbolTransformer.prototype, "transformBinaryOperator", [tree]);
    },
    transformMemberLookupExpression: function(tree) {
      var operand = this.transformAny(tree.operand);
      var memberExpression = this.transformAny(tree.memberExpression);
      return parseExpression($__297, operand, memberExpression);
    }
  }, {}, TempVarTransformer);
  return {get SymbolTransformer() {
      return SymbolTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/TemplateLiteralTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/TemplateLiteralTransformer";
  var $__301 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      BINARY_OPERATOR = $__301.BINARY_OPERATOR,
      COMMA_EXPRESSION = $__301.COMMA_EXPRESSION,
      CONDITIONAL_EXPRESSION = $__301.CONDITIONAL_EXPRESSION,
      TEMPLATE_LITERAL_PORTION = $__301.TEMPLATE_LITERAL_PORTION;
  var $__301 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      LiteralExpression = $__301.LiteralExpression,
      ParenExpression = $__301.ParenExpression;
  var LiteralToken = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/LiteralToken").LiteralToken;
  var $__301 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/PredefinedName"),
      DEFINE_PROPERTIES = $__301.DEFINE_PROPERTIES,
      OBJECT = $__301.OBJECT,
      RAW = $__301.RAW;
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var TempVarTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/TempVarTransformer").TempVarTransformer;
  var $__301 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType"),
      PERCENT = $__301.PERCENT,
      PLUS = $__301.PLUS,
      SLASH = $__301.SLASH,
      STAR = $__301.STAR,
      STRING = $__301.STRING;
  var $__301 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createArgumentList = $__301.createArgumentList,
      createArrayLiteralExpression = $__301.createArrayLiteralExpression,
      createBinaryOperator = $__301.createBinaryOperator,
      createCallExpression = $__301.createCallExpression,
      createIdentifierExpression = $__301.createIdentifierExpression,
      createMemberExpression = $__301.createMemberExpression,
      createObjectFreeze = $__301.createObjectFreeze,
      createObjectLiteralExpression = $__301.createObjectLiteralExpression,
      createOperatorToken = $__301.createOperatorToken,
      createPropertyDescriptor = $__301.createPropertyDescriptor,
      createPropertyNameAssignment = $__301.createPropertyNameAssignment,
      createStringLiteral = $__301.createStringLiteral;
  function createCallSiteIdObject(tree) {
    var elements = tree.elements;
    return createObjectFreeze(createCallExpression(createMemberExpression(OBJECT, DEFINE_PROPERTIES), createArgumentList(createCookedStringArray(elements), createObjectLiteralExpression(createPropertyNameAssignment(RAW, createPropertyDescriptor({value: createObjectFreeze(createRawStringArray(elements))}))))));
  }
  function maybeAddEmptyStringAtEnd(elements, items) {
    var length = elements.length;
    if (!length || elements[length - 1].type !== TEMPLATE_LITERAL_PORTION) items.push(createStringLiteral(''));
  }
  function createRawStringArray(elements) {
    var items = [];
    for (var i = 0; i < elements.length; i += 2) {
      var str = replaceRaw(JSON.stringify(elements[i].value.value));
      var loc = elements[i].location;
      var expr = new LiteralExpression(loc, new LiteralToken(STRING, str, loc));
      items.push(expr);
    }
    maybeAddEmptyStringAtEnd(elements, items);
    return createArrayLiteralExpression(items);
  }
  function createCookedStringLiteralExpression(tree) {
    var str = cookString(tree.value.value);
    var loc = tree.location;
    return new LiteralExpression(loc, new LiteralToken(STRING, str, loc));
  }
  function createCookedStringArray(elements) {
    var items = [];
    for (var i = 0; i < elements.length; i += 2) {
      items.push(createCookedStringLiteralExpression(elements[i]));
    }
    maybeAddEmptyStringAtEnd(elements, items);
    return createArrayLiteralExpression(items);
  }
  function replaceRaw(s) {
    return s.replace(/\u2028|\u2029/g, function(c) {
      switch (c) {
        case '\u2028':
          return '\\u2028';
        case '\u2029':
          return '\\u2029';
        default:
          throw Error('Not reachable');
      }
    });
  }
  function cookString(s) {
    var sb = ['"'];
    var i = 0,
        k = 1,
        c,
        c2;
    while (i < s.length) {
      c = s[i++];
      switch (c) {
        case '\\':
          c2 = s[i++];
          switch (c2) {
            case '\n':
            case '\u2028':
            case '\u2029':
              break;
            case '\r':
              if (s[i + 1] === '\n') {
                i++;
              }
              break;
            default:
              sb[k++] = c;
              sb[k++] = c2;
          }
          break;
        case '"':
          sb[k++] = '\\"';
          break;
        case '\n':
          sb[k++] = '\\n';
          break;
        case '\r':
          sb[k++] = '\\r';
          break;
        case '\t':
          sb[k++] = '\\t';
          break;
        case '\f':
          sb[k++] = '\\f';
          break;
        case '\b':
          sb[k++] = '\\b';
          break;
        case '\u2028':
          sb[k++] = '\\u2028';
          break;
        case '\u2029':
          sb[k++] = '\\u2029';
          break;
        default:
          sb[k++] = c;
      }
    }
    sb[k++] = '"';
    return sb.join('');
  }
  var TemplateLiteralTransformer = function TemplateLiteralTransformer() {
    $traceurRuntime.defaultSuperCall(this, $TemplateLiteralTransformer.prototype, arguments);
  };
  var $TemplateLiteralTransformer = TemplateLiteralTransformer;
  ($traceurRuntime.createClass)(TemplateLiteralTransformer, {
    transformFunctionBody: function(tree) {
      return ParseTreeTransformer.prototype.transformFunctionBody.call(this, tree);
    },
    transformTemplateLiteralExpression: function(tree) {
      if (!tree.operand) return this.createDefaultTemplateLiteral(tree);
      var operand = this.transformAny(tree.operand);
      var elements = tree.elements;
      var callsiteIdObject = createCallSiteIdObject(tree);
      var idName = this.addTempVar(callsiteIdObject);
      var args = [createIdentifierExpression(idName)];
      for (var i = 1; i < elements.length; i += 2) {
        args.push(this.transformAny(elements[i]));
      }
      return createCallExpression(operand, createArgumentList(args));
    },
    transformTemplateSubstitution: function(tree) {
      var transformedTree = this.transformAny(tree.expression);
      switch (transformedTree.type) {
        case BINARY_OPERATOR:
          switch (transformedTree.operator.type) {
            case STAR:
            case PERCENT:
            case SLASH:
              return transformedTree;
          }
        case COMMA_EXPRESSION:
        case CONDITIONAL_EXPRESSION:
          return new ParenExpression(null, transformedTree);
      }
      return transformedTree;
    },
    transformTemplateLiteralPortion: function(tree) {
      return createCookedStringLiteralExpression(tree);
    },
    createDefaultTemplateLiteral: function(tree) {
      var length = tree.elements.length;
      if (length === 0) {
        var loc = tree.location;
        return new LiteralExpression(loc, new LiteralToken(STRING, '""', loc));
      }
      var firstNonEmpty = tree.elements[0].value.value === '' ? - 1: 0;
      var binaryExpression = this.transformAny(tree.elements[0]);
      if (length == 1) return binaryExpression;
      var plusToken = createOperatorToken(PLUS);
      for (var i = 1; i < length; i++) {
        var element = tree.elements[i];
        if (element.type === TEMPLATE_LITERAL_PORTION) {
          if (element.value.value === '') continue; else if (firstNonEmpty < 0 && i === 2) binaryExpression = binaryExpression.right;
        }
        var transformedTree = this.transformAny(tree.elements[i]);
        binaryExpression = createBinaryOperator(binaryExpression, plusToken, transformedTree);
      }
      return new ParenExpression(null, binaryExpression);
    }
  }, {}, TempVarTransformer);
  return {get TemplateLiteralTransformer() {
      return TemplateLiteralTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/TypeAssertionTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/TypeAssertionTransformer";
  var $__302 = Object.freeze(Object.defineProperties(["assert.type(", ", ", ")"], {raw: {value: Object.freeze(["assert.type(", ", ", ")"])}}));
  var $__304 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType"),
      BINDING_ELEMENT = $__304.BINDING_ELEMENT,
      REST_PARAMETER = $__304.REST_PARAMETER;
  var $__304 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      ImportDeclaration = $__304.ImportDeclaration,
      ImportSpecifier = $__304.ImportSpecifier,
      ImportSpecifierSet = $__304.ImportSpecifierSet,
      Module = $__304.Module,
      ModuleSpecifier = $__304.ModuleSpecifier,
      ReturnStatement = $__304.ReturnStatement,
      Script = $__304.Script,
      VariableDeclaration = $__304.VariableDeclaration;
  var $__304 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeFactory"),
      createExpressionStatement = $__304.createExpressionStatement,
      createIdentifierToken = $__304.createIdentifierToken,
      createStringLiteralToken = $__304.createStringLiteralToken;
  var $__304 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser"),
      parseExpression = $__304.parseExpression,
      parseStatement = $__304.parseStatement;
  var ParameterTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParameterTransformer").ParameterTransformer;
  var options = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/options").options;
  var TypeAssertionTransformer = function TypeAssertionTransformer(identifierGenerator) {
    $traceurRuntime.superCall(this, $TypeAssertionTransformer.prototype, "constructor", [identifierGenerator]);
    this.returnTypeStack_ = [];
    this.assertionAdded_ = false;
  };
  var $TypeAssertionTransformer = TypeAssertionTransformer;
  ($traceurRuntime.createClass)(TypeAssertionTransformer, {
    transformScript: function(tree) {
      return this.prependAssertionImport_($traceurRuntime.superCall(this, $TypeAssertionTransformer.prototype, "transformScript", [tree]), Script);
    },
    transformModule: function(tree) {
      return this.prependAssertionImport_($traceurRuntime.superCall(this, $TypeAssertionTransformer.prototype, "transformModule", [tree]), Module);
    },
    transformVariableDeclaration: function(tree) {
      if (tree.typeAnnotation) {
        tree = new VariableDeclaration(tree.location, tree.lvalue, tree.typeAnnotation, this.assertType_(tree.initialiser, tree.typeAnnotation));
      }
      return $traceurRuntime.superCall(this, $TypeAssertionTransformer.prototype, "transformVariableDeclaration", [tree]);
    },
    transformFormalParameter: function(tree) {
      if (tree.typeAnnotation !== null) {
        switch (tree.parameter.type) {
          case BINDING_ELEMENT:
            this.transformBindingElementParameter_(tree.parameter, tree.typeAnnotation);
            break;
          case REST_PARAMETER:
            break;
        }
      }
      return $traceurRuntime.superCall(this, $TypeAssertionTransformer.prototype, "transformFormalParameter", [tree]);
    },
    transformGetAccessor: function(tree) {
      this.pushReturnType_(tree.typeAnnotation);
      tree = $traceurRuntime.superCall(this, $TypeAssertionTransformer.prototype, "transformGetAccessor", [tree]);
      this.popReturnType_();
      return tree;
    },
    transformPropertyMethodAssignment: function(tree) {
      this.pushReturnType_(tree.typeAnnotation);
      tree = $traceurRuntime.superCall(this, $TypeAssertionTransformer.prototype, "transformPropertyMethodAssignment", [tree]);
      this.popReturnType_();
      return tree;
    },
    transformFunctionDeclaration: function(tree) {
      this.pushReturnType_(tree.typeAnnotation);
      tree = $traceurRuntime.superCall(this, $TypeAssertionTransformer.prototype, "transformFunctionDeclaration", [tree]);
      this.popReturnType_();
      return tree;
    },
    transformFunctionExpression: function(tree) {
      this.pushReturnType_(tree.typeAnnotation);
      tree = $traceurRuntime.superCall(this, $TypeAssertionTransformer.prototype, "transformFunctionExpression", [tree]);
      this.popReturnType_();
      return tree;
    },
    transformReturnStatement: function(tree) {
      tree = $traceurRuntime.superCall(this, $TypeAssertionTransformer.prototype, "transformReturnStatement", [tree]);
      var expression = this.assertType_(tree.expression, this.returnType_);
      if (tree.expression !== expression) return new ReturnStatement(tree.location, expression);
      return tree;
    },
    transformBindingElementParameter_: function(tree, typeAnnotation) {
      if (!tree.binding.isPattern()) {
        this.pushParameterAssertion_(tree, typeAnnotation);
        return;
      }
    },
    pushParameterAssertion_: function(element, typeAnnotation) {
      this.parameterStatements.push(createExpressionStatement(this.assertType_(element.binding.identifierToken, typeAnnotation)));
    },
    pushReturnType_: function(typeAnnotation) {
      this.returnTypeStack_.push(typeAnnotation);
    },
    assertType_: function(expression, typeAnnotation) {
      if (expression === null || typeAnnotation === null) return expression;
      this.assertionAdded_ = true;
      return parseExpression($__302, expression, typeAnnotation.name);
    },
    prependAssertionImport_: function(tree, Ctor) {
      if (!this.assertionAdded_ || options.typeAssertionModule === null) return tree;
      var importStatement = new ImportDeclaration(null, new ImportSpecifierSet(null, [new ImportSpecifier(null, createIdentifierToken('assert'), null)]), new ModuleSpecifier(null, createStringLiteralToken(options.typeAssertionModule)));
      tree = new Ctor(tree.location, $traceurRuntime.spread([importStatement], tree.scriptItemList), tree.moduleName);
      return tree;
    },
    popReturnType_: function() {
      return this.returnTypeStack_.pop();
    },
    get returnType_() {
      return this.returnTypeStack_.length > 0 ? this.returnTypeStack_[this.returnTypeStack_.length - 1]: null;
    }
  }, {}, ParameterTransformer);
  return {get TypeAssertionTransformer() {
      return TypeAssertionTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/TypeTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/TypeTransformer";
  var $__306 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      FormalParameter = $__306.FormalParameter,
      FunctionDeclaration = $__306.FunctionDeclaration,
      FunctionExpression = $__306.FunctionExpression,
      GetAccessor = $__306.GetAccessor,
      PropertyMethodAssignment = $__306.PropertyMethodAssignment,
      VariableDeclaration = $__306.VariableDeclaration;
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var TypeTransformer = function TypeTransformer() {
    $traceurRuntime.defaultSuperCall(this, $TypeTransformer.prototype, arguments);
  };
  var $TypeTransformer = TypeTransformer;
  ($traceurRuntime.createClass)(TypeTransformer, {
    transformVariableDeclaration: function(tree) {
      if (tree.typeAnnotation) {
        tree = new VariableDeclaration(tree.location, tree.lvalue, null, tree.initialiser);
      }
      return $traceurRuntime.superCall(this, $TypeTransformer.prototype, "transformVariableDeclaration", [tree]);
    },
    transformFormalParameter: function(tree) {
      if (tree.typeAnnotation !== null) return new FormalParameter(tree.location, tree.parameter, null, []);
      return tree;
    },
    transformFunctionDeclaration: function(tree) {
      if (tree.typeAnnotation) {
        tree = new FunctionDeclaration(tree.location, tree.name, tree.isGenerator, tree.formalParameterList, null, tree.annotations, tree.functionBody);
      }
      return $traceurRuntime.superCall(this, $TypeTransformer.prototype, "transformFunctionDeclaration", [tree]);
    },
    transformFunctionExpression: function(tree) {
      if (tree.typeAnnotation) {
        tree = new FunctionExpression(tree.location, tree.name, tree.isGenerator, tree.formalParameterList, null, tree.annotations, tree.functionBody);
      }
      return $traceurRuntime.superCall(this, $TypeTransformer.prototype, "transformFunctionExpression", [tree]);
    },
    transformPropertyMethodAssignment: function(tree) {
      if (tree.typeAnnotation) {
        tree = new PropertyMethodAssignment(tree.location, tree.isStatic, tree.isGenerator, tree.name, tree.formalParameterList, null, tree.annotations, tree.functionBody);
      }
      return $traceurRuntime.superCall(this, $TypeTransformer.prototype, "transformPropertyMethodAssignment", [tree]);
    },
    transformGetAccessor: function(tree) {
      if (tree.typeAnnotation) {
        tree = new GetAccessor(tree.location, tree.isStatic, tree.name, null, tree.annotations, tree.body);
      }
      return $traceurRuntime.superCall(this, $TypeTransformer.prototype, "transformGetAccessor", [tree]);
    }
  }, {}, ParseTreeTransformer);
  return {get TypeTransformer() {
      return TypeTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/TypeofTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/TypeofTransformer";
  var $__307 = Object.freeze(Object.defineProperties(["$traceurRuntime.typeof(", ")"], {raw: {value: Object.freeze(["$traceurRuntime.typeof(", ")"])}})),
      $__308 = Object.freeze(Object.defineProperties(["(typeof ", " === 'undefined' ?\n          'undefined' : ", ")"], {raw: {value: Object.freeze(["(typeof ", " === 'undefined' ?\n          'undefined' : ", ")"])}}));
  var IDENTIFIER_EXPRESSION = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTreeType").IDENTIFIER_EXPRESSION;
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var TYPEOF = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").TYPEOF;
  var parseExpression = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PlaceholderParser").parseExpression;
  var TypeofTransformer = function TypeofTransformer() {
    $traceurRuntime.defaultSuperCall(this, $TypeofTransformer.prototype, arguments);
  };
  var $TypeofTransformer = TypeofTransformer;
  ($traceurRuntime.createClass)(TypeofTransformer, {transformUnaryExpression: function(tree) {
      if (tree.operator.type !== TYPEOF) return $traceurRuntime.superCall(this, $TypeofTransformer.prototype, "transformUnaryExpression", [tree]);
      var operand = this.transformAny(tree.operand);
      var expression = parseExpression($__307, operand);
      if (operand.type === IDENTIFIER_EXPRESSION) {
        return parseExpression($__308, operand, expression);
      }
      return expression;
    }}, {}, ParseTreeTransformer);
  return {get TypeofTransformer() {
      return TypeofTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/UniqueIdentifierGenerator", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/UniqueIdentifierGenerator";
  var UniqueIdentifierGenerator = function UniqueIdentifierGenerator() {
    this.identifierIndex = 0;
  };
  ($traceurRuntime.createClass)(UniqueIdentifierGenerator, {generateUniqueIdentifier: function() {
      return ("$__" + this.identifierIndex++);
    }}, {});
  return {get UniqueIdentifierGenerator() {
      return UniqueIdentifierGenerator;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/FromOptionsTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/FromOptionsTransformer";
  var AmdTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/AmdTransformer").AmdTransformer;
  var AnnotationsTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/AnnotationsTransformer").AnnotationsTransformer;
  var ArrayComprehensionTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ArrayComprehensionTransformer").ArrayComprehensionTransformer;
  var ArrowFunctionTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ArrowFunctionTransformer").ArrowFunctionTransformer;
  var BlockBindingTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/BlockBindingTransformer").BlockBindingTransformer;
  var ClassTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ClassTransformer").ClassTransformer;
  var CommonJsModuleTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/CommonJsModuleTransformer").CommonJsModuleTransformer;
  var DefaultParametersTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/DefaultParametersTransformer").DefaultParametersTransformer;
  var DestructuringTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/DestructuringTransformer").DestructuringTransformer;
  var ForOfTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ForOfTransformer").ForOfTransformer;
  var FreeVariableChecker = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/semantics/FreeVariableChecker").FreeVariableChecker;
  var GeneratorComprehensionTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/GeneratorComprehensionTransformer").GeneratorComprehensionTransformer;
  var GeneratorTransformPass = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/GeneratorTransformPass").GeneratorTransformPass;
  var InlineModuleTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/InlineModuleTransformer").InlineModuleTransformer;
  var ModuleTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ModuleTransformer").ModuleTransformer;
  var MultiTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/MultiTransformer").MultiTransformer;
  var NumericLiteralTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/NumericLiteralTransformer").NumericLiteralTransformer;
  var ObjectLiteralTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ObjectLiteralTransformer").ObjectLiteralTransformer;
  var ObjectMap = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/ObjectMap").ObjectMap;
  var ParseTreeValidator = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/ParseTreeValidator").ParseTreeValidator;
  var PropertyNameShorthandTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/PropertyNameShorthandTransformer").PropertyNameShorthandTransformer;
  var RestParameterTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/RestParameterTransformer").RestParameterTransformer;
  var SpreadTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/SpreadTransformer").SpreadTransformer;
  var SymbolTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/SymbolTransformer").SymbolTransformer;
  var TemplateLiteralTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/TemplateLiteralTransformer").TemplateLiteralTransformer;
  var TypeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/TypeTransformer").TypeTransformer;
  var TypeAssertionTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/TypeAssertionTransformer").TypeAssertionTransformer;
  var TypeofTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/TypeofTransformer").TypeofTransformer;
  var UniqueIdentifierGenerator = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/UniqueIdentifierGenerator").UniqueIdentifierGenerator;
  var $__314 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/options"),
      options = $__314.options,
      transformOptions = $__314.transformOptions;
  var FromOptionsTransformer = function FromOptionsTransformer(reporter) {
    var idGenerator = arguments[1] !== (void 0) ? arguments[1]: new UniqueIdentifierGenerator();
    var $__312 = this;
    $traceurRuntime.superCall(this, $FromOptionsTransformer.prototype, "constructor", [reporter, options.validate]);
    var append = (function(transformer) {
      $__312.append((function(tree) {
        return new transformer(idGenerator, reporter).transformAny(tree);
      }));
    });
    if (transformOptions.numericLiterals) append(NumericLiteralTransformer);
    if (transformOptions.templateLiterals) append(TemplateLiteralTransformer);
    if (transformOptions.annotations) append(AnnotationsTransformer);
    if (options.typeAssertions) append(TypeAssertionTransformer);
    if (transformOptions.modules) {
      switch (transformOptions.modules) {
        case 'commonjs':
          append(CommonJsModuleTransformer);
          break;
        case 'amd':
          append(AmdTransformer);
          break;
        case 'inline':
          append(InlineModuleTransformer);
          break;
        default:
          append(ModuleTransformer);
      }
    }
    if (transformOptions.arrowFunctions) append(ArrowFunctionTransformer);
    if (transformOptions.classes) append(ClassTransformer);
    if (transformOptions.propertyNameShorthand) append(PropertyNameShorthandTransformer);
    if (transformOptions.propertyMethods || transformOptions.computedPropertyNames) {
      append(ObjectLiteralTransformer);
    }
    if (transformOptions.generatorComprehension) append(GeneratorComprehensionTransformer);
    if (transformOptions.arrayComprehension) append(ArrayComprehensionTransformer);
    if (transformOptions.forOf) append(ForOfTransformer);
    if (transformOptions.restParameters) append(RestParameterTransformer);
    if (transformOptions.defaultParameters) append(DefaultParametersTransformer);
    if (transformOptions.destructuring) append(DestructuringTransformer);
    if (transformOptions.types) append(TypeTransformer);
    if (transformOptions.generators || transformOptions.deferredFunctions) append(GeneratorTransformPass);
    if (transformOptions.spread) append(SpreadTransformer);
    if (transformOptions.blockBinding) append(BlockBindingTransformer);
    if (transformOptions.symbols) {
      append(SymbolTransformer);
      append(TypeofTransformer);
    }
    if (options.freeVariableChecker) {
      this.append((function(tree) {
        FreeVariableChecker.checkScript(reporter, tree);
        return tree;
      }));
    }
  };
  var $FromOptionsTransformer = FromOptionsTransformer;
  ($traceurRuntime.createClass)(FromOptionsTransformer, {}, {}, MultiTransformer);
  return {get FromOptionsTransformer() {
      return FromOptionsTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/module/AttachModuleNameTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/module/AttachModuleNameTransformer";
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var $__316 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      Module = $__316.Module,
      Script = $__316.Script;
  var AttachModuleNameTransformer = function AttachModuleNameTransformer(moduleName) {
    this.moduleName_ = moduleName;
  };
  ($traceurRuntime.createClass)(AttachModuleNameTransformer, {
    transformModule: function(tree) {
      return new Module(tree.location, tree.scriptItemList, this.moduleName_);
    },
    transformScript: function(tree) {
      return new Script(tree.location, tree.scriptItemList, this.moduleName_);
    }
  }, {}, ParseTreeTransformer);
  return {get AttachModuleNameTransformer() {
      return AttachModuleNameTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/util/url", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/util/url";
  var canonicalizeUrl = $traceurRuntime.canonicalizeUrl;
  var isAbsolute = $traceurRuntime.isAbsolute;
  var removeDotSegments = $traceurRuntime.removeDotSegments;
  var resolveUrl = $traceurRuntime.resolveUrl;
  return {
    get canonicalizeUrl() {
      return canonicalizeUrl;
    },
    get isAbsolute() {
      return isAbsolute;
    },
    get removeDotSegments() {
      return removeDotSegments;
    },
    get resolveUrl() {
      return resolveUrl;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/module/ModuleSpecifierVisitor", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/module/ModuleSpecifierVisitor";
  var ParseTreeVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/ParseTreeVisitor").ParseTreeVisitor;
  var STRING = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/TokenType").STRING;
  var LiteralToken = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/LiteralToken").LiteralToken;
  var canonicalizeUrl = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/url").canonicalizeUrl;
  var options = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/options").options;
  var ModuleSpecifierVisitor = function ModuleSpecifierVisitor(reporter) {
    $traceurRuntime.superCall(this, $ModuleSpecifierVisitor.prototype, "constructor", []);
    this.moduleSpecifiers_ = Object.create(null);
  };
  var $ModuleSpecifierVisitor = ModuleSpecifierVisitor;
  ($traceurRuntime.createClass)(ModuleSpecifierVisitor, {
    get moduleSpecifiers() {
      return Object.keys(this.moduleSpecifiers_);
    },
    visitModuleSpecifier: function(tree) {
      this.moduleSpecifiers_[tree.token.processedValue] = true;
    },
    visitVariableDeclaration: function(tree) {
      this.addTypeAssertionDependency_(tree.typeAnnotation);
      return $traceurRuntime.superCall(this, $ModuleSpecifierVisitor.prototype, "visitVariableDeclaration", [tree]);
    },
    visitFormalParameter: function(tree) {
      this.addTypeAssertionDependency_(tree.typeAnnotation);
      return $traceurRuntime.superCall(this, $ModuleSpecifierVisitor.prototype, "visitFormalParameter", [tree]);
    },
    visitGetAccessor: function(tree) {
      this.addTypeAssertionDependency_(tree.typeAnnotation);
      return $traceurRuntime.superCall(this, $ModuleSpecifierVisitor.prototype, "visitGetAccessor", [tree]);
    },
    visitPropertyMethodAssignment: function(tree) {
      this.addTypeAssertionDependency_(tree.typeAnnotation);
      return $traceurRuntime.superCall(this, $ModuleSpecifierVisitor.prototype, "visitPropertyMethodAssignment", [tree]);
    },
    visitFunctionDeclaration: function(tree) {
      this.addTypeAssertionDependency_(tree.typeAnnotation);
      return $traceurRuntime.superCall(this, $ModuleSpecifierVisitor.prototype, "visitFunctionDeclaration", [tree]);
    },
    visitFunctionExpression: function(tree) {
      this.addTypeAssertionDependency_(tree.typeAnnotation);
      return $traceurRuntime.superCall(this, $ModuleSpecifierVisitor.prototype, "visitFunctionExpression", [tree]);
    },
    addTypeAssertionDependency_: function(typeAnnotation) {
      if (typeAnnotation !== null && options.typeAssertionModule !== null) this.moduleSpecifiers_[options.typeAssertionModule] = true;
    }
  }, {}, ParseTreeVisitor);
  return {get ModuleSpecifierVisitor() {
      return ModuleSpecifierVisitor;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/runtime/system-map", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/runtime/system-map";
  function prefixMatchLength(name, prefix) {
    var prefixParts = prefix.split('/');
    var nameParts = name.split('/');
    if (prefixParts.length > nameParts.length) return 0;
    for (var i = 0; i < prefixParts.length; i++) {
      if (nameParts[i] != prefixParts[i]) return 0;
    }
    return prefixParts.length;
  }
  function applyMap(map, name, parentName) {
    var curMatch,
        curMatchLength = 0;
    var curParent,
        curParentMatchLength = 0;
    if (parentName) {
      var mappedName;
      Object.getOwnPropertyNames(map).some(function(p) {
        var curMap = map[p];
        if (curMap && typeof curMap === 'object') {
          if (prefixMatchLength(parentName, p) <= curParentMatchLength) return;
          Object.getOwnPropertyNames(curMap).forEach(function(q) {
            if (prefixMatchLength(name, q) > curMatchLength) {
              curMatch = q;
              curMatchLength = q.split('/').length;
              curParent = p;
              curParentMatchLength = p.split('/').length;
            }
          });
        }
        if (curMatch) {
          var subPath = name.split('/').splice(curMatchLength).join('/');
          mappedName = map[curParent][curMatch] + (subPath ? '/' + subPath: '');
          return mappedName;
        }
      });
    }
    if (mappedName) return mappedName;
    Object.getOwnPropertyNames(map).forEach(function(p) {
      var curMap = map[p];
      if (curMap && typeof curMap === 'string') {
        if (prefixMatchLength(name, p) > curMatchLength) {
          curMatch = p;
          curMatchLength = p.split('/').length;
        }
      }
    });
    if (!curMatch) return name;
    var subPath = name.split('/').splice(curMatchLength).join('/');
    return map[curMatch] + (subPath ? '/' + subPath: '');
  }
  var systemjs = {applyMap: applyMap};
  return {get systemjs() {
      return systemjs;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/module/ValidationVisitor", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/module/ValidationVisitor";
  var ModuleVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/module/ModuleVisitor").ModuleVisitor;
  var ValidationVisitor = function ValidationVisitor() {
    $traceurRuntime.defaultSuperCall(this, $ValidationVisitor.prototype, arguments);
  };
  var $ValidationVisitor = ValidationVisitor;
  ($traceurRuntime.createClass)(ValidationVisitor, {
    checkExport_: function(tree, name) {
      var description = this.validatingModuleDescription_;
      if (description && !description.getExport(name)) {
        var moduleName = description.normalizedName;
        this.reportError(tree, ("'" + name + "' is not exported by '" + moduleName + "'"));
      }
    },
    checkImport_: function(tree, name) {
      var existingImport = this.moduleSymbol.getImport(name);
      if (existingImport) {
        this.reportError(tree, ("'" + name + "' was previously imported at " + existingImport.location.start));
      } else {
        this.moduleSymbol.addImport(name, tree);
      }
    },
    visitAndValidate_: function(moduleDescription, tree) {
      var validatingModuleDescription = this.validatingModuleDescription_;
      this.validatingModuleDescription_ = moduleDescription;
      this.visitAny(tree);
      this.validatingModuleDescription_ = validatingModuleDescription;
    },
    visitNamedExport: function(tree) {
      if (tree.moduleSpecifier) {
        var name = tree.moduleSpecifier.token.processedValue;
        var moduleDescription = this.getModuleDescriptionForModuleSpecifier(name);
        this.visitAndValidate_(moduleDescription, tree.specifierSet);
      }
    },
    visitExportSpecifier: function(tree) {
      this.checkExport_(tree, tree.lhs.value);
    },
    visitImportDeclaration: function(tree) {
      var name = tree.moduleSpecifier.token.processedValue;
      var moduleDescription = this.getModuleDescriptionForModuleSpecifier(name);
      this.visitAndValidate_(moduleDescription, tree.importClause);
    },
    visitImportSpecifier: function(tree) {
      var importName = tree.rhs ? tree.rhs.value: tree.lhs.value;
      this.checkImport_(tree, importName);
      this.checkExport_(tree, tree.lhs.value);
    },
    visitImportedBinding: function(tree) {
      var importName = tree.binding.identifierToken.value;
      this.checkImport_(tree, importName);
      this.checkExport_(tree, 'default');
    }
  }, {}, ModuleVisitor);
  return {get ValidationVisitor() {
      return ValidationVisitor;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/semantics/ModuleAnalyzer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/semantics/ModuleAnalyzer";
  var ExportVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/module/ExportVisitor").ExportVisitor;
  var ValidationVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/module/ValidationVisitor").ValidationVisitor;
  var transformOptions = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/options").transformOptions;
  var ModuleAnalyzer = function ModuleAnalyzer(reporter) {
    this.reporter_ = reporter;
  };
  ($traceurRuntime.createClass)(ModuleAnalyzer, {analyzeTrees: function(trees, moduleSymbols, loader) {
      if (!transformOptions.modules) return;
      var reporter = this.reporter_;
      function getModuleSymbol(i) {
        return moduleSymbols.length ? moduleSymbols[i]: moduleSymbols;
      }
      function doVisit(ctor) {
        for (var i = 0; i < trees.length; i++) {
          var visitor = new ctor(reporter, loader, getModuleSymbol(i));
          visitor.visitAny(trees[i]);
        }
      }
      function reverseVisit(ctor) {
        for (var i = trees.length - 1; i >= 0; i--) {
          var visitor = new ctor(reporter, loader, getModuleSymbol(i));
          visitor.visitAny(trees[i]);
        }
      }
      reverseVisit(ExportVisitor);
      doVisit(ValidationVisitor);
    }}, {});
  return {get ModuleAnalyzer() {
      return ModuleAnalyzer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/runtime/webLoader", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/runtime/webLoader";
  var webLoader = {load: function(url, callback, errback) {
      var xhr = new XMLHttpRequest();
      xhr.onload = (function() {
        if (xhr.status == 200 || xhr.status == 0) {
          callback(xhr.responseText);
        } else {
          errback();
        }
        xhr = null;
      });
      xhr.onerror = (function() {
        errback();
      });
      xhr.open('GET', url, true);
      xhr.send();
      return (function() {
        xhr && xhr.abort();
      });
    }};
  return {get webLoader() {
      return webLoader;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/runtime/LoaderHooks", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/runtime/LoaderHooks";
  var AttachModuleNameTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/module/AttachModuleNameTransformer").AttachModuleNameTransformer;
  var FromOptionsTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/FromOptionsTransformer").FromOptionsTransformer;
  var ModuleAnalyzer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/semantics/ModuleAnalyzer").ModuleAnalyzer;
  var ModuleSpecifierVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/module/ModuleSpecifierVisitor").ModuleSpecifierVisitor;
  var ModuleSymbol = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/semantics/ModuleSymbol").ModuleSymbol;
  var Parser = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Parser").Parser;
  var options = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/options").options;
  var SourceFile = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/SourceFile").SourceFile;
  var systemjs = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/system-map").systemjs;
  var write = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/outputgeneration/TreeWriter").write;
  var UniqueIdentifierGenerator = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/UniqueIdentifierGenerator").UniqueIdentifierGenerator;
  var $__324 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/url"),
      isAbsolute = $__324.isAbsolute,
      resolveUrl = $__324.resolveUrl;
  var webLoader = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/webLoader").webLoader;
  var assert = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/assert").assert;
  var NOT_STARTED = 0;
  var LOADING = 1;
  var LOADED = 2;
  var PARSED = 3;
  var TRANSFORMING = 4;
  var TRANSFORMED = 5;
  var COMPLETE = 6;
  var ERROR = 7;
  var identifierGenerator = new UniqueIdentifierGenerator();
  var LoaderHooks = function LoaderHooks(reporter, rootUrl) {
    var outputOptions = arguments[2];
    var fileLoader = arguments[3] !== (void 0) ? arguments[3]: webLoader;
    var moduleStore = arguments[4] !== (void 0) ? arguments[4]: $traceurRuntime.ModuleStore;
    this.reporter = reporter;
    this.rootUrl_ = rootUrl;
    this.outputOptions_ = outputOptions;
    this.moduleStore_ = moduleStore;
    this.fileLoader = fileLoader;
    this.analyzer_ = new ModuleAnalyzer(this.reporter);
  };
  ($traceurRuntime.createClass)(LoaderHooks, {
    get: function(normalizedName) {
      return this.moduleStore_.get(normalizedName);
    },
    set: function(normalizedName, module) {
      this.moduleStore_.set(normalizedName, module);
    },
    normalize: function(name, referrerName, referrerAddress) {
      var normalizedName = this.moduleStore_.normalize(name, referrerName, referrerAddress);
      if (System.map) return systemjs.applyMap(System.map, normalizedName, referrerName); else return normalizedName;
    },
    rootUrl: function() {
      return this.rootUrl_;
    },
    getModuleSpecifiers: function(codeUnit) {
      if (!this.parse(codeUnit)) return;
      codeUnit.state = PARSED;
      var moduleSpecifierVisitor = new ModuleSpecifierVisitor(this.reporter);
      moduleSpecifierVisitor.visit(codeUnit.metadata.tree);
      return moduleSpecifierVisitor.moduleSpecifiers;
    },
    parse: function(codeUnit) {
      assert(!codeUnit.metadata.tree);
      var reporter = this.reporter;
      var normalizedName = codeUnit.normalizedName;
      var program = codeUnit.text;
      var url = codeUnit.url || normalizedName;
      var file = new SourceFile(url, program);
      var parser = new Parser(file, reporter);
      if (codeUnit.type == 'module') codeUnit.metadata.tree = parser.parseModule(); else codeUnit.metadata.tree = parser.parseScript();
      codeUnit.metadata.moduleSymbol = new ModuleSymbol(codeUnit.metadata.tree, normalizedName);
      return !reporter.hadError();
    },
    transform: function(codeUnit) {
      var transformer = new AttachModuleNameTransformer(codeUnit.normalizedName);
      var transformedTree = transformer.transformAny(codeUnit.metadata.tree);
      transformer = new FromOptionsTransformer(this.reporter, identifierGenerator);
      return transformer.transform(transformedTree);
    },
    fetch: function($__324, callback, errback) {
      var address = $__324.address;
      this.fileLoader.load(address, callback, errback);
    },
    instantiate: function($__325) {
      var name = $__325.name,
          metadata = $__325.metadata,
          address = $__325.address,
          source = $__325.source,
          sourceMap = $__325.sourceMap;
      return undefined;
    },
    locate: function(load) {
      load.url = this.locate_(load);
      return load.url;
    },
    locate_: function(load) {
      var normalizedModuleName = load.normalizedName;
      var asJS = normalizedModuleName + '.js';
      if (options.referrer) {
        if (asJS.indexOf(options.referrer) === 0) {
          asJS = asJS.slice(options.referrer.length);
          load.metadata.locateMap = {
            pattern: options.referrer,
            replacement: ''
          };
        }
      }
      if (isAbsolute(asJS)) return asJS;
      var baseURL = load.metadata && load.metadata.baseURL;
      baseURL = baseURL || this.rootUrl();
      if (baseURL) {
        load.metadata.baseURL = baseURL;
        return resolveUrl(baseURL, asJS);
      }
      return asJS;
    },
    nameTrace: function(load) {
      var trace = '';
      if (load.metadata.locateMap) {
        trace += this.locateMapTrace(load);
      }
      if (load.metadata.baseURL) {
        trace += this.baseURLTrace(load);
      }
      return trace;
    },
    locateMapTrace: function(load) {
      var map = load.metadata.locateMap;
      return ("LoaderHooks.locate found \'" + map.pattern + "\' -> \'" + map.replacement + "\'\n");
    },
    baseURLTrace: function(load) {
      return 'LoaderHooks.locate resolved against \'' + load.metadata.baseURL + '\'\n';
    },
    evaluateCodeUnit: function(codeUnit) {
      var result = ('global', eval)(codeUnit.metadata.transcoded);
      codeUnit.metadata.transformedTree = null;
      return result;
    },
    analyzeDependencies: function(dependencies, loader) {
      var trees = [];
      var moduleSymbols = [];
      for (var i = 0; i < dependencies.length; i++) {
        var codeUnit = dependencies[i];
        assert(codeUnit.state >= PARSED);
        if (codeUnit.state == PARSED) {
          trees.push(codeUnit.metadata.tree);
          moduleSymbols.push(codeUnit.metadata.moduleSymbol);
        }
      }
      this.analyzer_.analyzeTrees(trees, moduleSymbols, loader);
      this.checkForErrors(dependencies, 'analyze');
    },
    transformDependencies: function(dependencies, dependentName) {
      for (var i = 0; i < dependencies.length; i++) {
        var codeUnit = dependencies[i];
        if (codeUnit.state >= TRANSFORMED) {
          continue;
        }
        if (codeUnit.state === TRANSFORMING) {
          var cir = codeUnit.normalizedName;
          var cle = dependentName;
          this.reporter.reportError(codeUnit.metadata.tree, ("Unsupported circular dependency between " + cir + " and " + cle));
          break;
        }
        codeUnit.state = TRANSFORMING;
        this.transformCodeUnit(codeUnit);
        this.instantiate(codeUnit);
      }
      this.checkForErrors(dependencies, 'transform');
    },
    transformCodeUnit: function(codeUnit) {
      this.transformDependencies(codeUnit.dependencies, codeUnit.normalizedName);
      if (codeUnit.state === ERROR) return;
      codeUnit.metadata.transformedTree = codeUnit.transform();
      codeUnit.state = TRANSFORMED;
      codeUnit.metadata.transcoded = write(codeUnit.metadata.transformedTree, this.outputOptions_);
      if (codeUnit.url && codeUnit.metadata.transcoded) codeUnit.metadata.transcoded += '//# sourceURL=' + codeUnit.url;
      codeUnit.sourceMap = this.outputOptions_ && this.outputOptions_.sourceMap;
    },
    checkForErrors: function(dependencies, phase) {
      if (this.reporter.hadError()) {
        for (var i = 0; i < dependencies.length; i++) {
          var codeUnit = dependencies[i];
          if (codeUnit.state >= COMPLETE) {
            continue;
          }
          codeUnit.state = ERROR;
        }
        for (var i = 0; i < dependencies.length; i++) {
          var codeUnit = dependencies[i];
          if (codeUnit.state == ERROR) {
            codeUnit.dispatchError(phase);
          }
        }
        return true;
      }
      return false;
    }
  }, {});
  return {get LoaderHooks() {
      return LoaderHooks;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/runtime/InterceptOutputLoaderHooks", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/runtime/InterceptOutputLoaderHooks";
  var LoaderHooks = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/LoaderHooks").LoaderHooks;
  var InterceptOutputLoaderHooks = function InterceptOutputLoaderHooks() {
    for (var args = [],
        $__327 = 0; $__327 < arguments.length; $__327++) args[$__327] = arguments[$__327];
    $traceurRuntime.superCall(this, $InterceptOutputLoaderHooks.prototype, "constructor", $traceurRuntime.spread(args));
    this.sourceMap = null;
    this.transcoded = null;
    this.onTranscoded = (function() {});
  };
  var $InterceptOutputLoaderHooks = InterceptOutputLoaderHooks;
  ($traceurRuntime.createClass)(InterceptOutputLoaderHooks, {instantiate: function($__328) {
      var metadata = $__328.metadata;
      this.sourceMap = metadata.sourceMap;
      this.transcoded = metadata.transcoded;
      this.onTranscoded(metadata);
      return undefined;
    }}, {}, LoaderHooks);
  return {get InterceptOutputLoaderHooks() {
      return InterceptOutputLoaderHooks;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/runtime/InternalLoader", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/runtime/InternalLoader";
  var ArrayMap = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/ArrayMap").ArrayMap;
  var LoaderHooks = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/LoaderHooks").LoaderHooks;
  var ObjectMap = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/ObjectMap").ObjectMap;
  var $__331 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/url"),
      canonicalizeUrl = $__331.canonicalizeUrl,
      isAbsolute = $__331.isAbsolute,
      resolveUrl = $__331.resolveUrl;
  var getUid = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/uid").getUid;
  var NOT_STARTED = 0;
  var LOADING = 1;
  var LOADED = 2;
  var PARSED = 3;
  var TRANSFORMING = 4;
  var TRANSFORMED = 5;
  var COMPLETE = 6;
  var ERROR = 7;
  var CodeUnit = function CodeUnit(loaderHooks, normalizedName, type, state, name, referrerName, address) {
    this.loaderHooks = loaderHooks;
    this.normalizedName = normalizedName;
    this.type = type;
    this.name_ = name;
    this.referrerName_ = referrerName;
    this.address_ = address;
    this.uid = getUid();
    this.state_ = state || NOT_STARTED;
    this.error = null;
    this.result = null;
    this.data_ = {};
    this.dependencies = [];
  };
  ($traceurRuntime.createClass)(CodeUnit, {
    get state() {
      return this.state_;
    },
    set state(state) {
      if (state < this.state_) {
        throw new Error('Invalid state change');
      }
      this.state_ = state;
    },
    get metadata() {
      return this.data_;
    },
    nameTrace: function() {
      var trace = this.specifiedAs();
      if (isAbsolute(this.name_)) {
        return trace + 'An absolute name.\n';
      }
      if (this.referrerName_) {
        return trace + this.importedBy() + this.normalizesTo();
      }
      return trace + this.normalizesTo();
    },
    specifiedAs: function() {
      return ("Specified as " + this.name_ + ".\n");
    },
    importedBy: function() {
      return ("Imported by " + this.referrerName_ + ".\n");
    },
    normalizesTo: function() {
      return 'Normalizes to ' + this.normalizedName + '\n';
    },
    addListener: function(callback, errback) {
      if (!this.listeners) {
        this.listeners = [];
      }
      this.listeners.push(callback, errback);
      if (this.state >= COMPLETE) {
        this.dispatchComplete(this.result);
      }
    },
    dispatchError: function(value) {
      this.dispatch_(value, 1);
    },
    dispatchComplete: function(value) {
      this.dispatch_(value, 0);
    },
    dispatch_: function(value, error) {
      var listeners = this.listeners;
      if (!listeners) {
        return;
      }
      listeners = listeners.concat();
      this.listeners = [];
      for (var i = error; i < listeners.length; i += 2) {
        var f = listeners[i];
        if (f) {
          f(value);
        }
      }
    },
    transform: function() {
      return this.loaderHooks.transform(this);
    },
    instantiate: function() {
      if (this.loaderHooks.instantiate(this)) throw new Error('instantiate() with factory return not implemented.');
    }
  }, {});
  var PreCompiledCodeUnit = function PreCompiledCodeUnit(loaderHooks, normalizedName, name, referrerName, address, module) {
    $traceurRuntime.superCall(this, $PreCompiledCodeUnit.prototype, "constructor", [loaderHooks, normalizedName, 'module', COMPLETE, name, referrerName, address]);
    this.result = module;
  };
  var $PreCompiledCodeUnit = PreCompiledCodeUnit;
  ($traceurRuntime.createClass)(PreCompiledCodeUnit, {}, {}, CodeUnit);
  var LoadCodeUnit = function LoadCodeUnit(loaderHooks, normalizedName, name, referrerName, address) {
    $traceurRuntime.superCall(this, $LoadCodeUnit.prototype, "constructor", [loaderHooks, normalizedName, 'module', NOT_STARTED, name, referrerName, address]);
  };
  var $LoadCodeUnit = LoadCodeUnit;
  ($traceurRuntime.createClass)(LoadCodeUnit, {}, {}, CodeUnit);
  var EvalCodeUnit = function EvalCodeUnit(loaderHooks, code) {
    var type = arguments[2] !== (void 0) ? arguments[2]: 'script';
    var normalizedName = arguments[3];
    var referrerName = arguments[4];
    var address = arguments[5];
    $traceurRuntime.superCall(this, $EvalCodeUnit.prototype, "constructor", [loaderHooks, normalizedName, type, LOADED, null, referrerName, address]);
    this.text = code;
  };
  var $EvalCodeUnit = EvalCodeUnit;
  ($traceurRuntime.createClass)(EvalCodeUnit, {}, {}, CodeUnit);
  var InternalLoader = function InternalLoader(loaderHooks) {
    this.loaderHooks = loaderHooks;
    this.reporter = loaderHooks.reporter;
    this.cache = new ArrayMap();
    this.urlToKey = Object.create(null);
    this.sync_ = false;
    this.translateHook = loaderHooks.translate || defaultTranslate;
  };
  ($traceurRuntime.createClass)(InternalLoader, {
    loadTextFile: function(url, callback, errback) {
      return this.loaderHooks.fetch({address: url}, callback, errback);
    },
    load: function(name) {
      var referrerName = arguments[1] !== (void 0) ? arguments[1]: this.loaderHooks.rootUrl();
      var address = arguments[2];
      var type = arguments[3] !== (void 0) ? arguments[3]: 'script';
      var codeUnit = this.getCodeUnit_(name, referrerName, address, type);
      if (codeUnit.state != NOT_STARTED || codeUnit.state == ERROR) {
        return codeUnit;
      }
      codeUnit.state = LOADING;
      var loader = this;
      var translate = this.translateHook;
      var url = this.loaderHooks.locate(codeUnit);
      codeUnit.abort = this.loadTextFile(url, function(text) {
        codeUnit.text = translate(text);
        codeUnit.state = LOADED;
        loader.handleCodeUnitLoaded(codeUnit);
      }, function() {
        codeUnit.state = ERROR;
        loader.handleCodeUnitLoadError(codeUnit);
      });
      return codeUnit;
    },
    module: function(code, referrerName, address) {
      var codeUnit = new EvalCodeUnit(this.loaderHooks, code, 'module', null, referrerName, address);
      this.cache.set({}, codeUnit);
      return codeUnit;
    },
    define: function(normalizedName, code, address) {
      var codeUnit = new EvalCodeUnit(this.loaderHooks, code, 'module', normalizedName, null, address);
      var key = this.getKey(normalizedName, 'module');
      this.cache.set(key, codeUnit);
      return codeUnit;
    },
    script: function(code, referrerName, address) {
      var codeUnit = new EvalCodeUnit(this.loaderHooks, code, 'script', null, referrerName, address);
      this.cache.set({}, codeUnit);
      this.handleCodeUnitLoaded(codeUnit);
      return codeUnit;
    },
    getKey: function(url, type) {
      var combined = type + ':' + url;
      if (combined in this.urlToKey) {
        return this.urlToKey[combined];
      }
      return this.urlToKey[combined] = {};
    },
    getCodeUnit_: function(name, referrerName, address, type) {
      var normalizedName = System.normalize(name, referrerName, address);
      var key = this.getKey(normalizedName, type);
      var cacheObject = this.cache.get(key);
      if (!cacheObject) {
        var module = this.loaderHooks.get(normalizedName);
        if (module) {
          cacheObject = new PreCompiledCodeUnit(this.loaderHooks, normalizedName, name, referrerName, address, module);
          cacheObject.type = 'module';
        } else {
          cacheObject = new LoadCodeUnit(this.loaderHooks, normalizedName, name, referrerName, address);
          cacheObject.type = type;
        }
        this.cache.set(key, cacheObject);
      }
      return cacheObject;
    },
    areAll: function(state) {
      return this.cache.values().every((function(codeUnit) {
        return codeUnit.state >= state;
      }));
    },
    getCodeUnitForModuleSpecifier: function(name, referrerName) {
      return this.getCodeUnit_(name, referrerName, null, 'module');
    },
    handleCodeUnitLoaded: function(codeUnit) {
      var $__329 = this;
      var referrerName = codeUnit.normalizedName;
      var moduleSpecifiers = this.loaderHooks.getModuleSpecifiers(codeUnit);
      if (!moduleSpecifiers) {
        this.abortAll();
        return;
      }
      codeUnit.dependencies = moduleSpecifiers.sort().map((function(name) {
        return $__329.getCodeUnit_(name, referrerName, null, 'module');
      }));
      codeUnit.dependencies.forEach((function(dependency) {
        $__329.load(dependency.normalizedName, null, null, 'module');
      }));
      if (this.areAll(PARSED)) {
        this.analyze();
        this.transform();
        this.evaluate();
      }
    },
    handleCodeUnitLoadError: function(codeUnit) {
      var message = ("Failed to load '" + codeUnit.url + "'.\n") + codeUnit.nameTrace() + this.loaderHooks.nameTrace(codeUnit);
      this.reporter.reportError(null, message);
      this.abortAll();
      codeUnit.error = message;
      codeUnit.dispatchError(message);
    },
    abortAll: function() {
      this.cache.values().forEach((function(codeUnit) {
        if (codeUnit.abort) {
          codeUnit.abort();
          codeUnit.state = ERROR;
        }
      }));
      this.cache.values().forEach((function(codeUnit) {
        codeUnit.dispatchError(codeUnit.error || 'Error in dependency');
      }));
    },
    analyze: function() {
      this.loaderHooks.analyzeDependencies(this.cache.values(), this);
    },
    transform: function() {
      this.loaderHooks.transformDependencies(this.cache.values());
    },
    orderDependencies: function(codeUnit) {
      var visited = new ObjectMap();
      var ordered = [];
      function orderCodeUnits(codeUnit) {
        if (visited.has(codeUnit)) {
          return;
        }
        visited.set(codeUnit, true);
        codeUnit.dependencies.forEach(orderCodeUnits);
        ordered.push(codeUnit);
      }
      this.cache.values().forEach(orderCodeUnits);
      return ordered;
    },
    evaluate: function() {
      var dependencies = this.orderDependencies(codeUnit);
      for (var i = 0; i < dependencies.length; i++) {
        var codeUnit = dependencies[i];
        if (codeUnit.state >= COMPLETE) {
          continue;
        }
        var result;
        try {
          result = this.loaderHooks.evaluateCodeUnit(codeUnit);
        } catch (ex) {
          codeUnit.error = ex;
          this.reporter.reportError(null, String(ex));
          this.abortAll();
          codeUnit.dispatchError(codeUnit.error);
          return;
        }
        codeUnit.result = result;
        codeUnit.text = null;
      }
      for (var i = 0; i < dependencies.length; i++) {
        var codeUnit = dependencies[i];
        if (codeUnit.state >= COMPLETE) {
          continue;
        }
        codeUnit.state = COMPLETE;
        codeUnit.dispatchComplete(codeUnit.result);
      }
    }
  }, {});
  function defaultTranslate(source) {
    return source;
  }
  var SystemLoaderHooks = LoaderHooks;
  var internals = {
    CodeUnit: CodeUnit,
    EvalCodeUnit: EvalCodeUnit,
    LoadCodeUnit: LoadCodeUnit,
    LoaderHooks: LoaderHooks
  };
  return {
    get InternalLoader() {
      return InternalLoader;
    },
    get internals() {
      return internals;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/runtime/Loader", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/runtime/Loader";
  var InternalLoader = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/InternalLoader").InternalLoader;
  var Loader = function Loader(loaderHooks) {
    this.internalLoader_ = new InternalLoader(loaderHooks);
    this.loaderHooks_ = loaderHooks;
  };
  ($traceurRuntime.createClass)(Loader, {
    import: function(name) {
      var $__333 = arguments[1] !== (void 0) ? arguments[1]: {},
          referrerName = $__333.referrerName,
          address = $__333.address;
      var callback = arguments[2] !== (void 0) ? arguments[2]: (function(module) {});
      var errback = arguments[3] !== (void 0) ? arguments[3]: (function(ex) {
        throw ex;
      });
      var codeUnit = this.internalLoader_.load(name, referrerName, address, 'module');
      codeUnit.addListener(function() {
        callback(System.get(codeUnit.normalizedName));
      }, errback);
    },
    module: function(source) {
      var $__333 = arguments[1] !== (void 0) ? arguments[1]: {},
          referrerName = $__333.referrerName,
          address = $__333.address;
      var callback = arguments[2] !== (void 0) ? arguments[2]: (function(module) {});
      var errback = arguments[3] !== (void 0) ? arguments[3]: (function(ex) {
        throw ex;
      });
      var codeUnit = this.internalLoader_.module (source, referrerName, address);
      codeUnit.addListener((function() {
        callback(codeUnit.result);
      }), errback);
      this.internalLoader_.handleCodeUnitLoaded(codeUnit);
    },
    define: function(normalizedName, source) {
      var $__333 = arguments[2],
          address = $__333.address,
          metadata = $__333.metadata;
      var callback = arguments[3] !== (void 0) ? arguments[3]: (function(module) {});
      var errback = arguments[4] !== (void 0) ? arguments[4]: (function(ex) {
        throw ex;
      });
      var codeUnit = this.internalLoader_.define(normalizedName, source, address, metadata);
      codeUnit.addListener((function() {
        callback(undefined);
      }), errback);
      this.internalLoader_.handleCodeUnitLoaded(codeUnit);
    },
    get: function(normalizedName) {
      return this.loaderHooks_.get(normalizedName);
    },
    set: function(normalizedName, module) {
      this.loaderHooks_.set(normalizedName, module);
    },
    normalize: function(name, referrerName, referrerAddress) {
      return this.loaderHooks_.normalize(name, referrerName, referrerAddress);
    }
  }, {});
  ;
  return {
    get Loader() {
      return Loader;
    },
    get LoaderHooks() {
      return LoaderHooks;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/WebPageTranscoder", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/WebPageTranscoder";
  var Loader = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/Loader").Loader;
  var ErrorReporter = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/ErrorReporter").ErrorReporter;
  var InterceptOutputLoaderHooks = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/InterceptOutputLoaderHooks").InterceptOutputLoaderHooks;
  var webLoader = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/webLoader").webLoader;
  var WebPageTranscoder = function WebPageTranscoder(url) {
    this.url = url;
    this.numPending_ = 0;
    this.numberInlined_ = 0;
  };
  ($traceurRuntime.createClass)(WebPageTranscoder, {
    asyncLoad_: function(url, fncOfContent, onScriptsReady) {
      var $__334 = this;
      this.numPending_++;
      webLoader.load(url, (function(content) {
        if (content) fncOfContent(content); else console.warn('Failed to load', url);
        if (--$__334.numPending_ <= 0) onScriptsReady();
      }), (function(error) {
        console.error('WebPageTranscoder FAILED to load ' + url, error);
      }));
    },
    addFileFromScriptElement: function(scriptElement, name, content) {
      this.loader.module (content, name);
    },
    nextInlineScriptName_: function() {
      this.numberInlined_ += 1;
      if (!this.inlineScriptNameBase_) {
        var segments = this.url.split('.');
        segments.pop();
        this.inlineScriptNameBase_ = segments.join('.');
      }
      return this.inlineScriptNameBase_ + '_' + this.numberInlined_ + '.js';
    },
    addFilesFromScriptElements: function(scriptElements, onScriptsReady) {
      for (var i = 0,
          length = scriptElements.length; i < length; i++) {
        var scriptElement = scriptElements[i];
        if (!scriptElement.src) {
          var name = this.nextInlineScriptName_();
          var content = scriptElement.textContent;
          this.addFileFromScriptElement(scriptElement, name, content);
        } else {
          var name = scriptElement.src;
          this.asyncLoad_(name, this.addFileFromScriptElement.bind(this, scriptElement, name), onScriptsReady);
        }
      }
      if (this.numPending_ <= 0) onScriptsReady();
    },
    get reporter() {
      if (!this.reporter_) {
        this.reporter_ = new ErrorReporter();
      }
      return this.reporter_;
    },
    get loader() {
      if (!this.loader_) {
        var loaderHooks = new InterceptOutputLoaderHooks(this.reporter, this.url);
        this.loader_ = new Loader(loaderHooks);
      }
      return this.loader_;
    },
    putFile: function(file) {
      var scriptElement = document.createElement('script');
      scriptElement.setAttribute('data-traceur-src-url', file.name);
      scriptElement.textContent = file.generatedSource;
      var parent = file.scriptElement.parentNode;
      parent.insertBefore(scriptElement, file.scriptElement || null);
    },
    selectAndProcessScripts: function(done) {
      var selector = 'script[type="module"]';
      var scripts = document.querySelectorAll(selector);
      if (!scripts.length) {
        done();
        return;
      }
      this.addFilesFromScriptElements(scripts, (function() {
        done();
      }));
    },
    run: function() {
      var done = arguments[0] !== (void 0) ? arguments[0]: (function() {});
      var $__334 = this;
      var ready = document.readyState;
      if (ready === 'complete' || ready === 'loaded') {
        this.selectAndProcessScripts(done);
      } else {
        document.addEventListener('DOMContentLoaded', (function() {
          return $__334.selectAndProcessScripts(done);
        }), false);
      }
    }
  }, {});
  return {get WebPageTranscoder() {
      return WebPageTranscoder;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/codegeneration/CloneTreeTransformer", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/codegeneration/CloneTreeTransformer";
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var $__338 = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/trees/ParseTrees"),
      BindingIdentifier = $__338.BindingIdentifier,
      BreakStatement = $__338.BreakStatement,
      ContinueStatement = $__338.ContinueStatement,
      DebuggerStatement = $__338.DebuggerStatement,
      EmptyStatement = $__338.EmptyStatement,
      ExportSpecifier = $__338.ExportSpecifier,
      ExportStar = $__338.ExportStar,
      IdentifierExpression = $__338.IdentifierExpression,
      ImportSpecifier = $__338.ImportSpecifier,
      LiteralExpression = $__338.LiteralExpression,
      ModuleSpecifier = $__338.ModuleSpecifier,
      PredefinedType = $__338.PredefinedType,
      PropertyNameShorthand = $__338.PropertyNameShorthand,
      TemplateLiteralPortion = $__338.TemplateLiteralPortion,
      RestParameter = $__338.RestParameter,
      SuperExpression = $__338.SuperExpression,
      ThisExpression = $__338.ThisExpression;
  var CloneTreeTransformer = function CloneTreeTransformer() {
    $traceurRuntime.defaultSuperCall(this, $CloneTreeTransformer.prototype, arguments);
  };
  var $CloneTreeTransformer = CloneTreeTransformer;
  ($traceurRuntime.createClass)(CloneTreeTransformer, {
    transformBindingIdentifier: function(tree) {
      return new BindingIdentifier(tree.location, tree.identifierToken);
    },
    transformBreakStatement: function(tree) {
      return new BreakStatement(tree.location, tree.name);
    },
    transformContinueStatement: function(tree) {
      return new ContinueStatement(tree.location, tree.name);
    },
    transformDebuggerStatement: function(tree) {
      return new DebuggerStatement(tree.location);
    },
    transformEmptyStatement: function(tree) {
      return new EmptyStatement(tree.location);
    },
    transformExportSpecifier: function(tree) {
      return new ExportSpecifier(tree.location, tree.lhs, tree.rhs);
    },
    transformExportStar: function(tree) {
      return new ExportStar(tree.location);
    },
    transformIdentifierExpression: function(tree) {
      return new IdentifierExpression(tree.location, tree.identifierToken);
    },
    transformImportSpecifier: function(tree) {
      return new ImportSpecifier(tree.location, tree.lhs, tree.rhs);
    },
    transformList: function(list) {
      if (!list) {
        return null;
      } else if (list.length == 0) {
        return [];
      } else {
        return $traceurRuntime.superCall(this, $CloneTreeTransformer.prototype, "transformList", [list]);
      }
    },
    transformLiteralExpression: function(tree) {
      return new LiteralExpression(tree.location, tree.literalToken);
    },
    transformModuleSpecifier: function(tree) {
      return new ModuleSpecifier(tree.location, tree.token);
    },
    transformPredefinedType: function(tree) {
      return new PredefinedType(tree.location, tree.typeToken);
    },
    transformPropertyNameShorthand: function(tree) {
      return new PropertyNameShorthand(tree.location, tree.name);
    },
    transformTemplateLiteralPortion: function(tree) {
      return new TemplateLiteralPortion(tree.location, tree.value);
    },
    transformSuperExpression: function(tree) {
      return new SuperExpression(tree.location);
    },
    transformThisExpression: function(tree) {
      return new ThisExpression(tree.location);
    }
  }, {}, ParseTreeTransformer);
  CloneTreeTransformer.cloneTree = function(tree) {
    return new CloneTreeTransformer().transformAny(tree);
  };
  return {get CloneTreeTransformer() {
      return CloneTreeTransformer;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/outputgeneration/SourceMapIntegration", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/outputgeneration/SourceMapIntegration";
  function makeDefine(mapping, id) {
    var require = function(id) {
      return mapping[id];
    };
    var exports = mapping[id] = {};
    var module = null;
    return function(factory) {
      factory(require, exports, module);
    };
  }
  var define,
      m = {};
  define = makeDefine(m, './util');
  if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
  }
  define(function(require, exports, module) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /([\w+\-.]+):\/\/((\w+:\w+)@)?([\w.]+)?(:(\d+))?(\S+)?/;
    var dataUrlRegexp = /^data:.+\,.+/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[3],
        host: match[4],
        port: match[6],
        path: match[7]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = aParsedUrl.scheme + "://";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    function join(aRoot, aPath) {
      var url;
      if (aPath.match(urlRegexp) || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aPath.charAt(0) === '/' && (url = urlParse(aRoot))) {
        url.path = aPath;
        return urlGenerate(url);
      }
      return aRoot.replace(/\/$/, '') + '/' + aPath;
    }
    exports.join = join;
    function toSetString(aStr) {
      return '$' + aStr;
    }
    exports.toSetString = toSetString;
    function fromSetString(aStr) {
      return aStr.substr(1);
    }
    exports.fromSetString = fromSetString;
    function relative(aRoot, aPath) {
      aRoot = aRoot.replace(/\/$/, '');
      var url = urlParse(aRoot);
      if (aPath.charAt(0) == "/" && url && url.path == "/") {
        return aPath.slice(1);
      }
      return aPath.indexOf(aRoot + '/') === 0 ? aPath.substr(aRoot.length + 1): aPath;
    }
    exports.relative = relative;
    function strcmp(aStr1, aStr2) {
      var s1 = aStr1 || "";
      var s2 = aStr2 || "";
      return (s1 > s2) - (s1 < s2);
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp;
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp || onlyCompareOriginal) {
        return cmp;
      }
      cmp = strcmp(mappingA.name, mappingB.name);
      if (cmp) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp) {
        return cmp;
      }
      return mappingA.generatedColumn - mappingB.generatedColumn;
    }
    ;
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
      var cmp;
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    ;
    exports.compareByGeneratedPositions = compareByGeneratedPositions;
  });
  define = makeDefine(m, './array-set');
  if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
  }
  define(function(require, exports, module) {
    var util = require('./util');
    function ArraySet() {
      this._array = [];
      this._set = {};
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0,
          len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var isDuplicate = this.has(aStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        this._set[util.toSetString(aStr)] = idx;
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      return Object.prototype.hasOwnProperty.call(this._set, util.toSetString(aStr));
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (this.has(aStr)) {
        return this._set[util.toSetString(aStr)];
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error('No element indexed by ' + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  });
  define = makeDefine(m, './base64');
  if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
  }
  define(function(require, exports, module) {
    var charToIntMap = {};
    var intToCharMap = {};
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('').forEach(function(ch, index) {
      charToIntMap[ch] = index;
      intToCharMap[index] = ch;
    });
    exports.encode = function base64_encode(aNumber) {
      if (aNumber in intToCharMap) {
        return intToCharMap[aNumber];
      }
      throw new TypeError("Must be between 0 and 63: " + aNumber);
    };
    exports.decode = function base64_decode(aChar) {
      if (aChar in charToIntMap) {
        return charToIntMap[aChar];
      }
      throw new TypeError("Not a valid base 64 digit: " + aChar);
    };
  });
  define = makeDefine(m, './base64-vlq');
  if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
  }
  define(function(require, exports, module) {
    var base64 = require('./base64');
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? ((- aValue) << 1) + 1: (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? - shifted: shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr) {
      var i = 0;
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation,
          digit;
      do {
        if (i >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charAt(i++));
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      return {
        value: fromVLQSigned(result),
        rest: aStr.slice(i)
      };
    };
  });
  define = makeDefine(m, './binary-search');
  if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
  }
  define(function(require, exports, module) {
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return aHaystack[mid];
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
        }
        return aHaystack[mid];
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
        }
        return aLow < 0 ? null: aHaystack[aLow];
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare) {
      return aHaystack.length > 0 ? recursiveSearch(- 1, aHaystack.length, aNeedle, aHaystack, aCompare): null;
    };
  });
  define = makeDefine(m, './source-map-generator');
  if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
  }
  define(function(require, exports, module) {
    var base64VLQ = require('./base64-vlq');
    var util = require('./util');
    var ArraySet = require('./array-set').ArraySet;
    function SourceMapGenerator(aArgs) {
      this._file = util.getArg(aArgs, 'file');
      this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = [];
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }};
        if (mapping.source) {
          newMapping.source = mapping.source;
          if (sourceRoot) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);
      this._validateMapping(generated, original, source, name);
      if (source && !this._sources.has(source)) {
        this._sources.add(source);
      }
      if (name && !this._names.has(name)) {
        this._names.add(name);
      }
      this._mappings.push({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent !== null) {
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile) {
      if (!aSourceFile) {
        aSourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot) {
        aSourceFile = util.relative(sourceRoot, aSourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.forEach(function(mapping) {
        if (mapping.source === aSourceFile && mapping.originalLine) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source !== null) {
            if (sourceRoot) {
              mapping.source = util.relative(sourceRoot, original.source);
            } else {
              mapping.source = original.source;
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name !== null && mapping.name !== null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          if (sourceRoot) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aGenerated && 'line'in aGenerated && 'column'in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && 'line'in aGenerated && 'column'in aGenerated && aOriginal && 'line'in aOriginal && 'column'in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          orginal: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;
      this._mappings.sort(util.compareByGeneratedPositions);
      for (var i = 0,
          len = this._mappings.length; i < len; i++) {
        mapping = this._mappings[i];
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }
        result += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source) - previousSource);
          previousSource = this._sources.indexOf(mapping.source);
          result += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          result += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name) - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key]: null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        file: this._file,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._sourceRoot) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  });
  define = makeDefine(m, './source-map-consumer');
  if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
  }
  define(function(require, exports, module) {
    var util = require('./util');
    var binarySearch = require('./binary-search');
    var ArraySet = require('./array-set').ArraySet;
    var base64VLQ = require('./base64-vlq');
    function SourceMapConsumer(aSourceMap) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === 'string') {
        sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
      }
      var version = util.getArg(sourceMap, 'version');
      var sources = util.getArg(sourceMap, 'sources');
      var names = util.getArg(sourceMap, 'names');
      var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
      var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
      var mappings = util.getArg(sourceMap, 'mappings');
      var file = util.getArg(sourceMap, 'file', null);
      if (version !== this._version) {
        throw new Error('Unsupported version: ' + version);
      }
      this._names = ArraySet.fromArray(names, true);
      this._sources = ArraySet.fromArray(sources, true);
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this.file = file;
      this._generatedMappings = [];
      this._originalMappings = [];
      this._parseMappings(mappings, sourceRoot);
    }
    SourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(SourceMapConsumer.prototype);
      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
      smc.file = aSourceMap._file;
      smc._generatedMappings = aSourceMap._mappings.slice().sort(util.compareByGeneratedPositions);
      smc._originalMappings = aSourceMap._mappings.slice().sort(util.compareByOriginalPositions);
      return smc;
    };
    SourceMapConsumer.prototype._version = 3;
    Object.defineProperty(SourceMapConsumer.prototype, 'sources', {get: function() {
        return this._sources.toArray().map(function(s) {
          return this.sourceRoot ? util.join(this.sourceRoot, s): s;
        }, this);
      }});
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var mappingSeparator = /^[,;]/;
      var str = aStr;
      var mapping;
      var temp;
      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        } else if (str.charAt(0) === ',') {
          str = str.slice(1);
        } else {
          mapping = {};
          mapping.generatedLine = generatedLine;
          temp = base64VLQ.decode(str);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;
          if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
            temp = base64VLQ.decode(str);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source, but no line and column');
            }
            temp = base64VLQ.decode(str);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source and line, but no column');
            }
            temp = base64VLQ.decode(str);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;
            if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
              temp = base64VLQ.decode(str);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }
          this._generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this._originalMappings.push(mapping);
          }
        }
      }
      this._originalMappings.sort(util.compareByOriginalPositions);
    };
    SourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator);
    };
    SourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };
      var mapping = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositions);
      if (mapping) {
        var source = util.getArg(mapping, 'source', null);
        if (source && this.sourceRoot) {
          source = util.join(this.sourceRoot, source);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: util.getArg(mapping, 'name', null)
        };
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    SourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource) {
      if (!this.sourcesContent) {
        return null;
      }
      if (this.sourceRoot) {
        aSource = util.relative(this.sourceRoot, aSource);
      }
      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }
      var url;
      if (this.sourceRoot && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };
    SourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };
      if (this.sourceRoot) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }
      var mapping = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions);
      if (mapping) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null)
        };
      }
      return {
        line: null,
        column: null
      };
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source;
        if (source && sourceRoot) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };
    exports.SourceMapConsumer = SourceMapConsumer;
  });
  define = makeDefine(m, './source-node');
  if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
  }
  define(function(require, exports, module) {
    var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
    var util = require('./util');
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine === undefined ? null: aLine;
      this.column = aColumn === undefined ? null: aColumn;
      this.source = aSource === undefined ? null: aSource;
      this.name = aName === undefined ? null: aName;
      if (aChunks != null) this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split('\n');
      var lastGeneratedLine = 1,
          lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping === null) {
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(remainingLines.shift() + "\n");
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[0];
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[0] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
        } else {
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            do {
              code += remainingLines.shift() + "\n";
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } while (lastGeneratedLine < mapping.generatedLine);
            if (lastGeneratedColumn < mapping.generatedColumn) {
              var nextLine = remainingLines[0];
              code += nextLine.substr(0, mapping.generatedColumn);
              remainingLines[0] = nextLine.substr(mapping.generatedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
            }
            addMappingWithCode(lastMapping, code);
          } else {
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
          }
        }
        lastMapping = mapping;
      }, this);
      addMappingWithCode(lastMapping, remainingLines.join("\n"));
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, mapping.source, code, mapping.name));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0,
          len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk instanceof SourceNode) {
          chunk.walk(aFn);
        } else {
          if (chunk !== '') {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild instanceof SourceNode) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === 'string') {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push(''.replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0,
          len = this.children.length; i < len; i++) {
        if (this.children[i]instanceof SourceNode) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0,
          len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({generated: {
              line: generated.line,
              column: generated.column
            }});
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        chunk.split('').forEach(function(ch) {
          if (ch === '\n') {
            generated.line++;
            generated.column = 0;
          } else {
            generated.column++;
          }
        });
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return {
        code: generated.code,
        map: map
      };
    };
    exports.SourceNode = SourceNode;
  });
  var SourceMapGenerator = m['./source-map-generator'].SourceMapGenerator;
  var SourceMapConsumer = m['./source-map-consumer'].SourceMapConsumer;
  var SourceNode = m['./source-node'].SourceNode;
  return {
    get SourceMapGenerator() {
      return SourceMapGenerator;
    },
    get SourceMapConsumer() {
      return SourceMapConsumer;
    },
    get SourceNode() {
      return SourceNode;
    }
  };
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/runtime/TraceurLoader", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/runtime/TraceurLoader";
  var InternalLoader = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/InternalLoader").InternalLoader;
  var Loader = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/Loader").Loader;
  var TraceurLoader = function TraceurLoader(loaderHooks) {
    $traceurRuntime.superCall(this, $TraceurLoader.prototype, "constructor", [loaderHooks]);
  };
  var $TraceurLoader = TraceurLoader;
  ($traceurRuntime.createClass)(TraceurLoader, {
    loadAsScript: function(filename) {
      var $__340 = arguments[1] !== (void 0) ? arguments[1]: {},
          referrerName = $__340.referrerName,
          address = $__340.address;
      var callback = arguments[2] !== (void 0) ? arguments[2]: (function(result) {});
      var errback = arguments[3] !== (void 0) ? arguments[3]: (function(ex) {
        throw ex;
      });
      var name = filename.replace(/\.js$/, '');
      var codeUnit = this.internalLoader_.load(name, referrerName, address, 'script');
      codeUnit.addListener(function(result) {
        callback(result);
      }, errback);
    },
    script: function(source) {
      var $__340 = arguments[1] !== (void 0) ? arguments[1]: {},
          referrerName = $__340.referrerName,
          address = $__340.address;
      var callback = arguments[2] !== (void 0) ? arguments[2]: (function(result) {});
      var errback = arguments[3] !== (void 0) ? arguments[3]: (function(ex) {
        throw ex;
      });
      try {
        var codeUnit = this.internalLoader_.script(source, null, referrerName, address);
        callback(codeUnit.result);
      } catch (ex) {
        errback(ex);
      }
    },
    semVerRegExp_: function() {
      return /^(\d+)\.(\d+)\.(\d+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+[0-9A-Za-z-]+)?$/;
    },
    semverMap: function(normalizedName) {
      var slash = normalizedName.indexOf('/');
      var version = normalizedName.slice(0, slash);
      var at = version.indexOf('@');
      if (at !== - 1) {
        var semver = normalizedName.slice(at + 1, slash);
        var m = this.semVerRegExp_().exec(semver);
        if (m) {
          var major = m[1];
          var minor = m[2];
          var packageName = version.slice(0, at);
          var map = Object.create(null);
          map[packageName] = version;
          map[packageName + '@' + major] = version;
          map[packageName + '@' + major + '.' + minor] = version;
        }
      }
      return map;
    }
  }, {}, Loader);
  return {get TraceurLoader() {
      return TraceurLoader;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/runtime/System", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/runtime/System";
  var globalThis = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/globalThis").default;
  var ErrorReporter = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/ErrorReporter").ErrorReporter;
  var TraceurLoader = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/TraceurLoader").TraceurLoader;
  var LoaderHooks = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/LoaderHooks").LoaderHooks;
  var options = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/options").options;
  var webLoader = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/webLoader").webLoader;
  var url;
  var fileLoader;
  if (typeof window !== 'undefined' && window.location) {
    url = window.location.href;
    fileLoader = webLoader;
  }
  var loaderHooks = new LoaderHooks(new ErrorReporter(), url, options, fileLoader);
  var System = new TraceurLoader(loaderHooks);
  if (typeof window !== 'undefined') window.System = System;
  if (typeof global !== 'undefined') global.System = System;
  System.map = System.semverMap(__moduleName);
  return {get System() {
      return System;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/util/TestErrorReporter", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/util/TestErrorReporter";
  var ErrorReporter = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/ErrorReporter").ErrorReporter;
  var TestErrorReporter = function TestErrorReporter() {
    this.errors = [];
  };
  ($traceurRuntime.createClass)(TestErrorReporter, {
    reportMessageInternal: function(location, format, args) {
      this.errors.push(ErrorReporter.format(location, format, args));
    },
    hasMatchingError: function(expected) {
      return this.errors.some((function(error) {
        return error.indexOf(expected) !== - 1;
      }));
    }
  }, {}, ErrorReporter);
  return {get TestErrorReporter() {
      return TestErrorReporter;
    }};
});
$traceurRuntime.ModuleStore.registerModule("traceur@0.0.20/src/traceur", function() {
  "use strict";
  var __moduleName = "traceur@0.0.20/src/traceur";
  var $__traceur_64_0_46_0_46_20_47_src_47_runtime_47_System__ = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/System");
  var System = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/System").System;
  var ModuleStore = System.get('@traceur/src/runtime/ModuleStore');
  var $__traceur_64_0_46_0_46_20_47_src_47_options__ = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/options");
  var $__traceur_64_0_46_0_46_20_47_src_47_WebPageTranscoder__ = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/WebPageTranscoder");
  var ModuleAnalyzer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/semantics/ModuleAnalyzer").ModuleAnalyzer;
  var semantics = {ModuleAnalyzer: ModuleAnalyzer};
  var ErrorReporter = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/ErrorReporter").ErrorReporter;
  var SourcePosition = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/SourcePosition").SourcePosition;
  var SyntaxErrorReporter = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/SyntaxErrorReporter").SyntaxErrorReporter;
  var TestErrorReporter = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/TestErrorReporter").TestErrorReporter;
  var resolveUrl = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/util/url").resolveUrl;
  var util = {
    ErrorReporter: ErrorReporter,
    SourcePosition: SourcePosition,
    SyntaxErrorReporter: SyntaxErrorReporter,
    TestErrorReporter: TestErrorReporter,
    resolveUrl: resolveUrl
  };
  var IdentifierToken = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/IdentifierToken").IdentifierToken;
  var LiteralToken = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/LiteralToken").LiteralToken;
  var Parser = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Parser").Parser;
  var Scanner = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Scanner").Scanner;
  var SourceFile = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/SourceFile").SourceFile;
  var Token = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/syntax/Token").Token;
  var TokenType = $traceurRuntime.ModuleStore.get("traceur@0.0.20/src/syntax/TokenType");
  var trees = $traceurRuntime.ModuleStore.get("traceur@0.0.20/src/syntax/trees/ParseTrees");
  var syntax = {
    IdentifierToken: IdentifierToken,
    LiteralToken: LiteralToken,
    Parser: Parser,
    Scanner: Scanner,
    SourceFile: SourceFile,
    Token: Token,
    TokenType: TokenType,
    trees: trees
  };
  var ParseTreeMapWriter = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/outputgeneration/ParseTreeMapWriter").ParseTreeMapWriter;
  var ParseTreeWriter = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/outputgeneration/ParseTreeWriter").ParseTreeWriter;
  var SourceMapConsumer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/outputgeneration/SourceMapIntegration").SourceMapConsumer;
  var SourceMapGenerator = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/outputgeneration/SourceMapIntegration").SourceMapGenerator;
  var TreeWriter = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/outputgeneration/TreeWriter").TreeWriter;
  var outputgeneration = {
    ParseTreeMapWriter: ParseTreeMapWriter,
    ParseTreeWriter: ParseTreeWriter,
    SourceMapConsumer: SourceMapConsumer,
    SourceMapGenerator: SourceMapGenerator,
    TreeWriter: TreeWriter
  };
  var AmdTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/AmdTransformer").AmdTransformer;
  var AttachModuleNameTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/module/AttachModuleNameTransformer").AttachModuleNameTransformer;
  var CloneTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/CloneTreeTransformer").CloneTreeTransformer;
  var CommonJsModuleTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/CommonJsModuleTransformer").CommonJsModuleTransformer;
  var FromOptionsTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/FromOptionsTransformer").FromOptionsTransformer;
  var InlineModuleTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/InlineModuleTransformer").InlineModuleTransformer;
  var ModuleSpecifierVisitor = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/module/ModuleSpecifierVisitor").ModuleSpecifierVisitor;
  var ModuleTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ModuleTransformer").ModuleTransformer;
  var ParseTreeTransformer = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/codegeneration/ParseTreeTransformer").ParseTreeTransformer;
  var ParseTreeFactory = $traceurRuntime.ModuleStore.get("traceur@0.0.20/src/codegeneration/ParseTreeFactory");
  var codegeneration = {
    AmdTransformer: AmdTransformer,
    AttachModuleNameTransformer: AttachModuleNameTransformer,
    CloneTreeTransformer: CloneTreeTransformer,
    CommonJsModuleTransformer: CommonJsModuleTransformer,
    FromOptionsTransformer: FromOptionsTransformer,
    InlineModuleTransformer: InlineModuleTransformer,
    ModuleTransformer: ModuleTransformer,
    ParseTreeFactory: ParseTreeFactory,
    ParseTreeTransformer: ParseTreeTransformer,
    module: {ModuleSpecifierVisitor: ModuleSpecifierVisitor}
  };
  var modules = $traceurRuntime.ModuleStore.get("traceur@0.0.20/src/runtime/InternalLoader");
  ;
  var Loader = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/Loader").Loader;
  var LoaderHooks = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/LoaderHooks").LoaderHooks;
  var InterceptOutputLoaderHooks = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/InterceptOutputLoaderHooks").InterceptOutputLoaderHooks;
  var TraceurLoader = $traceurRuntime.getModuleImpl("traceur@0.0.20/src/runtime/TraceurLoader").TraceurLoader;
  var runtime = {
    InterceptOutputLoaderHooks: InterceptOutputLoaderHooks,
    Loader: Loader,
    LoaderHooks: LoaderHooks,
    TraceurLoader: TraceurLoader
  };
  return {
    get System() {
      return $__traceur_64_0_46_0_46_20_47_src_47_runtime_47_System__.System;
    },
    get ModuleStore() {
      return ModuleStore;
    },
    get options() {
      return $__traceur_64_0_46_0_46_20_47_src_47_options__.options;
    },
    get WebPageTranscoder() {
      return $__traceur_64_0_46_0_46_20_47_src_47_WebPageTranscoder__.WebPageTranscoder;
    },
    get semantics() {
      return semantics;
    },
    get util() {
      return util;
    },
    get syntax() {
      return syntax;
    },
    get outputgeneration() {
      return outputgeneration;
    },
    get codegeneration() {
      return codegeneration;
    },
    get modules() {
      return modules;
    },
    get runtime() {
      return runtime;
    }
  };
});
var traceur = $traceurRuntime.ModuleStore.get("traceur@0.0.20/src/traceur");
$traceurRuntime.ModuleStore.set('traceur@', traceur);

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){(function() {
  var Aether, acorn_loose, csredux, defaults, escodegen, esprima, execution, fixLocations, instrumentation, jshint, morph, normalizer, optionsValidator, problems, protectAPI, protectBuiltins, traceur, transforms, _, _ref, _ref1, _ref2, _ref3, _ref4, _ref5,
    __slice = [].slice;

  _ = (_ref = (_ref1 = (_ref2 = typeof window !== "undefined" && window !== null ? window._ : void 0) != null ? _ref2 : typeof self !== "undefined" && self !== null ? self._ : void 0) != null ? _ref1 : typeof global !== "undefined" && global !== null ? global._ : void 0) != null ? _ref : require('lodash');

  traceur = (_ref3 = (_ref4 = (_ref5 = typeof window !== "undefined" && window !== null ? window.traceur : void 0) != null ? _ref5 : typeof self !== "undefined" && self !== null ? self.traceur : void 0) != null ? _ref4 : typeof global !== "undefined" && global !== null ? global.traceur : void 0) != null ? _ref3 : require('traceur');

  esprima = require('esprima');

  acorn_loose = require('acorn/acorn_loose');

  jshint = require('jshint').JSHINT;

  normalizer = require('JS_WALA/normalizer/lib/normalizer');

  escodegen = require('escodegen');

  csredux = require('coffee-script-redux');

  defaults = require('./defaults');

  problems = require('./problems');

  execution = require('./execution');

  fixLocations = require('./fixLocations');

  morph = require('./morph');

  transforms = require('./transforms');

  protectAPI = require('./protectAPI');

  protectBuiltins = require('./protectBuiltins');

  instrumentation = require('./instrumentation');

  optionsValidator = require('./validators/options');

  module.exports = Aether = (function() {
    Aether.defaults = defaults;

    Aether.problems = problems;

    Aether.execution = execution;

    Aether.prototype.depth = 0;

    function Aether(options) {
      var optionsValidation;
      this.originalOptions = _.cloneDeep(options);
      if (options == null) {
        options = {};
      }
      if (options.problems == null) {
        options.problems = {};
      }
      if (!options.excludeDefaultProblems) {
        options.problems = _.merge(_.cloneDeep(Aether.problems.problems), options.problems);
      }
      optionsValidation = optionsValidator(options);
      if (!optionsValidation.valid) {
        throw new Error("Options array is not valid: " + JSON.stringify(optionsValidation.errors, null, 4));
      }
      this.options = _.merge(_.cloneDeep(Aether.defaults), options);
      this.reset();
    }

    Aether.prototype.canTranspile = function(raw, thorough) {
      var e, lintProblems;
      if (thorough == null) {
        thorough = false;
      }
      if (!raw) {
        return true;
      }
      try {
        if (this.options.language === "javascript") {
          eval("'use strict;'\nthrow 0;" + raw);
        } else {
          true;
        }
      } catch (_error) {
        e = _error;
        if (e !== 0) {
          return false;
        }
      }
      if (!thorough) {
        return true;
      }
      lintProblems = this.lint(raw);
      return lintProblems.errors.length === 0;
    };

    Aether.prototype.hasChangedSignificantly = function(a, b, careAboutLineNumbers, careAboutLint) {
      var lintAether;
      if (careAboutLineNumbers == null) {
        careAboutLineNumbers = false;
      }
      if (careAboutLint == null) {
        careAboutLint = false;
      }
      if (careAboutLint) {
        lintAether = this;
      }
      return Aether.hasChangedSignificantly(a, b, careAboutLineNumbers, lintAether);
    };

    Aether.hasChangedSignificantly = function(a, b, careAboutLineNumbers, lintAether) {
      var aAST, bAST, options, walk, _ref6, _ref7, _ref8;
      if (careAboutLineNumbers == null) {
        careAboutLineNumbers = false;
      }
      if (lintAether == null) {
        lintAether = null;
      }
      if (!((a != null) && (b != null))) {
        return true;
      }
      if (a === b) {
        return false;
      }
      if (careAboutLineNumbers && this.hasChangedLineNumbers(a, b)) {
        return true;
      }
      if (lintAether != null ? lintAether.hasChangedLintProblems(a, b) : void 0) {
        return true;
      }
      options = {
        loc: false,
        range: false,
        comment: false,
        tolerant: true
      };
      _ref6 = [null, null], aAST = _ref6[0], bAST = _ref6[1];
      try {
        aAST = esprima.parse(a, options);
      } catch (_error) {}
      try {
        bAST = esprima.parse(b, options);
      } catch (_error) {}
      if ((!aAST || !bAST) && (aAST || bAST)) {
        return true;
      }
      if (aAST && bAST) {
        if (((_ref7 = aAST.errors) != null ? _ref7 : []).length !== ((_ref8 = bAST.errors) != null ? _ref8 : []).length) {
          return true;
        }
        return !_.isEqual(aAST.body, bAST.body);
      }
      options = {
        locations: false,
        tabSize: 4,
        ecmaVersion: 5
      };
      aAST = acorn_loose.parse_dammit(a, options);
      bAST = acorn_loose.parse_dammit(b, options);
      walk = function(node) {
        var child, grandchild, key, _results;
        node.start = node.end = null;
        _results = [];
        for (key in node) {
          child = node[key];
          if (_.isArray(child)) {
            _results.push((function() {
              var _i, _len, _results1;
              _results1 = [];
              for (_i = 0, _len = child.length; _i < _len; _i++) {
                grandchild = child[_i];
                if (_.isString(grandchild != null ? grandchild.type : void 0)) {
                  _results1.push(walk(grandchild));
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
            })());
          } else if (_.isString(child != null ? child.type : void 0)) {
            _results.push(walk(child));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      walk(aAST);
      walk(bAST);
      return !_.isEqual(aAST, bAST);
    };

    Aether.hasChangedLineNumbers = function(a, b) {
      if (!String.prototype.trimRight) {
        String.prototype.trimRight = function() {
          return String(this).replace(/\s\s*$/, '');
        };
      }
      a = a.replace(/^[ \t]+\/\/.*/g, '').trimRight();
      b = b.replace(/^[ \t]+\/\/.*/g, '').trimRight();
      return a.split('\n').length !== b.split('\n').length;
    };

    Aether.prototype.hasChangedLintProblems = function(a, b) {
      var aLintProblems, bLintProblems, p, _i, _j, _len, _len1, _ref6, _ref7;
      _ref6 = this.getAllProblems(this.lint(a));
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        p = _ref6[_i];
        aLintProblems = [p.id, p.message, p.hint];
      }
      _ref7 = this.getAllProblems(this.lint(b));
      for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
        p = _ref7[_j];
        bLintProblems = [p.id, p.message, p.hint];
      }
      return !_.isEqual(aLintProblems, bLintProblems);
    };

    Aether.prototype.reset = function() {
      this.problems = {
        errors: [],
        warnings: [],
        infos: []
      };
      this.style = {};
      this.flow = {};
      this.metrics = {};
      this.visualization = {};
      return this.pure = null;
    };

    Aether.prototype.transpile = function(raw) {
      this.raw = raw;
      this.reset();
      if (this.options.language !== 'coffeescript') {
        this.problems = this.lint(this.raw);
      }
      this.pure = this.purifyCode(this.raw);
      return this.pure;
    };

    Aether.prototype.beautify = function(raw) {
      var ast, beautified, e;
      try {
        ast = esprima.parse(raw, {
          range: true,
          tokens: true,
          comment: true,
          tolerant: true
        });
        ast = escodegen.attachComments(ast, ast.comments, ast.tokens);
      } catch (_error) {
        e = _error;
        console.log('got error beautifying', e);
        ast = acorn_loose.parse_dammit(raw, {
          tabSize: 4,
          ecmaVersion: 5
        });
      }
      beautified = escodegen.generate(ast, {
        comment: true,
        parse: esprima.parse
      });
      return beautified;
    };

    Aether.prototype.addProblem = function(problem, problems) {
      if (problems == null) {
        problems = null;
      }
      if (problem.level === "ignore") {
        return;
      }
      (problems != null ? problems : this.problems)[problem.level + "s"].push(problem);
      return problem;
    };

    Aether.prototype.wrap = function(rawCode) {
      if (this.wrappedCodePrefix == null) {
        this.wrappedCodePrefix = "function " + (this.options.functionName || 'foo') + "(" + (this.options.functionParameters.join(', ')) + ") {\n\"use strict\";";
      }
      if (this.wrappedCodeSuffix == null) {
        this.wrappedCodeSuffix = "\n}";
      }
      return this.wrappedCodePrefix + rawCode + this.wrappedCodeSuffix;
    };

    Aether.prototype.wrapCS = function(rawCode) {
      var i, indentedCode, lines, _i, _ref6;
      if (this.wrappedCodePrefix == null) {
        this.wrappedCodePrefix = "" + (this.options.functionName || 'foo') + " = (" + (this.options.functionParameters.join(', ')) + ") ->\n\n";
      }
      if (this.wrappedCodeSuffix == null) {
        this.wrappedCodeSuffix = "\n";
      }
      lines = rawCode.split("\n");
      for (i = _i = 0, _ref6 = lines.length; 0 <= _ref6 ? _i < _ref6 : _i > _ref6; i = 0 <= _ref6 ? ++_i : --_i) {
        lines[i] = "  " + lines[i];
      }
      indentedCode = lines.join("\n");
      return this.wrappedCodePrefix + indentedCode + this.wrappedCodeSuffix;
    };

    Aether.prototype.lint = function(rawCode) {
      var e, error, g, jshintGlobals, jshintOptions, jshintSuccess, lintProblems, wrappedCode, _i, _len, _ref6;
      wrappedCode = this.wrap(rawCode);
      lintProblems = {
        errors: [],
        warnings: [],
        infos: []
      };
      jshintOptions = {
        browser: false,
        couch: false,
        devel: false,
        dojo: false,
        jquery: false,
        mootools: false,
        node: false,
        nonstandard: false,
        phantom: false,
        prototypejs: false,
        rhino: false,
        worker: false,
        wsh: false,
        yui: false
      };
      jshintGlobals = _.keys(this.options.global);
      jshintGlobals = _.zipObject(jshintGlobals, (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = jshintGlobals.length; _i < _len; _i++) {
          g = jshintGlobals[_i];
          _results.push(false);
        }
        return _results;
      })());
      try {
        jshintSuccess = jshint(wrappedCode, jshintOptions, jshintGlobals);
      } catch (_error) {
        e = _error;
        console.warn("JSHint died with error", e);
      }
      _ref6 = jshint.errors;
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        error = _ref6[_i];
        this.addProblem(new problems.TranspileProblem(this, 'jshint', error != null ? error.code : void 0, error, {}, wrappedCode, this.wrappedCodePrefix), lintProblems);
      }
      return lintProblems;
    };

    Aether.prototype.createFunction = function() {
      var fn;
      fn = protectBuiltins.createSandboxedFunction(this.options.functionName || 'foo', this.pure, this);
      return protectBuiltins.wrapWithSandbox(this, fn);
    };

    Aether.prototype.createMethod = function(thisValue) {
      var fn;
      fn = this.createFunction();
      if (thisValue || this.options.thisValue) {
        fn = _.bind(fn, thisValue || this.options.thisValue);
      }
      return fn;
    };

    Aether.prototype.sandboxGenerator = function(fn) {
      var oldNext;
      oldNext = fn.next;
      fn.next = protectBuiltins.wrapWithSandbox(this, function() {
        return oldNext.apply(fn, arguments);
      });
      return fn;
    };

    Aether.prototype.run = function() {
      var args, error, fn;
      fn = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      try {
        if (fn == null) {
          fn = this.createMethod();
        }
        return fn.apply(null, args);
      } catch (_error) {
        error = _error;
        return this.addProblem(new problems.RuntimeProblem(this, error, {}));
      }
    };

    Aether.prototype.getAllProblems = function(problems) {
      return _.flatten(_.values(problems != null ? problems : this.problems));
    };

    Aether.prototype.serialize = function() {
      var serialized;
      serialized = {
        originalOptions: this.originalOptions,
        raw: this.raw,
        pure: this.pure,
        problems: this.problems
      };
      if (this.options.includeFlow) {
        serialized.flow = this.flow;
      }
      if (this.options.includeMetrics) {
        serialized.metrics = this.metrics;
      }
      if (this.options.includeStyle) {
        serialized.style = this.style;
      }
      if (this.options.includeVisualization) {
        serialized.visualization = this.visualization;
      }
      serialized.originalOptions.thisValue = null;
      return serialized;
    };

    Aether.deserialize = function(serialized) {
      var aether, prop, val;
      aether = new Aether(serialized.originalOptions);
      for (prop in serialized) {
        val = serialized[prop];
        if (prop !== "originalOptions") {
          aether[prop] = val;
        }
      }
      return aether;
    };

    Aether.prototype.walk = function(node, fn) {
      var child, grandchild, key, _i, _len, _results;
      _results = [];
      for (key in node) {
        child = node[key];
        if (_.isArray(child)) {
          for (_i = 0, _len = child.length; _i < _len; _i++) {
            grandchild = child[_i];
            if (_.isString(grandchild != null ? grandchild.type : void 0)) {
              this.walk(grandchild, fn);
            }
          }
        } else if (_.isString(child != null ? child.type : void 0)) {
          this.walk(child, fn);
        }
        _results.push(fn(child));
      }
      return _results;
    };

    Aether.prototype.traceurify = function(code) {
      var loader, loaderHooks, reporter, url;
      url = "randotron_" + Math.random();
      reporter = new traceur.util.ErrorReporter();
      loaderHooks = new traceur.runtime.InterceptOutputLoaderHooks(reporter, url);
      loader = new traceur.System.internalLoader_.constructor(loaderHooks);
      loader.script(code, url);
      if (reporter.hadError()) {
        console.warn("traceur had error trying to compile");
      }
      return loaderHooks.transcoded;
    };

    Aether.prototype.transform = function(code, transforms, parser, withAST) {
      var options, parse, t, temp, transformedAST, transformedCode, _ref6;
      if (parser == null) {
        parser = "esprima";
      }
      if (withAST == null) {
        withAST = false;
      }
      transformedCode = morph(code, (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = transforms.length; _i < _len; _i++) {
          t = transforms[_i];
          _results.push(_.bind(t, this));
        }
        return _results;
      }).call(this), parser);
      if (!withAST) {
        return transformedCode;
      }
      _ref6 = (function() {
        switch (parser) {
          case "esprima":
            return [
              esprima.parse, {
                loc: true,
                range: true,
                comment: true,
                tolerant: true
              }
            ];
          case "acorn_loose":
            return [
              acorn_loose.parse_dammit, {
                locations: true,
                tabSize: 4,
                ecmaVersion: 5
              }
            ];
          case "csredux":
            return [
              csredux.compile, {
                bare: true
              }
            ];
        }
      })(), parse = _ref6[0], options = _ref6[1];
      if (parser === 'csredux') {
        temp = csredux.parse(transformedCode, {
          optimise: false,
          raw: true
        });
        transformedAST = parse(temp, options);
        fixLocations(transformedAST);
      } else {
        transformedAST = parse(transformedCode, options);
      }
      return [transformedCode, transformedAST];
    };

    Aether.prototype.purifyCode = function(rawCode) {
      var error, instrumentedCode, interceptThis, normalized, normalizedAST, normalizedCode, normalizedNodeIndex, normalizedSourceMap, originalNodeRanges, parameter, postNormalizationTransforms, preNormalizationTransforms, preprocessedCode, problem, purifiedCode, transformedAST, transformedCode, varNames, wrappedCode, _i, _len, _ref10, _ref6, _ref7, _ref8, _ref9;
      if (this.options.language === 'coffeescript') {
        wrappedCode = this.wrapCS(rawCode);
      } else {
        preprocessedCode = this.checkCommonMistakes(rawCode);
        wrappedCode = this.wrap(preprocessedCode);
      }
      originalNodeRanges = [];
      varNames = {};
      _ref6 = this.options.functionParameters;
      for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
        parameter = _ref6[_i];
        varNames[parameter] = true;
      }
      preNormalizationTransforms = [transforms.makeGatherNodeRanges(originalNodeRanges, wrappedCode, this.wrappedCodePrefix), transforms.makeCheckThisKeywords(this.options.global, varNames), transforms.checkIncompleteMembers];
      if (this.options.language === 'coffeescript') {
        _ref7 = this.transform(wrappedCode, preNormalizationTransforms, "csredux", true), transformedCode = _ref7[0], transformedAST = _ref7[1];
      } else {
        try {
          _ref8 = this.transform(wrappedCode, preNormalizationTransforms, "esprima", true), transformedCode = _ref8[0], transformedAST = _ref8[1];
        } catch (_error) {
          error = _error;
          problem = new problems.TranspileProblem(this, 'esprima', error.id, error, {}, wrappedCode, '');
          this.addProblem(problem);
          originalNodeRanges.splice();
          _ref9 = this.transform(wrappedCode, preNormalizationTransforms, "acorn_loose", true), transformedCode = _ref9[0], transformedAST = _ref9[1];
        }
      }
      normalizedAST = normalizer.normalize(transformedAST);
      normalizedNodeIndex = [];
      this.walk(normalizedAST, function(node) {
        var pos, _ref10;
        if (!(pos = node != null ? (_ref10 = node.attr) != null ? _ref10.pos : void 0 : void 0)) {
          return;
        }
        node.loc = {
          start: {
            line: 1,
            column: normalizedNodeIndex.length
          },
          end: {
            line: 1,
            column: normalizedNodeIndex.length + 1
          }
        };
        return normalizedNodeIndex.push(node);
      });
      normalized = escodegen.generate(normalizedAST, {
        sourceMap: this.options.functionName || 'foo',
        sourceMapWithCode: true
      });
      normalizedCode = normalized.code;
      normalizedSourceMap = normalized.map;
      postNormalizationTransforms = [];
      if ((_ref10 = this.options.thisValue) != null ? _ref10.validateReturn : void 0) {
        postNormalizationTransforms.unshift(transforms.validateReturns);
      }
      if (this.options.yieldConditionally) {
        postNormalizationTransforms.unshift(transforms.yieldConditionally);
      }
      if (this.options.yieldAutomatically) {
        postNormalizationTransforms.unshift(transforms.yieldAutomatically);
      }
      if (this.options.includeFlow) {
        postNormalizationTransforms.unshift(transforms.makeInstrumentStatements(varNames));
      } else if (this.options.includeMetrics) {
        postNormalizationTransforms.unshift(transforms.makeInstrumentStatements());
      }
      if (this.options.includeMetrics || this.options.includeFlow) {
        postNormalizationTransforms.unshift(transforms.makeInstrumentCalls());
      }
      postNormalizationTransforms.unshift(transforms.makeFindOriginalNodes(originalNodeRanges, this.wrappedCodePrefix, normalizedSourceMap, normalizedNodeIndex));
      if (this.options.protectAPI) {
        postNormalizationTransforms.unshift(transforms.makeProtectAPI(this.options.functionParameters));
      }
      postNormalizationTransforms.unshift(transforms.interceptThis);
      instrumentedCode = this.transform(normalizedCode, postNormalizationTransforms);
      if (this.options.yieldConditionally || this.options.yieldAutomatically) {
        purifiedCode = this.traceurify(instrumentedCode);
      } else {
        purifiedCode = instrumentedCode;
      }
      interceptThis = 'var __interceptThis=(function(){var G=this;return function($this,sandbox){if($this==G){return sandbox;}return $this;};})();\n';
      purifiedCode = interceptThis + "return " + purifiedCode;
      if (false) {
        console.log("---NODE RANGES---:\n" + _.map(originalNodeRanges, function(n) {
          return "" + n.originalRange.start + " - " + n.originalRange.end + "\t" + (n.originalSource.replace(/\n/g, '↵'));
        }).join('\n'));
        console.log("---RAW CODE----: " + (rawCode.split('\n').length) + "\n", {
          code: rawCode
        });
        console.log("---WRAPPED-----: " + (wrappedCode.split('\n').length) + "\n", {
          code: wrappedCode
        });
        console.log("---TRANSFORMED-: " + (transformedCode.split('\n').length) + "\n", {
          code: transformedCode
        });
        console.log("---NORMALIZED--: " + (normalizedCode.split('\n').length) + "\n", {
          code: normalizedCode
        });
        console.log("---INSTRUMENTED: " + (instrumentedCode.split('\n').length) + "\n", {
          code: "return " + instrumentedCode
        });
        console.log("---PURIFIED----: " + (purifiedCode.split('\n').length) + "\n", {
          code: purifiedCode
        });
      }
      return purifiedCode;
    };

    Aether.prototype.checkCommonMistakes = function(code) {
      code = code.replace(/this\.\s*?\n/g, "this.IncompleteThisReference;");
      return code;
    };

    Aether.getFunctionBody = function(func) {
      var indent, line, lines, source;
      source = _.isString(func) ? func : func.toString();
      if (source.trim() === "function () {}") {
        return "";
      }
      source = source.substring(source.indexOf('{') + 2, source.lastIndexOf('}'));
      lines = source.split(/\r?\n/);
      indent = lines.length ? lines[0].length - lines[0].replace(/^ +/, '').length : 0;
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = lines.length; _i < _len; _i++) {
          line = lines[_i];
          _results.push(line.slice(indent));
        }
        return _results;
      })()).join('\n');
    };

    Aether.prototype.setLanguage = function(lang) {
      var optionsValidation;
      if (this.options.language === lang) {
        return;
      }
      optionsValidation = optionsValidator({
        language: lang
      });
      if (!optionsValidation.valid) {
        throw new Error("Options array is not valid: " + JSON.stringify(optionsValidation.errors, null, 4));
      }
      this.options.language = lang;
      this.wrappedCodePrefix = null;
      this.wrappedCodeSuffix = null;
      this.reset();
      return lang;
    };

    Aether.prototype.logStatementStart = instrumentation.logStatementStart;

    Aether.prototype.logStatement = instrumentation.logStatement;

    Aether.prototype.logCallStart = instrumentation.logCallStart;

    Aether.prototype.logCallEnd = instrumentation.logCallEnd;

    Aether.prototype.createAPIClone = protectAPI.createAPIClone;

    Aether.prototype.restoreAPIClone = protectAPI.restoreAPIClone;

    Aether.prototype.restoreBuiltins = protectBuiltins.restoreBuiltins;

    return Aether;

  })();

  if (typeof self !== "undefined" && self !== null) {
    self.Aether = Aether;
  }

  if (typeof window !== "undefined" && window !== null) {
    window.Aether = Aether;
  }

  if (typeof self !== "undefined" && self !== null) {
    if (self.esprima == null) {
      self.esprima = esprima;
    }
  }

  if (typeof window !== "undefined" && window !== null) {
    if (window.esprima == null) {
      window.esprima = esprima;
    }
  }

}).call(this);
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./defaults":2,"./execution":3,"./fixLocations":4,"./instrumentation":5,"./morph":6,"./problems":7,"./protectAPI":8,"./protectBuiltins":9,"./transforms":11,"./validators/options":12,"JS_WALA/normalizer/lib/normalizer":17,"acorn/acorn_loose":21,"coffee-script-redux":26,"escodegen":49,"esprima":54,"jshint":71,"lodash":56,"traceur":56}],2:[function(require,module,exports){
(function() {
  var defaults, execution;

  execution = require('./execution');

  module.exports = defaults = {
    thisValue: null,
    global: {
      Math: Math,
      parseInt: parseInt,
      parseFloat: parseFloat,
      "eval": eval,
      isNaN: isNaN,
      escape: escape,
      unescape: unescape
    },
    language: "javascript",
    languageVersion: "ES5",
    functionName: null,
    functionParameters: [],
    yieldAutomatically: false,
    yieldConditionally: false,
    requiresThis: true,
    executionCosts: execution,
    includeFlow: true,
    includeMetrics: true,
    includeStyle: true,
    includeVisualization: false,
    protectAPI: false
  };

}).call(this);

},{"./execution":3}],3:[function(require,module,exports){
(function() {
  var execution;

  module.exports = execution = {
    ArrayExpression: 1,
    ArrayPattern: 1,
    ArrowFunctionExpression: 1,
    AssignmentExpression: 1,
    BinaryExpression: 1,
    BlockStatement: 1,
    BreakStatement: 1,
    CallExpression: 1,
    CatchClause: 1,
    ClassBody: 1,
    ClassDeclaration: 1,
    ClassExpression: 1,
    ClassHeritage: 1,
    ComprehensionBlock: 1,
    ComprehensionExpression: 1,
    ConditionalExpression: 1,
    ContinueStatement: 1,
    DebuggerStatement: 1,
    DoWhileStatement: 1,
    EmptyStatement: 1,
    ExportDeclaration: 1,
    ExportBatchSpecifier: 1,
    ExportSpecifier: 1,
    ExpressionStatement: 1,
    ForInStatement: 1,
    ForOfStatement: 1,
    ForStatement: 1,
    FunctionDeclaration: 1,
    FunctionExpression: 1,
    Identifier: 1,
    IfStatement: 1,
    ImportDeclaration: 1,
    ImportSpecifier: 1,
    LabeledStatement: 1,
    Literal: 1,
    LogicalExpression: 1,
    MemberExpression: 1,
    MethodDefinition: 1,
    ModuleDeclaration: 1,
    NewExpression: 1,
    ObjectExpression: 1,
    ObjectPattern: 1,
    Program: 1,
    Property: 1,
    ReturnStatement: 1,
    SequenceExpression: 1,
    SpreadElement: 1,
    SwitchCase: 1,
    SwitchStatement: 1,
    TaggedTemplateExpression: 1,
    TemplateElement: 1,
    TemplateLiteral: 1,
    ThisExpression: 1,
    ThrowStatement: 1,
    TryStatement: 1,
    UnaryExpression: 1,
    UpdateExpression: 1,
    VariableDeclaration: 1,
    VariableDeclarator: 1,
    WhileStatement: 1,
    WithStatement: 1,
    YieldExpression: 1
  };

}).call(this);

},{}],4:[function(require,module,exports){
(function (global){(function() {
  var StructuredCode, estraverse, fixLocations, _, _ref, _ref1, _ref2;

  _ = (_ref = (_ref1 = (_ref2 = typeof window !== "undefined" && window !== null ? window._ : void 0) != null ? _ref2 : typeof self !== "undefined" && self !== null ? self._ : void 0) != null ? _ref1 : typeof global !== "undefined" && global !== null ? global._ : void 0) != null ? _ref : require('lodash');

  estraverse = require('estraverse');

  StructuredCode = (function() {
    function StructuredCode(code) {
      this.cursors = this.generateOffsets(code);
      this.length = this.cursors.length;
    }

    StructuredCode.prototype.generateOffsets = function(code) {
      var cursor, reg, res, result;
      reg = /(?:\r\n|[\r\n\u2028\u2029])/g;
      result = [0];
      while (res = reg.exec(code)) {
        cursor = res.index + res[0].length;
        reg.lastIndex = cursor;
        result.push(cursor);
      }
      return result;
    };

    StructuredCode.prototype.column = function(offset) {
      return this.loc(offset).column;
    };

    StructuredCode.prototype.line = function(offset) {
      return this.loc(offset).line;
    };

    StructuredCode.prototype.loc = function(offset) {
      var column, index, line;
      index = _.sortedIndex(this.cursors, offset);
      if (this.cursors.length > index && this.cursors[index] === offset) {
        column = 0;
        line = index + 1;
      } else {
        column = offset - this.cursors[index - 1];
        line = index;
      }
      return {
        column: column,
        line: line
      };
    };

    return StructuredCode;

  })();

  module.exports = fixLocations = function(program) {
    var structured;
    structured = new StructuredCode(program.raw);
    return estraverse.traverse(program, {
      leave: function(node, parent) {
        var loc;
        if (node.range != null) {
          loc = {
            start: null,
            end: structured.loc(node.range[1])
          };
          if (node.loc != null) {
            loc.start = node.loc.start;
          } else {
            loc.start = structured.loc(node.range[0]);
          }
          node.loc = loc;
        } else {
          node.loc = (function() {
            var _ref3;
            switch (node.type) {
              case 'BlockStatement':
                return {
                  start: node.body[0].loc.start,
                  end: node.body[node.body.length - 1].loc.end
                };
              case 'VariableDeclarator':
                if ((node != null ? (_ref3 = node.init) != null ? _ref3.loc : void 0 : void 0) != null) {
                  return {
                    start: node.id.loc.start,
                    end: node.init.loc.end
                  };
                } else {
                  return node.id.loc;
                }
                break;
              case 'ExpressionStatement':
                return node.expression.loc;
              case 'ReturnStatement':
                if (node.argument != null) {
                  return node.argument.loc;
                } else {
                  return node.loc;
                }
                break;
              case 'VariableDeclaration':
                return {
                  start: node.declarations[0].loc.start,
                  end: node.declarations[node.declarations.length - 1].loc.end
                };
              default:
                return {
                  start: {
                    line: 0,
                    column: 0
                  },
                  end: {
                    line: 0,
                    column: 0
                  }
                };
            }
          })();
        }
      }
    });
  };

}).call(this);
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"estraverse":55,"lodash":56}],5:[function(require,module,exports){
(function (global){(function() {
  var logCallEnd, logCallStart, logStatement, logStatementStart, serializeVariableValue, _, _ref, _ref1, _ref2,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = (_ref = (_ref1 = (_ref2 = typeof window !== "undefined" && window !== null ? window._ : void 0) != null ? _ref2 : typeof self !== "undefined" && self !== null ? self._ : void 0) != null ? _ref1 : typeof global !== "undefined" && global !== null ? global._ : void 0) != null ? _ref : require('lodash');

  serializeVariableValue = function(value, depth) {
    var brackets, isArray, key, max, size, v, values;
    if (depth == null) {
      depth = 0;
    }
    if (!value) {
      return value;
    }
    if (_.isFunction(value)) {
      return "<Function>";
    }
    if (value.__aetherAPIValue) {
      value = value.__aetherAPIValue;
    }
    if (!depth && value.serializeForAether) {
      return value.serializeForAether();
    }
    isArray = _.isArray(value);
    if (isArray || _.isPlainObject(value)) {
      brackets = isArray ? ["[", "]"] : ["{", "}"];
      size = _.size(value);
      if (!size) {
        return brackets.join("");
      }
      if (depth > 0) {
        return "" + brackets[0] + "... " + size + " items ..." + brackets[1];
      }
      max = 5;
      values = [];
      if (isArray) {
        values = (function() {
          var _i, _len, _ref3, _results;
          _ref3 = value.slice(0, max);
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            v = _ref3[_i];
            _results.push("" + serializeVariableValue(v, depth + 1));
          }
          return _results;
        })();
      } else {
        for (key in value) {
          v = value[key];
          if (values.length > max) {
            break;
          }
          values.push(key + ": " + serializeVariableValue(v, depth + 1));
        }
      }
      if (size > max) {
        values.push("(... " + (size - max) + " more)");
      }
      return "" + brackets[0] + "\n  " + (values.join('\n  ')) + "\n" + brackets[1];
    } else if (value.toString) {
      return value.toString();
    }
    return value;
  };

  module.exports.logStatementStart = logStatementStart = function(lastStatementRange) {
    this.lastStatementRange = lastStatementRange;
  };

  module.exports.logStatement = logStatement = function(range, source, userInfo) {
    var call, capture, flopt, m, name, state, value, variables, _base, _base1, _base2, _base3, _name, _ref3, _ref4;
    this.lastStatementRange = null;
    if (this.options.includeMetrics) {
      m = (_base = ((_base1 = this.metrics).statements != null ? (_base1 = this.metrics).statements : _base1.statements = {}))[_name = range[0].ofs + "-" + range[1].ofs] != null ? (_base = ((_base2 = this.metrics).statements != null ? (_base2 = this.metrics).statements : _base2.statements = {}))[_name = range[0].ofs + "-" + range[1].ofs] : _base[_name] = {
        source: source
      };
      if (m.executions == null) {
        m.executions = 0;
      }
      ++m.executions;
      if ((_base3 = this.metrics).statementsExecuted == null) {
        _base3.statementsExecuted = 0;
      }
      this.metrics.statementsExecuted += 1;
    }
    if (flopt = this.options.includeFlow) {
      call = _.last(this.callStack);
      ++call.statementsExecuted;
      capture = true;
      if ((flopt.callIndex != null) && flopt.callIndex !== this.flow.states.length - 1) {
        capture = false;
      }
      if ((flopt.statementIndex != null) && flopt.statementIndex !== call.statementsExecuted) {
        capture = false;
      }
      variables = {};
      _ref3 = this.vars;
      for (name in _ref3) {
        value = _ref3[name];
        if (capture || __indexOf.call((_ref4 = flopt.timelessVariables) != null ? _ref4 : [], name) >= 0) {
          variables[name] = serializeVariableValue(value);
        }
      }
      if (capture || !_.isEmpty(variables)) {
        state = {
          range: range,
          source: source,
          variables: variables,
          userInfo: _.cloneDeep(userInfo)
        };
        return call.statements.push(state);
      }
    }
  };

  module.exports.logCallStart = logCallStart = function(userInfo) {
    var call, _base, _base1;
    if (this.vars == null) {
      this.vars = {};
    }
    call = {
      statementsExecuted: 0,
      statements: [],
      userInfo: _.cloneDeep(userInfo)
    };
    (this.callStack != null ? this.callStack : this.callStack = []).push(call);
    if (this.options.includeMetrics) {
      if ((_base = this.metrics).callsExecuted == null) {
        _base.callsExecuted = 0;
      }
      ++this.metrics.callsExecuted;
      this.metrics.maxDepth = Math.max(this.metrics.maxDepth || 0, this.callStack.length);
    }
    if (this.options.includeFlow) {
      if (this.callStack.length === 1) {
        return ((_base1 = (this.flow != null ? this.flow : this.flow = {})).states != null ? (_base1 = (this.flow != null ? this.flow : this.flow = {})).states : _base1.states = []).push(call);
      } else {
        return 3;
      }
    }
  };

  module.exports.logCallEnd = logCallEnd = function() {
    return this.callStack.pop();
  };

}).call(this);
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"lodash":56}],6:[function(require,module,exports){
(function (global){(function() {
  var acorn_loose, csredux, esprima, fixLocations, insertHelpers, morph, _, _ref, _ref1, _ref2;

  _ = (_ref = (_ref1 = (_ref2 = typeof window !== "undefined" && window !== null ? window._ : void 0) != null ? _ref2 : typeof self !== "undefined" && self !== null ? self._ : void 0) != null ? _ref1 : typeof global !== "undefined" && global !== null ? global._ : void 0) != null ? _ref : require('lodash');

  esprima = require('esprima');

  acorn_loose = require('acorn/acorn_loose');

  csredux = require('coffee-script-redux');

  fixLocations = require('./fixLocations');

  module.exports = morph = function(source, transforms, parser) {
    var ast, chunks, csAST, lines, locToRange, posToOffset, walk;
    if (parser == null) {
      parser = "esprima";
    }
    chunks = source.split('');
    locToRange = null;
    if (parser === 'esprima') {
      ast = esprima.parse(source, {
        range: true,
        loc: true
      });
    } else if (parser === 'csredux') {
      csAST = csredux.parse(source, {
        optimise: false,
        raw: true
      });
      ast = csredux.compile(csAST, {
        bare: true
      });
      fixLocations(ast);
    } else if (parser === 'acorn_loose') {
      ast = acorn_loose.parse_dammit(source, {
        locations: true
      });
      lines = source.replace(/\n/g, '\n空').split('空');
      posToOffset = function(pos) {
        return _.reduce(lines.slice(0, pos.line - 1), (function(sum, line) {
          return sum + line.length;
        }), 0) + pos.column;
      };
      locToRange = function(loc) {
        return [posToOffset(loc.start), posToOffset(loc.end)];
      };
    }
    walk = function(node, parent) {
      var child, grandchild, key, transform, _i, _j, _len, _len1, _results;
      insertHelpers(node, parent, chunks, locToRange);
      for (key in node) {
        child = node[key];
        if (key === 'parent' || key === 'leadingComments') {
          continue;
        }
        if (_.isArray(child)) {
          for (_i = 0, _len = child.length; _i < _len; _i++) {
            grandchild = child[_i];
            if (_.isString(grandchild != null ? grandchild.type : void 0)) {
              walk(grandchild, node);
            }
          }
        } else if (_.isString(child != null ? child.type : void 0)) {
          walk(child, node);
        }
      }
      _results = [];
      for (_j = 0, _len1 = transforms.length; _j < _len1; _j++) {
        transform = transforms[_j];
        _results.push(transform(node));
      }
      return _results;
    };
    walk(ast, void 0);
    return chunks.join('');
  };

  insertHelpers = function(node, parent, chunks, locToRange) {
    var update;
    if (node.loc && locToRange) {
      node.range = locToRange(node.loc);
    }
    if (!node.range) {
      return;
    }
    node.parent = parent;
    node.source = function() {
      return chunks.slice(node.range[0], node.range[1]).join('');
    };
    update = function(s) {
      var i, _i, _ref3, _ref4, _results;
      chunks[node.range[0]] = s;
      _results = [];
      for (i = _i = _ref3 = node.range[0] + 1, _ref4 = node.range[1]; _ref3 <= _ref4 ? _i < _ref4 : _i > _ref4; i = _ref3 <= _ref4 ? ++_i : --_i) {
        _results.push(chunks[i] = '');
      }
      return _results;
    };
    if (_.isObject(node.update)) {
      _.extend(update, node.update);
    }
    return node.update = update;
  };

}).call(this);
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./fixLocations":4,"acorn/acorn_loose":21,"coffee-script-redux":26,"esprima":54,"lodash":56}],7:[function(require,module,exports){
(function() {
  var RuntimeProblem, TranspileProblem, UserCodeProblem, commonMethods, problems, ranges,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ranges = require('./ranges');

  module.exports.UserCodeProblem = UserCodeProblem = (function() {
    function UserCodeProblem(aether, reporter, kind) {
      var config, _ref;
      if (reporter == null) {
        reporter = 'unknown';
      }
      if (kind == null) {
        kind = "Unknown";
      }
      this.id = reporter + "_" + kind;
      config = (_ref = aether.options.problems[this.id]) != null ? _ref : {
        message: "Unknown problem",
        level: "error"
      };
      this.message = config.message;
      this.hint = config.hint;
      this.level = config.level;
    }

    UserCodeProblem.prototype.serialize = function() {
      var key, o, value;
      o = {};
      for (key in this) {
        if (!__hasProp.call(this, key)) continue;
        value = this[key];
        o[key] = value;
      }
      return o;
    };

    return UserCodeProblem;

  })();

  module.exports.TranspileProblem = TranspileProblem = (function(_super) {
    __extends(TranspileProblem, _super);

    function TranspileProblem(aether, reporter, kind, error, userInfo, code, codePrefix) {
      var endCol, line, lineOffset, originalLines, startCol, _ref, _ref1;
      this.userInfo = userInfo;
      if (code == null) {
        code = '';
      }
      if (codePrefix == null) {
        codePrefix = "function wrapped() {\n\"use strict\";\n";
      }
      TranspileProblem.__super__.constructor.call(this, aether, reporter, kind);
      this.type = 'transpile';
      if (this.userInfo == null) {
        this.userInfo = {};
      }
      if (code == null) {
        code = this.raw;
      }
      originalLines = code.slice(codePrefix.length).split('\n');
      lineOffset = codePrefix.split('\n').length - 1;
      switch (reporter) {
        case 'jshint':
          if (error == null) {
            error = {
              reason: "Unknown problem"
            };
          }
          this.message = error.reason;
          line = error.line - codePrefix.split('\n').length;
          if (line >= 0) {
            if ((_ref = error.evidence) != null ? _ref.length : void 0) {
              startCol = originalLines[line].indexOf(error.evidence);
              endCol = startCol + error.evidence.length;
            } else {
              _ref1 = [0, originalLines[line].length - 1], startCol = _ref1[0], endCol = _ref1[1];
            }
            this.ranges = [[ranges.rowColToPos(line, startCol, code, codePrefix), ranges.rowColToPos(line, endCol, code, codePrefix)]];
          } else {
            this.ranges = [[ranges.offsetToPos(0, code, codePrefix), ranges.offsetToPos(code.length - 1, code, codePrefix)]];
          }
          break;
        case 'esprima':
          this.message = error.message;
          this.ranges = [[ranges.rowColToPos(error.lineNumber - 1 - lineOffset, error.column - 1, code, codePrefix), ranges.rowColToPos(error.lineNumber - 1 - lineOffset, error.column, code, codePrefix)]];
          break;
        case 'aether':
          if (error.message) {
            this.message = error.message;
          }
          break;
        default:
          console.log("Unhandled UserCodeProblem reporter", reporter);
          if (error.message) {
            this.message = error.message;
          }
      }
    }

    return TranspileProblem;

  })(UserCodeProblem);

  module.exports.RuntimeProblem = RuntimeProblem = (function(_super) {
    __extends(RuntimeProblem, _super);

    function RuntimeProblem(aether, error, userInfo) {
      var kind, lineNumber, range, _ref;
      this.userInfo = userInfo;
      kind = error.name;
      RuntimeProblem.__super__.constructor.call(this, aether, 'runtime', kind);
      this.type = 'runtime';
      if (this.userInfo == null) {
        this.userInfo = {};
      }
      this.message = RuntimeProblem.explainErrorMessage(error);
      if (range = aether.lastStatementRange) {
        this.ranges = [range];
      }
      if ((_ref = this.ranges) != null ? _ref.length : void 0) {
        lineNumber = this.ranges[0][0].row + 1;
        if (this.message.search(/^Line \d+/) !== -1) {
          this.message = this.message.replace(/^Line \d+/, function(match, n) {
            return "Line " + lineNumber;
          });
        } else {
          this.message = "Line " + lineNumber + ": " + this.message;
        }
      }
    }

    RuntimeProblem.explainErrorMessage = function(error) {
      var closestMatch, closestMatchScore, commonMethod, explained, m, matchScore, method, missingMethodMatch, _i, _len, _ref, _ref1;
      m = error.toString();
      if (m === "RangeError: Maximum call stack size exceeded") {
        m += ". (Did you use call a function recursively?)";
      }
      missingMethodMatch = m.match(/has no method '(.*?)'/);
      if (missingMethodMatch) {
        method = missingMethodMatch[1];
        _ref = ['Murgatroyd Kerfluffle', 0], closestMatch = _ref[0], closestMatchScore = _ref[1];
        explained = false;
        for (_i = 0, _len = commonMethods.length; _i < _len; _i++) {
          commonMethod = commonMethods[_i];
          if (method === commonMethod) {
            m += ". (" + missingMethodMatch[1] + " not available in this challenge.)";
            explained = true;
            break;
          } else if (method.toLowerCase() === commonMethod.toLowerCase()) {
            m = "" + method + " should be " + commonMethod + " because JavaScript is case-sensitive.";
            explained = true;
            break;
          } else {
            matchScore = typeof string_score !== "undefined" && string_score !== null ? string_score.score(commonMethod, method, 0.5) : void 0;
            if (matchScore > closestMatchScore) {
              _ref1 = [commonMethod, matchScore], closestMatch = _ref1[0], closestMatchScore = _ref1[1];
            }
          }
        }
        if (!explained) {
          if (closestMatchScore > 0.25) {
            m += ". (Did you mean " + closestMatch + "?)";
          }
        }
        m = m.replace('TypeError:', 'Error:');
      }
      return m;
    };

    return RuntimeProblem;

  })(UserCodeProblem);

  module.exports.commonMethods = commonMethods = ['moveRight', 'moveLeft', 'moveUp', 'moveDown', 'attackNearbyEnemy', 'say', 'move', 'attackNearestEnemy', 'shootAt', 'rotateTo', 'shoot', 'distance', 'getNearestEnemy', 'getEnemies', 'attack', 'setAction', 'setTarget', 'getFriends', 'patrol'];

  module.exports.problems = problems = {
    unknown_Unknown: {
      message: "Unknown problem.",
      level: "error"
    },
    esprima_UnexpectedToken: {
      message: 'Unexpected token %0',
      level: "error"
    },
    esprima_UnexpectedNumber: {
      message: 'Unexpected number',
      level: "error"
    },
    esprima_UnexpectedString: {
      message: 'Unexpected string',
      level: "error"
    },
    esprima_UnexpectedIdentifier: {
      message: 'Unexpected identifier',
      level: "error"
    },
    esprima_UnexpectedReserved: {
      message: 'Unexpected reserved word',
      level: "error"
    },
    esprima_UnexpectedTemplate: {
      message: 'Unexpected quasi %0',
      level: "error"
    },
    esprima_UnexpectedEOS: {
      message: 'Unexpected end of input',
      level: "error"
    },
    esprima_NewlineAfterThrow: {
      message: 'Illegal newline after throw',
      level: "error"
    },
    esprima_InvalidRegExp: {
      message: 'Invalid regular expression',
      level: "error"
    },
    esprima_UnterminatedRegExp: {
      message: 'Invalid regular expression: missing /',
      level: "error"
    },
    esprima_InvalidLHSInAssignment: {
      message: 'Invalid left-hand side in assignment',
      level: "error"
    },
    esprima_InvalidLHSInFormalsList: {
      message: 'Invalid left-hand side in formals list',
      level: "error"
    },
    esprima_InvalidLHSInForIn: {
      message: 'Invalid left-hand side in for-in',
      level: "error"
    },
    esprima_MultipleDefaultsInSwitch: {
      message: 'More than one default clause in switch statement',
      level: "error"
    },
    esprima_NoCatchOrFinally: {
      message: 'Missing catch or finally after try',
      level: "error"
    },
    esprima_UnknownLabel: {
      message: 'Undefined label \'%0\'',
      level: "error"
    },
    esprima_Redeclaration: {
      message: '%0 \'%1\' has already been declared',
      level: "error"
    },
    esprima_IllegalContinue: {
      message: 'Illegal continue statement',
      level: "error"
    },
    esprima_IllegalBreak: {
      message: 'Illegal break statement',
      level: "error"
    },
    esprima_IllegalDuplicateClassProperty: {
      message: 'Illegal duplicate property in class definition',
      level: "error"
    },
    esprima_IllegalReturn: {
      message: 'Illegal return statement',
      level: "error"
    },
    esprima_IllegalYield: {
      message: 'Illegal yield expression',
      level: "error"
    },
    esprima_IllegalSpread: {
      message: 'Illegal spread element',
      level: "error"
    },
    esprima_StrictModeWith: {
      message: 'Strict mode code may not include a with statement',
      level: "error"
    },
    esprima_StrictCatchVariable: {
      message: 'Catch variable may not be eval or arguments in strict mode',
      level: "error"
    },
    esprima_StrictVarName: {
      message: 'Variable name may not be eval or arguments in strict mode',
      level: "error"
    },
    esprima_StrictParamName: {
      message: 'Parameter name eval or arguments is not allowed in strict mode',
      level: "error"
    },
    esprima_StrictParamDupe: {
      message: 'Strict mode function may not have duplicate parameter names',
      level: "error"
    },
    esprima_ParameterAfterRestParameter: {
      message: 'Rest parameter must be final parameter of an argument list',
      level: "error"
    },
    esprima_DefaultRestParameter: {
      message: 'Rest parameter can not have a default value',
      level: "error"
    },
    esprima_ElementAfterSpreadElement: {
      message: 'Spread must be the final element of an element list',
      level: "error"
    },
    esprima_ObjectPatternAsRestParameter: {
      message: 'Invalid rest parameter',
      level: "error"
    },
    esprima_ObjectPatternAsSpread: {
      message: 'Invalid spread argument',
      level: "error"
    },
    esprima_StrictFunctionName: {
      message: 'Function name may not be eval or arguments in strict mode',
      level: "error"
    },
    esprima_StrictOctalLiteral: {
      message: 'Octal literals are not allowed in strict mode.',
      level: "error"
    },
    esprima_StrictDelete: {
      message: 'Delete of an unqualified identifier in strict mode.',
      level: "error"
    },
    esprima_StrictDuplicateProperty: {
      message: 'Duplicate data property in object literal not allowed in strict mode',
      level: "error"
    },
    esprima_AccessorDataProperty: {
      message: 'Object literal may not have data and accessor property with the same name',
      level: "error"
    },
    esprima_AccessorGetSet: {
      message: 'Object literal may not have multiple get/set accessors with the same name',
      level: "error"
    },
    esprima_StrictLHSAssignment: {
      message: 'Assignment to eval or arguments is not allowed in strict mode',
      level: "error"
    },
    esprima_StrictLHSPostfix: {
      message: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
      level: "error"
    },
    esprima_StrictLHSPrefix: {
      message: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
      level: "error"
    },
    esprima_StrictReservedWord: {
      message: 'Use of future reserved word in strict mode',
      level: "error"
    },
    esprima_NewlineAfterModule: {
      message: 'Illegal newline after module',
      level: "error"
    },
    esprima_NoFromAfterImport: {
      message: 'Missing from after import',
      level: "error"
    },
    esprima_InvalidModuleSpecifier: {
      message: 'Invalid module specifier',
      level: "error"
    },
    esprima_NestedModule: {
      message: 'Module declaration can not be nested',
      level: "error"
    },
    esprima_NoYieldInGenerator: {
      message: 'Missing yield in generator',
      level: "error"
    },
    esprima_NoUnintializedConst: {
      message: 'Const must be initialized',
      level: "error"
    },
    esprima_ComprehensionRequiresBlock: {
      message: 'Comprehension must have at least one block',
      level: "error"
    },
    esprima_ComprehensionError: {
      message: 'Comprehension Error',
      level: "error"
    },
    esprima_EachNotAllowed: {
      message: 'Each is not supported',
      level: "error"
    },
    aether_UnexpectedIdentifier: {
      message: 'UnexpectedIdentifier',
      level: 'error'
    },
    aether_MissingVarKeyword: {
      message: 'MissingVarKeyword',
      level: 'error'
    },
    aether_UndefinedVariable: {
      message: 'UndefinedVariable',
      level: 'error'
    },
    aether_MissingThis: {
      message: 'Missing `this.` keyword.',
      level: 'error'
    },
    aether_IncompleteThis: {
      message: 'this.what?',
      level: 'error'
    },
    aether_Untranspilable: {
      message: 'Code could not be compiled. Check syntax.',
      level: 'error'
    },
    aether_NoEffect: {
      message: 'Statement has no effect.',
      level: 'warning'
    },
    aether_FalseBlockIndentation: {
      message: 'FalseBlockIndentation',
      level: 'warning'
    },
    aether_UndefinedProperty: {
      message: 'UndefinedProperty',
      level: 'warning'
    },
    aether_InconsistentIndentation: {
      message: 'InconsistentIndentation',
      level: 'info'
    },
    aether_SnakeCase: {
      message: 'SnakeCase',
      level: 'info'
    },
    aether_SingleQuotes: {
      message: 'SingleQuotes',
      level: "ignore"
    },
    aether_DoubleQuotes: {
      message: 'DoubleQuotes',
      level: "ignore"
    },
    aether_CamelCase: {
      message: 'CamelCase',
      level: 'ignore'
    },
    jshint_E001: {
      message: "Bad option: '{a}'.",
      level: "error"
    },
    jshint_E002: {
      message: "Bad option value.",
      level: "error"
    },
    jshint_E003: {
      message: "Expected a JSON value.",
      level: "error"
    },
    jshint_E004: {
      message: "Input is neither a string nor an array of strings.",
      level: "error"
    },
    jshint_E005: {
      message: "Input is empty.",
      level: "error"
    },
    jshint_E006: {
      message: "Unexpected early end of program.",
      level: "error"
    },
    jshint_E007: {
      message: "Missing \"use strict\" statement.",
      level: "error"
    },
    jshint_E008: {
      message: "Strict violation.",
      level: "error"
    },
    jshint_E009: {
      message: "Option 'validthis' can't be used in a global scope.",
      level: "error"
    },
    jshint_E010: {
      message: "'with' is not allowed in strict mode.",
      level: "error"
    },
    jshint_E011: {
      message: "const '{a}' has already been declared.",
      level: "error"
    },
    jshint_E012: {
      message: "const '{a}' is initialized to 'undefined'.",
      level: "error"
    },
    jshint_E013: {
      message: "Attempting to override '{a}' which is a constant.",
      level: "error"
    },
    jshint_E014: {
      message: "A regular expression literal can be confused with '/='.",
      level: "error"
    },
    jshint_E015: {
      message: "Unclosed regular expression.",
      level: "error"
    },
    jshint_E016: {
      message: "Invalid regular expression.",
      level: "error"
    },
    jshint_E017: {
      message: "Unclosed comment.",
      level: "error"
    },
    jshint_E018: {
      message: "Unbegun comment.",
      level: "error"
    },
    jshint_E019: {
      message: "Unmatched '{a}'.",
      level: "error"
    },
    jshint_E020: {
      message: "Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.",
      level: "error"
    },
    jshint_E021: {
      message: "Expected '{a}' and instead saw '{b}'.",
      level: "error"
    },
    jshint_E022: {
      message: "Line breaking error '{a}'.",
      level: "error"
    },
    jshint_E023: {
      message: "Missing '{a}'.",
      level: "error"
    },
    jshint_E024: {
      message: "Unexpected '{a}'.",
      level: "error"
    },
    jshint_E025: {
      message: "Missing ':' on a case clause.",
      level: "error"
    },
    jshint_E026: {
      message: "Missing '}' to match '{' from line {a}.",
      level: "error"
    },
    jshint_E027: {
      message: "Missing ']' to match '[' form line {a}.",
      level: "error"
    },
    jshint_E028: {
      message: "Illegal comma.",
      level: "error"
    },
    jshint_E029: {
      message: "Unclosed string.",
      level: "error"
    },
    jshint_E030: {
      message: "Expected an identifier and instead saw '{a}'.",
      level: "error"
    },
    jshint_E031: {
      message: "Bad assignment.",
      level: "error"
    },
    jshint_E032: {
      message: "Expected a small integer or 'false' and instead saw '{a}'.",
      level: "error"
    },
    jshint_E033: {
      message: "Expected an operator and instead saw '{a}'.",
      level: "error"
    },
    jshint_E034: {
      message: "get/set are ES5 features.",
      level: "error"
    },
    jshint_E035: {
      message: "Missing property name.",
      level: "error"
    },
    jshint_E036: {
      message: "Expected to see a statement and instead saw a block.",
      level: "error"
    },
    jshint_E039: {
      message: "Function declarations are not invocable. Wrap the whole function invocation in parens.",
      level: "error"
    },
    jshint_E040: {
      message: "Each value should have its own case label.",
      level: "error"
    },
    jshint_E041: {
      message: "Unrecoverable syntax error.",
      level: "error"
    },
    jshint_E042: {
      message: "Stopping.",
      level: "error"
    },
    jshint_E043: {
      message: "Too many errors.",
      level: "error"
    },
    jshint_E044: {
      message: "'{a}' is already defined and can't be redefined.",
      level: "error"
    },
    jshint_E045: {
      message: "Invalid for each loop.",
      level: "error"
    },
    jshint_E046: {
      message: "A yield statement shall be within a generator function (with syntax: `function*`)",
      level: "error"
    },
    jshint_E047: {
      message: "A generator function shall contain a yield statement.",
      level: "error"
    },
    jshint_E048: {
      message: "Let declaration not directly within block.",
      level: "error"
    },
    jshint_E049: {
      message: "A {a} cannot be named '{b}'.",
      level: "error"
    },
    jshint_E050: {
      message: "Mozilla requires the yield expression to be parenthesized here.",
      level: "error"
    },
    jshint_E051: {
      message: "Regular parameters cannot come after default parameters.",
      level: "error"
    },
    jshint_W001: {
      message: "'hasOwnProperty' is a really bad name.",
      level: "warning"
    },
    jshint_W002: {
      message: "Value of '{a}' may be overwritten in IE 8 and earlier.",
      level: "warning"
    },
    jshint_W003: {
      message: "'{a}' was used before it was defined.",
      level: "warning"
    },
    jshint_W004: {
      message: "'{a}' is already defined.",
      level: "warning"
    },
    jshint_W005: {
      message: "A dot following a number can be confused with a decimal point.",
      level: "warning"
    },
    jshint_W006: {
      message: "Confusing minuses.",
      level: "warning"
    },
    jshint_W007: {
      message: "Confusing pluses.",
      level: "warning"
    },
    jshint_W008: {
      message: "A leading decimal point can be confused with a dot: '{a}'.",
      level: "warning"
    },
    jshint_W009: {
      message: "The array literal notation [] is preferrable.",
      level: "warning"
    },
    jshint_W010: {
      message: "The object literal notation {} is preferrable.",
      level: "warning"
    },
    jshint_W011: {
      message: "Unexpected space after '{a}'.",
      level: "warning"
    },
    jshint_W012: {
      message: "Unexpected space before '{a}'.",
      level: "warning"
    },
    jshint_W013: {
      message: "Missing space after '{a}'.",
      level: "warning"
    },
    jshint_W014: {
      message: "Bad line breaking before '{a}'.",
      level: "warning"
    },
    jshint_W015: {
      message: "Expected '{a}' to have an indentation at {b} instead at {c}.",
      level: "warning"
    },
    jshint_W016: {
      message: "Unexpected use of '{a}'.",
      level: "warning"
    },
    jshint_W017: {
      message: "Bad operand.",
      level: "warning"
    },
    jshint_W018: {
      message: "Confusing use of '{a}'.",
      level: "warning"
    },
    jshint_W019: {
      message: "Use the isNaN function to compare with NaN.",
      level: "warning"
    },
    jshint_W020: {
      message: "Read only.",
      level: "warning"
    },
    jshint_W021: {
      message: "'{a}' is a function.",
      level: "warning"
    },
    jshint_W022: {
      message: "Do not assign to the exception parameter.",
      level: "warning"
    },
    jshint_W023: {
      message: "Expected an identifier in an assignment and instead saw a function invocation.",
      level: "warning"
    },
    jshint_W024: {
      message: "Expected an identifier and instead saw '{a}' (a reserved word).",
      level: "warning"
    },
    jshint_W025: {
      message: "Missing name in function declaration.",
      level: "warning"
    },
    jshint_W026: {
      message: "Inner functions should be listed at the top of the outer function.",
      level: "warning"
    },
    jshint_W027: {
      message: "Unreachable '{a}' after '{b}'.",
      level: "warning"
    },
    jshint_W028: {
      message: "Label '{a}' on {b} statement.",
      level: "warning"
    },
    jshint_W030: {
      message: "Expected an assignment or function call and instead saw an expression.",
      level: "warning"
    },
    jshint_W031: {
      message: "Do not use 'new' for side effects.",
      level: "warning"
    },
    jshint_W032: {
      message: "Unnecessary semicolon.",
      level: "warning"
    },
    jshint_W033: {
      message: "Missing semicolon.",
      level: "warning"
    },
    jshint_W034: {
      message: "Unnecessary directive \"{a}\".",
      level: "warning"
    },
    jshint_W035: {
      message: "Empty block.",
      level: "warning"
    },
    jshint_W036: {
      message: "Unexpected /*member '{a}'.",
      level: "warning"
    },
    jshint_W037: {
      message: "'{a}' is a statement label.",
      level: "warning"
    },
    jshint_W038: {
      message: "'{a}' used out of scope.",
      level: "warning"
    },
    jshint_W039: {
      message: "'{a}' is not allowed.",
      level: "warning"
    },
    jshint_W040: {
      message: "Possible strict violation.",
      level: "warning"
    },
    jshint_W041: {
      message: "Use '{a}' to compare with '{b}'.",
      level: "warning"
    },
    jshint_W042: {
      message: "Avoid EOL escaping.",
      level: "warning"
    },
    jshint_W043: {
      message: "Bad escaping of EOL. Use option multistr if needed.",
      level: "warning"
    },
    jshint_W044: {
      message: "Bad or unnecessary escaping.",
      level: "warning"
    },
    jshint_W045: {
      message: "Bad number '{a}'.",
      level: "warning"
    },
    jshint_W046: {
      message: "Don't use extra leading zeros '{a}'.",
      level: "warning"
    },
    jshint_W047: {
      message: "A trailing decimal point can be confused with a dot: '{a}'.",
      level: "warning"
    },
    jshint_W048: {
      message: "Unexpected control character in regular expression.",
      level: "warning"
    },
    jshint_W049: {
      message: "Unexpected escaped character '{a}' in regular expression.",
      level: "warning"
    },
    jshint_W050: {
      message: "JavaScript URL.",
      level: "warning"
    },
    jshint_W051: {
      message: "Variables should not be deleted.",
      level: "warning"
    },
    jshint_W052: {
      message: "Unexpected '{a}'.",
      level: "warning"
    },
    jshint_W053: {
      message: "Do not use {a} as a constructor.",
      level: "warning"
    },
    jshint_W054: {
      message: "The Function constructor is a form of eval.",
      level: "warning"
    },
    jshint_W055: {
      message: "A constructor name should start with an uppercase letter.",
      level: "warning"
    },
    jshint_W056: {
      message: "Bad constructor.",
      level: "warning"
    },
    jshint_W057: {
      message: "Weird construction. Is 'new' unnecessary?",
      level: "warning"
    },
    jshint_W058: {
      message: "Missing '()' invoking a constructor.",
      level: "warning"
    },
    jshint_W059: {
      message: "Avoid arguments.{a}.",
      level: "warning"
    },
    jshint_W060: {
      message: "document.write can be a form of eval.",
      level: "warning"
    },
    jshint_W061: {
      message: "eval can be harmful.",
      level: "warning"
    },
    jshint_W062: {
      message: "Wrap an immediate function invocation in parens to assist the reader in understanding that the expression is the result of a function, and not the function itself.",
      level: "warning"
    },
    jshint_W063: {
      message: "Math is not a function.",
      level: "warning"
    },
    jshint_W064: {
      message: "Missing 'new' prefix when invoking a constructor.",
      level: "warning"
    },
    jshint_W065: {
      message: "Missing radix parameter.",
      level: "warning"
    },
    jshint_W066: {
      message: "Implied eval. Consider passing a function instead of a string.",
      level: "warning"
    },
    jshint_W067: {
      message: "Bad invocation.",
      level: "warning"
    },
    jshint_W068: {
      message: "Wrapping non-IIFE function literals in parens is unnecessary.",
      level: "warning"
    },
    jshint_W069: {
      message: "['{a}'] is better written in dot notation.",
      level: "warning"
    },
    jshint_W070: {
      message: "Extra comma. (it breaks older versions of IE)",
      level: "warning"
    },
    jshint_W071: {
      message: "This function has too many statements. ({a})",
      level: "warning"
    },
    jshint_W072: {
      message: "This function has too many parameters. ({a})",
      level: "warning"
    },
    jshint_W073: {
      message: "Blocks are nested too deeply. ({a})",
      level: "warning"
    },
    jshint_W074: {
      message: "This function's cyclomatic complexity is too high. ({a})",
      level: "warning"
    },
    jshint_W075: {
      message: "Duplicate key '{a}'.",
      level: "warning"
    },
    jshint_W076: {
      message: "Unexpected parameter '{a}' in get {b} function.",
      level: "warning"
    },
    jshint_W077: {
      message: "Expected a single parameter in set {a} function.",
      level: "warning"
    },
    jshint_W078: {
      message: "Setter is defined without getter.",
      level: "warning"
    },
    jshint_W079: {
      message: "Redefinition of '{a}'.",
      level: "warning"
    },
    jshint_W080: {
      message: "It's not necessary to initialize '{a}' to 'undefined'.",
      level: "warning"
    },
    jshint_W081: {
      message: "Too many var statements.",
      level: "warning"
    },
    jshint_W082: {
      message: "Function declarations should not be placed in blocks. Use a function expression or move the statement to the top of the outer function.",
      level: "warning"
    },
    jshint_W083: {
      message: "Don't make functions within a loop.",
      level: "warning"
    },
    jshint_W084: {
      message: "Expected a conditional expression and instead saw an assignment.",
      level: "warning"
    },
    jshint_W085: {
      message: "Don't use 'with'.",
      level: "warning"
    },
    jshint_W086: {
      message: "Expected a 'break' statement before '{a}'.",
      level: "warning"
    },
    jshint_W087: {
      message: "Forgotten 'debugger' statement?",
      level: "warning"
    },
    jshint_W088: {
      message: "Creating global 'for' variable. Should be 'for (var {a} ...'.",
      level: "warning"
    },
    jshint_W089: {
      message: "The body of a for in should be wrapped in an if statement to filter unwanted properties from the prototype.",
      level: "warning"
    },
    jshint_W090: {
      message: "'{a}' is not a statement label.",
      level: "warning"
    },
    jshint_W091: {
      message: "'{a}' is out of scope.",
      level: "warning"
    },
    jshint_W092: {
      message: "Wrap the /regexp/ literal in parens to disambiguate the slash operator.",
      level: "warning"
    },
    jshint_W093: {
      message: "Did you mean to return a conditional instead of an assignment?",
      level: "warning"
    },
    jshint_W094: {
      message: "Unexpected comma.",
      level: "warning"
    },
    jshint_W095: {
      message: "Expected a string and instead saw {a}.",
      level: "warning"
    },
    jshint_W096: {
      message: "The '{a}' key may produce unexpected results.",
      level: "warning"
    },
    jshint_W097: {
      message: "Use the function form of \"use strict\".",
      level: "warning"
    },
    jshint_W098: {
      message: "'{a}' is defined but never used.",
      level: "warning"
    },
    jshint_W099: {
      message: "Mixed spaces and tabs.",
      level: "warning"
    },
    jshint_W100: {
      message: "This character may get silently deleted by one or more browsers.",
      level: "warning"
    },
    jshint_W101: {
      message: "Line is too long.",
      level: "warning"
    },
    jshint_W102: {
      message: "Trailing whitespace.",
      level: "warning"
    },
    jshint_W103: {
      message: "The '{a}' property is deprecated.",
      level: "warning"
    },
    jshint_W104: {
      message: "'{a}' is only available in JavaScript 1.7.",
      level: "warning"
    },
    jshint_W105: {
      message: "Unexpected {a} in '{b}'.",
      level: "warning"
    },
    jshint_W106: {
      message: "Identifier '{a}' is not in camel case.",
      level: "warning"
    },
    jshint_W107: {
      message: "Script URL.",
      level: "warning"
    },
    jshint_W108: {
      message: "Strings must use doublequote.",
      level: "warning"
    },
    jshint_W109: {
      message: "Strings must use singlequote.",
      level: "warning"
    },
    jshint_W110: {
      message: "Mixed double and single quotes.",
      level: "warning"
    },
    jshint_W112: {
      message: "Unclosed string.",
      level: "warning"
    },
    jshint_W113: {
      message: "Control character in string: {a}.",
      level: "warning"
    },
    jshint_W114: {
      message: "Avoid {a}.",
      level: "warning"
    },
    jshint_W115: {
      message: "Octal literals are not allowed in strict mode.",
      level: "warning"
    },
    jshint_W116: {
      message: "Expected '{a}' and instead saw '{b}'.",
      level: "warning"
    },
    jshint_W117: {
      message: "'{a}' is not defined.",
      level: "warning"
    },
    jshint_W118: {
      message: "'{a}' is only available in Mozilla JavaScript extensions (use moz option).",
      level: "warning"
    },
    jshint_W119: {
      message: "'{a}' is only available in ES6 (use esnext option).",
      level: "warning"
    },
    jshint_W120: {
      message: "You might be leaking a variable ({a}) here.",
      level: "warning"
    },
    jshint_I001: {
      message: "Comma warnings can be turned off with 'laxcomma'.",
      level: "ignore"
    },
    jshint_I002: {
      message: "Reserved words as properties can be used under the 'es5' option.",
      level: "ignore"
    },
    jshint_I003: {
      message: "ES5 option is now set per default",
      level: "ignore"
    }
  };

}).call(this);

},{"./ranges":10}],8:[function(require,module,exports){
(function (global){(function() {
  var argsClass, arrayClass, boolClass, cloneableClasses, createAPIClone, ctorByClass, dateClass, errorClass, funcClass, numberClass, objectClass, reFlags, regexpClass, restoreAPIClone, stringClass, _, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty;

  _ = (_ref = (_ref1 = (_ref2 = typeof window !== "undefined" && window !== null ? window._ : void 0) != null ? _ref2 : typeof self !== "undefined" && self !== null ? self._ : void 0) != null ? _ref1 : typeof global !== "undefined" && global !== null ? global._ : void 0) != null ? _ref : require('lodash');

  ctorByClass = {};

  argsClass = "[object Arguments]";

  ctorByClass[arrayClass = "[object Array]"] = Array;

  ctorByClass[boolClass = "[object Boolean]"] = Boolean;

  ctorByClass[dateClass = "[object Date]"] = Date;

  ctorByClass[errorClass = "[object Error]"] = Error;

  ctorByClass[funcClass = "[object Function]"] = Function;

  ctorByClass[numberClass = "[object Number]"] = Number;

  ctorByClass[objectClass = "[object Object]"] = Object;

  ctorByClass[regexpClass = "[object RegExp]"] = RegExp;

  ctorByClass[stringClass = "[object String]"] = String;

  cloneableClasses = {};

  cloneableClasses[funcClass] = false;

  cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  reFlags = /\w*$/;

  module.exports.createAPIClone = createAPIClone = function(value) {
    var className, clone, ctor, i, isArr, k, prop, result, v, _fn, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref3, _ref4, _ref5, _ref6, _ref7;
    if (!_.isObject(value)) {
      return value;
    }
    className = Object.prototype.toString.call(value);
    if (!cloneableClasses[className]) {
      return value;
    }
    ctor = ctorByClass[className];
    switch (className) {
      case boolClass:
      case dateClass:
        return new ctor(+value);
      case numberClass:
      case stringClass:
        return new ctor(value);
      case regexpClass:
        result = ctor(value.source, reFlags.exec(value));
        result.lastIndex = value.lastIndex;
        return result;
    }
    if (clone = value.__aetherAPIClone) {
      return clone;
    }
    if (value.__aetherAPIValue) {
      return value;
    }
    if (isArr = _.isArray(value)) {
      result = ctor(value.length);
      if (value.hasOwnProperty("index")) {
        result.index = value.index;
      }
      if (value.hasOwnProperty("input")) {
        result.input = value.input;
      }
    } else {
      result = {};
    }
    Object.defineProperty(value, "__aetherAPIClone", {
      value: result,
      writable: true,
      configurable: true
    });
    Object.defineProperty(result, "__aetherAPIValue", {
      value: value
    });
    if (isArr) {
      for (i = _i = 0, _len = value.length; _i < _len; i = ++_i) {
        v = value[i];
        result[i] = createAPIClone(v);
      }
    } else if (value.apiProperties) {
      _ref4 = (_ref3 = value.apiMethods) != null ? _ref3 : [];
      _fn = function(prop) {
        var fn;
        fn = function() {
          if (!value._aetherAPIMethodsAllowed) {
            throw new Error("Calling " + prop + " is not allowed.");
          }
          return value[prop].apply(value, arguments);
        };
        return Object.defineProperty(result, prop, {
          value: fn,
          enumerable: true
        });
      };
      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
        prop = _ref4[_j];
        _fn(prop);
      }
      _ref5 = value.apiProperties;
      for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
        prop = _ref5[_k];
        if (result[prop] == null) {
          (function(prop) {
            var fn;
            fn = function() {
              return createAPIClone(value[prop]);
            };
            return Object.defineProperty(result, prop, {
              get: fn,
              enumerable: true
            });
          })(prop);
        }
      }
      _ref7 = (_ref6 = value.apiUserProperties) != null ? _ref6 : [];
      for (_l = 0, _len3 = _ref7.length; _l < _len3; _l++) {
        prop = _ref7[_l];
        if (result[prop] == null) {
          result[prop] = createAPIClone(value[prop]);
        }
      }
    } else {
      for (k in value) {
        if (!__hasProp.call(value, k)) continue;
        v = value[k];
        Object.defineProperty(result, k, {
          value: createAPIClone(v),
          enumerable: true
        });
      }
    }
    return result;
  };

  module.exports.restoreAPIClone = restoreAPIClone = function(value, depth) {
    var className, isArr, k, result, source, v, _ref3;
    if (depth == null) {
      depth = 0;
    }
    if (!_.isObject(value)) {
      return value;
    }
    className = Object.prototype.toString.call(value);
    if (!cloneableClasses[className]) {
      return value;
    }
    if (className === boolClass || className === dateClass || className === numberClass || className === stringClass || className === regexpClass) {
      return value;
    }
    if (source = value.__aetherAPIValue) {
      return source;
    }
    if (source = (_ref3 = value.__aetherAPIClone) != null ? _ref3.__aetherAPIValue : void 0) {
      return source;
    }
    if (depth > 1) {
      return value;
    }
    if (isArr = _.isArray(value)) {
      result = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = value.length; _i < _len; _i++) {
          v = value[_i];
          _results.push(restoreAPIClone(v, depth + 1));
        }
        return _results;
      })();
    } else {
      result = {};
      for (k in value) {
        v = value[k];
        result[k] = restoreAPIClone(v, depth + 1);
      }
    }
    return result;
  };

}).call(this);
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"lodash":56}],9:[function(require,module,exports){
(function() {
  var builtinClones, builtinNames, builtinReal, cloneBuiltin, copy, copyBuiltin, createSandboxedFunction, getOwnPropertyNames, global, name, problems, raiseDisabledFunctionConstructor, restoreBuiltins, wrapWithSandbox;

  problems = require('./problems');

  getOwnPropertyNames = Object.getOwnPropertyNames;

  copy = function(source, target) {
    var name, _i, _len, _ref;
    _ref = getOwnPropertyNames(source);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      target[name] = source[name];
    }
    return target;
  };

  cloneBuiltin = function(obj, name) {
    var masked;
    if (obj == null) {
      throw name;
    }
    masked = {};
    copy(obj, masked);
    if (obj.prototype) {
      masked.prototype = {};
      copy(obj.prototype, masked.prototype);
    }
    return masked;
  };

  module.exports.copyBuiltin = copyBuiltin = function(source, target) {
    copy(source, target);
    if (source.prototype) {
      return copy(source.prototype, target.prototype);
    }
  };

  global = (function() {
    return this;
  })();

  builtinNames = ['Object', 'Function', 'Array', 'String', 'Boolean', 'Number', 'Date', 'RegExp', 'Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError'];

  builtinClones = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = builtinNames.length; _i < _len; _i++) {
      name = builtinNames[_i];
      _results.push(cloneBuiltin(global[name], name));
    }
    return _results;
  })();

  builtinReal = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = builtinNames.length; _i < _len; _i++) {
      name = builtinNames[_i];
      _results.push(global[name]);
    }
    return _results;
  })();

  module.exports.restoreBuiltins = restoreBuiltins = function(globals) {
    var cloned, offset, real, _i, _len;
    for (offset = _i = 0, _len = builtinNames.length; _i < _len; offset = ++_i) {
      name = builtinNames[offset];
      real = builtinReal[offset];
      cloned = builtinClones[offset];
      copyBuiltin(cloned, real);
      global[name] = real;
    }
  };

  module.exports.raiseDisabledFunctionConstructor = raiseDisabledFunctionConstructor = function() {
    throw new Error('[Sandbox] Function::constructor is disabled. If you are a developer, please make sure you have a reference to your builtins.');
  };

  module.exports.createSandboxedFunction = createSandboxedFunction = function(functionName, code, aether) {
    var dummyContext, dummyFunction, e, error, globalRef, globals, wrapper, _i, _len;
    globals = ['Vector', '_', 'NaN', 'Infinity', 'undefined', 'parseInt', 'parseFloat', 'isNaN', 'isFinite', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'Object', 'Function', 'Array', 'String', 'Boolean', 'Number', 'Date', 'RegExp', 'Math', 'JSON', 'Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError'];
    dummyContext = {};
    globalRef = global != null ? global : window;
    for (_i = 0, _len = globals.length; _i < _len; _i++) {
      name = globals[_i];
      dummyContext[name] = globalRef[name];
      if (name === 'Vector') {
        try {
          dummyContext[name] = eval("require('lib/world/vector')");
        } catch (_error) {
          error = _error;
          null;
        }
      }
    }
    dummyFunction = raiseDisabledFunctionConstructor;
    copyBuiltin(Function, dummyFunction);
    dummyContext.Function = dummyFunction;
    try {
      wrapper = new Function(['_aether'], code);
      wrapper.call(dummyContext, aether);
    } catch (_error) {
      e = _error;
      console.warn("Error creating function, so returning empty function instead. Error: " + e + "\nCode:", code);
      aether.addProblem(new problems.TranspileProblem(aether, 'aether', problems.problems.aether_Untranspilable, e, {}, code, ''));
      return function() {};
    }
    return dummyContext[functionName];
  };

  module.exports.wrapWithSandbox = wrapWithSandbox = function(self, fn) {
    return function() {
      var result;
      Function.prototype.constructor = raiseDisabledFunctionConstructor;
      try {
        self.depth++;
        result = fn.apply(this, arguments);
      } finally {
        self.depth--;
        if (self.depth <= 0) {
          restoreBuiltins();
        }
      }
      return result;
    };
  };

}).call(this);

},{"./problems":7}],10:[function(require,module,exports){
(function() {
  var buildRowOffsets, lastRowOffsets, lastRowOffsetsPrefix, lastRowOffsetsSource, offsetToPos, offsetToRow, offsetsToRange, rowColToPos, rowColsToRange, stringifyPos, stringifyRange;

  module.exports.offsetToPos = offsetToPos = function(offset, source, prefix) {
    var col, row, rowOffsets;
    if (prefix == null) {
      prefix = '';
    }
    rowOffsets = buildRowOffsets(source, prefix);
    offset -= prefix.length;
    row = offsetToRow(offset, rowOffsets);
    col = offset - rowOffsets[row];
    return {
      ofs: offset,
      row: row,
      col: col
    };
  };

  module.exports.offsetsToRange = offsetsToRange = function(start, end, source, prefix) {
    if (prefix == null) {
      prefix = '';
    }
    return {
      start: offsetToPos(start, source, prefix),
      end: offsetToPos(end, source, prefix)
    };
  };

  module.exports.rowColToPos = rowColToPos = function(row, col, source, prefix) {
    var offset, rowOffsets;
    if (prefix == null) {
      prefix = '';
    }
    rowOffsets = buildRowOffsets(source, prefix);
    offset = rowOffsets[row] + col;
    return {
      ofs: offset,
      row: row,
      col: col
    };
  };

  module.exports.rowColsToRange = rowColsToRange = function(start, end, source, prefix) {
    if (prefix == null) {
      prefix = '';
    }
    return {
      start: rowColToPos(start.row, start.col, source, prefix),
      end: rowColToPos(end.row, end.col, source, prefix)
    };
  };

  module.exports.stringifyPos = stringifyPos = function(pos) {
    return "{ofs: " + pos.ofs + ", row: " + pos.row + ", col: " + pos.col + "}";
  };

  module.exports.stringifyRange = stringifyRange = function(start, end) {
    return "[" + (stringifyPos(start)) + ", " + (stringifyPos(end)) + "]";
  };

  lastRowOffsets = null;

  lastRowOffsetsSource = null;

  lastRowOffsetsPrefix = null;

  buildRowOffsets = function(source, prefix) {
    var c, offset, rowOffsets, _i, _len, _ref;
    if (prefix == null) {
      prefix = '';
    }
    if (source === lastRowOffsetsSource && prefix === lastRowOffsetsPrefix) {
      return lastRowOffsets;
    }
    rowOffsets = [0];
    _ref = source.substr(prefix.length);
    for (offset = _i = 0, _len = _ref.length; _i < _len; offset = ++_i) {
      c = _ref[offset];
      if (c === '\n') {
        rowOffsets.push(offset + 1);
      }
    }
    lastRowOffsets = rowOffsets;
    lastRowOffsetsSource = source;
    lastRowOffsetsPrefix = prefix;
    return rowOffsets;
  };

  offsetToRow = function(offset, rowOffsets) {
    var alen, hi, lo, mid;
    alen = rowOffsets.length;
    if (offset <= 0) {
      return 0;
    }
    if (offset >= rowOffsets[alen - 1]) {
      return alen - 1;
    }
    lo = 0;
    hi = alen - 1;
    while (lo < hi) {
      mid = ~~((hi + lo) / 2);
      if (offset >= rowOffsets[mid] && offset < rowOffsets[mid + 1]) {
        return mid;
      }
      if (offset < rowOffsets[mid]) {
        hi = mid;
      } else {
        lo = mid;
      }
    }
    throw new Error("Bug in offsetToRow()");
  };

}).call(this);

},{}],11:[function(require,module,exports){
(function (global){(function() {
  var S, SourceMap, checkIncompleteMembers, esprima, getFunctionNestingLevel, getParents, getParentsOfTypes, interceptThis, makeCheckThisKeywords, makeFindOriginalNodes, makeGatherNodeRanges, makeInstrumentCalls, makeInstrumentStatements, makeProtectAPI, possiblyGeneratorifyAncestorFunction, problems, ranges, statements, validateReturns, yieldAutomatically, yieldConditionally, _, _ref, _ref1, _ref2,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = (_ref = (_ref1 = (_ref2 = typeof window !== "undefined" && window !== null ? window._ : void 0) != null ? _ref2 : typeof self !== "undefined" && self !== null ? self._ : void 0) != null ? _ref1 : typeof global !== "undefined" && global !== null ? global._ : void 0) != null ? _ref : require('lodash');

  problems = require('./problems');

  ranges = require('./ranges');

  esprima = require('esprima');

  SourceMap = require('source-map');

  S = esprima.Syntax;

  statements = [S.EmptyStatement, S.ExpressionStatement, S.BreakStatement, S.ContinueStatement, S.DebuggerStatement, S.DoWhileStatement, S.ForStatement, S.FunctionDeclaration, S.ClassDeclaration, S.IfStatement, S.ReturnStatement, S.SwitchStatement, S.ThrowStatement, S.TryStatement, S.VariableStatement, S.WhileStatement, S.WithStatement, S.VariableDeclaration];

  getParents = function(node) {
    var parents;
    parents = [];
    while (node.parent) {
      parents.push(node = node.parent);
    }
    return parents;
  };

  getParentsOfTypes = function(node, types) {
    return _.filter(getParents(node), function(elem) {
      var _ref3;
      return _ref3 = elem.type, __indexOf.call(types, _ref3) >= 0;
    });
  };

  getFunctionNestingLevel = function(node) {
    return getParentsOfTypes(node, [S.FunctionExpression]).length;
  };

  module.exports.makeGatherNodeRanges = makeGatherNodeRanges = function(nodeRanges, code, codePrefix) {
    return function(node) {
      if (!node.range) {
        return;
      }
      node.originalRange = ranges.offsetsToRange(node.range[0], node.range[1], code, codePrefix);
      node.originalSource = node.source();
      return nodeRanges.push(node);
    };
  };

  module.exports.makeCheckThisKeywords = makeCheckThisKeywords = function(global, varNames) {
    return function(node) {
      var p, param, problem, v, _i, _j, _k, _len, _len1, _len2, _ref3, _ref4, _ref5, _ref6, _results;
      if (node.type === S.VariableDeclarator) {
        return varNames[node.id.name] = true;
      } else if (node.type === S.AssignmentExpression) {
        return varNames[node.left.name] = true;
      } else if (node.type === S.FunctionDeclaration || node.type === S.FunctionExpression) {
        if (node.id != null) {
          varNames[node.id.name] = true;
        }
        _ref3 = node.params;
        _results = [];
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          param = _ref3[_i];
          _results.push(varNames[param.name] = true);
        }
        return _results;
      } else if (node.type === S.CallExpression) {
        v = node;
        while ((_ref4 = v.type) === S.CallExpression || _ref4 === S.MemberExpression) {
          v = v.object != null ? v.object : v.callee;
        }
        v = v.name;
        if (v && !varNames[v] && !global[v]) {
          _ref5 = getParentsOfTypes(node, [S.FunctionDeclaration, S.FunctionExpression, S.VariableDeclarator, S.AssignmentExpression]);
          for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
            p = _ref5[_j];
            if (p.id != null) {
              varNames[p.id.name] = true;
            }
            if (p.left != null) {
              varNames[p.left.name] = true;
            }
            if (p.params != null) {
              _ref6 = p.params;
              for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
                param = _ref6[_k];
                varNames[param.name] = true;
              }
            }
            if (varNames[v] === true) {
              return;
            }
          }
          problem = new problems.TranspileProblem(this, 'aether', 'MissingThis', {}, null, '', '');
          problem.message = "Missing `this.` keyword; should be `this." + v + "`.";
          problem.hint = "There is no function `" + v + "`, but `this` has a method `" + v + "`.";
          problem.ranges = [[node.originalRange.start, node.originalRange.end]];
          this.addProblem(problem);
          if (!this.options.requiresThis) {
            return node.update("this." + (node.source()));
          }
        }
      }
    };
  };

  module.exports.validateReturns = validateReturns = function(node) {
    var _ref3;
    if (getFunctionNestingLevel(node) !== 2) {
      return;
    }
    if (node.type === S.ReturnStatement && !node.argument) {
      return node.update(node.source().replace("return;", "return this.validateReturn('" + this.options.functionName + "', null);"));
    } else if (((_ref3 = node.parent) != null ? _ref3.type : void 0) === S.ReturnStatement) {
      return node.update("this.validateReturn('" + this.options.functionName + "', (" + (node.source()) + "))");
    }
  };

  module.exports.checkIncompleteMembers = checkIncompleteMembers = function(node) {
    var exp, m, problem, _ref3;
    if (node.type === 'ExpressionStatement') {
      exp = node.expression;
      if (exp.type === 'MemberExpression') {
        if (exp.property.name === "IncompleteThisReference") {
          problem = new problems.TranspileProblem(this, 'aether', 'IncompleteThis', {}, null, '', '');
          m = "this.what? (Check available spells below.)";
        } else {
          problem = new problems.TranspileProblem(this, 'aether', 'NoEffect', {}, null, '', '');
          m = "" + (exp.source()) + " has no effect.";
          if (_ref3 = exp.property.name, __indexOf.call(problems.commonMethods, _ref3) >= 0) {
            m += " It needs parentheses: " + (exp.source()) + "()";
          } else {
            problem.hint = "Is it a method? Those need parentheses: " + (exp.source()) + "()";
          }
        }
        problem.message = m;
        problem.ranges = [[node.originalRange.start, node.originalRange.end]];
        return this.addProblem(problem);
      }
    }
  };

  module.exports.makeFindOriginalNodes = makeFindOriginalNodes = function(originalNodes, codePrefix, normalizedSourceMap, normalizedNodeIndex) {
    var normalizedPosToOriginalNode, smc;
    normalizedPosToOriginalNode = function(pos) {
      var end, node, start, _i, _len;
      start = pos.start_offset - codePrefix.length;
      end = pos.end_offset - codePrefix.length;
      for (_i = 0, _len = originalNodes.length; _i < _len; _i++) {
        node = originalNodes[_i];
        if (start === node.originalRange.start.ofs && end === node.originalRange.end.ofs) {
          return node;
        }
      }
      return null;
    };
    smc = new SourceMap.SourceMapConsumer(normalizedSourceMap.toString());
    return function(node) {
      var mapped, normalizedNode;
      if (!(mapped = smc.originalPositionFor({
        line: node.loc.start.line,
        column: node.loc.start.column
      }))) {
        return;
      }
      if (!(normalizedNode = normalizedNodeIndex[mapped.column])) {
        return;
      }
      return node.originalNode = normalizedPosToOriginalNode(normalizedNode.attr.pos);
    };
  };

  possiblyGeneratorifyAncestorFunction = function(node) {
    while (node.type !== S.FunctionExpression) {
      node = node.parent;
    }
    return node.mustBecomeGeneratorFunction = true;
  };

  module.exports.yieldConditionally = yieldConditionally = function(node) {
    var _ref3;
    if (node.type === S.ExpressionStatement && ((_ref3 = node.expression.right) != null ? _ref3.type : void 0) === S.CallExpression) {
      if (getFunctionNestingLevel(node) !== 2) {
        return;
      }
      node.update("" + (node.source()) + " if (this._aetherShouldYield) { var _yieldValue = this._aetherShouldYield; this._aetherShouldYield = false; yield _yieldValue; }");
      node.yields = true;
      return possiblyGeneratorifyAncestorFunction(node);
    } else if (node.mustBecomeGeneratorFunction) {
      return node.update(node.source().replace(/^function \(/, 'function* ('));
    }
  };

  module.exports.yieldAutomatically = yieldAutomatically = function(node) {
    var _ref3;
    if (_ref3 = node.type, __indexOf.call(statements, _ref3) >= 0) {
      if (getFunctionNestingLevel(node) !== 2) {
        return;
      }
      node.update("" + (node.source()) + " yield 'waiting...';");
      node.yields = true;
      return possiblyGeneratorifyAncestorFunction(node);
    } else if (node.mustBecomeGeneratorFunction) {
      return node.update(node.source().replace(/^function \(/, 'function* ('));
    }
  };

  module.exports.makeInstrumentStatements = makeInstrumentStatements = function(varNames) {
    return function(node) {
      var loggers, orig, prefix, safeRange, safeSource, varName, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      orig = node.originalNode;
      if (!(orig && orig.originalRange.start.ofs >= 0)) {
        return;
      }
      if (_ref3 = node.type, __indexOf.call(statements, _ref3) < 0) {
        return;
      }
      if ((_ref4 = orig.type) === S.ThisExpression || _ref4 === S.Identifier) {
        return;
      }
      if (!(getFunctionNestingLevel(node) > 1)) {
        return;
      }
      if (((_ref5 = orig.parent) != null ? _ref5.type : void 0) === S.AssignmentExpression && ((_ref6 = orig.parent.parent) != null ? _ref6.type : void 0) === S.ExpressionStatement) {
        orig = orig.parent.parent;
      } else if (((_ref7 = orig.parent) != null ? _ref7.type : void 0) === S.VariableDeclarator && ((_ref8 = orig.parent.parent) != null ? _ref8.type : void 0) === S.VariableDeclaration) {
        orig = orig.parent.parent;
      }
      safeRange = ranges.stringifyRange(orig.originalRange.start, orig.originalRange.end);
      safeSource = orig.originalSource.replace(/\"/g, '\\"').replace(/\n/g, '\\n');
      prefix = "_aether.logStatementStart(" + safeRange + ");";
      loggers = (function() {
        var _results;
        _results = [];
        for (varName in varNames) {
          _results.push("_aether.vars['" + varName + "'] = typeof " + varName + " == 'undefined' ? undefined : " + varName + ";");
        }
        return _results;
      })();
      loggers.push("_aether.logStatement(" + safeRange + ", \"" + safeSource + "\", this._aetherUserInfo);");
      return node.update("" + prefix + " " + (node.source()) + " " + (loggers.join(' ')));
    };
  };

  module.exports.interceptThis = interceptThis = function(node) {
    if (node.type !== S.ThisExpression) {
      return;
    }
    if (!(getFunctionNestingLevel(node) > 1)) {
      return;
    }
    return node.update("__interceptThis(this, __global)");
  };

  module.exports.makeInstrumentCalls = makeInstrumentCalls = function(varNames) {
    return function(node) {
      if (getFunctionNestingLevel(node) !== 2) {
        return;
      }
      if (node.type === S.ReturnStatement) {
        node.update("_aether.logCallEnd(); " + (node.source()));
      }
      if (node.type !== S.VariableDeclaration) {
        return;
      }
      return node.update("_aether.logCallStart(this._aetherUserInfo); " + (node.source()));
    };
  };

  module.exports.makeProtectAPI = makeProtectAPI = function(parameters) {
    if (parameters == null) {
      parameters = [];
    }
    return function(node) {
      var arg, level, parameter, protectors, _i, _len, _ref3, _ref4;
      if ((_ref3 = node.type) !== S.CallExpression && _ref3 !== S.ThisExpression && _ref3 !== S.VariableDeclaration && _ref3 !== S.ReturnStatement) {
        return;
      }
      level = getFunctionNestingLevel(node);
      if (!(level > 1)) {
        return;
      }
      if (node.type === S.CallExpression) {
        _ref4 = node["arguments"];
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          arg = _ref4[_i];
          arg.update("_aether.restoreAPIClone(" + (arg.source()) + ")");
        }
      }
      if (node.parent.type === S.AssignmentExpression || node.type === S.ThisExpression) {
        return node.update("_aether.createAPIClone(" + (node.source()) + ")");
      } else if (level === 2) {
        if (node.type === S.VariableDeclaration && parameters.length) {
          protectors = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = parameters.length; _j < _len1; _j++) {
              parameter = parameters[_j];
              _results.push("" + parameter + " = _aether.createAPIClone(" + parameter + ");");
            }
            return _results;
          })();
          return node.update("" + (node.source()) + " " + (protectors.join(' ')));
        } else if (node.type === S.ReturnStatement && (arg = node.argument)) {
          return arg.update("_aether.restoreAPIClone(" + (arg.source()) + ")");
        }
      }
    };
  };

}).call(this);
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./problems":7,"./ranges":10,"esprima":54,"lodash":56,"source-map":78}],12:[function(require,module,exports){
(function() {
  var tv4;

  tv4 = require('tv4').tv4;

  module.exports = function(options) {
    return tv4.validateMultiple(options, {
      "type": "object",
      additionalProperties: false,
      properties: {
        thisValue: {
          required: false
        },
        global: {
          type: 'array',
          required: false
        },
        functionName: {
          required: false
        },
        functionParameters: {
          required: false
        },
        yieldAutomatically: {
          type: 'boolean',
          required: false
        },
        yieldConditionally: {
          type: 'boolean',
          required: false
        },
        requiresThis: {
          type: 'boolean',
          "default": true,
          description: 'Whether leaving off "this" is an error, or just a warning which we work around.'
        },
        executionCosts: {
          required: false
        },
        language: {
          type: 'string',
          description: "Input language",
          minLength: 1,
          'enum': ['javascript', 'coffeescript'],
          required: false
        },
        languageVersion: {
          type: 'string',
          description: "Input language version",
          minLength: 1,
          'enum': ["ES5", "ES6"]
        },
        problems: {
          required: false
        },
        includeFlow: {
          oneOf: [
            {
              type: 'boolean',
              "default": true,
              description: "If true, will record everything."
            }, {
              type: 'object',
              description: "Limitations on what to record.",
              properties: {
                callIndex: {
                  type: 'integer',
                  description: "If set, record flow only for the given call, not every call."
                },
                statementIndex: {
                  type: 'integer',
                  description: "If set, record flow only for the given statement within the given call."
                },
                timelessVariables: {
                  type: 'array',
                  description: "Record flow for these variables regardless of callIndex and statementIndex.",
                  items: {
                    type: 'string'
                  }
                }
              }
            }
          ]
        },
        includeMetrics: {
          type: 'boolean',
          "default": true
        },
        includeStyle: {
          type: 'boolean',
          "default": true
        },
        includeVisualization: {
          type: 'boolean',
          "default": false
        },
        protectAPI: {
          type: 'boolean',
          "default": false,
          description: "Whether to clone/restore values coming in and out of user code to limit them to apiProperties."
        }
      }
    });
  };

}).call(this);

},{"tv4":88}],13:[function(require,module,exports){
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/

/**
 * Convenience functions for constructing and navigating ASTs.
 */
//if(typeof define !== 'function') {
//  var define = require('amdefine')(module);
//}
//
//define(function(require, exports) {
  var position = require('./position');
  
  // constructor signatures; arguments in angle brackets are terminal children, the others subtrees
  var signatures = {
      AssignmentExpression: [ '<operator>', 'left', 'right'],
      ArrayExpression: [ 'elements' ],
      BlockStatement: [ 'body' ],
      BinaryExpression: [ '<operator>', 'left', 'right'],
      BreakStatement: [ 'label' ],
      CallExpression: [ 'callee', 'arguments' ],
      CatchClause: [ 'param', 'body' ],
      ConditionalExpression: [ 'test', 'consequent', 'alternate' ],
      ContinueStatement: [ 'label' ],
      DirectiveStatement: [ ],
      DoWhileStatement: [ 'body', 'test' ],
      DebuggerStatement: [ ],
      EmptyStatement: [ ],
      ExpressionStatement: [ 'expression' ],
      ForStatement: [ 'init', 'test', 'update', 'body' ],
      ForInStatement: [ 'left', 'right', 'body' ],
      FunctionDeclaration: [ 'id', 'params', 'body' ],
      FunctionExpression: [ 'id', 'params', 'body' ],
      Identifier: [ '<name>' ],
      IfStatement: [ 'test', 'consequent', 'alternate' ],
      Literal: [ '<value>' ],
      LabeledStatement: [ 'label', 'body' ],
      LogicalExpression: [ '<operator>', 'left', 'right' ],
      MemberExpression: [ 'object', 'property', '<computed>' ],
      NewExpression: [ 'callee', 'arguments' ],
      ObjectExpression: [ 'properties' ],
      Program: [ 'body' ],
      Property: [ 'key', 'value', '<kind>' ],
      ReturnStatement: [ 'argument' ],
      SequenceExpression: [ 'expressions' ],
      SwitchStatement: [ 'discriminant', 'cases' ],
      SwitchCase: [ 'test', 'consequent' ],
      ThisExpression: [ ],
      ThrowStatement: [ 'argument' ],
      TryStatement: [ 'block', 'guardedHandlers', 'handlers', 'finalizer' ],
      UnaryExpression: [ '<operator>', 'argument' ],
      UpdateExpression: [ '<operator>', 'argument', '<prefix>' ],
      VariableDeclaration: [ 'declarations', '<kind>' ],
      VariableDeclarator: [ 'id', 'init' ],
      WhileStatement: [ 'test', 'body' ],
      WithStatement: [ 'object', 'body' ]
  };

  // define a constructor from a signature
  function defconstructor(tpname, signature) {
    var child_names = [], nonterminal_children = [];
    for(var i=0;i<signature.length;++i)
      if(signature[i][0] === '<') {
        child_names[child_names.length] = signature[i].substring(1, signature[i].length-1);
      } else {
        child_names[child_names.length] = signature[i];
        nonterminal_children[nonterminal_children.length] = signature[i];
      }
    
    exports[tpname] = function() {
      this.type = tpname;
      this.attr = {};
      for(var i=0;i<arguments.length;++i)
        this[child_names[i]] = arguments[i];
      for(;i<child_names.length;++i)
        this[child_names[i]] = null;
    };
    exports[tpname].children = nonterminal_children;
  }
  
  // several convenience methods for accessing subtrees
  var getNumChild = exports.getNumChild = function(nd) {
    if(Array.isArray(nd))
      return nd.length;
    
    if(nd && nd.type)
      return exports[nd.type].children.length;
    
    return 0;
  };
  
  var getChild = exports.getChild = function(nd, i) {
    if(Array.isArray(nd))
      return nd[i];
    
    return nd[exports[nd.type].children[i]];
  };

  var setChild = exports.setChild = function(nd, i, v) {
    if(Array.isArray(nd))
      return nd[i] = v;

    return nd[exports[nd.type].children[i]] = v;
  };
  
  var forEachChild = exports.forEachChild = function(nd, cb) {
    for(var i = 0, n = getNumChild(nd); i < n; ++i)
      cb(getChild(nd, i), i);
  };
  
  var mapChildren = exports.mapChildren = function(nd, cb) {
    var res = [];
    forEachChild(nd, function(ch, i) {
      res[res.length] = cb(ch, i);
    });
    return res;
  };

  // simple debug printing function
  var dump = exports.dump = function(nd) {
    if(Array.isArray(nd))
      return "[" + nd.map(dump).join() + "]";
    
    if(!nd || !nd.type)
      return nd+"";
    
    return nd.type + "(" + mapChildren(nd, dump).join() + ")";
  };
  
  // we give every AST node a property "attr" for storing attributes
  exports.getAttribute = function(nd, name) {
    nd.attr = nd.attr || {};
    return nd.attr[name];
  };
  
  exports.setAttribute = function(nd, name, value) {
    nd.attr = nd.attr || {};
    nd.attr[name] = value;
    return nd;
  };
  
  // positions are attached as attributes
  exports.hasPosition = function(nd) {
      return !!exports.getAttribute(nd, 'pos') || !!nd.loc || !!nd.range;
  };
  
  exports.getPosition = function(nd) {
      if(!exports.getAttribute(nd, 'pos')) {
      var pos = position.DUMMY_POS.clone();
      if(nd.loc) {
	  if(nd.loc.source) {
	      pos.url = nd.loc.source;
	  }
        pos.start_line = nd.loc.start.line;
        pos.end_line = nd.loc.start.line;
      }
      if(nd.range) {
        pos.start_offset = nd.range[0];
        pos.end_offset = nd.range[1];
      }
      exports.setAttribute(nd, 'pos', pos);
    }
    return exports.getAttribute(nd, 'pos');
  };
  
  exports.setPosition = function(nd, pos) {
    exports.setAttribute(nd, 'pos', pos);
  };
  
  for(var p in signatures)
    defconstructor(p, signatures[p]);
//});

},{"./position":14}],14:[function(require,module,exports){
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/

/**
 * ADT for representing source positions identified by a URL, a start line, a start
 * offset (i.e., character offset from the beginning of the file), an end line, and
 * an end offset.
 * 
 * The start line corresponds to Esprima's loc.start.line, the start offset to
 * range[0], and similar for the end line and end offset.
 * 
 * For compatibility with Esprima, line numbering should normally be 1-based.
 */

//if(typeof define !== 'function') {
//  var define = require('amdefine')(module);
//}
//
//define(function(require, exports) {
  function Position(url, start_line, start_offset, end_line, end_offset) {
    this.url = url || "<unknown>";
    this.start_line = start_line;
    this.start_offset = start_offset;
    this.end_line = end_line;
    this.end_offset = end_offset;
  }
  
  Position.prototype.toString = function(short) {
    if(short)
      return this.start_line + ":" + this.start_offset;
    return this.url + "/" + this.start_line + ":" + this.start_offset + "-" + this.end_line + ":" + this.end_offset;
  };
  
  Position.prototype.clone = function() {
    return new Position(this.url, this.start_line, this.start_offset, this.end_line, this.end_offset);
  };
  
  Position.prototype.equals = function(o) {
    if(!(o instanceof Position))
      return false;
    return o.url === this.url &&
           o.start_line === this.start_line &&
           o.start_offset === this.start_offset &&
           o.end_line === this.end_line &&
           o.end_offset === this.end_offset;
  };
  
  var DUMMY_POS = new Position(null, -1, -1, -1, -1);
  
  exports.Position = Position;
  exports.DUMMY_POS = DUMMY_POS;
//});

},{}],15:[function(require,module,exports){
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/

/**
 * Helper function for determining whether a piece of code may terminate normally, or whether
 * it always returns/breaks/throws an exception.
 */
//if(typeof define !== 'function') {
//  var define = require('amdefine')(module);
//}
//
//define(function(require, exports) {
  var mayCompleteNormally = exports.mayCompleteNormally = function(nd) {
    switch(nd.type) {
    case 'ReturnStatement':
    case 'BreakStatement':
    case 'ContinueStatement':
    case 'ThrowStatement':
      return false;
    case 'IfStatement':
      return mayCompleteNormally(nd.consequent) || nd.alternate && mayCompleteNormally(nd.alternate);
    case 'WithStatement':
      return mayCompleteNormally(nd.body);
    case 'BlockStatement':
      for(var i=0;i<nd.body.length;++i)
        if(!mayCompleteNormally(nd.body[i]))
          return false;
      return true;
    default:
      return true;
    }
  };
//});

},{}],16:[function(require,module,exports){
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/

/**
 * Utility functions to collect all variable and function declarations in a subtree.
 */
//if(typeof define !== 'function') {
//  var define = require('amdefine')(module);
//}
//
//define(function(require, exports) {
  var ast = require('../../common/lib/ast');

  function getDeclName(decl) {
    if(decl.type === 'Identifier')
      return decl.name;
    return decl.id.name;
  }

  function collectDecls(nd, accu) {
    if(!nd)
      return accu;
    
    if(nd.type === 'FunctionDeclaration') {
      accu[accu.length] = nd;
    } else if(nd.type === 'VariableDeclarator') {
      accu[accu.length] = nd;
    } else if(nd.type !== 'FunctionExpression') {
      ast.forEachChild(nd, function(ch) {
        collectDecls(ch, accu);
      });
    }
    return accu;
  }
  
  exports.collectDecls = collectDecls;
  exports.getDeclName = getDeclName;
//});

},{"../../common/lib/ast":13}],17:[function(require,module,exports){
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/

/**
 * The normalizer itself. The main entry point is function 'normalize', which takes
 * an AST to normalize and an object with options.
 */
//if(typeof define !== 'function') {
//  var define = require('amdefine')(module);
//}
//
//define(function(require, exports) {
  var ast = require('../../common/lib/ast'),
      cflow = require('./cflow'),
      decls = require('./decls'),
      scopes = require('./scope'),
      position = require('../../common/lib/position');

  // for Array.prototype.flatmap
  require('./util');
  
  /** Some AST helper functions. */
  function getBase(nd) {
    if(nd.type !== 'MemberExpression')
      throw new Error("argument should be member expression");
    return nd.object;
  }
  
  function getIndex(nd) {
    if(nd.type !== 'MemberExpression')
      throw new Error("argument should be member expression");
    return nd.computed ? nd.property : new ast.Literal(nd.property.name);
  }
  
  function isLoop(nd) {
    switch(nd.type) {
    case 'WhileStatement':
    case 'DoWhileStatement':
    case 'ForStatement':
    case 'ForInStatement':
      return true;
    case 'LabeledStatement':
      return isLoop(nd.body);
    default:
      return false;
    }
  }
  
  /** Default options for the normalizer. */
  var default_options = {
    /** Ensure compatibility with previous implementation of normalizer. */
    backwards_compatible: false,
    
    /** Use more complex translation of global variable reads that leads to
     *  a ReferencError for undefined, undeclared globals; backwards_compatible
     *  implies 'false'. */
    reference_errors: false,
    
    /** Use only one return statement per function; backwards_compatible
     *  implies 'false'. */
    unify_ret: false,
    
    /** Unfold if statements so that only one branch is non-empty; backwards_compatible
     * implies 'true'. */
    unfold_ifs: false,

    /** Pretty-printer; doesn't do anything by default */
    pp: function() {}
  };
  
  function processOptions(options) {
    options = options || {};
    
    for(var p in default_options)
      if(!(p in options))
        options[p] = default_options[p];
    
    if(options.backwards_compatible) {
      options.reference_errors = false;
      options.unify_ret = false;
      options.unfold_ifs = true;
    }
    
    return options;
  }
  
  function normalize(nd, options) {
    options = processOptions(options);
    
    if(options.backwards_compatible) {
      ast.EmptyStatement = function() {
        return new ast.BlockStatement([]);
      };
      ast.EmptyStatement.children = [];      
    }
    
    /**
     * Creates a block containing the given statements. If no statements are provided, inserts no-op statement.
     * Also inserts no-op after last statement if that statement happens to be an 'if'; this is a workaround
     * for counterfactual execution, which needs to set a flag on the first statement after the 'if' to
     * communicate to the phi function inserter that it doesn't need to flush the heap. Ugly.
     */
    function mkBlock(stmts) {
      if(stmts.length === 0)
        stmts = [new ast.EmptyStatement()];
      if(options.backwards_compatible)
        stmts = insertNoOpAfterFinalIf(stmts);
      return new ast.BlockStatement(stmts);
    }
    
    function insertNoOpAfterFinalIf(stmts) {
      if(stmts.length && stmts[stmts.length-1].type === 'IfStatement')
        stmts[stmts.length++] = new ast.EmptyStatement();
      return stmts;
    }
    
    /** Counter for generating temporary variable names. */
    var tmpCount = 0;
    var tmp_prefix = "tmp";
    
    function isTmp(name) {
      return name.substring(0, tmp_prefix.length) === tmp_prefix &&
             Number(name.substring(tmp_prefix.length)) < tmpCount;
    }
    
    /** Determine URL of program */
    var url = nd.url || options.url || "<unknown>";
    
    /** Utility function to copy position information of old_node onto new_nodes,
     *  unless they already have positions. This copy is recursive, traversing
     *  all child nodes of any new nodes that do not have positions yet. */
    function inheritPosition(new_nodes, old_node) {
      var old_pos;
      if(ast.hasPosition(old_node)) {
        old_pos = ast.getPosition(old_node);
      } else if(old_node.range && old_node.loc) {
        old_pos = new position.Position(url,
                                        old_node.loc.start.line, old_node.range[0],
                                        old_node.loc.end.line, old_node.range[1]);
      } else {
        old_pos = position.DUMMY_POS;
      }
      
      function help(nd) {
        if(Array.isArray(nd))
          nd.forEach(help);
        if(nd && typeof nd.type === 'string' && !ast.hasPosition(nd)) {
          ast.setPosition(nd, old_pos.clone());
          ast.forEachChild(nd, help);
        }
      }
      
      help(new_nodes);
      return new_nodes;
    }

    /** Utility function for attaching source code comment to normalized statements. */
    function attachComment(stmts) {
	if(!stmts.length)
	    return;

	var comment_text = "";
	for(var i=1;i<arguments.length;++i) {
	    var fragment = arguments[i];
	    if(typeof fragment !== 'string')
		fragment = options.pp(fragment);
	    if(typeof fragment !== 'string')
		return;
	    comment_text += fragment;
	}
	comment_text = ' ' + comment_text.replace(/\s+/g, ' ');
	
	if(!stmts[0].leadingComments)
	    stmts[0].leadingComments = [];
	stmts[0].leadingComments.push({ type: 'Line', value: comment_text });
    }
      
    /** Normalize an entity, i.e., a program or a function. */
    function normalizeEntity(root, scope) {
      /** Declarations of temporary variables generated by the normalizer for this entity. */
      var tmps = [];
      
      /** Helper function for generating one new temporary name.
       *  If isLbl is true, the new name is to be used as a label and should not be entered
       *  into the tmps array. */
      function genTmp(isLbl) {
        var name = tmp_prefix + (tmpCount++);
        if(!isLbl)
          tmps[tmps.length] = new ast.VariableDeclarator(new ast.Identifier(name), null);
        return name;
      }
      
      /** Generate n new temporary names. */
      function genTmps(n) {
        var res = [];
        for(var i=0;i<n;++i)
          res[i] = genTmp();
        return res;
      }
      
      /** When unifying return statements, every function gets a return label and a return
       *  variable. The body is wrapped into a block of the form
       *  
       *  <pre>
       *    var ret_var;
       *    ret_label: {
       *    }
       *    return ret_var;
       *  </pre>
       *  
       *  Then, every return statement <code>return e;</code> is replaced by
       *  <code>ret_var = e; break ret_label;</code>. */
      var ret_label = null, ret_var = null;
      if(options.unify_ret && (root.type === 'FunctionDeclaration' ||
                               root.type === 'FunctionExpression')) {
        ret_label = genTmp(true);
        ret_var = genTmp();
      }
      
      /** Normalize an expression with the given target variable. If the target is null,
       *  a new temporary name is generated when necessary. */
      function normalizeExpression(nd, target) {
        var res;
        function getTarget() {
          return target || (target = genTmp());
        }
        
        switch(nd.type) {
        case 'Literal':
          // target = literal;
          res = [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()), nd))];
          break;
      
        case 'Identifier':
          var tmp = null;
          if(!isTmp(nd.name) && scope.isGlobal(nd.name)) {
            // global reads are rewritten into property accesses on __global; however, reading an undeclared, undefined global
            // should result in a ReferenceError, so we (optionally) introduce an if statement checking whether the global has
            // been declared/defined, and throw an error if not
          
            // temporary to hold the name of the global
            tmp = genTmp();
            res = [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(tmp), new ast.Literal(nd.name)))];
          
            if(!options.reference_errors || scope.isDeclaredGlobal(nd.name)) {
              // target = __global[tmp];
              res[1] = new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()),
                                                                                     new ast.MemberExpression(new ast.Identifier('__global'), new ast.Identifier(tmp), true)));
            } else {
              // check for shadowing of ReferenceError; give up if this happens
              // TODO: even if it isn't shadowed, some clown may have overwritten ReferenceError...
              if(!scope.isGlobal('ReferenceError'))
                throw new Error("global variable ReferenceError is shadowed");
            
              /* tmp2 = x in __global;
               * if(tmp2) {
               *   target = __global[tmp2];
               * } else {
               *   tmp3 = 'ReferenceError';
               *   tmp4 = __global[tmp3];
               *   tmp5 = new tmp4();
               *   throw tmp5;
               * } */
              var tmp2 = genTmp(), tmp3 = genTmp(), tmp4 = genTmp(), tmp5 = genTmp();
              res = res.concat(new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(tmp2), new ast.BinaryExpression('in', new ast.Identifier(tmp), new ast.Identifier('__global')))),
                               mkIf(tmp2,
                                    [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()), new ast.MemberExpression(new ast.Identifier('__global'), new ast.Identifier(tmp), true)))],
                                    [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(tmp3), new ast.Literal('ReferenceError'))),
                                     new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(tmp4), new ast.MemberExpression(new ast.Identifier('__global'), new ast.Identifier(tmp3), true))),
                                     new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(tmp5), new ast.NewExpression(new ast.Identifier(tmp4), []))),
                                     new ast.ThrowStatement(new ast.Identifier(tmp5))]));
            }
          } else {
            // locals are easy: target = x;
            res = [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()), new ast.Identifier(nd.name)))];
          }
        
          // handle possible 'with' bindings
          var with_bindings = scope.possibleWithBindings(nd.name);
          if(with_bindings.length) {
            var prelude = null;
          
            // load name of variable into 'tmp'; store code to do so into 'prelude'
            if(tmp) {
              prelude = res[0];
              res.shift();
            } else {
              tmp = genTmp();
              prelude = new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(tmp), new ast.Literal(nd.name))); 
            }
        
            with_bindings.forEach(function(with_var) {
              /*
               * tmp2 = tmp in with_var;
               * if(tmp2) {
               *   target = with_var[tmp];
               * } else {
               *   ...
               * }
               */
              var tmp2 = genTmp();
              res = [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(tmp2), new ast.BinaryExpression('in', new ast.Identifier(tmp), new ast.Identifier(with_var)))),
                     new ast.IfStatement(new ast.Identifier(tmp2),
                                         mkBlock([new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()), new ast.MemberExpression(new ast.Identifier(with_var), new ast.Identifier(tmp), true)))]),
                                         mkBlock(res))];
            });
          
            res.unshift(prelude);
          }
          break;
        
        case 'ArrayExpression':
          // allocate one temporary variable per array element (y1, ..., yn)
          var elt_tmps = genTmps(nd.elements.length);
          // recursively normalize array element expressions, skipping over omitted elements; the temporary will then
          // keep its initial undefined value, which is what we want
          var elements = nd.elements.flatmap(function(elt, i) { return elt ? normalizeExpression(elt, elt_tmps[i]) : []; });
          // target = [y1, ..., yn];
          res =  elements.concat(new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()),
                                                                                               new ast.ArrayExpression(elt_tmps.map(function(tmp) { return new ast.Identifier(tmp); })))));
          break;
          
        case 'ObjectExpression':
          // allocate one temporary variable per property; we may not need all of them if there are getters or setters
          var prop_tmps = genTmps(nd.properties.length);
          var props = [];
          var body = nd.properties.flatmap(function(prop, i) {
            switch(prop.kind) {
            case 'init':
              props[props.length] = new ast.Property(prop.key, new ast.Identifier(prop_tmps[i]), 'init');
              inheritPosition(props[props.length-1], prop);
              // recursively normalize property value expression
              return normalizeExpression(prop.value, prop_tmps[i]);
            case 'get':
            case 'set':
              // recursively normalize getter/setter
              var funexpr = normalizeEntity(prop.value, new scopes.FunctionScope(scope, prop.value));
              props[props.length] = new ast.Property(prop.key, funexpr, prop.kind);
              inheritPosition(props[props.length-1], prop);
              return [];
            default:
              throw new Error();
            }
          });
          res =  body.concat(new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()),
                                                                                           new ast.ObjectExpression(props))));
          break;
          
        case 'MemberExpression':
          var base_tmp = genTmp(), index_tmp = genTmp();
          var base = normalizeExpression(getBase(nd), base_tmp);
          var index = normalizeExpression(getIndex(nd), index_tmp);
          var idx = new ast.MemberExpression(new ast.Identifier(base_tmp), new ast.Identifier(index_tmp), true);
          // remember whether this member expression was a computed one originally
          if(nd.computed)
            ast.setAttribute(idx, 'isComputed', true);
          res =  base.concat(index,
                             new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()), idx)));
          break;
          
        case 'ThisExpression':
          if(scope instanceof scopes.GlobalScope)
            res =  [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()), new ast.Identifier('__global')))];
          else
            res =  [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()), new ast.ThisExpression()))];
          break;
          
        case 'FunctionExpression':
          var fn = normalizeEntity(nd, new scopes.FunctionScope(scope, nd));
          res = [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()), fn))];
          break;
        
        case 'AssignmentExpression':
          if(nd.operator === '=') {
            // simple assignments are handled similar to case 'Identifier' above
            if(nd.left.type === 'Identifier') {
              var res, tmp = null, right;
              var with_bindings = scope.possibleWithBindings(nd.left.name);
              if(!isTmp(nd.left.name) && scope.isGlobal(nd.left.name)) {
                tmp = genTmp();
                right = normalizeExpression(nd.right, getTarget());
                res = [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(tmp), new ast.Literal(nd.left.name))),
                       new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.MemberExpression(new ast.Identifier('__global'), new ast.Identifier(tmp), true),
                                                                                     new ast.Identifier(getTarget())))];
              } else {
                // mark variables that are written across scopes
                if(!scope.isLocal(nd.left.name))
                  ast.setAttribute(scope.lookup(nd.left.name), 'exposed', true);
              
                if(target || with_bindings.length) {
                  right = normalizeExpression(nd.right, getTarget());
                  res = [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(nd.left.name), new ast.Identifier(getTarget())))];
                } else {
                  target = nd.left.name;
                  right = normalizeExpression(nd.right, nd.left.name);
                  res = [];
                }
              }
            
              // handle 'with'
              if(with_bindings.length) {
                var prelude = null;
                if(tmp) {
                  prelude = res[0];
                  res.shift();
                } else {
                  tmp = genTmp();
                  prelude = new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(tmp), new ast.Literal(nd.left.name))); 
                }
            
                with_bindings.forEach(function(with_var) {
                  var tmp2 = genTmp();
                  res = [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(tmp2), new ast.BinaryExpression('in', new ast.Identifier(tmp), new ast.Identifier(with_var)))),
                         new ast.IfStatement(new ast.Identifier(tmp2),
                                             mkBlock([new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.MemberExpression(new ast.Identifier(with_var), new ast.Identifier(tmp), true), new ast.Identifier(getTarget())))]),
                                             mkBlock(res))];
                });
              
                res.unshift(prelude);
              }
            
              res = right.concat(res);
            } else if(nd.left.type === 'MemberExpression') {
              var base_tmp = genTmp(), index_tmp = genTmp();
              var base = normalizeExpression(getBase(nd.left), base_tmp),
                  index = normalizeExpression(getIndex(nd.left), index_tmp);
              var lhs = new ast.MemberExpression(new ast.Identifier(base_tmp), new ast.Identifier(index_tmp), true);
            
              if(nd.left.computed)
                ast.setAttribute(lhs, 'isComputed', true);
            
              var rhs_comp = normalizeExpression(nd.right, getTarget());
              res = base.concat(index, rhs_comp, new ast.ExpressionStatement(new ast.AssignmentExpression('=', lhs, new ast.Identifier(getTarget()))));
            } else {
              throw new Error("unexpected lhs of type " + nd.left.type);
            }
          } else {
            // compound assignments are desugared into normal assignments and then rewritten recursively
            var op = nd.operator.substring(0, nd.operator.length-1);
            var lhs = nd.left, rhs = nd.right;
          
            if(nd.left.type === 'Identifier') {
              var tmp = genTmp();
              res = normalizeExpression(rhs, tmp)
                    .concat(normalizeExpression(new ast.AssignmentExpression('=', new ast.Identifier(nd.left.name), new ast.BinaryExpression(op, new ast.Identifier(nd.left.name), new ast.Identifier(tmp)))));
            } else if(nd.left.type === 'MemberExpression') {
              var tmp = genTmp(), trg = getTarget();
              var base_tmp = genTmp(), index_tmp = genTmp(), extra = genTmp();
            
              res = normalizeExpression(getBase(lhs), base_tmp)
                   .concat(normalizeExpression(getIndex(lhs), index_tmp),
                           new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(extra), 
                                                                                         new ast.MemberExpression(new ast.Identifier(base_tmp), new ast.Identifier(index_tmp), true))),
                           normalizeExpression(rhs, tmp),
                           new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(trg),
                                                                                         new ast.BinaryExpression(op, new ast.Identifier(extra), new ast.Identifier(tmp)))),
                           new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.MemberExpression(new ast.Identifier(base_tmp), new ast.Identifier(index_tmp), true), new ast.Identifier(target))));
            } else {
              throw new Error("unexpected lhs");
            }
          }
          break;
        
        case 'CallExpression':
          if(nd.callee.type === 'MemberExpression') {
            var base_tmp = genTmp(), index_tmp = genTmp();
            var base = normalizeExpression(getBase(nd.callee), base_tmp);
            var index = normalizeExpression(getIndex(nd.callee), index_tmp);
            var arg_tmps = genTmps(nd.arguments.length);
            var args = nd.arguments.flatmap(function(arg, i) { return normalizeExpression(arg, arg_tmps[i]); });
            var callee = new ast.MemberExpression(new ast.Identifier(base_tmp), new ast.Identifier(index_tmp), true);
          
            if(nd.callee.computed)
              ast.setAttribute(callee, 'isComputed', true);
          
            res = base.concat(index, args,
                              new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()),
                                                                                            new ast.CallExpression(callee, arg_tmps.map(function(tmp) { return new ast.Identifier(tmp); })))));
            break;
          } else if(nd.callee.type === 'Identifier') {
            if(nd.callee.name === 'eval') {
              // TODO: handle 'eval' inside 'with'
              var arg_tmps = genTmps(nd.arguments.length);
              var args = nd.arguments.flatmap(function(arg, i) { return normalizeExpression(arg, arg_tmps[i]); });
              res = args.concat(new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()),
                                                                                              new ast.CallExpression(nd.callee, arg_tmps.map(function(tmp) { return new ast.Identifier(tmp); })))));
            } else {
              var tmp = genTmp();
              var fn = normalizeExpression(nd.callee, tmp);
              var arg_tmps = genTmps(nd.arguments.length);
              var args = nd.arguments.flatmap(function(arg, i) { return normalizeExpression(arg, arg_tmps[i]); });
              res = [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()),
                                                                                   new ast[nd.type](new ast.Identifier(tmp), arg_tmps.map(function(tmp) { return new ast.Identifier(tmp); }))))];
            
              var with_bindings = scope.possibleWithBindings(nd.callee.name);
              if(with_bindings.length) {
                var name_tmp = genTmp();
                var prelude = new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(name_tmp), new ast.Literal(nd.callee.name))); 
              
                with_bindings.forEach(function(with_var) {
                  var tmp2 = genTmp();
                  res = [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(tmp2), new ast.BinaryExpression('in', new ast.Identifier(name_tmp), new ast.Identifier(with_var)))),
                         new ast.IfStatement(new ast.Identifier(tmp2),
                                             mkBlock([new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()),
                                                                                                                    new ast.CallExpression(new ast.MemberExpression(new ast.Identifier(with_var), new ast.Identifier(name_tmp), true), 
                                                                                                                                           arg_tmps.map(function(tmp) { return new ast.Identifier(tmp); }))))]),
                                             mkBlock(res))];
                });
              
                res.unshift(prelude);
              }
            
              res = fn.concat(args, res);
            }
            break;
          }
        
        case 'NewExpression':
          var tmp = genTmp();
          var fn = normalizeExpression(nd.callee, tmp);
          var arg_tmps = genTmps(nd.arguments.length);
          var args = nd.arguments.flatmap(function(arg, i) { return normalizeExpression(arg, arg_tmps[i]); });
          res = fn.concat(args, new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()),
                                                                                              new ast[nd.type](new ast.Identifier(tmp), arg_tmps.map(function(tmp) { return new ast.Identifier(tmp); })))));
          break;
          
        case 'SequenceExpression':
          var n = nd.expressions.length;
          res = nd.expressions.flatmap(function(expr, i) {
            if(i < n - 1)
              return normalizeExpression(expr);
            return normalizeExpression(expr, target);
          });
          break;
        
        case 'LogicalExpression':
          var ltmp, l, r;
          if(nd.operator === '&&') {
            ltmp = genTmp();
            l = normalizeExpression(nd.left, ltmp);
            res = mkIf(ltmp, normalizeExpression(nd.right, getTarget()),
                             [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()), new ast.Identifier(ltmp)))]);
            res = l.concat(res);
          } else if(nd.operator === '||') {
            ltmp = genTmp();
            l = normalizeExpression(nd.left, ltmp);
            res = mkIf(ltmp, [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()), new ast.Identifier(ltmp)))],
                             normalizeExpression(nd.right, getTarget()));
            res = l.concat(res);
          } else {
            throw new Error("unknown logical expression");
          }
          break;
        
        case 'BinaryExpression':
          var ltmp = genTmp(), rtmp = genTmp();
          l = normalizeExpression(nd.left, ltmp);
          r = normalizeExpression(nd.right, rtmp);
          res = new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()),
                                                                              new ast.BinaryExpression(nd.operator, new ast.Identifier(ltmp), new ast.Identifier(rtmp))));
          res = l.concat(r, res);
          break;
        
        case 'ConditionalExpression':
          var tmp = genTmp();
          res = normalizeExpression(nd.test, tmp)
               .concat(mkIf(tmp, normalizeExpression(nd.consequent, target), 
                                 normalizeExpression(nd.alternate, target)));
          break;
        
        case 'UpdateExpression':
          var op = nd.operator === '++' ? '+' : '-';
          // postfix expressions in void context are handled like prefix expressions
          if(!nd.prefix && target) {
            if(nd.argument.type === 'Identifier') {
              res = normalizeExpression(nd.argument, target)
                   .concat(normalizeExpression(new ast.AssignmentExpression('=', new ast.Identifier(nd.argument.name), 
                                                                                 new ast.BinaryExpression(op, new ast.Identifier(nd.argument.name), new ast.Literal(1)))));
            
            } else if(nd.argument.type === 'MemberExpression') {
              var trg = getTarget();
              var base_tmp = genTmp(), index_tmp = genTmp(), extra = genTmp(), extra_extra = genTmp();
              res = normalizeExpression(getBase(nd.argument), base_tmp)
                   .concat(normalizeExpression(getIndex(nd.argument), index_tmp),
                           new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(trg), 
                                                                                         new ast.MemberExpression(new ast.Identifier(base_tmp), new ast.Identifier(index_tmp), true))),
                           new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(extra_extra), new ast.Literal(1))),
                           new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(extra), new ast.BinaryExpression(op, new ast.Identifier(target), new ast.Identifier(extra_extra)))),
                           new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.MemberExpression(new ast.Identifier(base_tmp), new ast.Identifier(index_tmp), true), new ast.Identifier(extra))));
            } else {
              throw new Error("unexpected operand to postfix expression");
            }
          } else {
            if(nd.argument.type === 'Identifier') {
              res = normalizeExpression(new ast.AssignmentExpression('=', nd.argument, new ast.BinaryExpression(op, new ast.Identifier(nd.argument.name), new ast.Literal(1))),
                                        target);
            } else if(nd.argument.type === 'MemberExpression') {
              var trg = getTarget();
              var base_tmp = genTmp(), index_tmp = genTmp(), extra = genTmp(), extra_extra = genTmp();
              res = normalizeExpression(getBase(nd.argument), base_tmp)
                   .concat(normalizeExpression(getIndex(nd.argument), index_tmp),
                           new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(extra), 
                                                                                         new ast.MemberExpression(new ast.Identifier(base_tmp), new ast.Identifier(index_tmp), true))),
                           new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(extra_extra), new ast.Literal(1))),
                           new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(trg),
                                                                                         new ast.BinaryExpression(op, new ast.Identifier(extra), new ast.Identifier(extra_extra)))),
                           new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.MemberExpression(new ast.Identifier(base_tmp), new ast.Identifier(index_tmp), true),
                                                                                         new ast.Identifier(target))));
            } else {
              throw new Error("unexpected operand to prefix expression");
            }
          }
          break;
        
        case 'UnaryExpression': 
          var op = nd.operator;
          if(op === 'delete') {
            if(nd.argument.type === 'Identifier') {
              if(!isTmp(nd.argument.name) && scope.isGlobal(nd.argument.name)) {
                var trg = getTarget();
                var tmp = genTmp();
                res = [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(tmp), new ast.Literal(nd.argument.name))),
                       new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(trg),
                                                                                     new ast.UnaryExpression('delete',
                                                                                                             new ast.MemberExpression(new ast.Identifier('__global'),
                                                                                                                                      new ast.Identifier(tmp), true))))];              
              } else {
                res = [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()), nd))];
              }
            } else if(nd.argument.type === 'MemberExpression') {
              var trg = getTarget();
              var base_tmp = genTmp(), index_tmp = genTmp();
              res = normalizeExpression(getBase(nd.argument), base_tmp)
                   .concat(normalizeExpression(getIndex(nd.argument), index_tmp),
                           new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(trg),
                                                                                         new ast.UnaryExpression('delete',
                                                                                                                 new ast.MemberExpression(new ast.Identifier(base_tmp),
                                                                                                                                           new ast.Identifier(index_tmp), true)))));
            } else {
              throw new Error();
            }
          } else {
            var tmp = genTmp();
            res = normalizeExpression(nd.argument, tmp)
                 .concat(new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(getTarget()),
                                                                                       new ast.UnaryExpression(op, new ast.Identifier(tmp)))));
          }
          break;
        
        default:
          throw new Error("unknown expression type: " + nd.type);
        }
        return inheritPosition(res, nd);
      }
      
      function normalizeStatement(nd, brk_label, cont_label) {
        var res;
        
        function rec(stmt) {
          return normalizeStatement(stmt, brk_label, cont_label);
        }
      
        switch(nd.type) {
        case 'EmptyStatement':
          res = [];
	  attachComment(res, nd);
          break;
          
        case 'ExpressionStatement':
          res = normalizeExpression(nd.expression);
	  attachComment(res, nd);
          break;
          
        // variable declarations are collected by normalizeEntity(); all we need to do here is to extract initializers into assignments
        case 'VariableDeclaration':
          res = nd.declarations.flatmap(rec);
	  attachComment(res, nd);
          break;
        
        case 'VariableDeclarator':
          if(nd.init)
            res = normalizeExpression(new ast.AssignmentExpression('=', new ast.Identifier(nd.id.name), nd.init));
          else
            res = [];
          break;
        
        // function declarations are collected by normalizeEntity()
        case 'FunctionDeclaration':
          res = [];
          break;
        
        case 'BlockStatement':
          res = nd.body.flatmap(rec);
          break;
        
        case 'ReturnStatement':
          if(options.unify_ret) {
            res = nd.argument ? normalizeExpression(nd.argument, ret_var) : [];
            res.push(new ast.BreakStatement(new ast.Identifier(ret_label)));
          } else {
            if(nd.argument) {
              var tmp = genTmp();
              res = normalizeExpression(nd.argument, tmp).concat(new ast.ReturnStatement(new ast.Identifier(tmp)));
            } else {
              res = [new ast.ReturnStatement(null)];
            }
          }
	  attachComment(res, nd);
          break;
        
        case 'DebuggerStatement':
          res = [new ast.DebuggerStatement()];
	  attachComment(res, nd);
          break;
        
        case 'IfStatement':
          var tmp = genTmp();
          var res = normalizeExpression(nd.test, tmp);
          var thenBranch = rec(nd.consequent);
          var elseBranch = nd.alternate ? rec(nd.alternate) : [];
          res = res.concat(mkIf(tmp, thenBranch, elseBranch));
	  attachComment(res, "if(", nd.test, ")");
          break;
        
        case 'ThrowStatement':
          var tmp = genTmp();
          res = normalizeExpression(nd.argument, tmp).concat(new ast.ThrowStatement(new ast.Identifier(tmp)));
	  attachComment(res, nd);
          break;
        
        case 'TryStatement':
          // handle incompatibility between Esprima and Acorn ASTs
          if(!nd.handlers)
            nd.handlers = nd.handler ? [nd.handler] : [];

          if(nd.handlers.length > 0 && nd.finalizer) {
            res = rec(new ast.TryStatement(new ast.BlockStatement([new ast.TryStatement(nd.block, nd.guardedHandlers, nd.handlers, null)]),
                                           [], [], nd.finalizer));
          } else if(nd.handlers.length > 0) {
            if(nd.guardedHandlers && nd.guardedHandlers.length > 0 || nd.handlers.length > 1)
              throw new Error("fancy catch clauses not supported");
          
            var tryblock = rec(nd.block);
            scope = new scopes.CatchScope(scope, nd.handlers[0]);
            var catchblock = rec(nd.handlers[0].body);
            scope = scope.outer;
  
            res = [new ast.TryStatement(mkBlock(tryblock), [], [new ast.CatchClause(nd.handlers[0].param, mkBlock(catchblock))], null)];
          } else if(nd.finalizer) {
            var tryblock = rec(nd.block);
            if(nd.finalizer.body.length === 0) {
              res = tryblock;
            } else {
              var finallyblock = rec(nd.finalizer);
              res = [new ast.TryStatement(mkBlock(tryblock), [], [], mkBlock(finallyblock))];
            }
          }
	  attachComment(res, "try");
          break;
        
        case 'LabeledStatement':
          var stmts = normalizeStatement(nd.body, nd.label.name, isLoop(nd.body) ? nd.label.name : cont_label);
          res = [new ast.LabeledStatement(nd.label, mkBlock(stmts))];
          attachComment(res, nd.label.name + ": { ... }");
          break;
        
        case 'BreakStatement':
          if(nd.label)
            res = [nd];
          else
            res = [new ast.BreakStatement(new ast.Identifier(brk_label))];
          attachComment(res, nd);
          break;
        
        case 'ContinueStatement':
          if(nd.label)
            res = [new ast.BreakStatement(new ast.Identifier(nd.label.name))];
          else
            res = [new ast.BreakStatement(new ast.Identifier(cont_label))];
          attachComment(res, nd);
          break;
        
        case 'WhileStatement':
          var condtmp = genTmp();
          var brk_lbl = genTmp(true), cont_lbl = genTmp(true);

          // initial computation of condition
          var cond1 = normalizeExpression(nd.test, condtmp);
          // while body
          var body = [new ast.LabeledStatement(new ast.Identifier(cont_lbl), mkBlock(normalizeStatement(nd.body, brk_lbl, cont_lbl)))];
          // computation of updated condition
          var cond2 = normalizeExpression(nd.test, condtmp);
          res = cond1.concat(new ast.LabeledStatement(new ast.Identifier(brk_lbl),
                                                      new ast.BlockStatement([new ast.WhileStatement(new ast.Identifier(condtmp),
                                                                                                     mkBlock(body.concat(cond2)))])));
	  attachComment(res, "while(", nd.test, ")");
          break;
        
        case 'DoWhileStatement':
          var tmp = genTmp();
          var brk_lbl = genTmp(true), cont_lbl = genTmp(true);
        
          var body = [new ast.LabeledStatement(new ast.Identifier(cont_lbl), mkBlock(normalizeStatement(nd.body, brk_lbl, cont_lbl)))];
          var cond = normalizeExpression(nd.test, tmp);
          res = [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(tmp), new ast.Literal(true))),
                 new ast.LabeledStatement(new ast.Identifier(brk_lbl), new ast.BlockStatement([new ast.WhileStatement(new ast.Identifier(tmp),
                                                                                                                      mkBlock(body.concat(cond)))]))];
	  attachComment(res, "do { ... } while(", nd.test, ");");
          break;
        
        case 'ForInStatement':
          if(nd.left.type === 'VariableDeclaration') {
            res = rec(nd.left).concat(rec(new ast.ForInStatement(new ast.Identifier(nd.left.declarations[0].id.name), nd.right, nd.body)));
          } else if(nd.left.type === 'Identifier') {
            var tmp = genTmp(), brk_lbl = genTmp(true), cont_lbl = genTmp(true);

            var init = normalizeExpression(nd.right, tmp);

            var body = [new ast.LabeledStatement(new ast.Identifier(cont_lbl), mkBlock(normalizeStatement(nd.body, brk_lbl, cont_lbl)))];
        
            var loopVar;
            if(scope.isLocal(nd.left.name)) {
              loopVar = nd.left.name;
            } else {
              loopVar = genTmp();
              body = normalizeExpression(new ast.AssignmentExpression('=', new ast.Identifier(nd.left.name), new ast.Identifier(loopVar)))
                    .concat(body);
            }
        
            res = init.concat(new ast.LabeledStatement(new ast.Identifier(brk_lbl), 
                                                       new ast.BlockStatement([new ast.ForInStatement(new ast.Identifier(loopVar), new ast.Identifier(tmp),
                                                                                                      mkBlock(body))])));
          } else {
            // TODO: support member expressions as nd.left
            throw new Error("cannot handle for-in loop");
          }
	  attachComment(res, "for(", nd.left, " in ", nd.right, ") { ... }");
          break;
        
        case 'ForStatement':
          var init = nd.init ? (nd.init.type === 'VariableDeclaration' ? rec(nd.init) : normalizeExpression(nd.init)) : [];
          var condVar = genTmp();
          var cond1, cond2;
          if(!nd.test) {
            cond1 = [new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(condVar), new ast.Literal(true)))];
            cond2 = [];
          } else {
            cond1 = normalizeExpression(nd.test, condVar);
            cond2 = normalizeExpression(nd.test, condVar);
          }
          var update = nd.update ? normalizeExpression(nd.update) : [];
          var brk_lbl = genTmp(true), cont_lbl = genTmp(true);
          var body = [new ast.LabeledStatement(new ast.Identifier(cont_lbl), mkBlock(normalizeStatement(nd.body, brk_lbl, cont_lbl)))];
          res = init.concat(cond1,
                            new ast.LabeledStatement(new ast.Identifier(brk_lbl),
                                                     new ast.BlockStatement([new ast.WhileStatement(new ast.Identifier(condVar),
                                                                                                    mkBlock(body.concat(update, cond2)))])));
	  attachComment(res, "for(", nd.init || "", ";", nd.test || "", ";", nd.update || "", ") { ... }");
          break;
          
        case 'SwitchStatement':
          var tmp = genTmp(), lbl = genTmp(true);
  
          var cond = normalizeExpression(nd.discriminant, tmp);
          
          // initialise default to single no-op statement
          var default_stmts = [new ast.EmptyStatement()];
          var body = default_stmts;
  
          if(nd.cases)
            for(var i=nd.cases.length-1;i>=0;--i) {
              if(!nd.cases[i].test) {
                // overwrite default statements
                default_stmts.length = 0;
                Array.prototype.push.apply(default_stmts, nd.cases[i].consequent.flatmap(function(stmt) { return normalizeStatement(stmt, lbl, cont_label); }));
              } else {
                var all_stmts = nd.cases[i].consequent;
                for(var j=i+1;j<nd.cases.length;++j) {
                  if(all_stmts.length && !cflow.mayCompleteNormally(all_stmts[all_stmts.length-1]))
                    break;
                  Array.prototype.push.apply(all_stmts, nd.cases[j].consequent);
                }
                var tmp2 = genTmp(), tmp3 = genTmp();
                body = normalizeExpression(nd.cases[i].test, tmp2)
                      .concat(new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(tmp3),
                                                                                            new ast.BinaryExpression("===", new ast.Identifier(tmp), new ast.Identifier(tmp2)))),
                              new ast.IfStatement(new ast.Identifier(tmp3),
                                                  mkBlock(all_stmts.flatmap(function(stmt) { return normalizeStatement(stmt, lbl, cont_label); })),
                                                  mkBlock(body)));
              }
            }
  
          res = cond.concat(new ast.LabeledStatement(new ast.Identifier(lbl), mkBlock(body)));
          attachComment(res, "switch(", nd.discriminant, ") { ... }");
          break;
      
        case 'WithStatement':
          var tmp = genTmp();
          var preamble = normalizeExpression(nd.object, tmp);
          scope = new scopes.WithScope(scope, tmp);
          var body = rec(nd.body);
          scope = scope.outer;
          res = preamble.concat(body);
	  attachComment(res, "with(", nd.object, ") { ... }");
          break;
      
        default:
          throw new Error("unknown statement type " + nd.type);
        }
        
        return inheritPosition(res, nd);
      }

      /* To simplify counterfactual execution, we want to replace conditionals of the
       * form
       * 
       *     if(x) {
       *       ...
       *     } else {
       *       ...
       *     }
       * 
       * where both "then" and "else" branch are non-trivial with code
       * of the form
       * 
       *     if(x) {
       *       ...
       *     } else {
       *       ;
       *     }
       *     if(x) {
       *       ;
       *     } else {
       *       ...
       *     }
       */
      function mkIf(cond, thenBranch, elseBranch) {
        var thenTrivial = thenBranch.length === 0,
            elseTrivial = elseBranch.length === 0;
        if(options.unfold_ifs && !thenTrivial && !elseTrivial) {
          var tmp = genTmp();
          return []
                .concat(new ast.ExpressionStatement(new ast.AssignmentExpression('=', new ast.Identifier(tmp), new ast.Identifier(cond))))
                .concat(new ast.IfStatement(new ast.Identifier(cond), mkBlock(thenBranch), mkBlock([])))
                .concat(new ast.IfStatement(new ast.Identifier(tmp), mkBlock([]), mkBlock(elseBranch)));
        } else {
          return [new ast.IfStatement(new ast.Identifier(cond), mkBlock(thenBranch), mkBlock(elseBranch))];
        }
      }

      if(root.type === 'FunctionDeclaration' || root.type === 'FunctionExpression') {
        var body = normalizeStatement(root.body);

        if(options.backwards_compatible)
          insertNoOpAfterFinalIf(body);

        if(options.unify_ret)
          body = [new ast.LabeledStatement(new ast.Identifier(ret_label), new ast.BlockStatement(body)),
                  new ast.ReturnStatement(new ast.Identifier(ret_var))];
        else if(cflow.mayCompleteNormally(new ast.BlockStatement(body)))
          body.push(new ast.ReturnStatement(null));

        if(ast.getAttribute(root, 'exposed'))
          throw new Error("Cannot handle downward exposed function expressions.");

        // process locally declared functions
        var fundecls;
        if(options.backwards_compatible) {
          fundecls = [];
          scope.decls.forEach(function(decl) {
            if(decl.type === 'FunctionDeclaration')
              fundecls = normalizeExpression(inheritPosition(new ast.AssignmentExpression('=', new ast.Identifier(decl.id.name),
                                                                                               new ast.FunctionExpression(decl.id, decl.params, decl.body)), decl)).concat(fundecls);
          });
        } else {
          fundecls = scope.decls.flatmap(function(decl) {
            if(decl.type === 'FunctionDeclaration')
              return normalizeExpression(inheritPosition(new ast.AssignmentExpression('=', new ast.Identifier(decl.id.name),
                                                                                           new ast.FunctionExpression(null, decl.params, decl.body)), decl));
            return [];
          });
        }
        body = fundecls.concat(body);

        // create variable declaration for local variables, functions and generated temporaries
        var local_names = [];
        scope.decls.forEach(function(decl) {
          if(decl.type !== 'FunctionDeclaration' && decl.type !== 'VariableDeclarator')
            return;
          var name = decls.getDeclName(decl);
          if(local_names.indexOf(name) === -1)
            local_names[local_names.length] = name;
        });
        var localDecls = [].concat(local_names.map(function(x) { return new ast.VariableDeclarator(new ast.Identifier(x), null); }),
                                   tmps);
        if(localDecls.length > 0)
          body.unshift(new ast.VariableDeclaration(localDecls, 'var'));

        var fn_expr = new ast.FunctionExpression(root.id, root.params, new ast.BlockStatement(body));
        if(ret_var)
          ast.setAttribute(fn_expr, 'ret_var', ret_var);
        return inheritPosition(fn_expr, root);
      } else if(root.type === 'Program') {
        var body = root.body.flatmap(function(stmt) { return normalizeStatement(stmt); });
  
        // declarations for locally declared functions become assignments to be inserted at the beginning of the program
        var fundecls = scope.decls.flatmap(function(decl) {
          if(decl.type === 'FunctionDeclaration')
            return normalizeExpression(inheritPosition(new ast.AssignmentExpression('=', new ast.Identifier(decl.id.name),
                                                                                         new ast.FunctionExpression(options.backwards_compatible ? decl.id : null, 
                                                                                                                    decl.params, decl.body)), decl));
          return [];
        });
  
        // variable declaration for temporaries, if necessary
        var tmpdecls = tmps.length > 0 ? [new ast.VariableDeclaration(tmps, 'var')] : [];
  
        if(options.backwards_compatible)
          insertNoOpAfterFinalIf(body);
  
        // whole program is wrapped into (function(__global) { ... })(this);
        return new ast.Program([new ast.ExpressionStatement(new ast.CallExpression(new ast.FunctionExpression(null, [new ast.Identifier("__global")],
                                                                                                             new ast.BlockStatement(tmpdecls.concat(fundecls, body))),
                                                                                   [new ast.ThisExpression()]))]);
      }
    }
   
    return normalizeEntity(nd, new scopes.GlobalScope(nd));
  }
    
  exports.normalize = normalize;
//});

},{"../../common/lib/ast":13,"../../common/lib/position":14,"./cflow":15,"./decls":16,"./scope":18,"./util":19}],18:[function(require,module,exports){
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/

/**
 * Scope objects keep track of name binding. Each scope object represents
 * either the global scope, a function scope, a catch clause scope, or
 * a 'with' scope.
 */

//if(typeof define !== 'function') {
//  var define = require('amdefine')(module);
//}
//
//define(function(require, exports) {
  var decls = require('./decls');
  
  // abstract base class of all scopes
  function Scope(outer, decls) {
    this.outer = outer;
    this.decls = decls;
  }
  
  // is x a global variable in this scope?
  Scope.prototype.isGlobal = function(x) {
    return !this.isLocal(x) && this.outer.isGlobal(x);
  };
  
  // does x have a declaration at the global level?
  Scope.prototype.isDeclaredGlobal = function(x) {
    return this.outer.isDeclaredGlobal();
  };
  
  // look up x among the local declarations in this scope
  Scope.prototype.localLookup = function(x) {
    for(var i=0;i<this.decls.length;++i)
      if(decls.getDeclName(this.decls[i]) === x)
        return this.decls[i];
    return null;
  };
  
  // is x a local variable declared in this scope?
  Scope.prototype.isLocal = function(x) { return !!this.localLookup(x); };
  
  // look up x in this or an enclosing scope
  Scope.prototype.lookup = function(x) {
    return this.localLookup(x) || this.outer && this.outer.lookup(x);
  };
  
  // object representing the global scope
  function GlobalScope(root) {
    Scope.call(this, null, decls.collectDecls(root, []));
  }
  GlobalScope.prototype = Object.create(Scope.prototype);
  
  GlobalScope.prototype.isGlobal = function(x) { return true; };
  GlobalScope.prototype.isLocal = function(x) { return false; };
  GlobalScope.prototype.possibleWithBindings = function(x) { return []; };
  GlobalScope.prototype.isDeclaredGlobal = function(x) {
    return !!this.localLookup(x);
  };
    
  // constructor representing a function scope
  function FunctionScope(outer, fn) {
    this.fn = fn;
    Scope.call(this, outer, fn.params.concat(decls.collectDecls(fn.body, [])));
  }
  FunctionScope.prototype = Object.create(Scope.prototype);
  
  // 'arguments' and (in a named function expression) the function itself are local,
  // even though they are not declared
  FunctionScope.prototype.isLocal = function(x) {
    return x === 'arguments' ||
           this.fn.type === 'FunctionExpression' && this.fn.id && this.fn.id.name === x ||
           Scope.prototype.isLocal.call(this, x);
  };
  
  // list of enclosing with statements (represented by the variables they 'with' on) that
  // may bind x
  FunctionScope.prototype.possibleWithBindings = function(x) {
    if(this.isLocal(x))
      return [];
    return this.outer.possibleWithBindings(x);
  };
  
  // constructor representing a catch clause scope
  function CatchScope(outer, cc) {
    Scope.call(this, outer, [cc.param]);
  }
  CatchScope.prototype = Object.create(Scope.prototype);
  
  CatchScope.prototype.isLocal = function(x) { return x === this.decls[0].name || this.outer.isLocal(x); };
  
  CatchScope.prototype.possibleWithBindings = function(x) {
    if(x === this.decls[0].name)
      return [];
    return this.outer.possibleWithBindings(x);
  };
  
  // constructor representing a with scope
  function WithScope(outer, with_var) {
    Scope.call(this, outer, []);
    this.with_var = with_var;
  }
  WithScope.prototype = Object.create(Scope.prototype);
  
  WithScope.prototype.isLocal = function(x) { return this.outer.isLocal(x); };
  
  WithScope.prototype.possibleWithBindings = function(x) {
    var bindings = this.outer.possibleWithBindings(x);
    bindings.unshift(this.with_var);
    return bindings;
  };
  
  exports.Scope = Scope;
  exports.GlobalScope = GlobalScope;
  exports.FunctionScope = FunctionScope;
  exports.CatchScope = CatchScope;
  exports.WithScope = WithScope;
//});

},{"./decls":16}],19:[function(require,module,exports){
/*******************************************************************************
 * Copyright (c) 2012 IBM Corporation.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/

/**
 * Utility methods. 
 */
//if(typeof define !== 'function') {
//  var define = require('amdefine')(module);
//}
//
//define(function(require, exports) {
  var flatmap = function(fn, thisArg) {  
    var res = [];
    for(var i=0;i<this.length;++i) {
      var r = fn.call(thisArg, this[i], i, this);
      for(var j=0;j<r.length;++j)
        res[res.length] = r[j];
    }
    return res;
  };
  if(typeof Object.defineProperty !== 'undefined')
    Object.defineProperty(Array.prototype, 'flatmap', {
      value: flatmap,
      enumerable: false
    });
  else
    Array.prototype.flatmap = flatmap;
//});

},{}],20:[function(require,module,exports){
// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke and released under an MIT
// license. The Unicode regexps (for identifiers and whitespace) were
// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/marijnh/acorn/issues
//
// This file defines the main parser interface. The library also comes
// with a [error-tolerant parser][dammit] and an
// [abstract syntax tree walker][walk], defined in other files.
//
// [dammit]: acorn_loose.js
// [walk]: util/walk.js

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") return mod(exports); // CommonJS
  if (typeof define == "function" && define.amd) return define(["exports"], mod); // AMD
  mod(this.acorn || (this.acorn = {})); // Plain browser env
})(function(exports) {
  "use strict";

  exports.version = "0.3.1";

  // The main exported interface (under `self.acorn` when in the
  // browser) is a `parse` function that takes a code string and
  // returns an abstract syntax tree as specified by [Mozilla parser
  // API][api], with the caveat that the SpiderMonkey-specific syntax
  // (`let`, `yield`, inline XML, etc) is not recognized.
  //
  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

  var options, input, inputLen, sourceFile;

  exports.parse = function(inpt, opts) {
    input = String(inpt); inputLen = input.length;
    setOptions(opts);
    initTokenState();
    return parseTopLevel(options.program);
  };

  // A second optional argument can be given to further configure
  // the parser process. These options are recognized:

  var defaultOptions = exports.defaultOptions = {
    // `ecmaVersion` indicates the ECMAScript version to parse. Must
    // be either 3 or 5. This
    // influences support for strict mode, the set of reserved words, and
    // support for getters and setter.
    ecmaVersion: 5,
    // Turn on `strictSemicolons` to prevent the parser from doing
    // automatic semicolon insertion.
    strictSemicolons: false,
    // When `allowTrailingCommas` is false, the parser will not allow
    // trailing commas in array and object literals.
    allowTrailingCommas: true,
    // By default, reserved words are not enforced. Enable
    // `forbidReserved` to enforce them.
    forbidReserved: false,
    // When `locations` is on, `loc` properties holding objects with
    // `start` and `end` properties in `{line, column}` form (with
    // line being 1-based and column 0-based) will be attached to the
    // nodes.
    locations: false,
    // A function can be passed as `onComment` option, which will
    // cause Acorn to call that function with `(block, text, start,
    // end)` parameters whenever a comment is skipped. `block` is a
    // boolean indicating whether this is a block (`/* */`) comment,
    // `text` is the content of the comment, and `start` and `end` are
    // character offsets that denote the start and end of the comment.
    // When the `locations` option is on, two more parameters are
    // passed, the full `{line, column}` locations of the start and
    // end of the comments.
    onComment: null,
    // Nodes have their start and end characters offsets recorded in
    // `start` and `end` properties (directly on the node, rather than
    // the `loc` object, which holds line/column data. To also add a
    // [semi-standardized][range] `range` property holding a `[start,
    // end]` array with the same numbers, set the `ranges` option to
    // `true`.
    //
    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
    ranges: false,
    // It is possible to parse multiple files into a single AST by
    // passing the tree produced by parsing the first file as
    // `program` option in subsequent parses. This will add the
    // toplevel forms of the parsed file to the `Program` (top) node
    // of an existing parse tree.
    program: null,
    // When `location` is on, you can pass this to record the source
    // file in every node's `loc` object.
    sourceFile: null
  };

  function setOptions(opts) {
    options = opts || {};
    for (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))
      options[opt] = defaultOptions[opt];
    sourceFile = options.sourceFile || null;
  }

  // The `getLineInfo` function is mostly useful when the
  // `locations` option is off (for performance reasons) and you
  // want to find the line/column position for a given character
  // offset. `input` should be the code string that the offset refers
  // into.

  var getLineInfo = exports.getLineInfo = function(input, offset) {
    for (var line = 1, cur = 0;;) {
      lineBreak.lastIndex = cur;
      var match = lineBreak.exec(input);
      if (match && match.index < offset) {
        ++line;
        cur = match.index + match[0].length;
      } else break;
    }
    return {line: line, column: offset - cur};
  };

  // Acorn is organized as a tokenizer and a recursive-descent parser.
  // The `tokenize` export provides an interface to the tokenizer.
  // Because the tokenizer is optimized for being efficiently used by
  // the Acorn parser itself, this interface is somewhat crude and not
  // very modular. Performing another parse or call to `tokenize` will
  // reset the internal state, and invalidate existing tokenizers.

  exports.tokenize = function(inpt, opts) {
    input = String(inpt); inputLen = input.length;
    setOptions(opts);
    initTokenState();

    var t = {};
    function getToken(forceRegexp) {
      readToken(forceRegexp);
      t.start = tokStart; t.end = tokEnd;
      t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;
      t.type = tokType; t.value = tokVal;
      return t;
    }
    getToken.jumpTo = function(pos, reAllowed) {
      tokPos = pos;
      if (options.locations) {
        tokCurLine = tokLineStart = lineBreak.lastIndex = 0;
        var match;
        while ((match = lineBreak.exec(input)) && match.index < pos) {
          ++tokCurLine;
          tokLineStart = match.index + match[0].length;
        }
      }
      var ch = input.charAt(pos - 1);
      tokRegexpAllowed = reAllowed;
      skipSpace();
    };
    return getToken;
  };

  // State is kept in (closure-)global variables. We already saw the
  // `options`, `input`, and `inputLen` variables above.

  // The current position of the tokenizer in the input.

  var tokPos;

  // The start and end offsets of the current token.

  var tokStart, tokEnd;

  // When `options.locations` is true, these hold objects
  // containing the tokens start and end line/column pairs.

  var tokStartLoc, tokEndLoc;

  // The type and value of the current token. Token types are objects,
  // named by variables against which they can be compared, and
  // holding properties that describe them (indicating, for example,
  // the precedence of an infix operator, and the original name of a
  // keyword token). The kind of value that's held in `tokVal` depends
  // on the type of the token. For literals, it is the literal value,
  // for operators, the operator name, and so on.

  var tokType, tokVal;

  // Interal state for the tokenizer. To distinguish between division
  // operators and regular expressions, it remembers whether the last
  // token was one that is allowed to be followed by an expression.
  // (If it is, a slash is probably a regexp, if it isn't it's a
  // division operator. See the `parseStatement` function for a
  // caveat.)

  var tokRegexpAllowed;

  // When `options.locations` is true, these are used to keep
  // track of the current line, and know when a new line has been
  // entered.

  var tokCurLine, tokLineStart;

  // These store the position of the previous token, which is useful
  // when finishing a node and assigning its `end` position.

  var lastStart, lastEnd, lastEndLoc;

  // This is the parser's state. `inFunction` is used to reject
  // `return` statements outside of functions, `labels` to verify that
  // `break` and `continue` have somewhere to jump to, and `strict`
  // indicates whether strict mode is on.

  var inFunction, labels, strict;

  // This function is used to raise exceptions on parse errors. It
  // takes an offset integer (into the current `input`) to indicate
  // the location of the error, attaches the position to the end
  // of the error message, and then raises a `SyntaxError` with that
  // message.

  function raise(pos, message) {
    var loc = getLineInfo(input, pos);
    message += " (" + loc.line + ":" + loc.column + ")";
    var err = new SyntaxError(message);
    err.pos = pos; err.loc = loc; err.raisedAt = tokPos;
    throw err;
  }

  // ## Token types

  // The assignment of fine-grained, information-carrying type objects
  // allows the tokenizer to store the information it has about a
  // token in a way that is very cheap for the parser to look up.

  // All token type variables start with an underscore, to make them
  // easy to recognize.

  // These are the general types. The `type` property is only used to
  // make them recognizeable when debugging.

  var _num = {type: "num"}, _regexp = {type: "regexp"}, _string = {type: "string"};
  var _name = {type: "name"}, _eof = {type: "eof"};

  // Keyword tokens. The `keyword` property (also used in keyword-like
  // operators) indicates that the token originated from an
  // identifier-like word, which is used when parsing property names.
  //
  // The `beforeExpr` property is used to disambiguate between regular
  // expressions and divisions. It is set on all token types that can
  // be followed by an expression (thus, a slash after them would be a
  // regular expression).
  //
  // `isLoop` marks a keyword as starting a loop, which is important
  // to know when parsing a label, in order to allow or disallow
  // continue jumps to that label.

  var _break = {keyword: "break"}, _case = {keyword: "case", beforeExpr: true}, _catch = {keyword: "catch"};
  var _continue = {keyword: "continue"}, _debugger = {keyword: "debugger"}, _default = {keyword: "default"};
  var _do = {keyword: "do", isLoop: true}, _else = {keyword: "else", beforeExpr: true};
  var _finally = {keyword: "finally"}, _for = {keyword: "for", isLoop: true}, _function = {keyword: "function"};
  var _if = {keyword: "if"}, _return = {keyword: "return", beforeExpr: true}, _switch = {keyword: "switch"};
  var _throw = {keyword: "throw", beforeExpr: true}, _try = {keyword: "try"}, _var = {keyword: "var"};
  var _while = {keyword: "while", isLoop: true}, _with = {keyword: "with"}, _new = {keyword: "new", beforeExpr: true};
  var _this = {keyword: "this"};

  // The keywords that denote values.

  var _null = {keyword: "null", atomValue: null}, _true = {keyword: "true", atomValue: true};
  var _false = {keyword: "false", atomValue: false};

  // Some keywords are treated as regular operators. `in` sometimes
  // (when parsing `for`) needs to be tested against specifically, so
  // we assign a variable name to it for quick comparing.

  var _in = {keyword: "in", binop: 7, beforeExpr: true};

  // Map keyword names to token types.

  var keywordTypes = {"break": _break, "case": _case, "catch": _catch,
                      "continue": _continue, "debugger": _debugger, "default": _default,
                      "do": _do, "else": _else, "finally": _finally, "for": _for,
                      "function": _function, "if": _if, "return": _return, "switch": _switch,
                      "throw": _throw, "try": _try, "var": _var, "while": _while, "with": _with,
                      "null": _null, "true": _true, "false": _false, "new": _new, "in": _in,
                      "instanceof": {keyword: "instanceof", binop: 7, beforeExpr: true}, "this": _this,
                      "typeof": {keyword: "typeof", prefix: true, beforeExpr: true},
                      "void": {keyword: "void", prefix: true, beforeExpr: true},
                      "delete": {keyword: "delete", prefix: true, beforeExpr: true}};

  // Punctuation token types. Again, the `type` property is purely for debugging.

  var _bracketL = {type: "[", beforeExpr: true}, _bracketR = {type: "]"}, _braceL = {type: "{", beforeExpr: true};
  var _braceR = {type: "}"}, _parenL = {type: "(", beforeExpr: true}, _parenR = {type: ")"};
  var _comma = {type: ",", beforeExpr: true}, _semi = {type: ";", beforeExpr: true};
  var _colon = {type: ":", beforeExpr: true}, _dot = {type: "."}, _question = {type: "?", beforeExpr: true};

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator. `isUpdate` specifies that the node produced by
  // the operator should be of type UpdateExpression rather than
  // simply UnaryExpression (`++` and `--`).
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};
  var _assign = {isAssign: true, beforeExpr: true}, _plusmin = {binop: 9, prefix: true, beforeExpr: true};
  var _incdec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};
  var _bin1 = {binop: 1, beforeExpr: true}, _bin2 = {binop: 2, beforeExpr: true};
  var _bin3 = {binop: 3, beforeExpr: true}, _bin4 = {binop: 4, beforeExpr: true};
  var _bin5 = {binop: 5, beforeExpr: true}, _bin6 = {binop: 6, beforeExpr: true};
  var _bin7 = {binop: 7, beforeExpr: true}, _bin8 = {binop: 8, beforeExpr: true};
  var _bin10 = {binop: 10, beforeExpr: true};

  // Provide access to the token types for external users of the
  // tokenizer.

  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,
                      parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,
                      dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,
                      num: _num, regexp: _regexp, string: _string};
  for (var kw in keywordTypes) exports.tokTypes["_" + kw] = keywordTypes[kw];

  // This is a trick taken from Esprima. It turns out that, on
  // non-Chrome browsers, to check whether a string is in a set, a
  // predicate containing a big ugly `switch` statement is faster than
  // a regular expression, and on Chrome the two are about on par.
  // This function uses `eval` (non-lexical) to produce such a
  // predicate from a space-separated string of words.
  //
  // It starts by sorting the words by length.

  function makePredicate(words) {
    words = words.split(" ");
    var f = "", cats = [];
    out: for (var i = 0; i < words.length; ++i) {
      for (var j = 0; j < cats.length; ++j)
        if (cats[j][0].length == words[i].length) {
          cats[j].push(words[i]);
          continue out;
        }
      cats.push([words[i]]);
    }
    function compareTo(arr) {
      if (arr.length == 1) return f += "return str === " + JSON.stringify(arr[0]) + ";";
      f += "switch(str){";
      for (var i = 0; i < arr.length; ++i) f += "case " + JSON.stringify(arr[i]) + ":";
      f += "return true}return false;";
    }

    // When there are more than three length categories, an outer
    // switch first dispatches on the lengths, to save on comparisons.

    if (cats.length > 3) {
      cats.sort(function(a, b) {return b.length - a.length;});
      f += "switch(str.length){";
      for (var i = 0; i < cats.length; ++i) {
        var cat = cats[i];
        f += "case " + cat[0].length + ":";
        compareTo(cat);
      }
      f += "}";

    // Otherwise, simply generate a flat `switch` statement.

    } else {
      compareTo(words);
    }
    return new Function("str", f);
  }

  // The ECMAScript 3 reserved word list.

  var isReservedWord3 = makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile");

  // ECMAScript 5 reserved words.

  var isReservedWord5 = makePredicate("class enum extends super const export import");

  // The additional reserved words in strict mode.

  var isStrictReservedWord = makePredicate("implements interface let package private protected public static yield");

  // The forbidden variable names in strict mode.

  var isStrictBadIdWord = makePredicate("eval arguments");

  // And the keywords.

  var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this");

  // ## Character categories

  // Big ugly regular expressions that match characters in the
  // whitespace, identifier, and identifier-start categories. These
  // are only applied when a character is found to actually have a
  // code point above 128.

  var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/;
  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
  var nonASCIIidentifierChars = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

  // Whether a single character denotes a newline.

  var newline = /[\n\r\u2028\u2029]/;

  // Matches a whole line break (where CRLF is considered a single
  // line break). Used to count lines.

  var lineBreak = /\r\n|[\n\r\u2028\u2029]/g;

  // Test whether a given character code starts an identifier.

  var isIdentifierStart = exports.isIdentifierStart = function(code) {
    if (code < 65) return code === 36;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123)return true;
    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  };

  // Test whether a given character is part of an identifier.

  var isIdentifierChar = exports.isIdentifierChar = function(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code < 91) return true;
    if (code < 97) return code === 95;
    if (code < 123)return true;
    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  };

  // ## Tokenizer

  // These are used when `options.locations` is on, for the
  // `tokStartLoc` and `tokEndLoc` properties.

  function line_loc_t() {
    this.line = tokCurLine;
    this.column = tokPos - tokLineStart;
  }

  // Reset the token state. Used at the start of a parse.

  function initTokenState() {
    tokCurLine = 1;
    tokPos = tokLineStart = 0;
    tokRegexpAllowed = true;
    skipSpace();
  }

  // Called at the end of every token. Sets `tokEnd`, `tokVal`, and
  // `tokRegexpAllowed`, and skips the space after the token, so that
  // the next one's `tokStart` will point at the right position.

  function finishToken(type, val) {
    tokEnd = tokPos;
    if (options.locations) tokEndLoc = new line_loc_t;
    tokType = type;
    skipSpace();
    tokVal = val;
    tokRegexpAllowed = type.beforeExpr;
  }

  function skipBlockComment() {
    var startLoc = options.onComment && options.locations && new line_loc_t;
    var start = tokPos, end = input.indexOf("*/", tokPos += 2);
    if (end === -1) raise(tokPos - 2, "Unterminated comment");
    tokPos = end + 2;
    if (options.locations) {
      lineBreak.lastIndex = start;
      var match;
      while ((match = lineBreak.exec(input)) && match.index < tokPos) {
        ++tokCurLine;
        tokLineStart = match.index + match[0].length;
      }
    }
    if (options.onComment)
      options.onComment(true, input.slice(start + 2, end), start, tokPos,
                        startLoc, options.locations && new line_loc_t);
  }

  function skipLineComment() {
    var start = tokPos;
    var startLoc = options.onComment && options.locations && new line_loc_t;
    var ch = input.charCodeAt(tokPos+=2);
    while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8329) {
      ++tokPos;
      ch = input.charCodeAt(tokPos);
    }
    if (options.onComment)
      options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,
                        startLoc, options.locations && new line_loc_t);
  }

  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.

  function skipSpace() {
    while (tokPos < inputLen) {
      var ch = input.charCodeAt(tokPos);
      if (ch === 32) { // ' '
        ++tokPos;
      } else if(ch === 13) {
        ++tokPos;
        var next = input.charCodeAt(tokPos);
        if(next === 10) {
          ++tokPos;
        }
        if(options.locations) {
          ++tokCurLine;
          tokLineStart = tokPos;
        }
      } else if (ch === 10) {
        ++tokPos;
        ++tokCurLine;
        tokLineStart = tokPos;
      } else if(ch < 14 && ch > 8) {
        ++tokPos;
      } else if (ch === 47) { // '/'
        var next = input.charCodeAt(tokPos+1);
        if (next === 42) { // '*'
          skipBlockComment();
        } else if (next === 47) { // '/'
          skipLineComment();
        } else break;
      } else if ((ch < 14 && ch > 8) || ch === 32 || ch === 160) { // ' ', '\xa0'
        ++tokPos;
      } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++tokPos;
      } else {
        break;
      }
    }
  }

  // ### Token reading

  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because operator parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //
  // The `forceRegexp` parameter is used in the one case where the
  // `tokRegexpAllowed` trick does not work. See `parseStatement`.

  function readToken_dot() {
    var next = input.charCodeAt(tokPos+1);
    if (next >= 48 && next <= 57) return readNumber(true);
    ++tokPos;
    return finishToken(_dot);
  }

  function readToken_slash() { // '/'
    var next = input.charCodeAt(tokPos+1);
    if (tokRegexpAllowed) {++tokPos; return readRegexp();}
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(_slash, 1);
  }

  function readToken_mult_modulo() { // '%*'
    var next = input.charCodeAt(tokPos+1);
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(_bin10, 1);
  }

  function readToken_pipe_amp(code) { // '|&'
    var next = input.charCodeAt(tokPos+1);
    if (next === code) return finishOp(code === 124 ? _bin1 : _bin2, 2);
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(code === 124 ? _bin3 : _bin5, 1);
  }

  function readToken_caret() { // '^'
    var next = input.charCodeAt(tokPos+1);
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(_bin4, 1);
  }

  function readToken_plus_min(code) { // '+-'
    var next = input.charCodeAt(tokPos+1);
    if (next === code) return finishOp(_incdec, 2);
    if (next === 61) return finishOp(_assign, 2);
    return finishOp(_plusmin, 1);
  }

  function readToken_lt_gt(code) { // '<>'
    var next = input.charCodeAt(tokPos+1);
    var size = 1;
    if (next === code) {
      size = code === 62 && input.charCodeAt(tokPos+2) === 62 ? 3 : 2;
      if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);
      return finishOp(_bin8, size);
    }
    if (next === 61)
      size = input.charCodeAt(tokPos+2) === 61 ? 3 : 2;
    return finishOp(_bin7, size);
  }

  function readToken_eq_excl(code) { // '=!'
    var next = input.charCodeAt(tokPos+1);
    if (next === 61) return finishOp(_bin6, input.charCodeAt(tokPos+2) === 61 ? 3 : 2);
    return finishOp(code === 61 ? _eq : _prefix, 1);
  }

  function getTokenFromCode(code) {
    switch(code) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit.
    case 46: // '.'
      return readToken_dot();

      // Punctuation tokens.
    case 40: ++tokPos; return finishToken(_parenL);
    case 41: ++tokPos; return finishToken(_parenR);
    case 59: ++tokPos; return finishToken(_semi);
    case 44: ++tokPos; return finishToken(_comma);
    case 91: ++tokPos; return finishToken(_bracketL);
    case 93: ++tokPos; return finishToken(_bracketR);
    case 123: ++tokPos; return finishToken(_braceL);
    case 125: ++tokPos; return finishToken(_braceR);
    case 58: ++tokPos; return finishToken(_colon);
    case 63: ++tokPos; return finishToken(_question);

      // '0x' is a hexadecimal number.
    case 48: // '0'
      var next = input.charCodeAt(tokPos+1);
      if (next === 120 || next === 88) return readHexNumber();
      // Anything else beginning with a digit is an integer, octal
      // number, or float.
    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
      return readNumber(false);

      // Quotes produce strings.
    case 34: case 39: // '"', "'"
      return readString(code);

    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

    case 47: // '/'
      return readToken_slash(code);

    case 37: case 42: // '%*'
      return readToken_mult_modulo();

    case 124: case 38: // '|&'
      return readToken_pipe_amp(code);

    case 94: // '^'
      return readToken_caret();

    case 43: case 45: // '+-'
      return readToken_plus_min(code);

    case 60: case 62: // '<>'
      return readToken_lt_gt(code);

    case 61: case 33: // '=!'
      return readToken_eq_excl(code);

    case 126: // '~'
      return finishOp(_prefix, 1);
    }

    return false;
  }

  function readToken(forceRegexp) {
    if (!forceRegexp) tokStart = tokPos;
    else tokPos = tokStart + 1;
    if (options.locations) tokStartLoc = new line_loc_t;
    if (forceRegexp) return readRegexp();
    if (tokPos >= inputLen) return finishToken(_eof);

    var code = input.charCodeAt(tokPos);
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (isIdentifierStart(code) || code === 92 /* '\' */) return readWord();

    var tok = getTokenFromCode(code);

    if (tok === false) {
      // If we are here, we either found a non-ASCII identifier
      // character, or something that's entirely disallowed.
      var ch = String.fromCharCode(code);
      if (ch === "\\" || nonASCIIidentifierStart.test(ch)) return readWord();
      raise(tokPos, "Unexpected character '" + ch + "'");
    }
    return tok;
  }

  function finishOp(type, size) {
    var str = input.slice(tokPos, tokPos + size);
    tokPos += size;
    finishToken(type, str);
  }

  // Parse a regular expression. Some context-awareness is necessary,
  // since a '/' inside a '[]' set does not end the expression.

  function readRegexp() {
    var content = "", escaped, inClass, start = tokPos;
    for (;;) {
      if (tokPos >= inputLen) raise(start, "Unterminated regular expression");
      var ch = input.charAt(tokPos);
      if (newline.test(ch)) raise(start, "Unterminated regular expression");
      if (!escaped) {
        if (ch === "[") inClass = true;
        else if (ch === "]" && inClass) inClass = false;
        else if (ch === "/" && !inClass) break;
        escaped = ch === "\\";
      } else escaped = false;
      ++tokPos;
    }
    var content = input.slice(start, tokPos);
    ++tokPos;
    // Need to use `readWord1` because '\uXXXX' sequences are allowed
    // here (don't ask).
    var mods = readWord1();
    if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, "Invalid regexp flag");
    return finishToken(_regexp, new RegExp(content, mods));
  }

  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.

  function readInt(radix, len) {
    var start = tokPos, total = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      var code = input.charCodeAt(tokPos), val;
      if (code >= 97) val = code - 97 + 10; // a
      else if (code >= 65) val = code - 65 + 10; // A
      else if (code >= 48 && code <= 57) val = code - 48; // 0-9
      else val = Infinity;
      if (val >= radix) break;
      ++tokPos;
      total = total * radix + val;
    }
    if (tokPos === start || len != null && tokPos - start !== len) return null;

    return total;
  }

  function readHexNumber() {
    tokPos += 2; // 0x
    var val = readInt(16);
    if (val == null) raise(tokStart + 2, "Expected hexadecimal number");
    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");
    return finishToken(_num, val);
  }

  // Read an integer, octal integer, or floating-point number.

  function readNumber(startsWithDot) {
    var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;
    if (!startsWithDot && readInt(10) === null) raise(start, "Invalid number");
    if (input.charCodeAt(tokPos) === 46) {
      ++tokPos;
      readInt(10);
      isFloat = true;
    }
    var next = input.charCodeAt(tokPos);
    if (next === 69 || next === 101) { // 'eE'
      next = input.charCodeAt(++tokPos);
      if (next === 43 || next === 45) ++tokPos; // '+-'
      if (readInt(10) === null) raise(start, "Invalid number");
      isFloat = true;
    }
    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, "Identifier directly after number");

    var str = input.slice(start, tokPos), val;
    if (isFloat) val = parseFloat(str);
    else if (!octal || str.length === 1) val = parseInt(str, 10);
    else if (/[89]/.test(str) || strict) raise(start, "Invalid number");
    else val = parseInt(str, 8);
    return finishToken(_num, val);
  }

  // Read a string value, interpreting backslash-escapes.

  function readString(quote) {
    tokPos++;
    var out = "";
    for (;;) {
      if (tokPos >= inputLen) raise(tokStart, "Unterminated string constant");
      var ch = input.charCodeAt(tokPos);
      if (ch === quote) {
        ++tokPos;
        return finishToken(_string, out);
      }
      if (ch === 92) { // '\'
        ch = input.charCodeAt(++tokPos);
        var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));
        if (octal) octal = octal[0];
        while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, octal.length - 1);
        if (octal === "0") octal = null;
        ++tokPos;
        if (octal) {
          if (strict) raise(tokPos - 2, "Octal literal in strict mode");
          out += String.fromCharCode(parseInt(octal, 8));
          tokPos += octal.length - 1;
        } else {
          switch (ch) {
          case 110: out += "\n"; break; // 'n' -> '\n'
          case 114: out += "\r"; break; // 'r' -> '\r'
          case 120: out += String.fromCharCode(readHexChar(2)); break; // 'x'
          case 117: out += String.fromCharCode(readHexChar(4)); break; // 'u'
          case 85: out += String.fromCharCode(readHexChar(8)); break; // 'U'
          case 116: out += "\t"; break; // 't' -> '\t'
          case 98: out += "\b"; break; // 'b' -> '\b'
          case 118: out += "\u000b"; break; // 'v' -> '\u000b'
          case 102: out += "\f"; break; // 'f' -> '\f'
          case 48: out += "\0"; break; // 0 -> '\0'
          case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos; // '\r\n'
          case 10: // ' \n'
            if (options.locations) { tokLineStart = tokPos; ++tokCurLine; }
            break;
          default: out += String.fromCharCode(ch); break;
          }
        }
      } else {
        if (ch === 13 || ch === 10 || ch === 8232 || ch === 8329) raise(tokStart, "Unterminated string constant");
        out += String.fromCharCode(ch); // '\'
        ++tokPos;
      }
    }
  }

  // Used to read character escape sequences ('\x', '\u', '\U').

  function readHexChar(len) {
    var n = readInt(16, len);
    if (n === null) raise(tokStart, "Bad character escape sequence");
    return n;
  }

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.

  var containsEsc;

  // Read an identifier, and return it as a string. Sets `containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Only builds up the word character-by-character when it actually
  // containeds an escape, as a micro-optimization.

  function readWord1() {
    containsEsc = false;
    var word, first = true, start = tokPos;
    for (;;) {
      var ch = input.charCodeAt(tokPos);
      if (isIdentifierChar(ch)) {
        if (containsEsc) word += input.charAt(tokPos);
        ++tokPos;
      } else if (ch === 92) { // "\"
        if (!containsEsc) word = input.slice(start, tokPos);
        containsEsc = true;
        if (input.charCodeAt(++tokPos) != 117) // "u"
          raise(tokPos, "Expecting Unicode escape sequence \\uXXXX");
        ++tokPos;
        var esc = readHexChar(4);
        var escStr = String.fromCharCode(esc);
        if (!escStr) raise(tokPos - 1, "Invalid Unicode escape");
        if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))
          raise(tokPos - 4, "Invalid Unicode escape");
        word += escStr;
      } else {
        break;
      }
      first = false;
    }
    return containsEsc ? word : input.slice(start, tokPos);
  }

  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.

  function readWord() {
    var word = readWord1();
    var type = _name;
    if (!containsEsc) {
      if (isKeyword(word)) type = keywordTypes[word];
      else if (options.forbidReserved &&
               (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(word) ||
               strict && isStrictReservedWord(word))
        raise(tokStart, "The keyword '" + word + "' is reserved");
    }
    return finishToken(type, word);
  }

  // ## Parser

  // A recursive descent parser operates by defining functions for all
  // syntactic elements, and recursively calling those, each function
  // advancing the input stream and returning an AST node. Precedence
  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`
  // instead of `(!x)[1]` is handled by the fact that the parser
  // function that parses unary prefix operators is called first, and
  // in turn calls the function that parses `[]` subscripts — that
  // way, it'll receive the node for `x[1]` already parsed, and wraps
  // *that* in the unary operator node.
  //
  // Acorn uses an [operator precedence parser][opp] to handle binary
  // operator precedence, because it is much more compact than using
  // the technique outlined above, which uses different, nesting
  // functions to specify precedence, for all of the ten binary
  // precedence levels that JavaScript defines.
  //
  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

  // ### Parser utilities

  // Continue to the next token.

  function next() {
    lastStart = tokStart;
    lastEnd = tokEnd;
    lastEndLoc = tokEndLoc;
    readToken();
  }

  // Enter strict mode. Re-reads the next token to please pedantic
  // tests ("use strict"; 010; -- should fail).

  function setStrict(strct) {
    strict = strct;
    tokPos = lastEnd;
    while (tokPos < tokLineStart) {
      tokLineStart = input.lastIndexOf("\n", tokLineStart - 2) + 1;
      --tokCurLine;
    }
    skipSpace();
    readToken();
  }

  // Start an AST node, attaching a start offset.

  function node_t() {
    this.type = null;
    this.start = tokStart;
    this.end = null;
  }

  function node_loc_t() {
    this.start = tokStartLoc;
    this.end = null;
    if (sourceFile !== null) this.source = sourceFile;
  }

  function startNode() {
    var node = new node_t();
    if (options.locations)
      node.loc = new node_loc_t();
    if (options.ranges)
      node.range = [tokStart, 0];
    return node;
  }

  // Start a node whose start offset information should be based on
  // the start of another node. For example, a binary operator node is
  // only started after its left-hand side has already been parsed.

  function startNodeFrom(other) {
    var node = new node_t();
    node.start = other.start;
    if (options.locations) {
      node.loc = new node_loc_t();
      node.loc.start = other.loc.start;
    }
    if (options.ranges)
      node.range = [other.range[0], 0];

    return node;
  }

  // Finish an AST node, adding `type` and `end` properties.

  function finishNode(node, type) {
    node.type = type;
    node.end = lastEnd;
    if (options.locations)
      node.loc.end = lastEndLoc;
    if (options.ranges)
      node.range[1] = lastEnd;
    return node;
  }

  // Test whether a statement node is the string literal `"use strict"`.

  function isUseStrict(stmt) {
    return options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" &&
      stmt.expression.type === "Literal" && stmt.expression.value === "use strict";
  }

  // Predicate that tests whether the next token is of the given
  // type, and if yes, consumes it as a side effect.

  function eat(type) {
    if (tokType === type) {
      next();
      return true;
    }
  }

  // Test whether a semicolon can be inserted at the current position.

  function canInsertSemicolon() {
    return !options.strictSemicolons &&
      (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));
  }

  // Consume a semicolon, or, failing that, see if we are allowed to
  // pretend that there is a semicolon at this position.

  function semicolon() {
    if (!eat(_semi) && !canInsertSemicolon()) unexpected();
  }

  // Expect a token of a given type. If found, consume it, otherwise,
  // raise an unexpected token error.

  function expect(type) {
    if (tokType === type) next();
    else unexpected();
  }

  // Raise an unexpected token error.

  function unexpected() {
    raise(tokStart, "Unexpected token");
  }

  // Verify that a node is an lval — something that can be assigned
  // to.

  function checkLVal(expr) {
    if (expr.type !== "Identifier" && expr.type !== "MemberExpression")
      raise(expr.start, "Assigning to rvalue");
    if (strict && expr.type === "Identifier" && isStrictBadIdWord(expr.name))
      raise(expr.start, "Assigning to " + expr.name + " in strict mode");
  }

  // ### Statement parsing

  // Parse a program. Initializes the parser, reads any number of
  // statements, and wraps them in a Program node.  Optionally takes a
  // `program` argument.  If present, the statements will be appended
  // to its body instead of creating a new node.

  function parseTopLevel(program) {
    lastStart = lastEnd = tokPos;
    if (options.locations) lastEndLoc = new line_loc_t;
    inFunction = strict = null;
    labels = [];
    readToken();

    var node = program || startNode(), first = true;
    if (!program) node.body = [];
    while (tokType !== _eof) {
      var stmt = parseStatement();
      node.body.push(stmt);
      if (first && isUseStrict(stmt)) setStrict(true);
      first = false;
    }
    return finishNode(node, "Program");
  }

  var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

  // Parse a single statement.
  //
  // If expecting a statement and finding a slash operator, parse a
  // regular expression literal. This is to handle cases like
  // `if (foo) /blah/.exec(foo);`, where looking at the previous token
  // does not help.

  function parseStatement() {
    if (tokType === _slash)
      readToken(true);

    var starttype = tokType, node = startNode();

    // Most types of statements are recognized by the keyword they
    // start with. Many are trivial to parse, some require a bit of
    // complexity.

    switch (starttype) {
    case _break: case _continue:
      next();
      var isBreak = starttype === _break;
      if (eat(_semi) || canInsertSemicolon()) node.label = null;
      else if (tokType !== _name) unexpected();
      else {
        node.label = parseIdent();
        semicolon();
      }

      // Verify that there is an actual destination to break or
      // continue to.
      for (var i = 0; i < labels.length; ++i) {
        var lab = labels[i];
        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
          if (node.label && isBreak) break;
        }
      }
      if (i === labels.length) raise(node.start, "Unsyntactic " + starttype.keyword);
      return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

    case _debugger:
      next();
      semicolon();
      return finishNode(node, "DebuggerStatement");

    case _do:
      next();
      labels.push(loopLabel);
      node.body = parseStatement();
      labels.pop();
      expect(_while);
      node.test = parseParenExpression();
      semicolon();
      return finishNode(node, "DoWhileStatement");

      // Disambiguating between a `for` and a `for`/`in` loop is
      // non-trivial. Basically, we have to parse the init `var`
      // statement or expression, disallowing the `in` operator (see
      // the second parameter to `parseExpression`), and then check
      // whether the next token is `in`. When there is no init part
      // (semicolon immediately after the opening parenthesis), it is
      // a regular `for` loop.

    case _for:
      next();
      labels.push(loopLabel);
      expect(_parenL);
      if (tokType === _semi) return parseFor(node, null);
      if (tokType === _var) {
        var init = startNode();
        next();
        parseVar(init, true);
        if (init.declarations.length === 1 && eat(_in))
          return parseForIn(node, init);
        return parseFor(node, init);
      }
      var init = parseExpression(false, true);
      if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}
      return parseFor(node, init);

    case _function:
      next();
      return parseFunction(node, true);

    case _if:
      next();
      node.test = parseParenExpression();
      node.consequent = parseStatement();
      node.alternate = eat(_else) ? parseStatement() : null;
      return finishNode(node, "IfStatement");

    case _return:
      if (!inFunction) raise(tokStart, "'return' outside of function");
      next();

      // In `return` (and `break`/`continue`), the keywords with
      // optional arguments, we eagerly look for a semicolon or the
      // possibility to insert one.

      if (eat(_semi) || canInsertSemicolon()) node.argument = null;
      else { node.argument = parseExpression(); semicolon(); }
      return finishNode(node, "ReturnStatement");

    case _switch:
      next();
      node.discriminant = parseParenExpression();
      node.cases = [];
      expect(_braceL);
      labels.push(switchLabel);

      // Statements under must be grouped (by label) in SwitchCase
      // nodes. `cur` is used to keep the node that we are currently
      // adding statements to.

      for (var cur, sawDefault; tokType != _braceR;) {
        if (tokType === _case || tokType === _default) {
          var isCase = tokType === _case;
          if (cur) finishNode(cur, "SwitchCase");
          node.cases.push(cur = startNode());
          cur.consequent = [];
          next();
          if (isCase) cur.test = parseExpression();
          else {
            if (sawDefault) raise(lastStart, "Multiple default clauses"); sawDefault = true;
            cur.test = null;
          }
          expect(_colon);
        } else {
          if (!cur) unexpected();
          cur.consequent.push(parseStatement());
        }
      }
      if (cur) finishNode(cur, "SwitchCase");
      next(); // Closing brace
      labels.pop();
      return finishNode(node, "SwitchStatement");

    case _throw:
      next();
      if (newline.test(input.slice(lastEnd, tokStart)))
        raise(lastEnd, "Illegal newline after throw");
      node.argument = parseExpression();
      semicolon();
      return finishNode(node, "ThrowStatement");

    case _try:
      next();
      node.block = parseBlock();
      node.handler = null;
      if (tokType === _catch) {
        var clause = startNode();
        next();
        expect(_parenL);
        clause.param = parseIdent();
        if (strict && isStrictBadIdWord(clause.param.name))
          raise(clause.param.start, "Binding " + clause.param.name + " in strict mode");
        expect(_parenR);
        clause.guard = null;
        clause.body = parseBlock();
        node.handler = finishNode(clause, "CatchClause");
      }
      node.finalizer = eat(_finally) ? parseBlock() : null;
      if (!node.handler && !node.finalizer)
        raise(node.start, "Missing catch or finally clause");
      return finishNode(node, "TryStatement");

    case _var:
      next();
      node = parseVar(node);
      semicolon();
      return node;

    case _while:
      next();
      node.test = parseParenExpression();
      labels.push(loopLabel);
      node.body = parseStatement();
      labels.pop();
      return finishNode(node, "WhileStatement");

    case _with:
      if (strict) raise(tokStart, "'with' in strict mode");
      next();
      node.object = parseParenExpression();
      node.body = parseStatement();
      return finishNode(node, "WithStatement");

    case _braceL:
      return parseBlock();

    case _semi:
      next();
      return finishNode(node, "EmptyStatement");

      // If the statement does not start with a statement keyword or a
      // brace, it's an ExpressionStatement or LabeledStatement. We
      // simply start parsing an expression, and afterwards, if the
      // next token is a colon and the expression was a simple
      // Identifier node, we switch to interpreting it as a label.

    default:
      var maybeName = tokVal, expr = parseExpression();
      if (starttype === _name && expr.type === "Identifier" && eat(_colon)) {
        for (var i = 0; i < labels.length; ++i)
          if (labels[i].name === maybeName) raise(expr.start, "Label '" + maybeName + "' is already declared");
        var kind = tokType.isLoop ? "loop" : tokType === _switch ? "switch" : null;
        labels.push({name: maybeName, kind: kind});
        node.body = parseStatement();
        labels.pop();
        node.label = expr;
        return finishNode(node, "LabeledStatement");
      } else {
        node.expression = expr;
        semicolon();
        return finishNode(node, "ExpressionStatement");
      }
    }
  }

  // Used for constructs like `switch` and `if` that insist on
  // parentheses around their expression.

  function parseParenExpression() {
    expect(_parenL);
    var val = parseExpression();
    expect(_parenR);
    return val;
  }

  // Parse a semicolon-enclosed block of statements, handling `"use
  // strict"` declarations when `allowStrict` is true (used for
  // function bodies).

  function parseBlock(allowStrict) {
    var node = startNode(), first = true, strict = false, oldStrict;
    node.body = [];
    expect(_braceL);
    while (!eat(_braceR)) {
      var stmt = parseStatement();
      node.body.push(stmt);
      if (first && isUseStrict(stmt)) {
        oldStrict = strict;
        setStrict(strict = true);
      }
      first = false
    }
    if (strict && !oldStrict) setStrict(false);
    return finishNode(node, "BlockStatement");
  }

  // Parse a regular `for` loop. The disambiguation code in
  // `parseStatement` will already have parsed the init statement or
  // expression.

  function parseFor(node, init) {
    node.init = init;
    expect(_semi);
    node.test = tokType === _semi ? null : parseExpression();
    expect(_semi);
    node.update = tokType === _parenR ? null : parseExpression();
    expect(_parenR);
    node.body = parseStatement();
    labels.pop();
    return finishNode(node, "ForStatement");
  }

  // Parse a `for`/`in` loop.

  function parseForIn(node, init) {
    node.left = init;
    node.right = parseExpression();
    expect(_parenR);
    node.body = parseStatement();
    labels.pop();
    return finishNode(node, "ForInStatement");
  }

  // Parse a list of variable declarations.

  function parseVar(node, noIn) {
    node.declarations = [];
    node.kind = "var";
    for (;;) {
      var decl = startNode();
      decl.id = parseIdent();
      if (strict && isStrictBadIdWord(decl.id.name))
        raise(decl.id.start, "Binding " + decl.id.name + " in strict mode");
      decl.init = eat(_eq) ? parseExpression(true, noIn) : null;
      node.declarations.push(finishNode(decl, "VariableDeclarator"));
      if (!eat(_comma)) break;
    }
    return finishNode(node, "VariableDeclaration");
  }

  // ### Expression parsing

  // These nest, from the most general expression type at the top to
  // 'atomic', nondivisible expression types at the bottom. Most of
  // the functions will simply let the function(s) below them parse,
  // and, *if* the syntactic construct they handle is present, wrap
  // the AST node that the inner parser gave them in another node.

  // Parse a full expression. The arguments are used to forbid comma
  // sequences (in argument lists, array literals, or object literals)
  // or the `in` operator (in for loops initalization expressions).

  function parseExpression(noComma, noIn) {
    var expr = parseMaybeAssign(noIn);
    if (!noComma && tokType === _comma) {
      var node = startNodeFrom(expr);
      node.expressions = [expr];
      while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));
      return finishNode(node, "SequenceExpression");
    }
    return expr;
  }

  // Parse an assignment expression. This includes applications of
  // operators like `+=`.

  function parseMaybeAssign(noIn) {
    var left = parseMaybeConditional(noIn);
    if (tokType.isAssign) {
      var node = startNodeFrom(left);
      node.operator = tokVal;
      node.left = left;
      next();
      node.right = parseMaybeAssign(noIn);
      checkLVal(left);
      return finishNode(node, "AssignmentExpression");
    }
    return left;
  }

  // Parse a ternary conditional (`?:`) operator.

  function parseMaybeConditional(noIn) {
    var expr = parseExprOps(noIn);
    if (eat(_question)) {
      var node = startNodeFrom(expr);
      node.test = expr;
      node.consequent = parseExpression(true);
      expect(_colon);
      node.alternate = parseExpression(true, noIn);
      return finishNode(node, "ConditionalExpression");
    }
    return expr;
  }

  // Start the precedence parser.

  function parseExprOps(noIn) {
    return parseExprOp(parseMaybeUnary(noIn), -1, noIn);
  }

  // Parse binary operators with the operator precedence parsing
  // algorithm. `left` is the left-hand side of the operator.
  // `minPrec` provides context that allows the function to stop and
  // defer further parser to one of its callers when it encounters an
  // operator that has a lower precedence than the set it is parsing.

  function parseExprOp(left, minPrec, noIn) {
    var prec = tokType.binop;
    if (prec != null && (!noIn || tokType !== _in)) {
      if (prec > minPrec) {
        var node = startNodeFrom(left);
        node.left = left;
        node.operator = tokVal;
        next();
        node.right = parseExprOp(parseMaybeUnary(noIn), prec, noIn);
        var node = finishNode(node, /&&|\|\|/.test(node.operator) ? "LogicalExpression" : "BinaryExpression");
        return parseExprOp(node, minPrec, noIn);
      }
    }
    return left;
  }

  // Parse unary operators, both prefix and postfix.

  function parseMaybeUnary(noIn) {
    if (tokType.prefix) {
      var node = startNode(), update = tokType.isUpdate;
      node.operator = tokVal;
      node.prefix = true;
      next();
      node.argument = parseMaybeUnary(noIn);
      if (update) checkLVal(node.argument);
      else if (strict && node.operator === "delete" &&
               node.argument.type === "Identifier")
        raise(node.start, "Deleting local variable in strict mode");
      return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    }
    var expr = parseExprSubscripts();
    while (tokType.postfix && !canInsertSemicolon()) {
      var node = startNodeFrom(expr);
      node.operator = tokVal;
      node.prefix = false;
      node.argument = expr;
      checkLVal(expr);
      next();
      expr = finishNode(node, "UpdateExpression");
    }
    return expr;
  }

  // Parse call, dot, and `[]`-subscript expressions.

  function parseExprSubscripts() {
    return parseSubscripts(parseExprAtom());
  }

  function parseSubscripts(base, noCalls) {
    if (eat(_dot)) {
      var node = startNodeFrom(base);
      node.object = base;
      node.property = parseIdent(true);
      node.computed = false;
      return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
    } else if (eat(_bracketL)) {
      var node = startNodeFrom(base);
      node.object = base;
      node.property = parseExpression();
      node.computed = true;
      expect(_bracketR);
      return parseSubscripts(finishNode(node, "MemberExpression"), noCalls);
    } else if (!noCalls && eat(_parenL)) {
      var node = startNodeFrom(base);
      node.callee = base;
      node.arguments = parseExprList(_parenR, false);
      return parseSubscripts(finishNode(node, "CallExpression"), noCalls);
    } else return base;
  }

  // Parse an atomic expression — either a single token that is an
  // expression, an expression started by a keyword like `function` or
  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
  // or `{}`.

  function parseExprAtom() {
    switch (tokType) {
    case _this:
      var node = startNode();
      next();
      return finishNode(node, "ThisExpression");
    case _name:
      return parseIdent();
    case _num: case _string: case _regexp:
      var node = startNode();
      node.value = tokVal;
      node.raw = input.slice(tokStart, tokEnd);
      next();
      return finishNode(node, "Literal");

    case _null: case _true: case _false:
      var node = startNode();
      node.value = tokType.atomValue;
      node.raw = tokType.keyword
      next();
      return finishNode(node, "Literal");

    case _parenL:
      var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;
      next();
      var val = parseExpression();
      val.start = tokStart1;
      val.end = tokEnd;
      if (options.locations) {
        val.loc.start = tokStartLoc1;
        val.loc.end = tokEndLoc;
      }
      if (options.ranges)
        val.range = [tokStart1, tokEnd];
      expect(_parenR);
      return val;

    case _bracketL:
      var node = startNode();
      next();
      node.elements = parseExprList(_bracketR, true, true);
      return finishNode(node, "ArrayExpression");

    case _braceL:
      return parseObj();

    case _function:
      var node = startNode();
      next();
      return parseFunction(node, false);

    case _new:
      return parseNew();

    default:
      unexpected();
    }
  }

  // New's precedence is slightly tricky. It must allow its argument
  // to be a `[]` or dot subscript expression, but not a call — at
  // least, not without wrapping it in parentheses. Thus, it uses the

  function parseNew() {
    var node = startNode();
    next();
    node.callee = parseSubscripts(parseExprAtom(), true);
    if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);
    else node.arguments = [];
    return finishNode(node, "NewExpression");
  }

  // Parse an object literal.

  function parseObj() {
    var node = startNode(), first = true, sawGetSet = false;
    node.properties = [];
    next();
    while (!eat(_braceR)) {
      if (!first) {
        expect(_comma);
        if (options.allowTrailingCommas && eat(_braceR)) break;
      } else first = false;

      var prop = {key: parsePropertyName()}, isGetSet = false, kind;
      if (eat(_colon)) {
        prop.value = parseExpression(true);
        kind = prop.kind = "init";
      } else if (options.ecmaVersion >= 5 && prop.key.type === "Identifier" &&
                 (prop.key.name === "get" || prop.key.name === "set")) {
        isGetSet = sawGetSet = true;
        kind = prop.kind = prop.key.name;
        prop.key = parsePropertyName();
        if (tokType !== _parenL) unexpected();
        prop.value = parseFunction(startNode(), false);
      } else unexpected();

      // getters and setters are not allowed to clash — either with
      // each other or with an init property — and in strict mode,
      // init properties are also not allowed to be repeated.

      if (prop.key.type === "Identifier" && (strict || sawGetSet)) {
        for (var i = 0; i < node.properties.length; ++i) {
          var other = node.properties[i];
          if (other.key.name === prop.key.name) {
            var conflict = kind == other.kind || isGetSet && other.kind === "init" ||
              kind === "init" && (other.kind === "get" || other.kind === "set");
            if (conflict && !strict && kind === "init" && other.kind === "init") conflict = false;
            if (conflict) raise(prop.key.start, "Redefinition of property");
          }
        }
      }
      node.properties.push(prop);
    }
    return finishNode(node, "ObjectExpression");
  }

  function parsePropertyName() {
    if (tokType === _num || tokType === _string) return parseExprAtom();
    return parseIdent(true);
  }

  // Parse a function declaration or literal (depending on the
  // `isStatement` parameter).

  function parseFunction(node, isStatement) {
    if (tokType === _name) node.id = parseIdent();
    else if (isStatement) unexpected();
    else node.id = null;
    node.params = [];
    var first = true;
    expect(_parenL);
    while (!eat(_parenR)) {
      if (!first) expect(_comma); else first = false;
      node.params.push(parseIdent());
    }

    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldInFunc = inFunction, oldLabels = labels;
    inFunction = true; labels = [];
    node.body = parseBlock(true);
    inFunction = oldInFunc; labels = oldLabels;

    // If this is a strict mode function, verify that argument names
    // are not repeated, and it does not try to bind the words `eval`
    // or `arguments`.
    if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {
      for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {
        var id = i < 0 ? node.id : node.params[i];
        if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))
          raise(id.start, "Defining '" + id.name + "' in strict mode");
        if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)
          raise(id.start, "Argument name clash in strict mode");
      }
    }

    return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
  }

  // Parses a comma-separated list of expressions, and returns them as
  // an array. `close` is the token type that ends the list, and
  // `allowEmpty` can be turned on to allow subsequent commas with
  // nothing in between them to be parsed as `null` (which is needed
  // for array literals).

  function parseExprList(close, allowTrailingComma, allowEmpty) {
    var elts = [], first = true;
    while (!eat(close)) {
      if (!first) {
        expect(_comma);
        if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;
      } else first = false;

      if (allowEmpty && tokType === _comma) elts.push(null);
      else elts.push(parseExpression(true));
    }
    return elts;
  }

  // Parse the next token as an identifier. If `liberal` is true (used
  // when parsing properties), it will also convert keywords into
  // identifiers.

  function parseIdent(liberal) {
    var node = startNode();
    node.name = tokType === _name ? tokVal : (liberal && !options.forbidReserved && tokType.keyword) || unexpected();
    next();
    return finishNode(node, "Identifier");
  }

});

},{}],21:[function(require,module,exports){
// Acorn: Loose parser
//
// This module provides an alternative parser (`parse_dammit`) that
// exposes that same interface as `parse`, but will try to parse
// anything as JavaScript, repairing syntax error the best it can.
// There are circumstances in which it will raise an error and give
// up, but they are very rare. The resulting AST will be a mostly
// valid JavaScript AST (as per the [Mozilla parser API][api], except
// that:
//
// - Return outside functions is allowed
//
// - Label consistency (no conflicts, break only to existing labels)
//   is not enforced.
//
// - Bogus Identifier nodes with a name of `"✖"` are inserted whenever
//   the parser got too confused to return anything meaningful.
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
//
// The expected use for this is to *first* try `acorn.parse`, and only
// if that fails switch to `parse_dammit`. The loose parser might
// parse badly indented code incorrectly, so **don't** use it as
// your default parser.
//
// Quite a lot of acorn.js is duplicated here. The alternative was to
// add a *lot* of extra cruft to that file, making it less readable
// and slower. Copying and editing the code allowed me to make
// invasive changes and simplifications without creating a complicated
// tangle.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") return mod(exports, require("./acorn")); // CommonJS
  if (typeof define == "function" && define.amd) return define(["exports", "./acorn"], mod); // AMD
  mod(this.acorn || (this.acorn = {}), this.acorn); // Plain browser env
})(function(exports, acorn) {
  "use strict";

  var tt = acorn.tokTypes;

  var options, input, fetchToken, context;

  exports.parse_dammit = function(inpt, opts) {
    if (!opts) opts = {};
    input = String(inpt);
    options = opts;
    if (!opts.tabSize) opts.tabSize = 4;
    fetchToken = acorn.tokenize(inpt, opts);
    sourceFile = options.sourceFile || null;
    context = [];
    nextLineStart = 0;
    ahead.length = 0;
    next();
    return parseTopLevel();
  };

  var lastEnd, token = {start: 0, end: 0}, ahead = [];
  var curLineStart, nextLineStart, curIndent, lastEndLoc, sourceFile;

  function next() {
    lastEnd = token.end;
    if (options.locations)
      lastEndLoc = token.endLoc;

    if (ahead.length)
      token = ahead.shift();
    else
      token = readToken();

    if (token.start >= nextLineStart) {
      while (token.start >= nextLineStart) {
        curLineStart = nextLineStart;
        nextLineStart = lineEnd(curLineStart) + 1;
      }
      curIndent = indentationAfter(curLineStart);
    }
  }

  function readToken() {
    for (;;) {
      try {
        return fetchToken();
      } catch(e) {
        if (!(e instanceof SyntaxError)) throw e;

        // Try to skip some text, based on the error message, and then continue
        var msg = e.message, pos = e.raisedAt, replace = true;
        if (/unterminated/i.test(msg)) {
          pos = lineEnd(e.pos);
          if (/string/.test(msg)) {
            replace = {start: e.pos, end: pos, type: tt.string, value: input.slice(e.pos + 1, pos)};
          } else if (/regular expr/i.test(msg)) {
            var re = input.slice(e.pos, pos);
            try { re = new RegExp(re); } catch(e) {}
            replace = {start: e.pos, end: pos, type: tt.regexp, value: re};
          } else {
            replace = false;
          }
        } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number/i.test(msg)) {
          while (pos < input.length && !isSpace(input.charCodeAt(pos))) ++pos;
        } else if (/character escape|expected hexadecimal/i.test(msg)) {
          while (pos < input.length) {
            var ch = input.charCodeAt(pos++);
            if (ch === 34 || ch === 39 || isNewline(ch)) break;
          }
        } else if (/unexpected character/i.test(msg)) {
          pos++;
          replace = false;
        } else {
          throw e;
        }
        resetTo(pos);
        if (replace === true) replace = {start: pos, end: pos, type: tt.name, value: "✖"};
        if (replace) {
          if (options.locations) {
            replace.startLoc = acorn.getLineInfo(input, replace.start);
            replace.endLoc = acorn.getLineInfo(input, replace.end);
          }
          return replace;
        }
      }
    }
  }

  function resetTo(pos) {
    var ch = input.charAt(pos - 1);
    var reAllowed = !ch || /[\[\{\(,;:?\/*=+\-~!|&%^<>]/.test(ch) ||
      /[enwfd]/.test(ch) && /\b(keywords|case|else|return|throw|new|in|(instance|type)of|delete|void)$/.test(input.slice(pos - 10, pos));
    fetchToken.jumpTo(pos, reAllowed);
  }

  function copyToken(token) {
    var copy = {start: token.start, end: token.end, type: token.type, value: token.value};
    if (options.locations) {
      copy.startLoc = token.startLoc;
      copy.endLoc = token.endLoc;
    }
    return copy;
  }

  function lookAhead(n) {
    // Copy token objects, because fetchToken will overwrite the one
    // it returns, and in this case we still need it
    if (!ahead.length)
      token = copyToken(token);
    while (n > ahead.length)
      ahead.push(copyToken(readToken()));
    return ahead[n-1];
  }

  var newline = /[\n\r\u2028\u2029]/;

  function isNewline(ch) {
    return ch === 10 || ch === 13 || ch === 8232 || ch === 8329;
  }
  function isSpace(ch) {
    return (ch < 14 && ch > 8) || ch === 32 || ch === 160 || isNewline(ch);
  }

  function pushCx() {
    context.push(curIndent);
  }
  function popCx() {
    curIndent = context.pop();
  }

  function lineEnd(pos) {
    while (pos < input.length && !isNewline(input.charCodeAt(pos))) ++pos;
    return pos;
  }
  function lineStart(pos) {
    while (pos > 0 && !isNewline(input.charCodeAt(pos - 1))) --pos;
    return pos;
  }
  function indentationAfter(pos) {
    for (var count = 0;; ++pos) {
      var ch = input.charCodeAt(pos);
      if (ch === 32) ++count;
      else if (ch === 9) count += options.tabSize;
      else return count;
    }
  }

  function closes(closeTok, indent, line, blockHeuristic) {
    if (token.type === closeTok || token.type === tt.eof) return true;
    if (line != curLineStart && curIndent < indent && tokenStartsLine() &&
        (!blockHeuristic || nextLineStart >= input.length ||
         indentationAfter(nextLineStart) < indent)) return true;
    return false;
  }

  function tokenStartsLine() {
    for (var p = token.start - 1; p >= curLineStart; --p) {
      var ch = input.charCodeAt(p);
      if (ch !== 9 && ch !== 32) return false;
    }
    return true;
  }

  function node_t(start) {
    this.type = null;
    this.start = start;
    this.end = null;
  }

  function node_loc_t(start) {
    this.start = start || token.startLoc || {line: 1, column: 0};
    this.end = null;
    if (sourceFile !== null) this.source = sourceFile;
  }

  function startNode() {
    var node = new node_t(token.start);
    if (options.locations)
      node.loc = new node_loc_t();
    return node;
  }

  function startNodeFrom(other) {
    var node = new node_t(other.start);
    if (options.locations)
      node.loc = new node_loc_t(other.loc.start);
    return node;
  }

  function finishNode(node, type) {
    node.type = type;
    node.end = lastEnd;
    if (options.locations)
      node.loc.end = lastEndLoc;
    return node;
  }

  function getDummyLoc() {
    if (options.locations) {
      var loc = new node_loc_t();
      loc.end = loc.start;
      return loc;
    }
  };

  function dummyIdent() {
    var dummy = new node_t(token.start);
    dummy.type = "Identifier";
    dummy.end = token.start;
    dummy.name = "✖";
    dummy.loc = getDummyLoc();
    return dummy;
  }
  function isDummy(node) { return node.name == "✖"; }

  function eat(type) {
    if (token.type === type) {
      next();
      return true;
    }
  }

  function canInsertSemicolon() {
    return (token.type === tt.eof || token.type === tt.braceR || newline.test(input.slice(lastEnd, token.start)));
  }
  function semicolon() {
    eat(tt.semi);
  }

  function expect(type) {
    if (eat(type)) return true;
    if (lookAhead(1).type == type) {
      next(); next();
      return true;
    }
    if (lookAhead(2).type == type) {
      next(); next(); next();
      return true;
    }
  }

  function checkLVal(expr) {
    if (expr.type === "Identifier" || expr.type === "MemberExpression") return expr;
    return dummyIdent();
  }

  function parseTopLevel() {
    var node = startNode();
    node.body = [];
    while (token.type !== tt.eof) node.body.push(parseStatement());
    return finishNode(node, "Program");
  }

  function parseStatement() {
    var starttype = token.type, node = startNode();

    switch (starttype) {
    case tt._break: case tt._continue:
      next();
      var isBreak = starttype === tt._break;
      node.label = token.type === tt.name ? parseIdent() : null;
      semicolon();
      return finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

    case tt._debugger:
      next();
      semicolon();
      return finishNode(node, "DebuggerStatement");

    case tt._do:
      next();
      node.body = parseStatement();
      node.test = eat(tt._while) ? parseParenExpression() : dummyIdent();
      semicolon();
      return finishNode(node, "DoWhileStatement");

    case tt._for:
      next();
      pushCx();
      expect(tt.parenL);
      if (token.type === tt.semi) return parseFor(node, null);
      if (token.type === tt._var) {
        var init = startNode();
        next();
        parseVar(init, true);
        if (init.declarations.length === 1 && eat(tt._in))
          return parseForIn(node, init);
        return parseFor(node, init);
      }
      var init = parseExpression(false, true);
      if (eat(tt._in)) {return parseForIn(node, checkLVal(init));}
      return parseFor(node, init);

    case tt._function:
      next();
      return parseFunction(node, true);

    case tt._if:
      next();
      node.test = parseParenExpression();
      node.consequent = parseStatement();
      node.alternate = eat(tt._else) ? parseStatement() : null;
      return finishNode(node, "IfStatement");

    case tt._return:
      next();
      if (eat(tt.semi) || canInsertSemicolon()) node.argument = null;
      else { node.argument = parseExpression(); semicolon(); }
      return finishNode(node, "ReturnStatement");

    case tt._switch:
      var blockIndent = curIndent, line = curLineStart;
      next();
      node.discriminant = parseParenExpression();
      node.cases = [];
      pushCx();
      expect(tt.braceL);

      for (var cur; !closes(tt.braceR, blockIndent, line, true);) {
        if (token.type === tt._case || token.type === tt._default) {
          var isCase = token.type === tt._case;
          if (cur) finishNode(cur, "SwitchCase");
          node.cases.push(cur = startNode());
          cur.consequent = [];
          next();
          if (isCase) cur.test = parseExpression();
          else cur.test = null;
          expect(tt.colon);
        } else {
          if (!cur) {
            node.cases.push(cur = startNode());
            cur.consequent = [];
            cur.test = null;
          }
          cur.consequent.push(parseStatement());
        }
      }
      if (cur) finishNode(cur, "SwitchCase");
      popCx();
      eat(tt.braceR);
      return finishNode(node, "SwitchStatement");

    case tt._throw:
      next();
      node.argument = parseExpression();
      semicolon();
      return finishNode(node, "ThrowStatement");

    case tt._try:
      next();
      node.block = parseBlock();
      node.handler = null;
      if (token.type === tt._catch) {
        var clause = startNode();
        next();
        expect(tt.parenL);
        clause.param = parseIdent();
        expect(tt.parenR);
        clause.guard = null;
        clause.body = parseBlock();
        node.handler = finishNode(clause, "CatchClause");
      }
      node.finalizer = eat(tt._finally) ? parseBlock() : null;
      if (!node.handler && !node.finalizer) return node.block;
      return finishNode(node, "TryStatement");

    case tt._var:
      next();
      node = parseVar(node);
      semicolon();
      return node;

    case tt._while:
      next();
      node.test = parseParenExpression();
      node.body = parseStatement();
      return finishNode(node, "WhileStatement");

    case tt._with:
      next();
      node.object = parseParenExpression();
      node.body = parseStatement();
      return finishNode(node, "WithStatement");

    case tt.braceL:
      return parseBlock();

    case tt.semi:
      next();
      return finishNode(node, "EmptyStatement");

    default:
      var maybeName = token.value, expr = parseExpression();
      if (isDummy(expr)) {
        next();
        if (token.type === tt.eof) return finishNode(node, "EmptyStatement");
        return parseStatement();
      } else if (starttype === tt.name && expr.type === "Identifier" && eat(tt.colon)) {
        node.body = parseStatement();
        node.label = expr;
        return finishNode(node, "LabeledStatement");
      } else {
        node.expression = expr;
        semicolon();
        return finishNode(node, "ExpressionStatement");
      }
    }
  }

  function parseBlock() {
    var node = startNode();
    pushCx();
    expect(tt.braceL);
    var blockIndent = curIndent, line = curLineStart;
    node.body = [];
    while (!closes(tt.braceR, blockIndent, line, true))
      node.body.push(parseStatement());
    popCx();
    eat(tt.braceR);
    return finishNode(node, "BlockStatement");
  }

  function parseFor(node, init) {
    node.init = init;
    node.test = node.update = null;
    if (eat(tt.semi) && token.type !== tt.semi) node.test = parseExpression();
    if (eat(tt.semi) && token.type !== tt.parenR) node.update = parseExpression();
    popCx();
    expect(tt.parenR);
    node.body = parseStatement();
    return finishNode(node, "ForStatement");
  }

  function parseForIn(node, init) {
    node.left = init;
    node.right = parseExpression();
    popCx();
    expect(tt.parenR);
    node.body = parseStatement();
    return finishNode(node, "ForInStatement");
  }

  function parseVar(node, noIn) {
    node.declarations = [];
    node.kind = "var";
    while (token.type === tt.name) {
      var decl = startNode();
      decl.id = parseIdent();
      decl.init = eat(tt.eq) ? parseExpression(true, noIn) : null;
      node.declarations.push(finishNode(decl, "VariableDeclarator"));
      if (!eat(tt.comma)) break;
    }
    return finishNode(node, "VariableDeclaration");
  }

  function parseExpression(noComma, noIn) {
    var expr = parseMaybeAssign(noIn);
    if (!noComma && token.type === tt.comma) {
      var node = startNodeFrom(expr);
      node.expressions = [expr];
      while (eat(tt.comma)) node.expressions.push(parseMaybeAssign(noIn));
      return finishNode(node, "SequenceExpression");
    }
    return expr;
  }

  function parseParenExpression() {
    pushCx();
    expect(tt.parenL);
    var val = parseExpression();
    popCx();
    expect(tt.parenR);
    return val;
  }

  function parseMaybeAssign(noIn) {
    var left = parseMaybeConditional(noIn);
    if (token.type.isAssign) {
      var node = startNodeFrom(left);
      node.operator = token.value;
      node.left = checkLVal(left);
      next();
      node.right = parseMaybeAssign(noIn);
      return finishNode(node, "AssignmentExpression");
    }
    return left;
  }

  function parseMaybeConditional(noIn) {
    var expr = parseExprOps(noIn);
    if (eat(tt.question)) {
      var node = startNodeFrom(expr);
      node.test = expr;
      node.consequent = parseExpression(true);
      node.alternate = expect(tt.colon) ? parseExpression(true, noIn) : dummyIdent();
      return finishNode(node, "ConditionalExpression");
    }
    return expr;
  }

  function parseExprOps(noIn) {
    var indent = curIndent, line = curLineStart;
    return parseExprOp(parseMaybeUnary(noIn), -1, noIn, indent, line);
  }

  function parseExprOp(left, minPrec, noIn, indent, line) {
    if (curLineStart != line && curIndent < indent && tokenStartsLine()) return left;
    var prec = token.type.binop;
    if (prec != null && (!noIn || token.type !== tt._in)) {
      if (prec > minPrec) {
        var node = startNodeFrom(left);
        node.left = left;
        node.operator = token.value;
        next();
        if (curLineStart != line && curIndent < indent && tokenStartsLine())
          node.right = dummyIdent();
        else
          node.right = parseExprOp(parseMaybeUnary(noIn), prec, noIn, indent, line);
        var node = finishNode(node, /&&|\|\|/.test(node.operator) ? "LogicalExpression" : "BinaryExpression");
        return parseExprOp(node, minPrec, noIn, indent, line);
      }
    }
    return left;
  }

  function parseMaybeUnary(noIn) {
    if (token.type.prefix) {
      var node = startNode(), update = token.type.isUpdate;
      node.operator = token.value;
      node.prefix = true;
      next();
      node.argument = parseMaybeUnary(noIn);
      if (update) node.argument = checkLVal(node.argument);
      return finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
    }
    var expr = parseExprSubscripts();
    while (token.type.postfix && !canInsertSemicolon()) {
      var node = startNodeFrom(expr);
      node.operator = token.value;
      node.prefix = false;
      node.argument = checkLVal(expr);
      next();
      expr = finishNode(node, "UpdateExpression");
    }
    return expr;
  }

  function parseExprSubscripts() {
    var indent = curIndent, line = curLineStart;
    return parseSubscripts(parseExprAtom(), false, curIndent, line);
  }

  function parseSubscripts(base, noCalls, startIndent, line) {
    for (;;) {
      if (curLineStart != line && curIndent <= startIndent && tokenStartsLine()) {
        if (token.type == tt.dot && curIndent == startIndent)
          --startIndent;
        else
          return base;
      }

      if (eat(tt.dot)) {
        var node = startNodeFrom(base);
        node.object = base;
        if (curLineStart != line && curIndent <= startIndent && tokenStartsLine())
          node.property = dummyIdent();
        else
          node.property = parsePropertyName() || dummyIdent();
        node.computed = false;
        base = finishNode(node, "MemberExpression");
      } else if (token.type == tt.bracketL) {
        pushCx();
        next();
        var node = startNodeFrom(base);
        node.object = base;
        node.property = parseExpression();
        node.computed = true;
        popCx();
        expect(tt.bracketR);
        base = finishNode(node, "MemberExpression");
      } else if (!noCalls && token.type == tt.parenL) {
        pushCx();
        var node = startNodeFrom(base);
        node.callee = base;
        node.arguments = parseExprList(tt.parenR);
        base = finishNode(node, "CallExpression");
      } else {
        return base;
      }
    }
  }

  function parseExprAtom() {
    switch (token.type) {
    case tt._this:
      var node = startNode();
      next();
      return finishNode(node, "ThisExpression");
    case tt.name:
      return parseIdent();
    case tt.num: case tt.string: case tt.regexp:
      var node = startNode();
      node.value = token.value;
      node.raw = input.slice(token.start, token.end);
      next();
      return finishNode(node, "Literal");

    case tt._null: case tt._true: case tt._false:
      var node = startNode();
      node.value = token.type.atomValue;
      node.raw = token.type.keyword;
      next();
      return finishNode(node, "Literal");

    case tt.parenL:
      var tokStart1 = token.start;
      next();
      var val = parseExpression();
      val.start = tokStart1;
      val.end = token.end;
      expect(tt.parenR);
      return val;

    case tt.bracketL:
      var node = startNode();
      pushCx();
      node.elements = parseExprList(tt.bracketR);
      return finishNode(node, "ArrayExpression");

    case tt.braceL:
      return parseObj();

    case tt._function:
      var node = startNode();
      next();
      return parseFunction(node, false);

    case tt._new:
      return parseNew();

    default:
      return dummyIdent();
    }
  }

  function parseNew() {
    var node = startNode(), startIndent = curIndent, line = curLineStart;
    next();
    node.callee = parseSubscripts(parseExprAtom(), true, startIndent, line);
    if (token.type == tt.parenL) {
      pushCx();
      node.arguments = parseExprList(tt.parenR);
    } else {
      node.arguments = [];
    }
    return finishNode(node, "NewExpression");
  }

  function parseObj() {
    var node = startNode();
    node.properties = [];
    pushCx();
    next();
    var propIndent = curIndent, line = curLineStart;
    while (!closes(tt.braceR, propIndent, line)) {
      var name = parsePropertyName();
      if (!name) { if (isDummy(parseExpression(true))) next(); eat(tt.comma); continue; }
      var prop = {key: name}, isGetSet = false, kind;
      if (eat(tt.colon)) {
        prop.value = parseExpression(true);
        kind = prop.kind = "init";
      } else if (options.ecmaVersion >= 5 && prop.key.type === "Identifier" &&
                 (prop.key.name === "get" || prop.key.name === "set")) {
        isGetSet = true;
        kind = prop.kind = prop.key.name;
        prop.key = parsePropertyName() || dummyIdent();
        prop.value = parseFunction(startNode(), false);
      } else {
        next();
        eat(tt.comma);
        continue;
      }

      node.properties.push(prop);
      eat(tt.comma);
    }
    popCx();
    eat(tt.braceR);
    return finishNode(node, "ObjectExpression");
  }

  function parsePropertyName() {
    if (token.type === tt.num || token.type === tt.string) return parseExprAtom();
    if (token.type === tt.name || token.type.keyword) return parseIdent();
  }

  function parseIdent() {
    var node = startNode();
    node.name = token.type === tt.name ? token.value : token.type.keyword;
    next();
    return finishNode(node, "Identifier");
  }

  function parseFunction(node, isStatement) {
    if (token.type === tt.name) node.id = parseIdent();
    else if (isStatement) node.id = dummyIdent();
    else node.id = null;
    node.params = [];
    pushCx();
    expect(tt.parenL);
    while (token.type == tt.name) {
      node.params.push(parseIdent());
      eat(tt.comma);
    }
    popCx();
    eat(tt.parenR);
    node.body = parseBlock();
    return finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
  }

  function parseExprList(close) {
    var indent = curIndent, line = curLineStart, elts = [], continuedLine = nextLineStart;
    next(); // Opening bracket
    while (!closes(close, indent + (curLineStart <= continuedLine ? 1 : 0), line)) {
      var elt = parseExpression(true);
      if (isDummy(elt)) {
        if (closes(close, indent, line)) break;
        next();
      } else {
        elts.push(elt);
      }
      while (eat(tt.comma)) {}
    }
    popCx();
    eat(close);
    return elts;
  }
});

},{"./acorn":20}],22:[function(require,module,exports){
// Generated by CoffeeScript 2.0.0-beta8
var any, assignment, beingDeclared, collectIdentifiers, concat, concatMap, CS, declarationsNeeded, declarationsNeededRecursive, defaultRules, difference, divMod, dynamicMemberAccess, enabledHelpers, envEnrichments, exports, expr, fn, fn, foldl1, forceBlock, generateMutatingWalker, generateSoak, genSym, h, h, hasSoak, helperNames, helpers, inlineHelpers, intersect, isIdentifierName, JS, jsReserved, makeReturn, makeVarDeclaration, map, memberAccess, needsCaching, nub, owns, partition, span, stmt, union, usedAsExpression, variableDeclarations;
cache$ = require('./functional-helpers');
any = cache$.any;
concat = cache$.concat;
concatMap = cache$.concatMap;
difference = cache$.difference;
divMod = cache$.divMod;
foldl1 = cache$.foldl1;
intersect = cache$.intersect;
map = cache$.map;
nub = cache$.nub;
owns = cache$.owns;
partition = cache$.partition;
span = cache$.span;
union = cache$.union;
cache$1 = require('./helpers');
beingDeclared = cache$1.beingDeclared;
usedAsExpression = cache$1.usedAsExpression;
envEnrichments = cache$1.envEnrichments;
CS = require('./nodes');
JS = require('./js-nodes');
exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
jsReserved = [
  'break',
  'case',
  'catch',
  'class',
  'const',
  'continue',
  'debugger',
  'default',
  'delete',
  'do',
  'else',
  'enum',
  'export',
  'extends',
  'false',
  'finally',
  'for',
  'function',
  'if',
  'implements',
  'import',
  'in',
  'instanceof',
  'interface',
  'let',
  'native',
  'new',
  'null',
  'package',
  'private',
  'protected',
  'public',
  'return',
  'static',
  'super',
  'switch',
  'this',
  'throw',
  'true',
  'try',
  'typeof',
  'var',
  'void',
  'while',
  'with',
  'yield',
  'arguments',
  'eval'
];
genSym = function () {
  var genSymCounter;
  genSymCounter = 0;
  return function (pre) {
    return new JS.GenSym(pre, ++genSymCounter);
  };
}();
stmt = function (e) {
  var walk;
  if (!(null != e))
    return e;
  if (e.isStatement) {
    return e;
  } else if (e['instanceof'](JS.SequenceExpression)) {
    walk = function (seq) {
      return concatMap(seq.expressions, function (e) {
        if (e['instanceof'](JS.SequenceExpression)) {
          return walk(e);
        } else {
          return [stmt(e)];
        }
      });
    };
    return new JS.BlockStatement(walk(e));
  } else if (e['instanceof'](JS.ConditionalExpression)) {
    return new JS.IfStatement(expr(e.test), stmt(e.consequent), stmt(e.alternate));
  } else {
    return new JS.ExpressionStatement(e);
  }
};
expr = function (s) {
  var accum, alternate, block, consequent, iife, lastExpression, push;
  if (!(null != s))
    return s;
  if (s.isExpression) {
    return s;
  } else if (s['instanceof'](JS.BlockStatement)) {
    switch (s.body.length) {
    case 0:
      return helpers.undef();
    case 1:
      return expr(s.body[0]);
    default:
      return new JS.SequenceExpression(map(s.body, expr));
    }
  } else if (s['instanceof'](JS.ExpressionStatement)) {
    return s.expression;
  } else if (s['instanceof'](JS.ThrowStatement)) {
    return new JS.CallExpression(new JS.FunctionExpression(null, [], forceBlock(s)), []);
  } else if (s['instanceof'](JS.IfStatement)) {
    consequent = expr(null != s.consequent ? s.consequent : helpers.undef());
    alternate = expr(null != s.alternate ? s.alternate : helpers.undef());
    return new JS.ConditionalExpression(s.test, consequent, alternate);
  } else if (s['instanceof'](JS.ForInStatement, JS.ForStatement, JS.WhileStatement)) {
    accum = genSym('accum');
    push = function (x) {
      return stmt(new JS.CallExpression(memberAccess(accum, 'push'), [x]));
    };
    s.body = forceBlock(s.body);
    if (s.body.body.length) {
      lastExpression = s.body.body.slice(-1)[0];
      if (!lastExpression['instanceof'](JS.ThrowStatement))
        s.body.body[s.body.body.length - 1] = push(expr(lastExpression));
    } else {
      s.body.body.push(push(helpers.undef()));
    }
    block = new JS.BlockStatement([
      s,
      new JS.ReturnStatement(accum)
    ]);
    iife = new JS.FunctionExpression(null, [accum], block);
    return new JS.CallExpression(memberAccess(iife.g(), 'call'), [
      new JS.ThisExpression,
      new JS.ArrayExpression([])
    ]);
  } else if (s['instanceof'](JS.SwitchStatement, JS.TryStatement)) {
    block = new JS.BlockStatement([makeReturn(s)]);
    iife = new JS.FunctionExpression(null, [], block);
    return new JS.CallExpression(memberAccess(iife.g(), 'call'), [new JS.ThisExpression]);
  } else {
    throw new Error('expr: Cannot use a ' + s.type + ' as a value');
  }
};
makeReturn = function (node) {
  var stmts;
  if (!(null != node))
    return new JS.ReturnStatement;
  if (node['instanceof'](JS.BlockStatement)) {
    return new JS.BlockStatement([].slice.call(node.body.slice(0, -1)).concat([makeReturn(node.body.slice(-1)[0])]));
  } else if (node['instanceof'](JS.SequenceExpression)) {
    return new JS.SequenceExpression([].slice.call(node.expressions.slice(0, -1)).concat([makeReturn(node.expressions.slice(-1)[0])]));
  } else if (node['instanceof'](JS.IfStatement)) {
    return new JS.IfStatement(node.test, makeReturn(node.consequent), null != node.alternate ? makeReturn(node.alternate) : null);
  } else if (node['instanceof'](JS.SwitchStatement)) {
    return new JS.SwitchStatement(node.discriminant, map(node.cases, makeReturn));
  } else if (node['instanceof'](JS.SwitchCase)) {
    if (!node.consequent.length)
      return node;
    stmts = node.consequent.slice(-1)[0]['instanceof'](JS.BreakStatement) ? node.consequent.slice(0, -1) : node.consequent;
    return new JS.SwitchCase(node.test, [].slice.call(stmts.slice(0, -1)).concat([makeReturn(stmts.slice(-1)[0])]));
  } else if (node['instanceof'](JS.TryStatement)) {
    return new JS.TryStatement(makeReturn(node.block), map(node.handlers, makeReturn), null != node.finalizer ? makeReturn(node.finalizer) : null);
  } else if (node['instanceof'](JS.CatchClause)) {
    return new JS.CatchClause(node.param, makeReturn(node.body));
  } else if (node['instanceof'](JS.ThrowStatement, JS.ReturnStatement, JS.BreakStatement, JS.ContinueStatement, JS.DebuggerStatement)) {
    return node;
  } else if (node['instanceof'](JS.UnaryExpression) && node.operator === 'void') {
    return new JS.ReturnStatement;
  } else {
    return new JS.ReturnStatement(expr(node));
  }
};
generateMutatingWalker = function (fn) {
  return function (node, args) {
    var childName, n;
    args = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
    for (var i$ = 0, length$ = node.childNodes.length; i$ < length$; ++i$) {
      childName = node.childNodes[i$];
      if (!(null != node[childName]))
        continue;
      node[childName] = in$(childName, node.listMembers) ? function (accum$) {
        for (var i$1 = 0, length$1 = node[childName].length; i$1 < length$1; ++i$1) {
          n = node[childName][i$1];
          accum$.push(fn.apply(n, args));
        }
        return accum$;
      }.call(this, []) : fn.apply(node[childName], args);
    }
    return node;
  };
};
declarationsNeeded = function (node) {
  if (!(null != node))
    return [];
  if (node['instanceof'](JS.AssignmentExpression) && node.operator === '=' && node.left['instanceof'](JS.Identifier)) {
    return [node.left];
  } else if (node['instanceof'](JS.ForInStatement) && node.left['instanceof'](JS.Identifier)) {
    return [node.left];
  } else {
    return [];
  }
};
declarationsNeededRecursive = function (node) {
  if (!(null != node))
    return [];
  if (node['instanceof'](JS.FunctionExpression, JS.FunctionDeclaration) && !node.generated) {
    return [];
  } else {
    return union(declarationsNeeded(node), concatMap(node.childNodes, function (childName) {
      if (!(null != node[childName]))
        return [];
      if (in$(childName, node.listMembers)) {
        return concatMap(node[childName], declarationsNeededRecursive);
      } else {
        return declarationsNeededRecursive(node[childName]);
      }
    }));
  }
};
variableDeclarations = function (node) {
  if (!(null != node))
    return [];
  if (node['instanceof'](JS.FunctionDeclaration)) {
    return [node.id];
  } else if (node['instanceof'](JS.FunctionExpression) && !node.generated) {
    return [];
  } else if (node['instanceof'](JS.VariableDeclarator)) {
    return [node.id];
  } else {
    return concatMap(node.childNodes, function (childName) {
      if (!(null != node[childName]))
        return [];
      if (in$(childName, node.listMembers)) {
        return concatMap(node[childName], variableDeclarations);
      } else {
        return variableDeclarations(node[childName]);
      }
    });
  }
};
collectIdentifiers = function (node) {
  return nub(function () {
    switch (false) {
    case !!(null != node):
      return [];
    case !node['instanceof'](JS.Identifier):
      return [node.name];
    case !(node['instanceof'](JS.MemberExpression) && !node.computed):
      return collectIdentifiers(node.object);
    default:
      return concatMap(node.childNodes, function (childName) {
        if (!(null != node[childName]))
          return [];
        if (in$(childName, node.listMembers)) {
          return concatMap(node[childName], collectIdentifiers);
        } else {
          return collectIdentifiers(node[childName]);
        }
      });
    }
  }.call(this));
};
needsCaching = function (node) {
  if (!(null != node))
    return false;
  return envEnrichments(node, []).length > 0 || node['instanceof'](CS.FunctionApplications, CS.DoOp, CS.NewOp, CS.ArrayInitialiser, CS.ObjectInitialiser, CS.RegExp, CS.HeregExp, CS.PreIncrementOp, CS.PostIncrementOp, CS.PreDecrementOp, CS.PostDecrementOp, CS.Range) || any(difference(node.childNodes, node.listMembers), function (n) {
    return needsCaching(node[n]);
  }) || any(node.listMembers, function (n) {
    return any(node[n], needsCaching);
  });
};
forceBlock = function (node) {
  if (!(null != node))
    return new JS.BlockStatement([]);
  node = stmt(node);
  if (node['instanceof'](JS.BlockStatement)) {
    return node;
  } else {
    return new JS.BlockStatement([node]);
  }
};
makeVarDeclaration = function (vars) {
  var decls, v;
  vars.sort(function (a, b) {
    a = a.name.toLowerCase();
    b = b.name.toLowerCase();
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  });
  decls = function (accum$) {
    for (var i$ = 0, length$ = vars.length; i$ < length$; ++i$) {
      v = vars[i$];
      accum$.push(new JS.VariableDeclarator(v));
    }
    return accum$;
  }.call(this, []);
  return new JS.VariableDeclaration('var', decls);
};
isIdentifierName = function (name) {
  return !in$(name, jsReserved) && /^[$_a-z][$_a-z0-9]*$/i.test(name);
};
memberAccess = function (e, member) {
  if (isIdentifierName(member)) {
    return new JS.MemberExpression(false, expr(e), new JS.Identifier(member));
  } else {
    return new JS.MemberExpression(true, expr(e), new JS.Literal(member));
  }
};
dynamicMemberAccess = function (e, index) {
  if (index['instanceof'](JS.Literal) && typeof index.value === 'string') {
    return memberAccess(e, index.value);
  } else {
    return new JS.MemberExpression(true, expr(e), expr(index));
  }
};
assignment = function (assignee, expression, valueUsed) {
  var alternate, assignments, consequent, e, elements, i, index, m, numElements, p, propName, restName, size, test;
  if (null == valueUsed)
    valueUsed = false;
  assignments = [];
  expression = expr(expression);
  switch (false) {
  case !assignee.rest:
  case !assignee['instanceof'](JS.ArrayExpression):
    e = expression;
    if (valueUsed || assignee.elements.length > 1) {
      e = genSym('cache');
      assignments.push(new JS.AssignmentExpression('=', e, expression));
    }
    elements = assignee.elements;
    for (var i$ = 0, length$ = elements.length; i$ < length$; ++i$) {
      m = elements[i$];
      i = i$;
      if (m.rest)
        break;
      assignments.push(assignment(m, dynamicMemberAccess(e, new JS.Literal(i)), valueUsed));
    }
    if (elements.length > 0) {
      if (elements.slice(-1)[0].rest) {
        numElements = elements.length;
        restName = elements[numElements - 1] = elements[numElements - 1].expression;
        test = new JS.BinaryExpression('<=', new JS.Literal(numElements), memberAccess(e, 'length'));
        consequent = helpers.slice(e, new JS.Literal(numElements - 1));
        alternate = new JS.ArrayExpression([]);
        assignments.push(stmt(new JS.AssignmentExpression('=', restName, new JS.ConditionalExpression(test, consequent, alternate))));
      } else if (any(elements, function (p) {
          return p.rest;
        })) {
        restName = index = null;
        for (var i$1 = 0, length$1 = elements.length; i$1 < length$1; ++i$1) {
          p = elements[i$1];
          i = i$1;
          if (!p.rest)
            continue;
          restName = p.expression;
          index = i;
          break;
        }
        elements.splice(index, 1);
        numElements = elements.length;
        size = genSym('size');
        assignments.push(new JS.AssignmentExpression('=', size, memberAccess(e, 'length')));
        test = new JS.BinaryExpression('>', size, new JS.Literal(numElements));
        consequent = helpers.slice(e, new JS.Literal(index), new JS.BinaryExpression('-', size, new JS.Literal(numElements - index)));
        assignments.push(new JS.AssignmentExpression('=', restName, new JS.ConditionalExpression(test, consequent, new JS.ArrayExpression([]))));
        for (var i$2 = 0, length$2 = elements.slice(index).length; i$2 < length$2; ++i$2) {
          p = elements.slice(index)[i$2];
          i = i$2;
          assignments.push(stmt(new JS.AssignmentExpression('=', p, new JS.MemberExpression(true, e, new JS.BinaryExpression('-', size, new JS.Literal(numElements - index - i))))));
        }
      }
      if (any(elements, function (p) {
          return p.rest;
        }))
        throw new Error('Positional destructuring assignments may not have more than one rest operator');
    }
    break;
  case !assignee['instanceof'](JS.ObjectExpression):
    e = expression;
    if (valueUsed || assignee.properties.length > 1) {
      e = genSym('cache');
      assignments.push(new JS.AssignmentExpression('=', e, expression));
    }
    for (var i$3 = 0, length$3 = assignee.properties.length; i$3 < length$3; ++i$3) {
      m = assignee.properties[i$3];
      propName = m.key['instanceof'](JS.Identifier) ? new JS.Literal(m.key.name) : m.key;
      assignments.push(assignment(m.value, dynamicMemberAccess(e, propName), valueUsed));
    }
    break;
  case !assignee['instanceof'](JS.Identifier, JS.GenSym, JS.MemberExpression):
    assignments.push(new JS.AssignmentExpression('=', assignee, expr(expression)));
    break;
  default:
    throw new Error('compile: assignment: unassignable assignee: ' + assignee.type);
  }
  switch (assignments.length) {
  case 0:
    if (e === expression) {
      return helpers.undef();
    } else {
      return expression;
    }
  case 1:
    return assignments[0];
  default:
    return new JS.SequenceExpression(valueUsed ? [].slice.call(assignments).concat([e]) : assignments);
  }
};
hasSoak = function (node) {
  switch (false) {
  case !node['instanceof'](CS.SoakedFunctionApplication, CS.SoakedMemberAccessOp, CS.SoakedProtoMemberAccessOp, CS.SoakedDynamicMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp):
    return true;
  case !node['instanceof'](CS.FunctionApplication):
    return hasSoak(node['function']);
  case !node['instanceof'](CS.MemberAccessOps):
    return hasSoak(node.expression);
  default:
    return false;
  }
};
generateSoak = function () {
  var fn;
  fn = function (node) {
    var cache$2, cache$3, cache$4, cache$5, cache$6, ctor, e, memberName, sym, tests, typeofTest;
    switch (false) {
    case !node['instanceof'](CS.MemberAccessOp, CS.ProtoMemberAccessOp):
      cache$2 = fn(node.expression);
      tests = cache$2[0];
      e = cache$2[1];
      return [
        tests,
        new node.constructor(e, node.memberName)
      ];
    case !node['instanceof'](CS.DynamicMemberAccessOp, CS.DynamicProtoMemberAccessOp):
      cache$3 = fn(node.expression);
      tests = cache$3[0];
      e = cache$3[1];
      return [
        tests,
        new node.constructor(e, node.indexingExpr)
      ];
    case !node['instanceof'](CS.FunctionApplication):
      cache$4 = fn(node['function']);
      tests = cache$4[0];
      e = cache$4[1];
      return [
        tests,
        new CS.FunctionApplication(e, node['arguments'])
      ];
    case !node['instanceof'](CS.SoakedFunctionApplication):
      cache$5 = fn(node['function']);
      tests = cache$5[0];
      e = cache$5[1];
      typeofTest = function (e) {
        return new CS.EQOp(new CS.String('function'), new CS.TypeofOp(e));
      };
      if (needsCaching(e)) {
        sym = new CS.GenSym('cache');
        return [
          [].slice.call(tests).concat([typeofTest(new CS.AssignOp(sym, e))]),
          new CS.FunctionApplication(sym, node['arguments'])
        ];
      } else {
        return [
          [].slice.call(tests).concat([typeofTest(e)]),
          new CS.FunctionApplication(e, node['arguments'])
        ];
      }
    case !node['instanceof'](CS.SoakedMemberAccessOp, CS.SoakedProtoMemberAccessOp, CS.SoakedDynamicMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp):
      memberName = function () {
        switch (false) {
        case !node['instanceof'](CS.SoakedMemberAccessOp, CS.SoakedProtoMemberAccessOp):
          return 'memberName';
        case !node['instanceof'](CS.SoakedDynamicMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp):
          return 'indexingExpr';
        }
      }.call(this);
      ctor = function () {
        switch (false) {
        case !node['instanceof'](CS.SoakedMemberAccessOp):
          return CS.MemberAccessOp;
        case !node['instanceof'](CS.SoakedProtoMemberAccessOp):
          return CS.ProtoMemberAccessOp;
        case !node['instanceof'](CS.SoakedDynamicMemberAccessOp):
          return CS.DynamicMemberAccessOp;
        case !node['instanceof'](CS.SoakedDynamicProtoMemberAccessOp):
          return CS.DynamicProtoMemberAccessOp;
        }
      }.call(this);
      cache$6 = fn(node.expression);
      tests = cache$6[0];
      e = cache$6[1];
      if (needsCaching(e)) {
        sym = new CS.GenSym('cache');
        return [
          [].slice.call(tests).concat([new CS.UnaryExistsOp(new CS.AssignOp(sym, e))]),
          new ctor(sym, node[memberName])
        ];
      } else {
        return [
          [].slice.call(tests).concat([new CS.UnaryExistsOp(e)]),
          new ctor(e, node[memberName])
        ];
      }
    default:
      return [
        [],
        node
      ];
    }
  };
  return function (node) {
    var cache$2, e, tests;
    cache$2 = fn(node);
    tests = cache$2[0];
    e = cache$2[1];
    return new CS.Conditional(foldl1(tests, function (memo, t) {
      return new CS.LogicalAndOp(memo, t);
    }), e);
  };
}();
helperNames = {};
helpers = {
  'extends': function () {
    var block, child, ctor, f, key, parent, protoAccess;
    protoAccess = function (e) {
      return memberAccess(e, 'prototype');
    };
    child = new JS.Identifier('child');
    parent = new JS.Identifier('parent');
    ctor = new JS.Identifier('ctor');
    key = new JS.Identifier('key');
    block = [
      new JS.ForInStatement(new JS.VariableDeclaration('var', [new JS.VariableDeclarator(key, null)]), parent, new JS.IfStatement(helpers.isOwn(parent, key), f = stmt(new JS.AssignmentExpression('=', new JS.MemberExpression(true, child, key), new JS.MemberExpression(true, parent, key))))),
      new JS.FunctionDeclaration(ctor, [], new JS.BlockStatement([stmt(new JS.AssignmentExpression('=', memberAccess(new JS.ThisExpression, 'constructor'), child))])),
      new JS.AssignmentExpression('=', protoAccess(ctor), protoAccess(parent)),
      new JS.AssignmentExpression('=', protoAccess(child), new JS.NewExpression(ctor, [])),
      new JS.AssignmentExpression('=', memberAccess(child, '__super__'), protoAccess(parent)),
      new JS.ReturnStatement(child)
    ];
    return new JS.FunctionDeclaration(helperNames['extends'], [
      child,
      parent
    ], new JS.BlockStatement(map(block, stmt)));
  },
  construct: function () {
    var args, block, child, ctor, fn, result;
    child = new JS.Identifier('child');
    ctor = new JS.Identifier('ctor');
    fn = new JS.Identifier('fn');
    args = new JS.Identifier('args');
    result = new JS.Identifier('result');
    block = [
      new JS.VariableDeclaration('var', [new JS.VariableDeclarator(fn, new JS.FunctionExpression(null, [], new JS.BlockStatement([])))]),
      new JS.AssignmentExpression('=', memberAccess(fn, 'prototype'), memberAccess(ctor, 'prototype')),
      new JS.VariableDeclaration('var', [
        new JS.VariableDeclarator(child, new JS.NewExpression(fn, [])),
        new JS.VariableDeclarator(result, new JS.CallExpression(memberAccess(ctor, 'apply'), [
          child,
          args
        ]))
      ]),
      new JS.ReturnStatement(new JS.ConditionalExpression(new JS.BinaryExpression('===', result, new JS.CallExpression(new JS.Identifier('Object'), [result])), result, child))
    ];
    return new JS.FunctionDeclaration(helperNames.construct, [
      ctor,
      args
    ], new JS.BlockStatement(map(block, stmt)));
  },
  isOwn: function () {
    var args, functionBody, hop, params;
    hop = memberAccess(new JS.ObjectExpression([]), 'hasOwnProperty');
    params = args = [
      new JS.Identifier('o'),
      new JS.Identifier('p')
    ];
    functionBody = [new JS.CallExpression(memberAccess(hop, 'call'), args)];
    return new JS.FunctionDeclaration(helperNames.isOwn, params, makeReturn(new JS.BlockStatement(map(functionBody, stmt))));
  },
  'in': function () {
    var functionBody, i, length, list, loopBody, member, varDeclaration;
    member = new JS.Identifier('member');
    list = new JS.Identifier('list');
    i = new JS.Identifier('i');
    length = new JS.Identifier('length');
    varDeclaration = new JS.VariableDeclaration('var', [
      new JS.VariableDeclarator(i, new JS.Literal(0)),
      new JS.VariableDeclarator(length, memberAccess(list, 'length'))
    ]);
    loopBody = new JS.IfStatement(new JS.LogicalExpression('&&', new JS.BinaryExpression('in', i, list), new JS.BinaryExpression('===', new JS.MemberExpression(true, list, i), member)), new JS.ReturnStatement(new JS.Literal(true)));
    functionBody = [
      new JS.ForStatement(varDeclaration, new JS.BinaryExpression('<', i, length), new JS.UpdateExpression('++', true, i), loopBody),
      new JS.Literal(false)
    ];
    return new JS.FunctionDeclaration(helperNames['in'], [
      member,
      list
    ], makeReturn(new JS.BlockStatement(map(functionBody, stmt))));
  }
};
enabledHelpers = [];
for (h in helpers) {
  if (!isOwn$(helpers, h))
    continue;
  fn = helpers[h];
  helperNames[h] = genSym(h);
  helpers[h] = function (h, fn) {
    return function () {
      enabledHelpers.push(fn());
      return (helpers[h] = function () {
        return new JS.CallExpression(helperNames[h], arguments);
      }).apply(this, arguments);
    };
  }(h, fn);
}
inlineHelpers = {
  exp: function () {
    return new JS.CallExpression(memberAccess(new JS.Identifier('Math'), 'pow'), arguments);
  },
  undef: function () {
    return new JS.UnaryExpression('void', new JS.Literal(0));
  },
  slice: function () {
    return new JS.CallExpression(memberAccess(memberAccess(new JS.ArrayExpression([]), 'slice'), 'call'), arguments);
  }
};
for (h in inlineHelpers) {
  if (!isOwn$(inlineHelpers, h))
    continue;
  fn = inlineHelpers[h];
  helpers[h] = fn;
}
exports.Compiler = function () {
  Compiler.compile = function (this$) {
    return function () {
      var cache$2;
      return (cache$2 = new this$).compile.apply(cache$2, [].slice.call(arguments));
    };
  }(Compiler);
  defaultRules = [
    [
      CS.Program,
      function (param$) {
        var block, body, cache$2, cache$3, decls, fnDeclHelpers, inScope, options, otherHelpers, pkg, program;
        {
          cache$2 = param$;
          body = cache$2.body;
          inScope = cache$2.inScope;
          options = cache$2.options;
        }
        if (!(null != body))
          return new JS.Program([]);
        block = stmt(body);
        block = block['instanceof'](JS.BlockStatement) ? block.body : [block];
        cache$3 = partition(enabledHelpers, function (helper) {
          return helper['instanceof'](JS.FunctionDeclaration);
        });
        fnDeclHelpers = cache$3[0];
        otherHelpers = cache$3[1];
        [].push.apply(block, fnDeclHelpers);
        [].unshift.apply(block, otherHelpers);
        decls = nub(concatMap(block, declarationsNeededRecursive));
        if (decls.length > 0)
          if (options.bare) {
            block.unshift(makeVarDeclaration(decls));
          } else {
            block = [stmt(new JS.UnaryExpression('void', new JS.CallExpression(memberAccess(new JS.FunctionExpression(null, [], new JS.BlockStatement(block)), 'call'), [new JS.ThisExpression])))];
          }
        pkg = require('./../package.json');
        program = new JS.Program(block);
        program.leadingComments = [{
            type: 'Line',
            value: ' Generated by CoffeeScript ' + pkg.version
          }];
        return program;
      }
    ],
    [
      CS.Block,
      function (param$) {
        var statements;
        statements = param$.statements;
        switch (statements.length) {
        case 0:
          return new JS.EmptyStatement;
        case 1:
          return new stmt(statements[0]);
        default:
          return new JS.BlockStatement(concatMap(statements, function (s) {
            if (s['instanceof'](JS.BlockStatement)) {
              return map(s.body, stmt);
            } else if (s['instanceof'](JS.SequenceExpression)) {
              return map(s.expressions, stmt);
            } else {
              return [stmt(s)];
            }
          }));
        }
      }
    ],
    [
      CS.SeqOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.SequenceExpression([
          left,
          right
        ]);
      }
    ],
    [
      CS.Conditional,
      function (param$) {
        var ancestry, cache$2, condition;
        var alternate, consequent;
        {
          cache$2 = param$;
          condition = cache$2.condition;
          consequent = cache$2.consequent;
          alternate = cache$2.alternate;
          ancestry = cache$2.ancestry;
        }
        if (null != alternate) {
          if (!(null != consequent))
            throw new Error('Conditional with non-null alternate requires non-null consequent');
          if (!alternate['instanceof'](JS.IfStatement))
            alternate = forceBlock(alternate);
        }
        if (null != alternate || (null != ancestry[0] ? ancestry[0]['instanceof'](CS.Conditional) : void 0))
          consequent = forceBlock(consequent);
        return new JS.IfStatement(expr(condition), stmt(consequent), alternate);
      }
    ],
    [
      CS.ForIn,
      function (param$) {
        var block, body, cache$2, compile, e, filter, i, k, keyAssignee, length, op, step, target, update, valAssignee, varDeclaration;
        {
          cache$2 = param$;
          valAssignee = cache$2.valAssignee;
          keyAssignee = cache$2.keyAssignee;
          target = cache$2.target;
          step = cache$2.step;
          filter = cache$2.filter;
          body = cache$2.body;
          compile = cache$2.compile;
        }
        i = genSym('i');
        length = genSym('length');
        block = forceBlock(body);
        if (!block.body.length)
          block.body.push(stmt(helpers.undef()));
        if (this.target['instanceof'](CS.Range) && (this.target.left['instanceof'](CS.Int) || this.target.left['instanceof'](CS.UnaryNegateOp) && this.target.left.expression['instanceof'](CS.Int)) && (this.target.right['instanceof'](CS.Int) || this.target.right['instanceof'](CS.UnaryNegateOp) && this.target.right.expression['instanceof'](CS.Int))) {
          varDeclaration = new JS.AssignmentExpression('=', i, compile(this.target.left));
          update = new JS.UpdateExpression('++', true, i);
          if (null != keyAssignee) {
            k = genSym('k');
            varDeclaration = new JS.SequenceExpression([
              new JS.AssignmentExpression('=', k, new JS.Literal(0)),
              varDeclaration
            ]);
            update = new JS.SequenceExpression([
              new JS.UpdateExpression('++', true, k),
              update
            ]);
            block.body.unshift(stmt(new JS.AssignmentExpression('=', keyAssignee, k)));
          }
          if (null != valAssignee)
            block.body.unshift(stmt(new JS.AssignmentExpression('=', valAssignee, i)));
          op = this.target.isInclusive ? '<=' : '<';
          return new JS.ForStatement(varDeclaration, new JS.BinaryExpression(op, i, compile(this.target.right)), update, block);
        }
        e = needsCaching(this.target) ? genSym('cache') : target;
        varDeclaration = new JS.VariableDeclaration('var', [
          new JS.VariableDeclarator(i, new JS.Literal(0)),
          new JS.VariableDeclarator(length, memberAccess(e, 'length'))
        ]);
        if (!(e === target))
          varDeclaration.declarations.unshift(new JS.VariableDeclarator(e, target));
        if (null != this.filter)
          block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', filter), new JS.ContinueStatement)));
        if (null != keyAssignee)
          block.body.unshift(stmt(assignment(keyAssignee, i)));
        if (null != valAssignee)
          block.body.unshift(stmt(assignment(valAssignee, new JS.MemberExpression(true, e, i))));
        return new JS.ForStatement(varDeclaration, new JS.BinaryExpression('<', i, length), new JS.UpdateExpression('++', true, i), block);
      }
    ],
    [
      CS.ForOf,
      function (param$) {
        var block, body, cache$2, e, filter, keyAssignee, right, target, valAssignee;
        {
          cache$2 = param$;
          keyAssignee = cache$2.keyAssignee;
          valAssignee = cache$2.valAssignee;
          target = cache$2.target;
          filter = cache$2.filter;
          body = cache$2.body;
        }
        block = forceBlock(body);
        if (!block.body.length)
          block.body.push(stmt(helpers.undef()));
        e = this.isOwn && needsCaching(this.target) ? genSym('cache') : expr(target);
        if (null != this.filter)
          block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', filter), new JS.ContinueStatement)));
        if (null != valAssignee)
          block.body.unshift(stmt(assignment(valAssignee, new JS.MemberExpression(true, e, keyAssignee))));
        if (this.isOwn)
          block.body.unshift(stmt(new JS.IfStatement(new JS.UnaryExpression('!', helpers.isOwn(e, keyAssignee)), new JS.ContinueStatement)));
        right = e === target ? e : new JS.AssignmentExpression('=', e, target);
        return new JS.ForInStatement(keyAssignee, right, block);
      }
    ],
    [
      CS.While,
      function (param$) {
        var body, cache$2, condition;
        {
          cache$2 = param$;
          condition = cache$2.condition;
          body = cache$2.body;
        }
        return new JS.WhileStatement(expr(condition), forceBlock(body));
      }
    ],
    [
      CS.Switch,
      function (param$) {
        var alternate, c, cache$2;
        var cases, expression;
        {
          cache$2 = param$;
          expression = cache$2.expression;
          cases = cache$2.cases;
          alternate = cache$2.alternate;
        }
        cases = concat(cases);
        if (!(null != expression)) {
          expression = new JS.Literal(false);
          for (var i$ = 0, length$ = cases.length; i$ < length$; ++i$) {
            c = cases[i$];
            c.test = new JS.UnaryExpression('!', c.test);
          }
        }
        if (null != alternate)
          cases.push(new JS.SwitchCase(null, [stmt(alternate)]));
        for (var i$1 = 0, length$1 = cases.slice(0, -1).length; i$1 < length$1; ++i$1) {
          c = cases.slice(0, -1)[i$1];
          if (!((null != c.consequent ? c.consequent.length : void 0) > 0))
            continue;
          c.consequent.push(new JS.BreakStatement);
        }
        return new JS.SwitchStatement(expression, cases);
      }
    ],
    [
      CS.SwitchCase,
      function (param$) {
        var block, cache$2, cases, conditions, consequent;
        {
          cache$2 = param$;
          conditions = cache$2.conditions;
          consequent = cache$2.consequent;
        }
        cases = map(conditions, function (c) {
          return new JS.SwitchCase(c, []);
        });
        block = stmt(consequent);
        block = null != block ? block['instanceof'](JS.BlockStatement) ? block.body : [block] : [];
        cases[cases.length - 1].consequent = block;
        return cases;
      }
    ],
    [
      CS.Try,
      function (param$) {
        var body, cache$2, catchAssignee, catchBlock, catchBody, e, finallyBlock, finallyBody, handlers;
        {
          cache$2 = param$;
          body = cache$2.body;
          catchAssignee = cache$2.catchAssignee;
          catchBody = cache$2.catchBody;
          finallyBody = cache$2.finallyBody;
        }
        finallyBlock = null != this.finallyBody ? forceBlock(finallyBody) : null;
        if (null != this.catchBody || !(null != this.finallyBody)) {
          e = genSym('e');
          catchBlock = forceBlock(catchBody);
          if (null != catchAssignee)
            catchBlock.body.unshift(stmt(assignment(catchAssignee, e)));
          handlers = [new JS.CatchClause(e, catchBlock)];
        } else {
          handlers = [];
        }
        return new JS.TryStatement(forceBlock(body), handlers, finallyBlock);
      }
    ],
    [
      CS.Throw,
      function (param$) {
        var expression;
        expression = param$.expression;
        return new JS.ThrowStatement(expression);
      }
    ],
    [
      CS.Range,
      function (param$) {
        var accum, ancestry, body, cache$2, condition, conditionAlternate, conditionConsequent, conditionTest, i, left, left_, range, rawLeft, rawRight, right, right_, update, vars;
        {
          cache$2 = param$;
          left_ = cache$2.left;
          right_ = cache$2.right;
          ancestry = cache$2.ancestry;
        }
        if ((this.left['instanceof'](CS.Int) || this.left['instanceof'](CS.UnaryNegateOp) && this.left.expression['instanceof'](CS.Int)) && (this.right['instanceof'](CS.Int) || this.right['instanceof'](CS.UnaryNegateOp) && this.right.expression['instanceof'](CS.Int))) {
          rawLeft = this.left['instanceof'](CS.UnaryNegateOp) ? -this.left.expression.data : this.left.data;
          rawRight = this.right['instanceof'](CS.UnaryNegateOp) ? -this.right.expression.data : this.right.data;
          if (Math.abs(rawLeft - rawRight) <= 20) {
            range = this.isInclusive ? function () {
              var accum$;
              accum$ = [];
              for (var i$ = rawLeft; rawLeft <= rawRight ? i$ <= rawRight : i$ >= rawRight; rawLeft <= rawRight ? ++i$ : --i$)
                accum$.push(i$);
              return accum$;
            }.apply(this, arguments) : function () {
              var accum$;
              accum$ = [];
              for (var i$ = rawLeft; rawLeft <= rawRight ? i$ < rawRight : i$ > rawRight; rawLeft <= rawRight ? ++i$ : --i$)
                accum$.push(i$);
              return accum$;
            }.apply(this, arguments);
            return new JS.ArrayExpression(map(range, function (n) {
              if (n < 0) {
                return new JS.UnaryExpression('-', new JS.Literal(-n));
              } else {
                return new JS.Literal(n);
              }
            }));
          }
        }
        accum = genSym('accum');
        body = [stmt(new JS.AssignmentExpression('=', accum, new JS.ArrayExpression([])))];
        if (needsCaching(left_)) {
          left = genSym('from');
          body.push(stmt(new JS.AssignmentExpression('=', left, left_)));
        } else {
          left = left_;
        }
        if (needsCaching(right_)) {
          right = genSym('to');
          body.push(stmt(new JS.AssignmentExpression('=', right, right_)));
        } else {
          right = right_;
        }
        i = genSym('i');
        vars = new JS.VariableDeclaration('var', [new JS.VariableDeclarator(i, left)]);
        conditionTest = new JS.BinaryExpression('<=', left, right);
        conditionConsequent = new JS.BinaryExpression(this.isInclusive ? '<=' : '<', i, right);
        conditionAlternate = new JS.BinaryExpression(this.isInclusive ? '>=' : '>', i, right);
        condition = new JS.ConditionalExpression(conditionTest, conditionConsequent, conditionAlternate);
        update = new JS.ConditionalExpression(conditionTest, new JS.UpdateExpression('++', true, i), new JS.UpdateExpression('--', true, i));
        body.push(new JS.ForStatement(vars, condition, update, stmt(new JS.CallExpression(memberAccess(accum, 'push'), [i]))));
        body.push(new JS.ReturnStatement(accum));
        if (any(ancestry, function (ancestor) {
            return ancestor['instanceof'](CS.Functions);
          })) {
          return new JS.CallExpression(memberAccess(new JS.FunctionExpression(null, [], new JS.BlockStatement(body)), 'apply'), [
            new JS.ThisExpression,
            new JS.Identifier('arguments')
          ]);
        } else {
          return new JS.CallExpression(memberAccess(new JS.FunctionExpression(null, [], new JS.BlockStatement(body)), 'call'), [new JS.ThisExpression]);
        }
      }
    ],
    [
      CS.ArrayInitialiser,
      function () {
        var groupMembers;
        groupMembers = function (members) {
          var cache$2, cache$3, sliced, ys, zs;
          if (members.length === 0) {
            return [];
          } else {
            cache$2 = span(members, function (x) {
              return !x.spread;
            });
            ys = cache$2[0];
            zs = cache$2[1];
            if (ys.length === 0) {
              sliced = helpers.slice(zs[0].expression);
              cache$3 = [
                sliced,
                zs.slice(1)
              ];
              ys = cache$3[0];
              zs = cache$3[1];
              cache$3;
            } else {
              ys = new JS.ArrayExpression(map(ys, expr));
            }
            return [ys].concat(groupMembers(zs));
          }
        };
        return function (param$) {
          var cache$2, compile, grouped, members;
          {
            cache$2 = param$;
            members = cache$2.members;
            compile = cache$2.compile;
          }
          if (any(members, function (m) {
              return m.spread;
            })) {
            grouped = map(groupMembers(members), expr);
            if (grouped.length <= 1) {
              return grouped[0];
            } else {
              return new JS.CallExpression(memberAccess(grouped[0], 'concat'), grouped.slice(1));
            }
          } else {
            return new JS.ArrayExpression(map(members, expr));
          }
        };
      }()
    ],
    [
      CS.Spread,
      function (param$) {
        var expression;
        expression = param$.expression;
        return {
          spread: true,
          expression: expr(expression)
        };
      }
    ],
    [
      CS.ObjectInitialiser,
      function (param$) {
        var members;
        members = param$.members;
        return new JS.ObjectExpression(members);
      }
    ],
    [
      CS.ObjectInitialiserMember,
      function (param$) {
        var cache$2, expression, keyName;
        var key;
        {
          cache$2 = param$;
          key = cache$2.key;
          expression = cache$2.expression;
        }
        keyName = this.key.data;
        key = isIdentifierName(keyName) ? new JS.Identifier(keyName) : new JS.Literal(keyName);
        return new JS.Property(key, expr(expression));
      }
    ],
    [
      CS.DefaultParam,
      function (param$) {
        var cache$2, d, param;
        {
          cache$2 = param$;
          param = cache$2.param;
          d = cache$2['default'];
        }
        return {
          param: param,
          'default': d
        };
      }
    ],
    [
      CS.Function,
      CS.BoundFunction,
      function () {
        var handleParam;
        handleParam = function (param, original, block, inScope) {
          var decls, p;
          switch (false) {
          case !original['instanceof'](CS.Rest):
            return param;
          case !original['instanceof'](CS.Identifier):
            return param;
          case !original['instanceof'](CS.MemberAccessOps, CS.ObjectInitialiser, CS.ArrayInitialiser):
            p = genSym('param');
            decls = map(intersect(inScope, beingDeclared(original)), function (i) {
              return new JS.Identifier(i);
            });
            block.body.unshift(stmt(assignment(param, p)));
            if (decls.length)
              block.body.unshift(makeVarDeclaration(decls));
            return p;
          case !original['instanceof'](CS.DefaultParam):
            p = handleParam.call(this, param.param, original.param, block, inScope);
            block.body.unshift(new JS.IfStatement(new JS.BinaryExpression('==', new JS.Literal(null), p), stmt(assignment(p, param['default']))));
            return p;
          default:
            throw new Error('Unsupported parameter type: ' + original.className);
          }
        };
        return function (param$) {
          var alternate, ancestry, block, cache$2, consequent, i, index, inScope, last, newThis, numArgs, numParams, p, parameters_, paramName, performedRewrite, pIndex, reassignments, rewriteThis, test;
          var body, parameters;
          {
            cache$2 = param$;
            parameters = cache$2.parameters;
            body = cache$2.body;
            ancestry = cache$2.ancestry;
            inScope = cache$2.inScope;
          }
          if (!(null != ancestry[0] ? ancestry[0]['instanceof'](CS.Constructor) : void 0))
            body = makeReturn(body);
          block = forceBlock(body);
          last = block.body.slice(-1)[0];
          if ((null != last ? last['instanceof'](JS.ReturnStatement) : void 0) && !(null != last.argument))
            block.body = block.body.slice(0, -1);
          parameters_ = parameters.length === 0 ? [] : (pIndex = parameters.length, function (accum$) {
            while (pIndex--) {
              accum$.push(handleParam.call(this, parameters[pIndex], this.parameters[pIndex], block, inScope));
            }
            return accum$;
          }.call(this, []));
          parameters = parameters_.reverse();
          if (parameters.length > 0) {
            if (parameters.slice(-1)[0].rest) {
              numParams = parameters.length;
              paramName = parameters[numParams - 1] = parameters[numParams - 1].expression;
              test = new JS.BinaryExpression('<=', new JS.Literal(numParams), memberAccess(new JS.Identifier('arguments'), 'length'));
              consequent = helpers.slice(new JS.Identifier('arguments'), new JS.Literal(numParams - 1));
              alternate = new JS.ArrayExpression([]);
              block.body.unshift(stmt(new JS.AssignmentExpression('=', paramName, new JS.ConditionalExpression(test, consequent, alternate))));
            } else if (any(parameters, function (p) {
                return p.rest;
              })) {
              paramName = index = null;
              for (var i$ = 0, length$ = parameters.length; i$ < length$; ++i$) {
                p = parameters[i$];
                i = i$;
                if (!p.rest)
                  continue;
                paramName = p.expression;
                index = i;
                break;
              }
              parameters.splice(index, 1);
              numParams = parameters.length;
              numArgs = genSym('numArgs');
              reassignments = new JS.IfStatement(new JS.BinaryExpression('>', new JS.AssignmentExpression('=', numArgs, memberAccess(new JS.Identifier('arguments'), 'length')), new JS.Literal(numParams)), new JS.BlockStatement([stmt(new JS.AssignmentExpression('=', paramName, helpers.slice(new JS.Identifier('arguments'), new JS.Literal(index), new JS.BinaryExpression('-', numArgs, new JS.Literal(numParams - index)))))]), new JS.BlockStatement([stmt(new JS.AssignmentExpression('=', paramName, new JS.ArrayExpression([])))]));
              for (var i$1 = 0, length$1 = parameters.slice(index).length; i$1 < length$1; ++i$1) {
                p = parameters.slice(index)[i$1];
                i = i$1;
                reassignments.consequent.body.push(stmt(new JS.AssignmentExpression('=', p, new JS.MemberExpression(true, new JS.Identifier('arguments'), new JS.BinaryExpression('-', numArgs, new JS.Literal(numParams - index - i))))));
              }
              block.body.unshift(makeVarDeclaration([paramName]), reassignments);
            }
            if (any(parameters, function (p) {
                return p.rest;
              }))
              throw new Error('Parameter lists may not have more than one rest operator');
          }
          performedRewrite = false;
          if (this['instanceof'](CS.BoundFunction)) {
            newThis = genSym('this');
            rewriteThis = generateMutatingWalker(function () {
              if (this['instanceof'](JS.ThisExpression)) {
                performedRewrite = true;
                return newThis;
              } else if (this['instanceof'](JS.FunctionExpression, JS.FunctionDeclaration)) {
                return this;
              } else {
                return rewriteThis(this);
              }
            });
            rewriteThis(block);
          }
          fn = new JS.FunctionExpression(null, parameters, block);
          if (performedRewrite) {
            return new JS.CallExpression(new JS.FunctionExpression(null, [newThis], new JS.BlockStatement([new JS.ReturnStatement(fn)])), [new JS.ThisExpression]);
          } else {
            return fn;
          }
        };
      }()
    ],
    [
      CS.Rest,
      function (param$) {
        var expression;
        expression = param$.expression;
        return {
          rest: true,
          expression: expression,
          isExpression: true,
          isStatement: true
        };
      }
    ],
    [
      CS.Class,
      function (param$) {
        var _, args, block, body, c, cache$2, compile, ctorBody, ctorIndex, ctorRef, i, iife, instance, member, memberName, nameAssignee, params, parent, parentRef, protoAssignOp, protoMember, ps, rewriteThis;
        var ctor, name;
        {
          cache$2 = param$;
          nameAssignee = cache$2.nameAssignee;
          parent = cache$2.parent;
          name = cache$2.name;
          ctor = cache$2.ctor;
          body = cache$2.body;
          compile = cache$2.compile;
        }
        args = [];
        params = [];
        parentRef = genSym('super');
        block = forceBlock(body);
        if (name['instanceof'](JS.Identifier) && in$(name.name, jsReserved))
          name = genSym(name.name);
        if (null != ctor) {
          for (var i$ = 0, length$ = block.body.length; i$ < length$; ++i$) {
            c = block.body[i$];
            i = i$;
            if (!c['instanceof'](JS.FunctionDeclaration))
              continue;
            ctorIndex = i;
            break;
          }
          block.body.splice(ctorIndex, 1, ctor);
        } else {
          ctorBody = new JS.BlockStatement([]);
          if (null != parent)
            ctorBody.body.push(stmt(new JS.CallExpression(memberAccess(parentRef, 'apply'), [
              new JS.ThisExpression,
              new JS.Identifier('arguments')
            ])));
          ctor = new JS.FunctionDeclaration(name, [], ctorBody);
          ctorIndex = 0;
          block.body.unshift(ctor);
        }
        ctor.id = name;
        if (null != this.ctor && !this.ctor.expression['instanceof'](CS.Functions)) {
          ctorRef = genSym('externalCtor');
          ctor.body.body.push(makeReturn(new JS.CallExpression(memberAccess(ctorRef, 'apply'), [
            new JS.ThisExpression,
            new JS.Identifier('arguments')
          ])));
          block.body.splice(ctorIndex, 0, stmt(new JS.AssignmentExpression('=', ctorRef, expr(compile(this.ctor.expression)))));
        }
        if (this.boundMembers.length > 0) {
          instance = genSym('instance');
          for (var i$1 = 0, length$1 = this.boundMembers.length; i$1 < length$1; ++i$1) {
            protoAssignOp = this.boundMembers[i$1];
            memberName = protoAssignOp.assignee.data.toString();
            ps = function (accum$) {
              for (var i$2 = 0, length$2 = protoAssignOp.expression.parameters.length; i$2 < length$2; ++i$2) {
                _ = protoAssignOp.expression.parameters[i$2];
                accum$.push(genSym());
              }
              return accum$;
            }.call(this, []);
            member = memberAccess(new JS.ThisExpression, memberName);
            protoMember = memberAccess(memberAccess(name, 'prototype'), memberName);
            fn = new JS.FunctionExpression(null, ps, new JS.BlockStatement([makeReturn(new JS.CallExpression(memberAccess(protoMember, 'apply'), [
                instance,
                new JS.Identifier('arguments')
              ]))]));
            ctor.body.body.unshift(stmt(new JS.AssignmentExpression('=', member, fn)));
          }
          ctor.body.body.unshift(stmt(new JS.AssignmentExpression('=', instance, new JS.ThisExpression)));
        }
        if (null != parent) {
          params.push(parentRef);
          args.push(parent);
          block.body.unshift(stmt(helpers['extends'](name, parentRef)));
        }
        block.body.push(new JS.ReturnStatement(new JS.ThisExpression));
        rewriteThis = generateMutatingWalker(function () {
          if (this['instanceof'](JS.ThisExpression)) {
            return name;
          } else if (this['instanceof'](JS.FunctionExpression, JS.FunctionDeclaration)) {
            return this;
          } else {
            return rewriteThis(this);
          }
        });
        rewriteThis(block);
        iife = new JS.CallExpression(new JS.FunctionExpression(null, params, block).g(), args);
        if (null != nameAssignee) {
          return assignment(nameAssignee, iife);
        } else {
          return iife;
        }
      }
    ],
    [
      CS.Constructor,
      function (param$) {
        var expression, tmpName;
        expression = param$.expression;
        tmpName = genSym('class');
        if (this.expression['instanceof'](CS.Functions)) {
          return new JS.FunctionDeclaration(tmpName, expression.params, forceBlock(expression.body));
        } else {
          return new JS.FunctionDeclaration(tmpName, [], new JS.BlockStatement([]));
        }
      }
    ],
    [
      CS.ClassProtoAssignOp,
      function (param$) {
        var assignee, cache$2, compile, expression, protoMember;
        {
          cache$2 = param$;
          assignee = cache$2.assignee;
          expression = cache$2.expression;
          compile = cache$2.compile;
        }
        if (this.expression['instanceof'](CS.BoundFunction)) {
          return compile(new CS.ClassProtoAssignOp(this.assignee, new CS.Function(this.expression.parameters, this.expression.body)));
        } else {
          protoMember = memberAccess(memberAccess(new JS.ThisExpression, 'prototype'), this.assignee.data);
          return new JS.AssignmentExpression('=', protoMember, expression);
        }
      }
    ],
    [
      CS.AssignOp,
      function (param$) {
        var ancestry, assignee, cache$2, expression;
        {
          cache$2 = param$;
          assignee = cache$2.assignee;
          expression = cache$2.expression;
          ancestry = cache$2.ancestry;
        }
        return assignment(assignee, expression, usedAsExpression(this, ancestry));
      }
    ],
    [
      CS.CompoundAssignOp,
      function (param$) {
        var assignee, cache$2, condition, expression, inScope, op;
        {
          cache$2 = param$;
          assignee = cache$2.assignee;
          expression = cache$2.expression;
          inScope = cache$2.inScope;
        }
        op = function () {
          switch (this.op) {
          case CS.LogicalAndOp.prototype.className:
            return '&&';
          case CS.LogicalOrOp.prototype.className:
            return '||';
          case CS.ExistsOp.prototype.className:
            return '?';
          case CS.BitOrOp.prototype.className:
            return '|';
          case CS.BitXorOp.prototype.className:
            return '^';
          case CS.BitAndOp.prototype.className:
            return '&';
          case CS.LeftShiftOp.prototype.className:
            return '<<';
          case CS.SignedRightShiftOp.prototype.className:
            return '>>';
          case CS.UnsignedRightShiftOp.prototype.className:
            return '>>>';
          case CS.PlusOp.prototype.className:
            return '+';
          case CS.SubtractOp.prototype.className:
            return '-';
          case CS.MultiplyOp.prototype.className:
            return '*';
          case CS.DivideOp.prototype.className:
            return '/';
          case CS.RemOp.prototype.className:
            return '%';
          case CS.ExpOp.prototype.className:
            return '**';
          default:
            throw new Error('Unrecognised compound assignment operator');
          }
        }.call(this);
        if ((op === '&&' || op === '||' || op === '?') && assignee['instanceof'](JS.Identifier) && !in$(assignee.name, inScope))
          throw new Error('the variable "' + assignee.name + '" can\'t be assigned with ?= because it has not been defined.');
        switch (op) {
        case '&&':
        case '||':
          return new JS.LogicalExpression(op, assignee, new JS.AssignmentExpression('=', assignee, expr(expression)));
        case '?':
          condition = new JS.BinaryExpression('!=', new JS.Literal(null), assignee);
          return new JS.ConditionalExpression(condition, assignee, new JS.AssignmentExpression('=', assignee, expr(expression)));
        case '**':
          return new JS.AssignmentExpression('=', assignee, helpers.exp(assignee, expr(expression)));
        default:
          return new JS.AssignmentExpression('' + op + '=', assignee, expr(expression));
        }
      }
    ],
    [
      CS.ChainedComparisonOp,
      function (param$) {
        var cache$2, compile, expression, left, lhs;
        {
          cache$2 = param$;
          expression = cache$2.expression;
          compile = cache$2.compile;
        }
        if (!this.expression.left['instanceof'](CS.ComparisonOps))
          return expression;
        left = expression.left.right;
        lhs = compile(new CS.ChainedComparisonOp(this.expression.left));
        if (needsCaching(this.expression.left.right)) {
          left = genSym('cache');
          if (this.expression.left.left['instanceof'](CS.ComparisonOps)) {
            lhs.right.right = new JS.AssignmentExpression('=', left, lhs.right.right);
          } else {
            lhs.right = new JS.AssignmentExpression('=', left, lhs.right);
          }
        }
        return new JS.LogicalExpression('&&', lhs, new JS.BinaryExpression(expression.operator, left, expression.right));
      }
    ],
    [
      CS.FunctionApplication,
      function (param$) {
        var args, cache$2, compile, context, lhs;
        var fn;
        {
          cache$2 = param$;
          fn = cache$2['function'];
          args = cache$2['arguments'];
          compile = cache$2.compile;
        }
        if (any(args, function (m) {
            return m.spread;
          })) {
          lhs = this['function'];
          context = new CS.Null;
          if (needsCaching(this['function'])) {
            context = new CS.GenSym('cache');
            lhs = this['function']['instanceof'](CS.StaticMemberAccessOps) ? new this['function'].constructor(new CS.AssignOp(context, lhs.expression), this['function'].memberName) : this['function']['instanceof'](CS.DynamicMemberAccessOps) ? new this['function'].constructor(new CS.AssignOp(context, lhs.expression), this['function'].indexingExpr) : new CS.AssignOp(context, lhs);
          } else if (lhs['instanceof'](CS.MemberAccessOps)) {
            context = lhs.expression;
          }
          if (this['function']['instanceof'](CS.ProtoMemberAccessOp, CS.DynamicProtoMemberAccessOp)) {
            context = new CS.MemberAccessOp(context, 'prototype');
          } else if (this['function']['instanceof'](CS.SoakedProtoMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp)) {
            context = new CS.SoakedMemberAccessOp(context, 'prototype');
          }
          return compile(new CS.FunctionApplication(new CS.MemberAccessOp(lhs, 'apply'), [
            context,
            new CS.ArrayInitialiser(this['arguments'])
          ]));
        } else if (hasSoak(this)) {
          return compile(generateSoak(this));
        } else {
          return new JS.CallExpression(expr(fn), map(args, expr));
        }
      }
    ],
    [
      CS.SoakedFunctionApplication,
      function (param$) {
        var compile;
        compile = param$.compile;
        return compile(generateSoak(this));
      }
    ],
    [
      CS.NewOp,
      function (param$) {
        var args, cache$2, compile, ctor;
        {
          cache$2 = param$;
          ctor = cache$2.ctor;
          args = cache$2['arguments'];
          compile = cache$2.compile;
        }
        if (any(args, function (m) {
            return m.spread;
          })) {
          return helpers.construct(ctor, compile(new CS.ArrayInitialiser(this['arguments'])));
        } else {
          return new JS.NewExpression(ctor, map(args, expr));
        }
      }
    ],
    [
      CS.HeregExp,
      function (param$) {
        var args, expression, flag, flags;
        expression = param$.expression;
        args = [expression];
        if (flags = function (accum$) {
            for (var cache$2 = [
                  'g',
                  'i',
                  'm',
                  'y'
                ], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
              flag = cache$2[i$];
              if (!this.flags[flag])
                continue;
              accum$.push(flag);
            }
            return accum$;
          }.call(this, []).join(''))
          args.push(new JS.Literal(flags));
        return new JS.NewExpression(new JS.Identifier('RegExp'), args);
      }
    ],
    [
      CS.RegExp,
      function () {
        var flag, flags, re;
        flags = function (accum$) {
          for (var cache$2 = [
                'g',
                'i',
                'm',
                'y'
              ], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
            flag = cache$2[i$];
            if (!this.flags[flag])
              continue;
            accum$.push(flag);
          }
          return accum$;
        }.call(this, []).join('');
        re = new RegExp(this.data, flags);
        return new JS.Literal(re);
      }
    ],
    [
      CS.ConcatOp,
      function (param$) {
        var ancestry, cache$2, left, leftmost, plusOp, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
          ancestry = cache$2.ancestry;
        }
        plusOp = new JS.BinaryExpression('+', expr(left), expr(right));
        if (!ancestry[0]['instanceof'](CS.ConcatOp)) {
          leftmost = plusOp;
          while (null != (null != leftmost.left ? leftmost.left.left : void 0)) {
            leftmost = leftmost.left;
          }
          if (!(leftmost.left['instanceof'](JS.Literal) && 'string' === typeof leftmost.left.value))
            leftmost.left = new JS.BinaryExpression('+', new JS.Literal(''), leftmost.left);
        }
        return plusOp;
      }
    ],
    [
      CS.MemberAccessOp,
      CS.SoakedMemberAccessOp,
      function (param$) {
        var cache$2, compile, expression;
        {
          cache$2 = param$;
          expression = cache$2.expression;
          compile = cache$2.compile;
        }
        if (hasSoak(this)) {
          return expr(compile(generateSoak(this)));
        } else {
          return memberAccess(expression, this.memberName);
        }
      }
    ],
    [
      CS.ProtoMemberAccessOp,
      CS.SoakedProtoMemberAccessOp,
      function (param$) {
        var cache$2, compile, expression;
        {
          cache$2 = param$;
          expression = cache$2.expression;
          compile = cache$2.compile;
        }
        if (hasSoak(this)) {
          return expr(compile(generateSoak(this)));
        } else {
          return memberAccess(memberAccess(expression, 'prototype'), this.memberName);
        }
      }
    ],
    [
      CS.DynamicMemberAccessOp,
      CS.SoakedDynamicMemberAccessOp,
      function (param$) {
        var cache$2, compile, expression, indexingExpr;
        {
          cache$2 = param$;
          expression = cache$2.expression;
          indexingExpr = cache$2.indexingExpr;
          compile = cache$2.compile;
        }
        if (hasSoak(this)) {
          return expr(compile(generateSoak(this)));
        } else {
          return dynamicMemberAccess(expression, indexingExpr);
        }
      }
    ],
    [
      CS.DynamicProtoMemberAccessOp,
      CS.SoakedDynamicProtoMemberAccessOp,
      function (param$) {
        var cache$2, compile, expression, indexingExpr;
        {
          cache$2 = param$;
          expression = cache$2.expression;
          indexingExpr = cache$2.indexingExpr;
          compile = cache$2.compile;
        }
        if (hasSoak(this)) {
          return expr(compile(generateSoak(this)));
        } else {
          return dynamicMemberAccess(memberAccess(expression, 'prototype'), indexingExpr);
        }
      }
    ],
    [
      CS.Slice,
      function (param$) {
        var args, cache$2, expression, left, right;
        {
          cache$2 = param$;
          expression = cache$2.expression;
          left = cache$2.left;
          right = cache$2.right;
        }
        args = null != left ? [left] : null != right ? [new JS.Literal(0)] : [];
        if (null != right)
          args.push(this.isInclusive ? right['instanceof'](JS.Literal) && typeof right.data === 'number' ? new JS.Literal(right.data + 1) : new JS.LogicalExpression('||', new JS.BinaryExpression('+', new JS.UnaryExpression('+', right), new JS.Literal(1)), new JS.Literal(9e9)) : right);
        return new JS.CallExpression(memberAccess(expression, 'slice'), args);
      }
    ],
    [
      CS.ExistsOp,
      function (param$) {
        var ancestry, cache$2, condition, e, inScope, node;
        var left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
          ancestry = cache$2.ancestry;
          inScope = cache$2.inScope;
        }
        left = expr(left);
        right = expr(right);
        e = needsCaching(this.left) ? genSym('cache') : left;
        condition = new JS.BinaryExpression('!=', new JS.Literal(null), e);
        if (e['instanceof'](JS.Identifier) && !in$(e.name, inScope))
          condition = new JS.LogicalExpression('&&', new JS.BinaryExpression('!==', new JS.Literal('undefined'), new JS.UnaryExpression('typeof', e)), condition);
        node = new JS.ConditionalExpression(condition, e, right);
        if (e === left) {
          return node;
        } else {
          return new JS.SequenceExpression([
            new JS.AssignmentExpression('=', e, left),
            node
          ]);
        }
      }
    ],
    [
      CS.UnaryExistsOp,
      function (param$) {
        var cache$2, expression, inScope, nullTest, typeofTest;
        {
          cache$2 = param$;
          expression = cache$2.expression;
          inScope = cache$2.inScope;
        }
        nullTest = new JS.BinaryExpression('!=', new JS.Literal(null), expression);
        if (expression['instanceof'](JS.Identifier) && !in$(expression.name, inScope)) {
          typeofTest = new JS.BinaryExpression('!==', new JS.Literal('undefined'), new JS.UnaryExpression('typeof', expression));
          return new JS.LogicalExpression('&&', typeofTest, nullTest);
        } else {
          return nullTest;
        }
      }
    ],
    [
      CS.DoOp,
      function () {
        var deriveArgsFromParams;
        deriveArgsFromParams = function (params) {
          var args, index, param;
          return args = function (accum$) {
            for (var i$ = 0, length$ = params.length; i$ < length$; ++i$) {
              param = params[i$];
              index = i$;
              accum$.push(function () {
                switch (false) {
                case !param['instanceof'](CS.DefaultParam):
                  params[index] = param.param;
                  return param['default'];
                case !param['instanceof'](CS.Identifier, CS.MemberAccessOp):
                  return param;
                default:
                  return helpers.undef();
                }
              }.call(this));
            }
            return accum$;
          }.call(this, []);
        };
        return function (param$) {
          var args, cache$2, compile, expression;
          {
            cache$2 = param$;
            expression = cache$2.expression;
            compile = cache$2.compile;
          }
          args = [];
          if (this.expression['instanceof'](CS.AssignOp) && this.expression.expression['instanceof'](CS.Functions)) {
            args = deriveArgsFromParams(this.expression.expression.parameters);
          } else if (this.expression['instanceof'](CS.Functions)) {
            args = deriveArgsFromParams(this.expression.parameters);
          }
          return compile(new CS.FunctionApplication(this.expression, args));
        };
      }()
    ],
    [
      CS.Return,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.ReturnStatement(expr(e));
      }
    ],
    [
      CS.Break,
      function () {
        return new JS.BreakStatement;
      }
    ],
    [
      CS.Continue,
      function () {
        return new JS.ContinueStatement;
      }
    ],
    [
      CS.Debugger,
      function () {
        return new JS.DebuggerStatement;
      }
    ],
    [
      CS.ExpOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return helpers.exp(expr(left), expr(right));
      }
    ],
    [
      CS.DivideOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('/', expr(left), expr(right));
      }
    ],
    [
      CS.MultiplyOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('*', expr(left), expr(right));
      }
    ],
    [
      CS.RemOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('%', expr(left), expr(right));
      }
    ],
    [
      CS.PlusOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('+', expr(left), expr(right));
      }
    ],
    [
      CS.SubtractOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('-', expr(left), expr(right));
      }
    ],
    [
      CS.OfOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('in', expr(left), expr(right));
      }
    ],
    [
      CS.InOp,
      function (param$) {
        var cache$2, comparisons, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        if (right['instanceof'](JS.ArrayExpression) && right.elements.length < 5) {
          switch (right.elements.length) {
          case 0:
            if (needsCaching(this.left)) {
              return new JS.SequenceExpression([
                left,
                new JS.Literal(false)
              ]);
            } else {
              return new JS.Literal(false);
            }
          case 1:
            return new JS.BinaryExpression('===', left, right.elements[0]);
          default:
            if (needsCaching(this.left)) {
              return helpers['in'](expr(left), expr(right));
            } else {
              comparisons = map(right.elements, function (e) {
                return new JS.BinaryExpression('===', left, e);
              });
              return foldl1(comparisons, function (l, r) {
                return new JS.LogicalExpression('||', l, r);
              });
            }
          }
        } else {
          return helpers['in'](expr(left), expr(right));
        }
      }
    ],
    [
      CS.ExtendsOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return helpers['extends'](expr(left), expr(right));
      }
    ],
    [
      CS.InstanceofOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('instanceof', expr(left), expr(right));
      }
    ],
    [
      CS.LogicalAndOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.LogicalExpression('&&', expr(left), expr(right));
      }
    ],
    [
      CS.LogicalOrOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.LogicalExpression('||', expr(left), expr(right));
      }
    ],
    [
      CS.EQOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('===', expr(left), expr(right));
      }
    ],
    [
      CS.NEQOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('!==', expr(left), expr(right));
      }
    ],
    [
      CS.GTEOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('>=', expr(left), expr(right));
      }
    ],
    [
      CS.GTOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('>', expr(left), expr(right));
      }
    ],
    [
      CS.LTEOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('<=', expr(left), expr(right));
      }
    ],
    [
      CS.LTOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('<', expr(left), expr(right));
      }
    ],
    [
      CS.BitAndOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('&', expr(left), expr(right));
      }
    ],
    [
      CS.BitOrOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('|', expr(left), expr(right));
      }
    ],
    [
      CS.BitXorOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('^', expr(left), expr(right));
      }
    ],
    [
      CS.LeftShiftOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('<<', expr(left), expr(right));
      }
    ],
    [
      CS.SignedRightShiftOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('>>', expr(left), expr(right));
      }
    ],
    [
      CS.UnsignedRightShiftOp,
      function (param$) {
        var cache$2, left, right;
        {
          cache$2 = param$;
          left = cache$2.left;
          right = cache$2.right;
        }
        return new JS.BinaryExpression('>>>', expr(left), expr(right));
      }
    ],
    [
      CS.PreDecrementOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UpdateExpression('--', true, expr(e));
      }
    ],
    [
      CS.PreIncrementOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UpdateExpression('++', true, expr(e));
      }
    ],
    [
      CS.PostDecrementOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UpdateExpression('--', false, expr(e));
      }
    ],
    [
      CS.PostIncrementOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UpdateExpression('++', false, expr(e));
      }
    ],
    [
      CS.UnaryPlusOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UnaryExpression('+', expr(e));
      }
    ],
    [
      CS.UnaryNegateOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UnaryExpression('-', expr(e));
      }
    ],
    [
      CS.LogicalNotOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UnaryExpression('!', expr(e));
      }
    ],
    [
      CS.BitNotOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UnaryExpression('~', expr(e));
      }
    ],
    [
      CS.TypeofOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UnaryExpression('typeof', expr(e));
      }
    ],
    [
      CS.DeleteOp,
      function (param$) {
        var e;
        e = param$.expression;
        return new JS.UnaryExpression('delete', expr(e));
      }
    ],
    [
      CS.Identifier,
      function () {
        return new JS.Identifier(this.data);
      }
    ],
    [
      CS.GenSym,
      function () {
        var memos, symbols;
        symbols = [];
        memos = [];
        return function () {
          var memo;
          if (in$(this, symbols)) {
            return memos[symbols.indexOf(this)];
          } else {
            symbols.push(this);
            memos.push(memo = genSym(this.data));
            return memo;
          }
        };
      }()
    ],
    [
      CS.Bool,
      CS.Int,
      CS.Float,
      CS.String,
      function () {
        return new JS.Literal(this.data);
      }
    ],
    [
      CS.Null,
      function () {
        return new JS.Literal(null);
      }
    ],
    [
      CS.Undefined,
      function () {
        return helpers.undef();
      }
    ],
    [
      CS.This,
      function () {
        return new JS.ThisExpression;
      }
    ],
    [
      CS.JavaScript,
      function () {
        return new JS.CallExpression(new JS.Identifier('eval'), [new JS.Literal(this.data)]);
      }
    ]
  ];
  function Compiler() {
    var cache$2, ctor, ctors, handler, size$;
    this.rules = {};
    for (var i$ = 0, length$ = defaultRules.length; i$ < length$; ++i$) {
      {
        cache$2 = defaultRules[i$];
        size$ = cache$2.length;
        ctors = size$ > 1 ? [].slice.call(cache$2, 0, size$ - 1) : [];
        handler = cache$2[size$ - 1];
      }
      for (var i$1 = 0, length$1 = ctors.length; i$1 < length$1; ++i$1) {
        ctor = ctors[i$1];
        this.addRule(ctor, handler);
      }
    }
  }
  Compiler.prototype.addRule = function (ctor, handler) {
    this.rules[ctor.prototype.className] = handler;
    return this;
  };
  Compiler.prototype.compile = function () {
    var defaultRule, generateSymbols, walk;
    walk = function (fn, inScope, ancestry, options) {
      var child, childName, children, jsNode, member;
      if ((null != ancestry[0] ? ancestry[0]['instanceof'](CS.Function, CS.BoundFunction) : void 0) && this === ancestry[0].body)
        inScope = union(inScope, concatMap(ancestry[0].parameters, beingDeclared));
      ancestry.unshift(this);
      children = {};
      for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
        childName = this.childNodes[i$];
        if (!(null != this[childName]))
          continue;
        children[childName] = in$(childName, this.listMembers) ? function (accum$) {
          for (var i$1 = 0, length$1 = this[childName].length; i$1 < length$1; ++i$1) {
            member = this[childName][i$1];
            jsNode = walk.call(member, fn, inScope, ancestry);
            inScope = union(inScope, envEnrichments(member, inScope));
            accum$.push(jsNode);
          }
          return accum$;
        }.call(this, []) : (child = this[childName], jsNode = walk.call(child, fn, inScope, ancestry), inScope = union(inScope, envEnrichments(child, inScope)), jsNode);
      }
      children.inScope = inScope;
      children.ancestry = ancestry;
      children.options = options;
      children.compile = function (node) {
        return walk.call(node, fn, inScope, ancestry);
      };
      ancestry.shift();
      jsNode = fn.call(this, children);
      jsNode.raw = this.raw;
      jsNode.line = this.line;
      jsNode.column = this.column - 1;
      jsNode.offset = this.offset;
      return jsNode;
    };
    generateSymbols = function () {
      var format, generatedSymbols, generateName;
      generatedSymbols = {};
      format = function (pre, counter) {
        var cache$2, div, mod;
        if (pre) {
          return '' + pre + '$' + (counter || '');
        } else if (counter < 26) {
          return String.fromCharCode(97 + counter);
        } else {
          cache$2 = divMod(counter, 26);
          div = cache$2[0];
          mod = cache$2[1];
          return format(pre, div - 1) + format(pre, mod);
        }
      };
      generateName = function (node, param$) {
        var cache$2, formatted, nsCounters, usedSymbols;
        {
          cache$2 = param$;
          usedSymbols = cache$2.usedSymbols;
          nsCounters = cache$2.nsCounters;
        }
        if (owns(generatedSymbols, node.uniqueId)) {
          return generatedSymbols[node.uniqueId];
        } else {
          nsCounters[node.ns] = owns(nsCounters, node.ns) ? 1 + nsCounters[node.ns] : 0;
          while (in$(formatted = format(node.ns, nsCounters[node.ns]), usedSymbols)) {
            ++nsCounters[node.ns];
          }
          return generatedSymbols[node.uniqueId] = formatted;
        }
      };
      return generateMutatingWalker(function (state) {
        var alreadyDeclared, cache$2, declaredSymbols, declNames, decls, k, newNode, nsCounters, nsCounters_, params, undeclared, usedSymbols, v;
        state.declaredSymbols = union(state.declaredSymbols, map(declarationsNeeded(this), function (id) {
          return id.name;
        }));
        cache$2 = state;
        declaredSymbols = cache$2.declaredSymbols;
        usedSymbols = cache$2.usedSymbols;
        nsCounters = cache$2.nsCounters;
        newNode = this['instanceof'](JS.GenSym) ? (newNode = new JS.Identifier(generateName(this, state)), usedSymbols.push(newNode.name), newNode) : this['instanceof'](JS.FunctionExpression, JS.FunctionDeclaration) && !this.generated ? (params = concatMap(this.params, collectIdentifiers), nsCounters_ = {}, function (accum$) {
          for (k in nsCounters) {
            if (!isOwn$(nsCounters, k))
              continue;
            v = nsCounters[k];
            accum$.push(nsCounters_[k] = v);
          }
          return accum$;
        }.call(this, []), newNode = generateSymbols(this, {
          declaredSymbols: union(declaredSymbols, params),
          usedSymbols: union(usedSymbols, params),
          nsCounters: nsCounters_
        }), newNode.body = forceBlock(newNode.body), undeclared = map(declarationsNeededRecursive(this.body), function (id) {
          return id.name;
        }), undeclared = difference(undeclared, map(variableDeclarations(this.body), function (id) {
          return id.name;
        })), alreadyDeclared = union(declaredSymbols, concatMap(this.params, collectIdentifiers)), declNames = nub(difference(undeclared, alreadyDeclared)), decls = map(declNames, function (name) {
          return new JS.Identifier(name);
        }), decls.length > 0 ? newNode.body.body.unshift(makeVarDeclaration(decls)) : void 0, newNode) : generateSymbols(this, state);
        state.declaredSymbols = union(declaredSymbols, map(declarationsNeededRecursive(newNode), function (id) {
          return id.name;
        }));
        return newNode;
      });
    }();
    defaultRule = function () {
      throw new Error('compile: Non-exhaustive patterns in case: ' + this.className);
    };
    return function (ast, options) {
      var inScope, jsAST, rules;
      if (null == options)
        options = {};
      if (null != options.bare)
        options.bare;
      else
        options.bare = false;
      rules = this.rules;
      inScope = null != options.inScope ? options.inScope : [];
      jsAST = walk.call(ast, function () {
        return (null != rules[this.className] ? rules[this.className] : defaultRule).apply(this, arguments);
      }, inScope, [], options);
      return generateSymbols(jsAST, {
        declaredSymbols: inScope,
        usedSymbols: union(jsReserved.slice(), collectIdentifiers(jsAST)),
        nsCounters: {}
      });
    };
  }();
  return Compiler;
}();
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}
function isOwn$(o, p) {
  return {}.hasOwnProperty.call(o, p);
}

},{"./../package.json":48,"./functional-helpers":23,"./helpers":24,"./js-nodes":25,"./nodes":27}],23:[function(require,module,exports){
// Generated by CoffeeScript 2.0.0-beta8
var concat, foldl, map, nub, span;
this.any = function (list, fn) {
  var e;
  for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
    e = list[i$];
    if (fn(e))
      return true;
  }
  return false;
};
this.all = function (list, fn) {
  var e;
  for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
    e = list[i$];
    if (!fn(e))
      return false;
  }
  return true;
};
this.foldl = foldl = function (memo, list, fn) {
  var i;
  for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
    i = list[i$];
    memo = fn(memo, i);
  }
  return memo;
};
this.foldl1 = function (list, fn) {
  return foldl(list[0], list.slice(1), fn);
};
this.map = map = function (list, fn) {
  var e;
  return function (accum$) {
    for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
      e = list[i$];
      accum$.push(fn(e));
    }
    return accum$;
  }.call(this, []);
};
this.concat = concat = function (list) {
  var cache$;
  return (cache$ = []).concat.apply(cache$, [].slice.call(list));
};
this.concatMap = function (list, fn) {
  return concat(map(list, fn));
};
this.intersect = function (listA, listB) {
  var a;
  return function (accum$) {
    for (var i$ = 0, length$ = listA.length; i$ < length$; ++i$) {
      a = listA[i$];
      if (!in$(a, listB))
        continue;
      accum$.push(a);
    }
    return accum$;
  }.call(this, []);
};
this.difference = function (listA, listB) {
  var a;
  return function (accum$) {
    for (var i$ = 0, length$ = listA.length; i$ < length$; ++i$) {
      a = listA[i$];
      if (!!in$(a, listB))
        continue;
      accum$.push(a);
    }
    return accum$;
  }.call(this, []);
};
this.nub = nub = function (list) {
  var i, result;
  result = [];
  for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
    i = list[i$];
    if (!!in$(i, result))
      continue;
    result.push(i);
  }
  return result;
};
this.union = function (listA, listB) {
  var b;
  return listA.concat(function (accum$) {
    for (var cache$ = nub(listB), i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
      b = cache$[i$];
      if (!!in$(b, listA))
        continue;
      accum$.push(b);
    }
    return accum$;
  }.call(this, []));
};
this.flip = function (fn) {
  return function (b, a) {
    return fn.call(this, a, b);
  };
};
this.owns = function (hop) {
  return function (a, b) {
    return hop.call(a, b);
  };
}({}.hasOwnProperty);
this.span = span = function (list, f) {
  var cache$, ys, zs;
  if (list.length === 0) {
    return [
      [],
      []
    ];
  } else if (f(list[0])) {
    cache$ = span(list.slice(1), f);
    ys = cache$[0];
    zs = cache$[1];
    return [
      [list[0]].concat([].slice.call(ys)),
      zs
    ];
  } else {
    return [
      [],
      list
    ];
  }
};
this.divMod = function (a, b) {
  var c, div, mod;
  c = a % b;
  mod = c < 0 ? c + b : c;
  div = Math.floor(a / b);
  return [
    div,
    mod
  ];
};
this.partition = function (list, fn) {
  var item, result;
  result = [
    [],
    []
  ];
  for (var i$ = 0, length$ = list.length; i$ < length$; ++i$) {
    item = list[i$];
    result[+!fn(item)].push(item);
  }
  return result;
};
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}

},{}],24:[function(require,module,exports){
// Generated by CoffeeScript 2.0.0-beta8
var beingDeclared, cleanMarkers, concat, concatMap, CS, difference, envEnrichments, envEnrichments_, foldl, humanReadable, map, nub, numberLines, pointToErrorLocation, usedAsExpression, usedAsExpression_;
cache$ = require('./functional-helpers');
concat = cache$.concat;
concatMap = cache$.concatMap;
difference = cache$.difference;
foldl = cache$.foldl;
map = cache$.map;
nub = cache$.nub;
CS = require('./nodes');
this.numberLines = numberLines = function (input, startLine) {
  var currLine, i, line, lines, numbered, pad, padSize;
  if (null == startLine)
    startLine = 1;
  lines = input.split('\n');
  padSize = ('' + (lines.length + startLine - 1)).length;
  numbered = function (accum$) {
    for (var i$ = 0, length$ = lines.length; i$ < length$; ++i$) {
      line = lines[i$];
      i = i$;
      currLine = '' + (i + startLine);
      pad = Array(padSize + 1).join('0').slice(currLine.length);
      accum$.push('' + pad + currLine + ' : ' + lines[i]);
    }
    return accum$;
  }.call(this, []);
  return numbered.join('\n');
};
cleanMarkers = function (str) {
  return str.replace(/[\uEFEF\uEFFE\uEFFF]/g, '');
};
this.humanReadable = humanReadable = function (str) {
  return str.replace(/\uEFEF/g, '(INDENT)').replace(/\uEFFE/g, '(DEDENT)').replace(/\uEFFF/g, '(TERM)');
};
this.formatParserError = function (input, e) {
  var found, message, realColumn, unicode;
  realColumn = cleanMarkers(('' + input.split('\n')[e.line - 1] + '\n').slice(0, e.column)).length;
  if (!(null != e.found))
    return 'Syntax error on line ' + e.line + ', column ' + realColumn + ': unexpected end of input';
  found = JSON.stringify(humanReadable(e.found));
  found = found.replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"');
  unicode = e.found.charCodeAt(0).toString(16).toUpperCase();
  unicode = '\\u' + '0000'.slice(unicode.length) + unicode;
  message = 'Syntax error on line ' + e.line + ', column ' + realColumn + ": unexpected '" + found + "' (" + unicode + ')';
  return '' + message + '\n' + pointToErrorLocation(input, e.line, realColumn);
};
this.pointToErrorLocation = pointToErrorLocation = function (source, line, column, numLinesOfContext) {
  var currentLineOffset, lines, numberedLines, padSize, postLines, preLines, startLine;
  if (null == numLinesOfContext)
    numLinesOfContext = 3;
  lines = source.split('\n');
  currentLineOffset = line - 1;
  startLine = currentLineOffset - numLinesOfContext;
  if (startLine < 0)
    startLine = 0;
  preLines = lines.slice(startLine, +currentLineOffset + 1 || 9e9);
  postLines = lines.slice(currentLineOffset + 1, +(currentLineOffset + numLinesOfContext) + 1 || 9e9);
  numberedLines = numberLines(cleanMarkers([].slice.call(preLines).concat([].slice.call(postLines)).join('\n')), startLine + 1).split('\n');
  preLines = numberedLines.slice(0, preLines.length);
  postLines = numberedLines.slice(preLines.length);
  column = cleanMarkers(('' + lines[currentLineOffset] + '\n').slice(0, column)).length;
  padSize = (currentLineOffset + 1 + postLines.length).toString(10).length;
  return [].slice.call(preLines).concat(['' + Array(padSize + 1).join('^') + ' :~' + Array(column).join('~') + '^'], [].slice.call(postLines)).join('\n');
};
this.beingDeclared = beingDeclared = function (assignment) {
  switch (false) {
  case !!(null != assignment):
    return [];
  case !assignment['instanceof'](CS.Identifiers):
    return [assignment.data];
  case !assignment['instanceof'](CS.Rest):
    return beingDeclared(assignment.expression);
  case !assignment['instanceof'](CS.MemberAccessOps):
    return [];
  case !assignment['instanceof'](CS.DefaultParam):
    return beingDeclared(assignment.param);
  case !assignment['instanceof'](CS.ArrayInitialiser):
    return concatMap(assignment.members, beingDeclared);
  case !assignment['instanceof'](CS.ObjectInitialiser):
    return concatMap(assignment.vals(), beingDeclared);
  default:
    throw new Error('beingDeclared: Non-exhaustive patterns in case: ' + assignment.className);
  }
};
this.declarationsFor = function (node, inScope) {
  var vars;
  vars = envEnrichments(node, inScope);
  return foldl(new CS.Undefined().g(), vars, function (expr, v) {
    return new CS.AssignOp(new CS.Identifier(v).g(), expr).g();
  });
};
usedAsExpression_ = function (ancestors) {
  var grandparent, parent;
  parent = ancestors[0];
  grandparent = ancestors[1];
  switch (false) {
  case !!(null != parent):
    return true;
  case !parent['instanceof'](CS.Program, CS.Class):
    return false;
  case !parent['instanceof'](CS.SeqOp):
    return this === parent.right && usedAsExpression(parent, ancestors.slice(1));
  case !(parent['instanceof'](CS.Block) && parent.statements.indexOf(this) !== parent.statements.length - 1):
    return false;
  case !(parent['instanceof'](CS.Functions) && parent.body === this && null != grandparent && grandparent['instanceof'](CS.Constructor)):
    return false;
  default:
    return true;
  }
};
this.usedAsExpression = usedAsExpression = function (node, ancestors) {
  return usedAsExpression_.call(node, ancestors);
};
envEnrichments_ = function (inScope) {
  var possibilities;
  if (null == inScope)
    inScope = [];
  possibilities = nub(function () {
    switch (false) {
    case !this['instanceof'](CS.AssignOp):
      return concat([
        beingDeclared(this.assignee),
        envEnrichments(this.expression)
      ]);
    case !this['instanceof'](CS.Class):
      return concat([
        beingDeclared(this.nameAssignee),
        envEnrichments(this.parent)
      ]);
    case !this['instanceof'](CS.ForIn, CS.ForOf):
      return concat([
        beingDeclared(this.keyAssignee),
        beingDeclared(this.valAssignee),
        envEnrichments(this.target),
        envEnrichments(this.step),
        envEnrichments(this.filter),
        envEnrichments(this.body)
      ]);
    case !this['instanceof'](CS.Try):
      return concat([
        beingDeclared(this.catchAssignee),
        envEnrichments(this.body),
        envEnrichments(this.catchBody),
        envEnrichments(this.finallyBody)
      ]);
    case !this['instanceof'](CS.Functions):
      return [];
    default:
      return concatMap(this.childNodes, function (this$) {
        return function (child) {
          if (in$(child, this$.listMembers)) {
            return concatMap(this$[child], function (m) {
              return envEnrichments(m, inScope);
            });
          } else {
            return envEnrichments(this$[child], inScope);
          }
        };
      }(this));
    }
  }.call(this));
  return difference(possibilities, inScope);
};
this.envEnrichments = envEnrichments = function (node, args) {
  args = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
  if (null != node) {
    return envEnrichments_.apply(node, args);
  } else {
    return [];
  }
};
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}

},{"./functional-helpers":23,"./nodes":27}],25:[function(require,module,exports){
// Generated by CoffeeScript 2.0.0-beta8
var ArrayExpression, AssignmentExpression, BinaryExpression, BlockStatement, CallExpression, createNode, ctor, difference, exports, FunctionDeclaration, FunctionExpression, GenSym, handleLists, handlePrimitives, Identifier, isStatement, Literal, LogicalExpression, MemberExpression, NewExpression, node, nodeData, Nodes, ObjectExpression, params, Program, SequenceExpression, SwitchCase, SwitchStatement, TryStatement, UnaryExpression, UpdateExpression, VariableDeclaration, VariableDeclaration;
difference = require('./functional-helpers').difference;
exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
createNode = function (type, props) {
  return function (super$) {
    extends$(class$, super$);
    function class$() {
      var i, prop;
      for (var i$ = 0, length$ = props.length; i$ < length$; ++i$) {
        prop = props[i$];
        i = i$;
        this[prop] = arguments[i];
      }
    }
    class$.prototype.type = type;
    class$.prototype.childNodes = props;
    return class$;
  }(Nodes);
};
this.Nodes = Nodes = function () {
  function Nodes() {
  }
  Nodes.prototype.listMembers = [];
  Nodes.prototype['instanceof'] = function (ctors) {
    var ctor;
    ctors = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
    for (var i$ = 0, length$ = ctors.length; i$ < length$; ++i$) {
      ctor = ctors[i$];
      if (!(this.type === ctor.prototype.type))
        continue;
      return true;
    }
    return false;
  };
  Nodes.prototype.toBasicObject = function () {
    var child, obj, p;
    obj = { type: this.type };
    if (null != this.leadingComments)
      obj.leadingComments = this.leadingComments;
    for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
      child = this.childNodes[i$];
      if (in$(child, this.listMembers)) {
        obj[child] = function (accum$) {
          for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
            p = this[child][i$1];
            accum$.push('undefined' !== typeof p && null != p ? p.toBasicObject() : void 0);
          }
          return accum$;
        }.call(this, []);
      } else {
        obj[child] = null != this[child] ? this[child].toBasicObject() : void 0;
      }
    }
    if (null != this.line && null != this.column)
      obj.loc = {
        start: {
          line: this.line,
          column: this.column
        }
      };
    if (null != this.offset)
      obj.range = [
        this.offset,
        null != this.raw ? this.offset + this.raw.length : void 0
      ];
    if (null != this.raw)
      obj.raw = this.raw;
    return obj;
  };
  return Nodes;
}();
nodeData = [
  [
    'ArrayExpression',
    false,
    ['elements']
  ],
  [
    'AssignmentExpression',
    false,
    [
      'operator',
      'left',
      'right'
    ]
  ],
  [
    'BinaryExpression',
    false,
    [
      'operator',
      'left',
      'right'
    ]
  ],
  [
    'BlockStatement',
    true,
    ['body']
  ],
  [
    'BreakStatement',
    true,
    ['label']
  ],
  [
    'CallExpression',
    false,
    [
      'callee',
      'arguments'
    ]
  ],
  [
    'CatchClause',
    true,
    [
      'param',
      'body'
    ]
  ],
  [
    'ConditionalExpression',
    false,
    [
      'test',
      'consequent',
      'alternate'
    ]
  ],
  [
    'ContinueStatement',
    true,
    ['label']
  ],
  [
    'DebuggerStatement',
    true,
    []
  ],
  [
    'DoWhileStatement',
    true,
    [
      'body',
      'test'
    ]
  ],
  [
    'EmptyStatement',
    true,
    []
  ],
  [
    'ExpressionStatement',
    true,
    ['expression']
  ],
  [
    'ForInStatement',
    true,
    [
      'left',
      'right',
      'body'
    ]
  ],
  [
    'ForStatement',
    true,
    [
      'init',
      'test',
      'update',
      'body'
    ]
  ],
  [
    'FunctionDeclaration',
    true,
    [
      'id',
      'params',
      'body'
    ]
  ],
  [
    'FunctionExpression',
    false,
    [
      'id',
      'params',
      'body'
    ]
  ],
  [
    'GenSym',
    false,
    [
      'ns',
      'uniqueId'
    ]
  ],
  [
    'Identifier',
    false,
    ['name']
  ],
  [
    'IfStatement',
    true,
    [
      'test',
      'consequent',
      'alternate'
    ]
  ],
  [
    'LabeledStatement',
    true,
    [
      'label',
      'body'
    ]
  ],
  [
    'Literal',
    false,
    ['value']
  ],
  [
    'LogicalExpression',
    false,
    [
      'operator',
      'left',
      'right'
    ]
  ],
  [
    'MemberExpression',
    false,
    [
      'computed',
      'object',
      'property'
    ]
  ],
  [
    'NewExpression',
    false,
    [
      'callee',
      'arguments'
    ]
  ],
  [
    'ObjectExpression',
    false,
    ['properties']
  ],
  [
    'Program',
    true,
    ['body']
  ],
  [
    'Property',
    true,
    [
      'key',
      'value'
    ]
  ],
  [
    'ReturnStatement',
    true,
    ['argument']
  ],
  [
    'SequenceExpression',
    false,
    ['expressions']
  ],
  [
    'SwitchCase',
    true,
    [
      'test',
      'consequent'
    ]
  ],
  [
    'SwitchStatement',
    true,
    [
      'discriminant',
      'cases'
    ]
  ],
  [
    'ThisExpression',
    false,
    []
  ],
  [
    'ThrowStatement',
    true,
    ['argument']
  ],
  [
    'TryStatement',
    true,
    [
      'block',
      'handlers',
      'finalizer'
    ]
  ],
  [
    'UnaryExpression',
    false,
    [
      'operator',
      'argument'
    ]
  ],
  [
    'UpdateExpression',
    false,
    [
      'operator',
      'prefix',
      'argument'
    ]
  ],
  [
    'VariableDeclaration',
    true,
    [
      'kind',
      'declarations'
    ]
  ],
  [
    'VariableDeclarator',
    true,
    [
      'id',
      'init'
    ]
  ],
  [
    'WhileStatement',
    true,
    [
      'test',
      'body'
    ]
  ],
  [
    'WithStatement',
    true,
    [
      'object',
      'body'
    ]
  ]
];
for (var i$ = 0, length$ = nodeData.length; i$ < length$; ++i$) {
  {
    cache$ = nodeData[i$];
    node = cache$[0];
    isStatement = cache$[1];
    params = cache$[2];
  }
  exports[node] = ctor = createNode(node, params);
  ctor.prototype.isStatement = isStatement;
  ctor.prototype.isExpression = !isStatement;
}
cache$1 = exports;
Program = cache$1.Program;
BlockStatement = cache$1.BlockStatement;
Literal = cache$1.Literal;
Identifier = cache$1.Identifier;
FunctionExpression = cache$1.FunctionExpression;
CallExpression = cache$1.CallExpression;
SequenceExpression = cache$1.SequenceExpression;
ArrayExpression = cache$1.ArrayExpression;
BinaryExpression = cache$1.BinaryExpression;
UnaryExpression = cache$1.UnaryExpression;
NewExpression = cache$1.NewExpression;
VariableDeclaration = cache$1.VariableDeclaration;
ObjectExpression = cache$1.ObjectExpression;
MemberExpression = cache$1.MemberExpression;
UpdateExpression = cache$1.UpdateExpression;
AssignmentExpression = cache$1.AssignmentExpression;
LogicalExpression = cache$1.LogicalExpression;
GenSym = cache$1.GenSym;
FunctionDeclaration = cache$1.FunctionDeclaration;
VariableDeclaration = cache$1.VariableDeclaration;
SwitchStatement = cache$1.SwitchStatement;
SwitchCase = cache$1.SwitchCase;
TryStatement = cache$1.TryStatement;
handlePrimitives = function (ctor, primitives) {
  ctor.prototype.childNodes = difference(ctor.prototype.childNodes, primitives);
  return ctor.prototype.toBasicObject = function () {
    var obj, primitive;
    obj = Nodes.prototype.toBasicObject.call(this);
    for (var i$1 = 0, length$1 = primitives.length; i$1 < length$1; ++i$1) {
      primitive = primitives[i$1];
      obj[primitive] = this[primitive];
    }
    return obj;
  };
};
handlePrimitives(AssignmentExpression, ['operator']);
handlePrimitives(BinaryExpression, ['operator']);
handlePrimitives(LogicalExpression, ['operator']);
handlePrimitives(GenSym, [
  'ns',
  'uniqueId'
]);
handlePrimitives(Identifier, ['name']);
handlePrimitives(Literal, ['value']);
handlePrimitives(MemberExpression, ['computed']);
handlePrimitives(UnaryExpression, ['operator']);
handlePrimitives(UpdateExpression, [
  'operator',
  'prefix'
]);
handlePrimitives(VariableDeclaration, ['kind']);
handleLists = function (ctor, listProps) {
  return ctor.prototype.listMembers = listProps;
};
handleLists(ArrayExpression, ['elements']);
handleLists(BlockStatement, ['body']);
handleLists(CallExpression, ['arguments']);
handleLists(FunctionDeclaration, ['params']);
handleLists(FunctionExpression, ['params']);
handleLists(NewExpression, ['arguments']);
handleLists(ObjectExpression, ['properties']);
handleLists(Program, ['body']);
handleLists(SequenceExpression, ['expressions']);
handleLists(SwitchCase, ['consequent']);
handleLists(SwitchStatement, ['cases']);
handleLists(TryStatement, ['handlers']);
handleLists(VariableDeclaration, ['declarations']);
FunctionDeclaration.prototype.generated = FunctionExpression.prototype.generated = false;
FunctionDeclaration.prototype.g = FunctionExpression.prototype.g = function () {
  this.generated = true;
  return this;
};
function isOwn$(o, p) {
  return {}.hasOwnProperty.call(o, p);
}
function extends$(child, parent) {
  for (var key in parent)
    if (isOwn$(parent, key))
      child[key] = parent[key];
  function ctor() {
    this.constructor = child;
  }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}

},{"./functional-helpers":23}],26:[function(require,module,exports){
// Generated by CoffeeScript 2.0.0-beta8
var CoffeeScript, Compiler, cscodegen, escodegen, escodegenFormat, formatParserError, Nodes, Optimiser, Parser, pkg, Preprocessor;
formatParserError = require('./helpers').formatParserError;
Nodes = require('./nodes');
Preprocessor = require('./preprocessor').Preprocessor;
Parser = require('./parser');
Optimiser = require('./optimiser').Optimiser;
Compiler = require('./compiler').Compiler;
cscodegen = function () {
  try {
    return require('cscodegen');
  } catch (e$) {
    return;
  }
}.call(this);
escodegen = function () {
  try {
    return require('escodegen');
  } catch (e$1) {
    return;
  }
}.call(this);
pkg = require('./../package.json');
escodegenFormat = {
  indent: {
    style: '  ',
    base: 0
  },
  renumber: true,
  hexadecimal: true,
  quotes: 'auto',
  parentheses: false
};
CoffeeScript = {
  CoffeeScript: CoffeeScript,
  Compiler: Compiler,
  Optimiser: Optimiser,
  Parser: Parser,
  Preprocessor: Preprocessor,
  Nodes: Nodes,
  VERSION: pkg.version,
  parse: function (coffee, options) {
    var e, parsed, preprocessed;
    if (null == options)
      options = {};
    try {
      preprocessed = Preprocessor.process(coffee, { literate: options.literate });
      parsed = Parser.parse(preprocessed, {
        raw: options.raw,
        inputSource: options.inputSource
      });
      if (options.optimise) {
        return Optimiser.optimise(parsed);
      } else {
        return parsed;
      }
    } catch (e$2) {
      e = e$2;
      if (!(e instanceof Parser.SyntaxError))
        throw e;
      throw new Error(formatParserError(preprocessed, e));
    }
  },
  compile: function (csAst, options) {
    return Compiler.compile(csAst, options).toBasicObject();
  },
  cs: function (csAst, options) {
  },
  jsWithSourceMap: function (jsAst, name, options) {
    var targetName;
    if (null == name)
      name = 'unknown';
    if (null == options)
      options = {};
    if (!(null != escodegen))
      throw new Error('escodegen not found: run `npm install escodegen`');
    if (!{}.hasOwnProperty.call(jsAst, 'type'))
      jsAst = jsAst.toBasicObject();
    targetName = options.sourceMapFile || options.sourceMap && options.output.match(/^.*[\\\/]([^\\\/]+)$/)[1];
    return escodegen.generate(jsAst, {
      comment: !options.compact,
      sourceMapWithCode: true,
      sourceMap: name,
      file: targetName || 'unknown',
      format: options.compact ? escodegen.FORMAT_MINIFY : null != options.format ? options.format : escodegenFormat
    });
  },
  js: function (jsAst, options) {
    return this.jsWithSourceMap(jsAst, null, options).code;
  },
  sourceMap: function (jsAst, name, options) {
    return this.jsWithSourceMap(jsAst, name, options).map;
  },
  cs2js: function (input, options) {
    var csAST, jsAST;
    if (null == options)
      options = {};
    if (null != options.optimise)
      options.optimise;
    else
      options.optimise = true;
    csAST = CoffeeScript.parse(input, options);
    jsAST = CoffeeScript.compile(csAST, { bare: options.bare });
    return CoffeeScript.js(jsAST, { compact: options.compact || options.minify });
  }
};
module.exports = CoffeeScript;
if (null != (null != require.extensions ? require.extensions['.node'] : void 0))
  CoffeeScript.register = function () {
    return require('./register');
  };

},{"./../package.json":48,"./compiler":22,"./helpers":24,"./nodes":27,"./optimiser":28,"./parser":29,"./preprocessor":30,"./register":31,"cscodegen":34,"escodegen":35}],27:[function(require,module,exports){
// Generated by CoffeeScript 2.0.0-beta8
var ArrayInitialiser, Block, Bool, Class, CompoundAssignOp, concat, concatMap, Conditional, createNodes, difference, exports, ForOf, FunctionApplications, Functions, GenSym, handleLists, handlePrimitives, HeregExp, Identifier, Identifiers, map, NegatedConditional, NewOp, Nodes, nub, ObjectInitialiser, Primitives, Range, RegExp, RegExps, Slice, StaticMemberAccessOps, Super, Switch, SwitchCase, union, While;
cache$ = require('./functional-helpers');
map = cache$.map;
concat = cache$.concat;
concatMap = cache$.concatMap;
difference = cache$.difference;
nub = cache$.nub;
union = cache$.union;
exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
createNodes = function (subclasses, superclasses) {
  var className, specs;
  if (null == superclasses)
    superclasses = [];
  for (className in subclasses) {
    if (!isOwn$(subclasses, className))
      continue;
    specs = subclasses[className];
    (function (className) {
      var externalCtor$, isCategory, klass, params, superclass;
      superclass = null != superclasses[0] ? superclasses[0] : function () {
      };
      isCategory = 'undefined' !== typeof specs && null != specs && specs.length === 2;
      params = 'undefined' !== typeof specs && null != specs ? function () {
        switch (specs.length) {
        case 0:
          return [];
        case 1:
        case 2:
          return specs[0];
        }
      }.call(this) : null;
      if (null != params)
        params;
      else
        params = null != superclass.prototype.childNodes ? superclass.prototype.childNodes : [];
      klass = function (super$) {
        extends$(class$, super$);
        externalCtor$ = isCategory ? function () {
        } : function () {
          var i, param;
          for (var i$ = 0, length$ = params.length; i$ < length$; ++i$) {
            param = params[i$];
            i = i$;
            this[param] = arguments[i];
          }
          if (null != this.initialise)
            this.initialise.apply(this, arguments);
          return this;
        };
        function class$() {
          return externalCtor$.apply(this, arguments);
        }
        class$.prototype.className = className;
        class$.superclasses = superclasses;
        return class$;
      }(superclass);
      if (null != ('undefined' !== typeof specs && null != specs ? specs[0] : void 0))
        klass.prototype.childNodes = specs[0];
      if (isCategory)
        createNodes(specs[1], [klass].concat([].slice.call(superclasses)));
      return exports[className] = klass;
    }(className));
  }
};
createNodes({
  Nodes: [
    [],
    {
      BinOps: [
        [
          'left',
          'right'
        ],
        {
          AssignOps: [
            [
              'assignee',
              'expression'
            ],
            {
              AssignOp: null,
              ClassProtoAssignOp: null,
              CompoundAssignOp: [[
                  'op',
                  'assignee',
                  'expression'
                ]]
            }
          ],
          BitOps: [
            null,
            {
              BitAndOp: null,
              BitOrOp: null,
              BitXorOp: null,
              LeftShiftOp: null,
              SignedRightShiftOp: null,
              UnsignedRightShiftOp: null
            }
          ],
          ComparisonOps: [
            null,
            {
              EQOp: null,
              GTEOp: null,
              GTOp: null,
              LTEOp: null,
              LTOp: null,
              NEQOp: null
            }
          ],
          ConcatOp: null,
          ExistsOp: null,
          ExtendsOp: null,
          InOp: null,
          InstanceofOp: null,
          LogicalOps: [
            null,
            {
              LogicalAndOp: null,
              LogicalOrOp: null
            }
          ],
          MathsOps: [
            null,
            {
              ExpOp: null,
              DivideOp: null,
              MultiplyOp: null,
              RemOp: null,
              SubtractOp: null
            }
          ],
          OfOp: null,
          PlusOp: null,
          Range: [[
              'isInclusive',
              'left',
              'right'
            ]],
          SeqOp: null
        }
      ],
      Statements: [
        [],
        {
          Break: null,
          Continue: null,
          Debugger: null,
          Return: [['expression']],
          Throw: [['expression']]
        }
      ],
      UnaryOps: [
        ['expression'],
        {
          BitNotOp: null,
          DeleteOp: null,
          DoOp: null,
          LogicalNotOp: null,
          NewOp: [[
              'ctor',
              'arguments'
            ]],
          PreDecrementOp: null,
          PreIncrementOp: null,
          PostDecrementOp: null,
          PostIncrementOp: null,
          TypeofOp: null,
          UnaryExistsOp: null,
          UnaryNegateOp: null,
          UnaryPlusOp: null
        }
      ],
      MemberAccessOps: [
        null,
        {
          StaticMemberAccessOps: [
            [
              'expression',
              'memberName'
            ],
            {
              MemberAccessOp: null,
              ProtoMemberAccessOp: null,
              SoakedMemberAccessOp: null,
              SoakedProtoMemberAccessOp: null
            }
          ],
          DynamicMemberAccessOps: [
            [
              'expression',
              'indexingExpr'
            ],
            {
              DynamicMemberAccessOp: null,
              DynamicProtoMemberAccessOp: null,
              SoakedDynamicMemberAccessOp: null,
              SoakedDynamicProtoMemberAccessOp: null
            }
          ]
        }
      ],
      ChainedComparisonOp: [['expression']],
      FunctionApplications: [
        [
          'function',
          'arguments'
        ],
        {
          FunctionApplication: null,
          SoakedFunctionApplication: null
        }
      ],
      Super: [['arguments']],
      Program: [['body']],
      Block: [['statements']],
      Conditional: [[
          'condition',
          'consequent',
          'alternate'
        ]],
      ForIn: [[
          'valAssignee',
          'keyAssignee',
          'target',
          'step',
          'filter',
          'body'
        ]],
      ForOf: [[
          'isOwn',
          'keyAssignee',
          'valAssignee',
          'target',
          'filter',
          'body'
        ]],
      Switch: [[
          'expression',
          'cases',
          'alternate'
        ]],
      SwitchCase: [[
          'conditions',
          'consequent'
        ]],
      Try: [[
          'body',
          'catchAssignee',
          'catchBody',
          'finallyBody'
        ]],
      While: [[
          'condition',
          'body'
        ]],
      ArrayInitialiser: [['members']],
      ObjectInitialiser: [['members']],
      ObjectInitialiserMember: [[
          'key',
          'expression'
        ]],
      Class: [[
          'nameAssignee',
          'parent',
          'ctor',
          'body',
          'boundMembers'
        ]],
      Constructor: [['expression']],
      Functions: [
        [
          'parameters',
          'body'
        ],
        {
          Function: null,
          BoundFunction: null
        }
      ],
      DefaultParam: [[
          'param',
          'default'
        ]],
      Identifiers: [
        ['data'],
        {
          Identifier: null,
          GenSym: null
        }
      ],
      Null: null,
      Primitives: [
        ['data'],
        {
          Bool: null,
          JavaScript: null,
          Numbers: [
            null,
            {
              Int: null,
              Float: null
            }
          ],
          String: null
        }
      ],
      RegExps: [
        null,
        {
          RegExp: [[
              'data',
              'flags'
            ]],
          HeregExp: [[
              'expression',
              'flags'
            ]]
        }
      ],
      This: null,
      Undefined: null,
      Slice: [[
          'expression',
          'isInclusive',
          'left',
          'right'
        ]],
      Rest: [['expression']],
      Spread: [['expression']]
    }
  ]
});
cache$1 = exports;
Nodes = cache$1.Nodes;
Primitives = cache$1.Primitives;
CompoundAssignOp = cache$1.CompoundAssignOp;
StaticMemberAccessOps = cache$1.StaticMemberAccessOps;
Range = cache$1.Range;
ArrayInitialiser = cache$1.ArrayInitialiser;
ObjectInitialiser = cache$1.ObjectInitialiser;
NegatedConditional = cache$1.NegatedConditional;
Conditional = cache$1.Conditional;
Identifier = cache$1.Identifier;
ForOf = cache$1.ForOf;
Functions = cache$1.Functions;
While = cache$1.While;
Class = cache$1.Class;
Block = cache$1.Block;
NewOp = cache$1.NewOp;
Bool = cache$1.Bool;
FunctionApplications = cache$1.FunctionApplications;
RegExps = cache$1.RegExps;
RegExp = cache$1.RegExp;
HeregExp = cache$1.HeregExp;
Super = cache$1.Super;
Slice = cache$1.Slice;
Switch = cache$1.Switch;
Identifiers = cache$1.Identifiers;
SwitchCase = cache$1.SwitchCase;
GenSym = cache$1.GenSym;
Nodes.fromBasicObject = function (obj) {
  return exports[obj.type].fromBasicObject(obj);
};
Nodes.prototype.listMembers = [];
Nodes.prototype.toBasicObject = function () {
  var child, obj, p;
  obj = { type: this.className };
  if (null != this.line)
    obj.line = this.line;
  if (null != this.column)
    obj.column = this.column;
  if (null != this.raw) {
    obj.raw = this.raw;
    if (null != this.offset)
      obj.range = [
        this.offset,
        this.offset + this.raw.length
      ];
  }
  for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
    child = this.childNodes[i$];
    if (in$(child, this.listMembers)) {
      obj[child] = function (accum$) {
        for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
          p = this[child][i$1];
          accum$.push(p.toBasicObject());
        }
        return accum$;
      }.call(this, []);
    } else {
      obj[child] = null != this[child] ? this[child].toBasicObject() : void 0;
    }
  }
  return obj;
};
Nodes.prototype.fold = function (memo, fn) {
  var child, p;
  for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
    child = this.childNodes[i$];
    if (in$(child, this.listMembers)) {
      memo = function (accum$) {
        for (var i$1 = 0, length$1 = this[child].length; i$1 < length$1; ++i$1) {
          p = this[child][i$1];
          accum$.push(p.fold(memo, fn));
        }
        return accum$;
      }.call(this, []);
    } else {
      memo = this[child].fold(memo, fn);
    }
  }
  return fn(memo, this);
};
Nodes.prototype.clone = function () {
  var ctor, k, n, v;
  ctor = function () {
  };
  ctor.prototype = this.constructor.prototype;
  n = new ctor;
  for (k in this) {
    if (!isOwn$(this, k))
      continue;
    v = this[k];
    n[k] = v;
  }
  return n;
};
Nodes.prototype['instanceof'] = function (ctors) {
  var ctor, superclasses;
  ctors = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
  superclasses = map(this.constructor.superclasses, function (c) {
    return c.prototype.className;
  });
  for (var i$ = 0, length$ = ctors.length; i$ < length$; ++i$) {
    ctor = ctors[i$];
    if (!in$(ctor.prototype.className, [this.className].concat([].slice.call(superclasses))))
      continue;
    return true;
  }
  return false;
};
Nodes.prototype.r = function (param$) {
  this.raw = param$;
  return this;
};
Nodes.prototype.p = function (param$, param$1, param$2) {
  this.line = param$;
  this.column = param$1;
  this.offset = param$2;
  return this;
};
Nodes.prototype.generated = false;
Nodes.prototype.g = function () {
  this.generated = true;
  return this;
};
handlePrimitives = function (ctor, primitives) {
  primitives = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
  ctor.prototype.childNodes = difference(ctor.prototype.childNodes, primitives);
  return ctor.prototype.toBasicObject = function () {
    var obj, primitive;
    obj = Nodes.prototype.toBasicObject.call(this);
    for (var i$ = 0, length$ = primitives.length; i$ < length$; ++i$) {
      primitive = primitives[i$];
      obj[primitive] = this[primitive];
    }
    return obj;
  };
};
handlePrimitives(Class, 'boundMembers');
handlePrimitives(CompoundAssignOp, 'op');
handlePrimitives(ForOf, 'isOwn');
handlePrimitives(HeregExp, 'flags');
handlePrimitives(Identifiers, 'data');
handlePrimitives(Primitives, 'data');
handlePrimitives(Range, 'isInclusive');
handlePrimitives(RegExp, 'data', 'flags');
handlePrimitives(Slice, 'isInclusive');
handlePrimitives(StaticMemberAccessOps, 'memberName');
handleLists = function (ctor, listProps) {
  listProps = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
  return ctor.prototype.listMembers = listProps;
};
handleLists(ArrayInitialiser, 'members');
handleLists(Block, 'statements');
handleLists(Functions, 'parameters');
handleLists(FunctionApplications, 'arguments');
handleLists(NewOp, 'arguments');
handleLists(ObjectInitialiser, 'members');
handleLists(Super, 'arguments');
handleLists(Switch, 'cases');
handleLists(SwitchCase, 'conditions');
Block.wrap = function (s) {
  return new Block(null != s ? [s] : []).r(s.raw).p(s.line, s.column);
};
Class.prototype.initialise = function () {
  if (null != this.boundMembers)
    this.boundMembers;
  else
    this.boundMembers = [];
  this.name = new GenSym('class');
  if (null != this.nameAssignee)
    return this.name = function () {
      switch (false) {
      case !this.nameAssignee['instanceof'](Identifier):
        return new Identifier(this.nameAssignee.data);
      case !this.nameAssignee['instanceof'](StaticMemberAccessOps):
        return new Identifier(this.nameAssignee.memberName);
      default:
        return this.name;
      }
    }.call(this);
};
Class.prototype.childNodes.push('name');
ObjectInitialiser.prototype.keys = function () {
  return map(this.members, function (m) {
    return m.key;
  });
};
ObjectInitialiser.prototype.vals = function () {
  return map(this.members, function (m) {
    return m.expression;
  });
};
RegExps.prototype.initialise = function (_, flags) {
  var flag;
  this.flags = {};
  for (var cache$2 = [
        'g',
        'i',
        'm',
        'y'
      ], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
    flag = cache$2[i$];
    this.flags[flag] = in$(flag, flags);
  }
};
exports.NegatedConditional = function (super$) {
  extends$(NegatedConditional, super$);
  function NegatedConditional() {
    Conditional.apply(this, arguments);
  }
  return NegatedConditional;
}(Conditional);
exports.NegatedWhile = function (super$1) {
  extends$(NegatedWhile, super$1);
  function NegatedWhile() {
    While.apply(this, arguments);
  }
  return NegatedWhile;
}(While);
exports.Loop = function (super$2) {
  extends$(Loop, super$2);
  function Loop(body) {
    While.call(this, new Bool(true).g(), body);
  }
  return Loop;
}(While);
function isOwn$(o, p) {
  return {}.hasOwnProperty.call(o, p);
}
function extends$(child, parent) {
  for (var key in parent)
    if (isOwn$(parent, key))
      child[key] = parent[key];
  function ctor() {
    this.constructor = child;
  }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}

},{"./functional-helpers":23}],28:[function(require,module,exports){
(function (global){// Generated by CoffeeScript 2.0.0-beta8
var all, any, beingDeclared, concat, concatMap, CS, declarationsFor, defaultRules, difference, envEnrichments, exports, foldl, foldl1, isFalsey, isTruthy, makeDispatcher, mayHaveSideEffects, union, usedAsExpression;
cache$ = require('./functional-helpers');
all = cache$.all;
any = cache$.any;
concat = cache$.concat;
concatMap = cache$.concatMap;
difference = cache$.difference;
foldl = cache$.foldl;
foldl1 = cache$.foldl1;
union = cache$.union;
cache$1 = require('./helpers');
beingDeclared = cache$1.beingDeclared;
declarationsFor = cache$1.declarationsFor;
usedAsExpression = cache$1.usedAsExpression;
envEnrichments = cache$1.envEnrichments;
CS = require('./nodes');
exports = null != ('undefined' !== typeof module && null != module ? module.exports : void 0) ? 'undefined' !== typeof module && null != module ? module.exports : void 0 : this;
makeDispatcher = function (defaultValue, handlers, defaultHandler) {
  var cache$2, ctor, ctors, handler, handlers_, size$;
  if (null == defaultHandler)
    defaultHandler = function () {
    };
  handlers_ = {};
  for (var i$ = 0, length$ = handlers.length; i$ < length$; ++i$) {
    {
      cache$2 = handlers[i$];
      size$ = cache$2.length;
      ctors = size$ > 1 ? [].slice.call(cache$2, 0, size$ - 1) : [];
      handler = cache$2[size$ - 1];
    }
    for (var i$1 = 0, length$1 = ctors.length; i$1 < length$1; ++i$1) {
      ctor = ctors[i$1];
      handlers_[ctor.prototype.className] = handler;
    }
  }
  return function (node, args) {
    args = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
    if (!(null != node))
      return defaultValue;
    handler = Object.prototype.hasOwnProperty.call(handlers_, node.className) ? handlers_[node.className] : defaultHandler;
    return handler.apply(node, args);
  };
};
isTruthy = makeDispatcher(false, [
  [
    CS.ArrayInitialiser,
    CS.Class,
    CS.DeleteOp,
    CS.ForIn,
    CS.ForOf,
    CS.Function,
    CS.BoundFunction,
    CS.HeregExp,
    CS.ObjectInitialiser,
    CS.Range,
    CS.RegExp,
    CS.Slice,
    CS.TypeofOp,
    CS.While,
    function () {
      return true;
    }
  ],
  [
    CS.AssignOp,
    function () {
      return isTruthy(this.expression);
    }
  ],
  [
    CS.Block,
    function () {
      if (this.statements.length === 0) {
        return false;
      } else {
        return isTruthy(this.statements[this.statements.length - 1]);
      }
    }
  ],
  [
    CS.Bool,
    CS.Float,
    CS.Int,
    CS.String,
    function () {
      return !!this.data;
    }
  ],
  [
    CS.Conditional,
    function () {
      return isTruthy(this.condition) && isTruthy(this.consequent) || isFalsey(this.condition) && isTruthy(this.alternate);
    }
  ],
  [
    CS.LogicalAndOp,
    function () {
      return isTruthy(this.left) && isTruthy(this.right);
    }
  ],
  [
    CS.LogicalNotOp,
    function () {
      return isFalsey(this.expression);
    }
  ],
  [
    CS.LogicalOrOp,
    function () {
      return isTruthy(this.left) || isTruthy(this.right);
    }
  ],
  [
    CS.Program,
    function () {
      return isTruthy(this.body);
    }
  ],
  [
    CS.SeqOp,
    function () {
      return isTruthy(this.right);
    }
  ],
  [
    CS.Switch,
    function () {
      return all(this.cases, isTruthy) && (null != this.alternate ? isTruthy(this.alternate) : true);
    }
  ],
  [
    CS.SwitchCase,
    function () {
      return isTruthy(this.consequent);
    }
  ],
  [
    CS.UnaryExistsOp,
    function () {
      return isTruthy(this.expression) || this.expression['instanceof'](CS.Int, CS.Float, CS.String, CS.UnaryPlusOp, CS.UnaryNegateOp, CS.LogicalNotOp);
    }
  ]
], function () {
  return false;
});
isFalsey = makeDispatcher(false, [
  [
    CS.Null,
    CS.Undefined,
    function () {
      return true;
    }
  ],
  [
    CS.AssignOp,
    function () {
      return isFalsey(this.expression);
    }
  ],
  [
    CS.Block,
    function () {
      if (this.statements.length === 0) {
        return true;
      } else {
        return isFalsey(this.statements[this.statements.length - 1]);
      }
    }
  ],
  [
    CS.Bool,
    CS.Float,
    CS.Int,
    CS.String,
    function () {
      return !this.data;
    }
  ],
  [
    CS.Conditional,
    function () {
      return isTruthy(this.condition) && isFalsey(this.consequent) || isFalsey(this.condition) && isFalsey(this.alternate);
    }
  ],
  [
    CS.LogicalAndOp,
    function () {
      return isFalsey(this.left) || isFalsey(this.right);
    }
  ],
  [
    CS.LogicalNotOp,
    function () {
      return isTruthy(this.expression);
    }
  ],
  [
    CS.LogicalOrOp,
    function () {
      return isFalsey(this.left) && isFalsey(this.right);
    }
  ],
  [
    CS.Program,
    function () {
      return isFalsey(this.body);
    }
  ],
  [
    CS.SeqOp,
    function () {
      return isFalsey(this.right);
    }
  ],
  [
    CS.Switch,
    function () {
      return all(this.cases, isFalsey) && (null != this.alternate ? isFalsey(this.alternate) : true);
    }
  ],
  [
    CS.SwitchCase,
    function () {
      return isFalsey(this.block);
    }
  ],
  [
    CS.UnaryExistsOp,
    function () {
      return this.expression['instanceof'](CS.Null, CS.Undefined);
    }
  ]
], function () {
  return false;
});
mayHaveSideEffects = makeDispatcher(false, [
  [
    CS.Function,
    CS.BoundFunction,
    CS.Null,
    CS.RegExp,
    CS.This,
    CS.Undefined,
    function () {
      return false;
    }
  ],
  [
    CS.Break,
    CS.Continue,
    CS.Debugger,
    CS.DeleteOp,
    CS.NewOp,
    CS.Return,
    CS.Super,
    CS.PreDecrementOp,
    CS.PreIncrementOp,
    CS.PostDecrementOp,
    CS.PostIncrementOp,
    CS.ClassProtoAssignOp,
    CS.Constructor,
    CS.Throw,
    CS.JavaScript,
    CS.ExtendsOp,
    function () {
      return true;
    }
  ],
  [
    CS.Class,
    function (inScope) {
      return mayHaveSideEffects(this.parent, inScope) || null != this.nameAssignee && (this.name || beingDeclared(this.nameAssignee).length > 0);
    }
  ],
  [
    CS.Conditional,
    function (inScope) {
      return mayHaveSideEffects(this.condition, inScope) || !isFalsey(this.condition) && mayHaveSideEffects(this.consequent, inScope) || !isTruthy(this.condition) && mayHaveSideEffects(this.alternate, inScope);
    }
  ],
  [
    CS.DoOp,
    function (inScope) {
      var args, newScope, p;
      if (!this.expression['instanceof'](CS.Functions))
        return true;
      newScope = difference(inScope, concatMap(this.expression.parameters, beingDeclared));
      args = function (accum$) {
        for (var i$ = 0, length$ = this.expression.parameters.length; i$ < length$; ++i$) {
          p = this.expression.parameters[i$];
          accum$.push(p['instanceof'](CS.AssignOp) ? p.expression : p);
        }
        return accum$;
      }.call(this, []);
      if (any(args, function (a) {
          return mayHaveSideEffects(a, newScope);
        }))
        return true;
      return mayHaveSideEffects(this.expression.body, newScope);
    }
  ],
  [
    CS.ExistsOp,
    function (inScope) {
      if (mayHaveSideEffects(this.left, inScope))
        return true;
      if (this.left['instanceof'](CS.Undefined, CS.Null))
        return false;
      return mayHaveSideEffects(this.right, inScope);
    }
  ],
  [
    CS.FunctionApplication,
    CS.SoakedFunctionApplication,
    function (inScope) {
      var newScope;
      if (!this['function']['instanceof'](CS.Function, CS.BoundFunction))
        return true;
      newScope = difference(inScope, concatMap(this['function'].parameters, beingDeclared));
      if (any(this['arguments'], function (a) {
          return mayHaveSideEffects(a, newScope);
        }))
        return true;
      return mayHaveSideEffects(this['function'].body, newScope);
    }
  ],
  [
    CS.LogicalAndOp,
    function (inScope) {
      if (mayHaveSideEffects(this.left, inScope))
        return true;
      if (isFalsey(this.left))
        return false;
      return mayHaveSideEffects(this.right, inScope);
    }
  ],
  [
    CS.LogicalOrOp,
    function (inScope) {
      if (mayHaveSideEffects(this.left, inScope))
        return true;
      if (isTruthy(this.left))
        return false;
      return mayHaveSideEffects(this.right, inScope);
    }
  ],
  [
    CS.While,
    function (inScope) {
      return mayHaveSideEffects(this.condition, inScope) || !isFalsey(this.condition) && mayHaveSideEffects(this.body, inScope);
    }
  ],
  [
    CS.AssignOp,
    CS.ClassProtoAssignOp,
    CS.CompoundAssignOp,
    function (inScope) {
      return true;
    }
  ],
  [
    CS.Bool,
    CS.Float,
    CS.Identifier,
    CS.Int,
    CS.String,
    function () {
      return false;
    }
  ]
], function (inScope) {
  return any(this.childNodes, function (this$) {
    return function (child) {
      if (in$(child, this$.listMembers)) {
        return any(this$[child], function (m) {
          return mayHaveSideEffects(m, inScope);
        });
      } else {
        return mayHaveSideEffects(this$[child], inScope);
      }
    };
  }(this));
});
exports.Optimiser = function () {
  Optimiser.optimise = function (this$) {
    return function () {
      var cache$2;
      return (cache$2 = new this$).optimise.apply(cache$2, [].slice.call(arguments));
    };
  }(Optimiser);
  Optimiser.isTruthy = isTruthy;
  Optimiser.isFalsey = isFalsey;
  Optimiser.mayHaveSideEffects = mayHaveSideEffects;
  defaultRules = [
    [
      CS.Program,
      function () {
        if (!(null != this.body) || mayHaveSideEffects(this.body, [])) {
          return this;
        } else {
          return new CS.Program(null);
        }
      }
    ],
    [
      CS.Block,
      function (param$) {
        var inScope;
        inScope = param$.inScope;
        switch (this.statements.length) {
        case 0:
          return new CS.Undefined().g();
        case 1:
          return this.statements[0];
        default:
          return foldl(this.statements[0], this.statements.slice(1), function (expr, s) {
            return new CS.SeqOp(expr, s);
          });
        }
      }
    ],
    [
      CS.SeqOp,
      function (param$) {
        var ancestry, cache$2, canDropLast, inScope;
        {
          cache$2 = param$;
          inScope = cache$2.inScope;
          ancestry = cache$2.ancestry;
        }
        canDropLast = !usedAsExpression(this, ancestry);
        if (this.left['instanceof'](CS.Undefined)) {
          return this.right;
        } else if (this.left['instanceof'](CS.Return, CS.Throw)) {
          return this.left;
        } else if (mayHaveSideEffects(this.left, inScope)) {
          if (mayHaveSideEffects(this.right, inScope)) {
            return this;
          } else if (!canDropLast) {
            return this;
          } else if (this.right['instanceof'](CS.Undefined)) {
            return this.left;
          } else {
            return new CS.SeqOp(this.left, declarationsFor(this.right, union(inScope, envEnrichments(this.left, inScope))));
          }
        } else if (this.right['instanceof'](CS.Identifier) && this.right.data === 'eval' && ((null != ancestry[0] ? ancestry[0]['instanceof'](CS.FunctionApplication) : void 0) && ancestry[0]['function'] === this || (null != ancestry[0] ? ancestry[0]['instanceof'](CS.DoOp) : void 0) && ancestry[0].expression === this)) {
          if (this.left['instanceof'](CS.Int) && (0 <= this.left.data && this.left.data <= 9)) {
            return this;
          } else if (mayHaveSideEffects(this.left, inScope)) {
            return this;
          } else {
            return new CS.SeqOp(new CS.Int(0).g(), this.right);
          }
        } else if (mayHaveSideEffects(this.right, inScope)) {
          return new CS.SeqOp(declarationsFor(this.left, inScope), this.right);
        } else if (canDropLast) {
          return declarationsFor(this, inScope);
        } else {
          return this.right;
        }
      }
    ],
    [
      CS.AssignOp,
      function () {
        if (!this.expression['instanceof'](CS.SeqOp))
          return this;
        return new CS.SeqOp(this.expression.left, new CS.AssignOp(this.assignee, this.expression.right));
      }
    ],
    [
      CS.While,
      function (param$) {
        var inScope;
        inScope = param$.inScope;
        if (isFalsey(this.condition)) {
          return new CS.Block([
            mayHaveSideEffects(this.condition, inScope) ? new CS.SeqOp(this.condition, declarationsFor(this.body)) : null != this.body ? declarationsFor(this.body, inScope) : new CS.Undefined,
            new CS.ArrayInitialiser([])
          ]);
        } else if (isTruthy(this.condition)) {
          if (mayHaveSideEffects(this.condition, inScope)) {
            return this;
          } else if (null != this.body) {
            if (this instanceof CS.Loop) {
              return this;
            } else {
              return new CS.Loop(this.body).g();
            }
          } else {
            return new CS.ArrayInitialiser([]);
          }
        } else {
          return this;
        }
      }
    ],
    [
      CS.Conditional,
      function (param$) {
        var block, cache$2, cache$3, decls, inScope, removedBlock;
        inScope = param$.inScope;
        if (isFalsey(this.condition)) {
          cache$2 = [
            this.consequent,
            this.alternate
          ];
          removedBlock = cache$2[0];
          block = cache$2[1];
          cache$2;
        } else if (isTruthy(this.condition)) {
          cache$3 = [
            this.consequent,
            this.alternate
          ];
          block = cache$3[0];
          removedBlock = cache$3[1];
          cache$3;
        } else {
          return this;
        }
        decls = declarationsFor(removedBlock, inScope);
        block = null != block ? new CS.SeqOp(decls, block) : decls;
        if (mayHaveSideEffects(this.condition, inScope))
          block = new CS.SeqOp(this.condition, block);
        return block;
      }
    ],
    [
      CS.ForIn,
      function (param$) {
        var inScope;
        inScope = param$.inScope;
        if (!(this.target['instanceof'](CS.ArrayInitialiser) && this.target.members.length === 0))
          return this;
        return new CS.SeqOp(declarationsFor(this, inScope), new CS.ArrayInitialiser([]).g());
      }
    ],
    [
      CS.ForOf,
      function (param$) {
        var inScope;
        inScope = param$.inScope;
        if (!(this.isOwn && this.target['instanceof'](CS.ObjectInitialiser) && this.target.members.length === 0))
          return this;
        return new CS.SeqOp(declarationsFor(this, inScope), new CS.ArrayInitialiser([]).g());
      }
    ],
    [
      CS.ForIn,
      CS.ForOf,
      function (param$) {
        var inScope;
        inScope = param$.inScope;
        if (!isFalsey(this.filter))
          return this;
        return new CS.SeqOp(declarationsFor(this, inScope), new CS.ArrayInitialiser([]).g());
      }
    ],
    [
      CS.ForIn,
      function () {
        if (!isTruthy(this.filter))
          return this;
        return new CS.ForIn(this.valAssignee, this.keyAssignee, this.target, this.step, null, this.body);
      }
    ],
    [
      CS.ForOf,
      function () {
        if (!isTruthy(this.filter))
          return this;
        return new CS.ForOf(this.isOwn, this.keyAssignee, this.valAssignee, this.target, null, this.body);
      }
    ],
    [
      CS.ArrayInitialiser,
      function (param$) {
        var ancestry, cache$2, inScope;
        {
          cache$2 = param$;
          inScope = cache$2.inScope;
          ancestry = cache$2.ancestry;
        }
        if (usedAsExpression(this, ancestry)) {
          return this;
        } else {
          return foldl(new CS.Undefined().g(), this.members, function (expr, m) {
            return new CS.SeqOp(expr, m);
          });
        }
      }
    ],
    [
      CS.ExistsOp,
      function () {
        if (this.left['instanceof'](CS.Null, CS.Undefined)) {
          return this.right;
        } else {
          return this;
        }
      }
    ],
    [
      CS.UnaryExistsOp,
      function () {
        if (this.expression['instanceof'](CS.Null, CS.Undefined)) {
          return new CS.Bool(false).g();
        } else {
          return this;
        }
      }
    ],
    [
      CS.LogicalNotOp,
      function (param$) {
        var inScope;
        inScope = param$.inScope;
        switch (false) {
        case !this.expression['instanceof'](CS.Int, CS.Float, CS.String, CS.Bool):
          return new CS.Bool(!this.expression.data).g();
        case !this.expression['instanceof'](CS.Functions):
          return new CS.Bool(false).g();
        case !this.expression['instanceof'](CS.Null, CS.Undefined):
          return new CS.Bool(true).g();
        case !this.expression['instanceof'](CS.ArrayInitialiser, CS.ObjectInitialiser):
          if (mayHaveSideEffects(this.expression, inScope)) {
            return this;
          } else {
            return new CS.SeqOp(declarationsFor(this.expression, inScope), new CS.Bool(false).g());
          }
        case !this.expression['instanceof'](CS.LogicalNotOp):
          if (this.expression.expression['instanceof'](CS.LogicalNotOp)) {
            return this.expression.expression;
          } else {
            return this;
          }
        default:
          return this;
        }
      }
    ],
    [
      CS.TypeofOp,
      function () {
        switch (false) {
        case !this.expression['instanceof'](CS.Int, CS.Float, CS.UnaryNegateOp, CS.UnaryPlusOp):
          return new CS.String('number').g();
        case !this.expression['instanceof'](CS.String):
          return new CS.String('string').g();
        case !this.expression['instanceof'](CS.Functions):
          return new CS.String('function').g();
        case !this.expression['instanceof'](CS.Undefined):
          return new CS.String('undefined').g();
        default:
          return this;
        }
      }
    ],
    [
      CS.SeqOp,
      function (param$) {
        var ancestry;
        ancestry = param$.ancestry;
        if (!((null != ancestry[0] ? ancestry[0]['instanceof'](CS.Functions) : void 0) && ancestry[0].body === this))
          return this;
        if (this.right['instanceof'](CS.Return) && null != this.right.expression) {
          return new CS.SeqOp(this.left, this.right.expression);
        } else if (this.right['instanceof'](CS.Undefined)) {
          return new CS.SeqOp(this.left, new CS.Return);
        } else {
          return this;
        }
      }
    ],
    [
      CS.Function,
      CS.BoundFunction,
      function () {
        if (!(null != this.block && (this.block['instanceof'](CS.Undefined) || this.block['instanceof'](CS.Return) && !(null != this.block.expression))))
          return this;
        return new this.constructor(this.parameters, null);
      }
    ],
    [
      CS.Return,
      function () {
        if (null != this.expression ? this.expression['instanceof'](CS.Undefined) : void 0) {
          return new CS.Return;
        } else {
          return this;
        }
      }
    ],
    [
      CS.Slice,
      function () {
        if ((null != this.left ? this.left['instanceof'](CS.Int, CS.String) : void 0) && +this.left.data === 0) {
          return new CS.Slice(this.expression, this.isInclusive, null, this.right);
        } else if (this.isInclusive && (null != this.right ? this.right['instanceof'](CS.UnaryNegateOp) : void 0) && this.right.expression['instanceof'](CS.Int) && this.right.expression.data === 1) {
          return new CS.Slice(this.expression, true, this.left, null);
        } else {
          return this;
        }
      }
    ]
  ];
  function Optimiser() {
    var cache$2, ctor, ctors, handler, size$;
    this.rules = {};
    for (var i$ = 0, length$ = defaultRules.length; i$ < length$; ++i$) {
      {
        cache$2 = defaultRules[i$];
        size$ = cache$2.length;
        ctors = size$ > 1 ? [].slice.call(cache$2, 0, size$ - 1) : [];
        handler = cache$2[size$ - 1];
      }
      for (var i$1 = 0, length$1 = ctors.length; i$1 < length$1; ++i$1) {
        ctor = ctors[i$1];
        this.addRule(ctor.prototype.className, handler);
      }
    }
  }
  Optimiser.prototype.addRule = function (ctor, handler) {
    (null != this.rules[ctor] ? this.rules[ctor] : this.rules[ctor] = []).push(handler);
    return this;
  };
  Optimiser.prototype.optimise = function () {
    var walk;
    walk = function (fn, inScope, ancestry) {
      var childName, member, n, p, replacementNode;
      if (null == inScope)
        inScope = [];
      if (null == ancestry)
        ancestry = [];
      ancestry.unshift(this);
      for (var i$ = 0, length$ = this.childNodes.length; i$ < length$; ++i$) {
        childName = this.childNodes[i$];
        if (!(null != this[childName]))
          continue;
        if (in$(childName, this.listMembers)) {
          for (var i$1 = 0, length$1 = this[childName].length; i$1 < length$1; ++i$1) {
            member = this[childName][i$1];
            n = i$1;
            while (this[childName][n] !== walk.call(this[childName][n] = fn.call(this[childName][n], {
                inScope: inScope,
                ancestry: ancestry
              }), fn, inScope, ancestry)) {
            }
            inScope = union(inScope, envEnrichments(this[childName][n], inScope));
          }
        } else {
          while (this[childName] !== walk.call(this[childName] = fn.call(this[childName], {
              inScope: inScope,
              ancestry: ancestry
            }), fn, inScope, ancestry)) {
          }
          inScope = union(inScope, envEnrichments(this[childName], inScope));
        }
      }
      ancestry.shift();
      replacementNode = fn.call(this, {
        inScope: inScope,
        ancestry: ancestry
      });
      if (this !== replacementNode) {
        while (replacementNode !== walk.call(replacementNode = fn.call(replacementNode, {
            inScope: inScope,
            ancestry: ancestry
          }), fn, inScope, ancestry)) {
        }
        for (var cache$2 = [
              'raw',
              'line',
              'column',
              'offset'
            ], i$2 = 0, length$2 = cache$2.length; i$2 < length$2; ++i$2) {
          p = cache$2[i$2];
          replacementNode[p] = this[p];
        }
      }
      return replacementNode;
    };
    return function (ast) {
      var rules;
      rules = this.rules;
      return walk.call(ast, function (param$) {
        var ancestry, memo, rule;
        ancestry = param$.ancestry;
        if (!(null != this) || this === global)
          throw new Error('Optimiser rules must produce a node. `null` is not a node.');
        if (in$(this, ancestry))
          return this;
        memo = this;
        for (var cache$2 = null != rules[memo.className] ? rules[memo.className] : [], i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
          rule = cache$2[i$];
          memo = rule.apply(memo, arguments);
          if (memo !== this)
            break;
        }
        return memo;
      });
    };
  }();
  return Optimiser;
}();
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./functional-helpers":23,"./helpers":24,"./nodes":27}],29:[function(require,module,exports){
module.exports = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successful,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input) {
      var parseFunctions = {
        "program": parse_program
      };
      
      var options = arguments.length > 1 ? arguments[1] : {},
          startRule;
      
      if (options.startRule !== undefined) {
        startRule = options.startRule;
        
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Can't start parsing from rule " + quote(startRule) + ".");
        }
      } else {
        startRule = "program";
      }
      
      var pos = 0;
      var reportedPos = 0;
      var cachedReportedPos = 0;
      var cachedReportedPosDetails = { line: 1, column: 1, seenCR: false };
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      var cache = {};
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function computeReportedPosDetails() {
        function advanceCachedReportedPos() {
          var ch;
          
          for (; cachedReportedPos < reportedPos; cachedReportedPos++) {
            ch = input.charAt(cachedReportedPos);
            if (ch === "\n") {
              if (!cachedReportedPosDetails.seenCR) { cachedReportedPosDetails.line++; }
              cachedReportedPosDetails.column = 1;
              cachedReportedPosDetails.seenCR = false;
            } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
              cachedReportedPosDetails.line++;
              cachedReportedPosDetails.column = 1;
              cachedReportedPosDetails.seenCR = true;
            } else {
              cachedReportedPosDetails.column++;
              cachedReportedPosDetails.seenCR = false;
            }
          }
        }
        
        if (cachedReportedPos !== reportedPos) {
          if (cachedReportedPos > reportedPos) {
            cachedReportedPos = 0;
            cachedReportedPosDetails = { line: 1, column: 1, seenCR: false };
          }
          advanceCachedReportedPos();
        }
        
        return cachedReportedPosDetails;
      }
      
      function text() {
        return input.substring(reportedPos, pos);
      }
      
      function offset() {
        return reportedPos;
      }
      
      function line() {
        return computeReportedPosDetails().line;
      }
      
      function column() {
        return computeReportedPosDetails().column;
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_program() {
        var cacheKey = "program@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_TERMINATOR();
        r3 = r3 !== null ? r3 : "";
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_toplevelBlock();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(leader, b) {
              return rp(new CS.Program(b || null));
            })(r3, r5);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_toplevelBlock() {
        var cacheKey = "toplevelBlock@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_toplevelStatement();
        if (r3 !== null) {
          r4 = [];
          r6 = pos;
          r7 = parse__();
          if (r7 !== null) {
            r8 = parse_TERMINATOR();
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_toplevelStatement();
                if (r10 !== null) {
                  r5 = [r7, r8, r9, r10];
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          } else {
            r5 = null;
            pos = r6;
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = pos;
            r7 = parse__();
            if (r7 !== null) {
              r8 = parse_TERMINATOR();
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_toplevelStatement();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          }
          if (r4 !== null) {
            r5 = parse_TERMINATOR();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(s, ss) {
              return rp(new CS.Block([s].concat(ss.map(function(s){ return s[3]; }))));
            })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_toplevelStatement() {
        var cacheKey = "toplevelStatement@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = pos;
        r2 = pos;
        r4 = pos;
        reportFailures++;
        r3 = parse_return();
        if (r3 === null) {
          r3 = parse_continue();
          if (r3 === null) {
            r3 = parse_break();
          }
        }
        reportFailures--;
        if (r3 === null) {
          r3 = "";
        } else {
          r3 = null;
          pos = r4;
        }
        if (r3 !== null) {
          r4 = parse_statement();
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(s) { return s; })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_block() {
        var cacheKey = "block@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_statement();
        if (r3 !== null) {
          r4 = [];
          r6 = pos;
          r7 = parse__();
          if (r7 !== null) {
            r8 = parse_TERMINATOR();
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_statement();
                if (r10 !== null) {
                  r5 = [r7, r8, r9, r10];
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          } else {
            r5 = null;
            pos = r6;
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = pos;
            r7 = parse__();
            if (r7 !== null) {
              r8 = parse_TERMINATOR();
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_statement();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          }
          if (r4 !== null) {
            r5 = parse_TERMINATOR();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(s, ss) {
              return rp(new CS.Block([s].concat(ss.map(function(s){ return s[3]; }))));
            })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_statement() {
        var cacheKey = "statement@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_expression();
        if (r0 === null) {
          r0 = parse_return();
          if (r0 === null) {
            r0 = parse_continue();
            if (r0 === null) {
              r0 = parse_break();
              if (r0 === null) {
                r0 = parse_throw();
                if (r0 === null) {
                  r0 = parse_debugger();
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_expression() {
        var cacheKey = "expression@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_expressionworthy();
        if (r0 === null) {
          r0 = parse_seqExpression();
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_secondaryStatement() {
        var cacheKey = "secondaryStatement@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_secondaryExpression();
        if (r0 === null) {
          r0 = parse_return();
          if (r0 === null) {
            r0 = parse_continue();
            if (r0 === null) {
              r0 = parse_break();
              if (r0 === null) {
                r0 = parse_throw();
                if (r0 === null) {
                  r0 = parse_debugger();
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_secondaryExpression() {
        var cacheKey = "secondaryExpression@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_expressionworthy();
        if (r0 === null) {
          r0 = parse_assignmentExpression();
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_secondaryExpressionNoImplicitObjectCall() {
        var cacheKey = "secondaryExpressionNoImplicitObjectCall@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_expressionworthy();
        if (r0 === null) {
          r0 = parse_assignmentExpressionNoImplicitObjectCall();
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_expressionworthy() {
        var cacheKey = "expressionworthy@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_functionLiteral();
        if (r0 === null) {
          r0 = parse_conditional();
          if (r0 === null) {
            r0 = parse_while();
            if (r0 === null) {
              r0 = parse_loop();
              if (r0 === null) {
                r0 = parse_try();
                if (r0 === null) {
                  r0 = parse_forOf();
                  if (r0 === null) {
                    r0 = parse_forIn();
                    if (r0 === null) {
                      r0 = parse_switch();
                      if (r0 === null) {
                        r0 = parse_implicitObjectLiteral();
                        if (r0 === null) {
                          r0 = parse_class();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_seqExpression() {
        var cacheKey = "seqExpression@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_postfixControlFlowExpression();
        if (r3 !== null) {
          r5 = pos;
          r6 = parse__();
          if (r6 !== null) {
            if (input.charCodeAt(pos) === 59) {
              r7 = ";";
              pos++;
            } else {
              r7 = null;
              if (reportFailures === 0) {
                matchFailed("\";\"");
              }
            }
            if (r7 !== null) {
              r8 = parse_TERMINATOR();
              r8 = r8 !== null ? r8 : "";
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_expression();
                  if (r10 !== null) {
                    r4 = [r6, r7, r8, r9, r10];
                  } else {
                    r4 = null;
                    pos = r5;
                  }
                } else {
                  r4 = null;
                  pos = r5;
                }
              } else {
                r4 = null;
                pos = r5;
              }
            } else {
              r4 = null;
              pos = r5;
            }
          } else {
            r4 = null;
            pos = r5;
          }
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(left, right) {
              if(!right) return left;
              return rp(new CS.SeqOp(left, right[4]));
            })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_postfixControlFlowExpression() {
        var cacheKey = "postfixControlFlowExpression@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_secondaryStatement();
        if (r3 !== null) {
          r4 = [];
          r6 = pos;
          r7 = parse__();
          if (r7 !== null) {
            r8 = parse_postfixControlFlowOp();
            if (r8 !== null) {
              r5 = [r7, r8];
            } else {
              r5 = null;
              pos = r6;
            }
          } else {
            r5 = null;
            pos = r6;
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = pos;
            r7 = parse__();
            if (r7 !== null) {
              r8 = parse_postfixControlFlowOp();
              if (r8 !== null) {
                r5 = [r7, r8];
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(expr, postfixes) {
              return foldl(function(expr, postfixContainer){
                var constructor, cond,
                    postfix = postfixContainer[1],
                    indicator = postfix.type;
                switch(indicator){
                  case 'if':
                  case 'unless':
                    constructor = ('unless' === indicator) ? CS.NegatedConditional : CS.Conditional;
                    cond = ('unless' === indicator) ? new CS.LogicalNotOp(postfix.cond).g() : postfix.cond;
                    return rp(new constructor(cond, expr, null));
                  case 'while':
                  case 'until':
                    constructor = ('until' === indicator) ? CS.NegatedWhile : CS.While;
                    cond = ('until' === indicator) ? new CS.LogicalNotOp(postfix.cond).g() : postfix.cond;
                    return rp(new constructor(cond, expr));
                  case 'for-in':
                    return rp(new CS.ForIn(postfix.val, postfix.key, postfix.list, postfix.step, postfix.filter, expr));
                  case 'for-of':
                    return rp(new CS.ForOf(postfix.own, postfix.key, postfix.val, postfix.obj, postfix.filter, expr));
                }
              }, expr, postfixes)
            })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_postfixControlFlowOp() {
        var cacheKey = "postfixControlFlowOp@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_IF();
        if (r3 === null) {
          r3 = parse_UNLESS();
        }
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_assignmentExpression();
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(kw, e) { return {type: kw, cond: e}; })(r3, r5);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse_WHILE();
          if (r3 === null) {
            r3 = parse_UNTIL();
          }
          if (r3 !== null) {
            r4 = parse__();
            if (r4 !== null) {
              r5 = parse_assignmentExpression();
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(kw, e) { return {type: kw, cond: e}; })(r3, r5);
          }
          if (r0 === null) {
            pos = r1;
          }
          if (r0 === null) {
            r1 = pos;
            r2 = pos;
            r3 = parse_FOR();
            if (r3 !== null) {
              r4 = parse__();
              if (r4 !== null) {
                r6 = pos;
                r7 = parse_Assignable();
                if (r7 !== null) {
                  r8 = parse__();
                  if (r8 !== null) {
                    r10 = pos;
                    if (input.charCodeAt(pos) === 44) {
                      r11 = ",";
                      pos++;
                    } else {
                      r11 = null;
                      if (reportFailures === 0) {
                        matchFailed("\",\"");
                      }
                    }
                    if (r11 !== null) {
                      r12 = parse__();
                      if (r12 !== null) {
                        r13 = parse_Assignable();
                        if (r13 !== null) {
                          r14 = parse__();
                          if (r14 !== null) {
                            r9 = [r11, r12, r13, r14];
                          } else {
                            r9 = null;
                            pos = r10;
                          }
                        } else {
                          r9 = null;
                          pos = r10;
                        }
                      } else {
                        r9 = null;
                        pos = r10;
                      }
                    } else {
                      r9 = null;
                      pos = r10;
                    }
                    r9 = r9 !== null ? r9 : "";
                    if (r9 !== null) {
                      r5 = [r7, r8, r9];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
                r5 = r5 !== null ? r5 : "";
                if (r5 !== null) {
                  r6 = parse_IN();
                  if (r6 !== null) {
                    r7 = parse__();
                    if (r7 !== null) {
                      r8 = parse_assignmentExpression();
                      if (r8 !== null) {
                        r10 = pos;
                        r11 = parse__();
                        if (r11 !== null) {
                          r12 = parse_BY();
                          if (r12 !== null) {
                            r13 = parse__();
                            if (r13 !== null) {
                              r14 = parse_assignmentExpression();
                              if (r14 !== null) {
                                r9 = [r11, r12, r13, r14];
                              } else {
                                r9 = null;
                                pos = r10;
                              }
                            } else {
                              r9 = null;
                              pos = r10;
                            }
                          } else {
                            r9 = null;
                            pos = r10;
                          }
                        } else {
                          r9 = null;
                          pos = r10;
                        }
                        r9 = r9 !== null ? r9 : "";
                        if (r9 !== null) {
                          r11 = pos;
                          r12 = parse__();
                          if (r12 !== null) {
                            r13 = parse_WHEN();
                            if (r13 !== null) {
                              r14 = parse__();
                              if (r14 !== null) {
                                r15 = parse_assignmentExpression();
                                if (r15 !== null) {
                                  r10 = [r12, r13, r14, r15];
                                } else {
                                  r10 = null;
                                  pos = r11;
                                }
                              } else {
                                r10 = null;
                                pos = r11;
                              }
                            } else {
                              r10 = null;
                              pos = r11;
                            }
                          } else {
                            r10 = null;
                            pos = r11;
                          }
                          r10 = r10 !== null ? r10 : "";
                          if (r10 !== null) {
                            r0 = [r3, r4, r5, r6, r7, r8, r9, r10];
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
            if (r0 !== null) {
              reportedPos = r1;
              r0 = (function(maybeVal, list, maybeStep, maybeFilter) {
                    var val = maybeVal ? maybeVal[0] : null,
                        key = maybeVal && maybeVal[2] ? maybeVal[2][2] : null,
                        step = maybeStep ? maybeStep[3] : new CS.Int(1).r('1').g(),
                        filter = maybeFilter ? maybeFilter[3] : null;
                    return 0,
                      { type: 'for-in'
                      , val: val, key: key, list: list, step: step, filter: filter
                      };
                  })(r5, r8, r9, r10);
            }
            if (r0 === null) {
              pos = r1;
            }
            if (r0 === null) {
              r1 = pos;
              r2 = pos;
              r3 = parse_FOR();
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r6 = pos;
                  r7 = parse_OWN();
                  if (r7 !== null) {
                    r8 = parse__();
                    if (r8 !== null) {
                      r5 = [r7, r8];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                  r5 = r5 !== null ? r5 : "";
                  if (r5 !== null) {
                    r6 = parse_Assignable();
                    if (r6 !== null) {
                      r7 = parse__();
                      if (r7 !== null) {
                        r9 = pos;
                        if (input.charCodeAt(pos) === 44) {
                          r10 = ",";
                          pos++;
                        } else {
                          r10 = null;
                          if (reportFailures === 0) {
                            matchFailed("\",\"");
                          }
                        }
                        if (r10 !== null) {
                          r11 = parse__();
                          if (r11 !== null) {
                            r12 = parse_Assignable();
                            if (r12 !== null) {
                              r13 = parse__();
                              if (r13 !== null) {
                                r8 = [r10, r11, r12, r13];
                              } else {
                                r8 = null;
                                pos = r9;
                              }
                            } else {
                              r8 = null;
                              pos = r9;
                            }
                          } else {
                            r8 = null;
                            pos = r9;
                          }
                        } else {
                          r8 = null;
                          pos = r9;
                        }
                        r8 = r8 !== null ? r8 : "";
                        if (r8 !== null) {
                          r9 = parse_OF();
                          if (r9 !== null) {
                            r10 = parse__();
                            if (r10 !== null) {
                              r11 = parse_assignmentExpression();
                              if (r11 !== null) {
                                r13 = pos;
                                r14 = parse__();
                                if (r14 !== null) {
                                  r15 = parse_WHEN();
                                  if (r15 !== null) {
                                    r16 = parse__();
                                    if (r16 !== null) {
                                      r17 = parse_assignmentExpression();
                                      if (r17 !== null) {
                                        r12 = [r14, r15, r16, r17];
                                      } else {
                                        r12 = null;
                                        pos = r13;
                                      }
                                    } else {
                                      r12 = null;
                                      pos = r13;
                                    }
                                  } else {
                                    r12 = null;
                                    pos = r13;
                                  }
                                } else {
                                  r12 = null;
                                  pos = r13;
                                }
                                r12 = r12 !== null ? r12 : "";
                                if (r12 !== null) {
                                  r0 = [r3, r4, r5, r6, r7, r8, r9, r10, r11, r12];
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = (function(maybeOwn, key, maybeVal, obj, maybeFilter) {
                      var own = !!maybeOwn,
                          val = maybeVal ? maybeVal[2] : null,
                          filter = maybeFilter ? maybeFilter[3] : null;
                      return 0,
                        { type: 'for-of'
                        , own: own, key: key, val: val, obj: obj, filter: filter
                        };
                    })(r5, r6, r8, r11, r12);
              }
              if (r0 === null) {
                pos = r1;
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_assignmentExpression() {
        var cacheKey = "assignmentExpression@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_assignmentOp();
        if (r0 === null) {
          r0 = parse_compoundAssignmentOp();
          if (r0 === null) {
            r0 = parse_existsAssignmentOp();
            if (r0 === null) {
              r0 = parse_binaryExpression();
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_assignmentOp() {
        var cacheKey = "assignmentOp@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_Assignable();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos) === 61) {
              r5 = "=";
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"=\"");
              }
            }
            if (r5 !== null) {
              r7 = pos;
              reportFailures++;
              if (input.charCodeAt(pos) === 61) {
                r6 = "=";
                pos++;
              } else {
                r6 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              reportFailures--;
              if (r6 === null) {
                r6 = "";
              } else {
                r6 = null;
                pos = r7;
              }
              if (r6 !== null) {
                r8 = pos;
                r9 = pos;
                r10 = parse_TERMINDENT();
                if (r10 !== null) {
                  r11 = parse_secondaryExpression();
                  if (r11 !== null) {
                    r12 = parse_DEDENT();
                    if (r12 !== null) {
                      r7 = [r10, r11, r12];
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                } else {
                  r7 = null;
                  pos = r9;
                }
                if (r7 !== null) {
                  reportedPos = r8;
                  r7 = (function(e) { return e; })(r11);
                }
                if (r7 === null) {
                  pos = r8;
                }
                if (r7 === null) {
                  r8 = pos;
                  r9 = pos;
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_secondaryExpression();
                      if (r12 !== null) {
                        r7 = [r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                  if (r7 !== null) {
                    reportedPos = r8;
                    r7 = (function(e) { return e; })(r12);
                  }
                  if (r7 === null) {
                    pos = r8;
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(left, right) {
                return rp(new CS.AssignOp(left, right));
              })(r3, r7);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_compoundAssignmentOp() {
        var cacheKey = "compoundAssignmentOp@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_CompoundAssignable();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r6 = pos;
            reportFailures++;
            if (input.charCodeAt(pos) === 63) {
              r5 = "?";
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"?\"");
              }
            }
            reportFailures--;
            if (r5 === null) {
              r5 = "";
            } else {
              r5 = null;
              pos = r6;
            }
            if (r5 !== null) {
              r6 = parse_CompoundAssignmentOperators();
              if (r6 !== null) {
                if (input.charCodeAt(pos) === 61) {
                  r7 = "=";
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"=\"");
                  }
                }
                if (r7 !== null) {
                  r9 = pos;
                  r10 = pos;
                  r11 = parse_TERMINDENT();
                  if (r11 !== null) {
                    r12 = parse_secondaryExpression();
                    if (r12 !== null) {
                      r13 = parse_DEDENT();
                      if (r13 !== null) {
                        r8 = [r11, r12, r13];
                      } else {
                        r8 = null;
                        pos = r10;
                      }
                    } else {
                      r8 = null;
                      pos = r10;
                    }
                  } else {
                    r8 = null;
                    pos = r10;
                  }
                  if (r8 !== null) {
                    reportedPos = r9;
                    r8 = (function(e) { return e; })(r12);
                  }
                  if (r8 === null) {
                    pos = r9;
                  }
                  if (r8 === null) {
                    r9 = pos;
                    r10 = pos;
                    r11 = parse_TERMINATOR();
                    r11 = r11 !== null ? r11 : "";
                    if (r11 !== null) {
                      r12 = parse__();
                      if (r12 !== null) {
                        r13 = parse_secondaryExpression();
                        if (r13 !== null) {
                          r8 = [r11, r12, r13];
                        } else {
                          r8 = null;
                          pos = r10;
                        }
                      } else {
                        r8 = null;
                        pos = r10;
                      }
                    } else {
                      r8 = null;
                      pos = r10;
                    }
                    if (r8 !== null) {
                      reportedPos = r9;
                      r8 = (function(e) { return e; })(r13);
                    }
                    if (r8 === null) {
                      pos = r9;
                    }
                  }
                  if (r8 !== null) {
                    r0 = [r3, r4, r5, r6, r7, r8];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(left, op, right) {
                return rp(new CS.CompoundAssignOp(constructorLookup[op].prototype.className, left, right));
              })(r3, r6, r8);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_CompoundAssignmentOperators() {
        var cacheKey = "CompoundAssignmentOperators@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        if (input.substr(pos, 2) === "&&") {
          r0 = "&&";
          pos += 2;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("\"&&\"");
          }
        }
        if (r0 === null) {
          r0 = parse_AND();
          if (r0 === null) {
            if (input.substr(pos, 2) === "||") {
              r0 = "||";
              pos += 2;
            } else {
              r0 = null;
              if (reportFailures === 0) {
                matchFailed("\"||\"");
              }
            }
            if (r0 === null) {
              r0 = parse_OR();
              if (r0 === null) {
                if (input.substr(pos, 2) === "**") {
                  r0 = "**";
                  pos += 2;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"**\"");
                  }
                }
                if (r0 === null) {
                  if (/^[?&\^|*\/%]/.test(input.charAt(pos))) {
                    r0 = input.charAt(pos);
                    pos++;
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed("[?&\\^|*\\/%]");
                    }
                  }
                  if (r0 === null) {
                    r2 = pos;
                    if (input.charCodeAt(pos) === 43) {
                      r3 = "+";
                      pos++;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"+\"");
                      }
                    }
                    if (r3 !== null) {
                      r5 = pos;
                      reportFailures++;
                      if (input.charCodeAt(pos) === 43) {
                        r4 = "+";
                        pos++;
                      } else {
                        r4 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      reportFailures--;
                      if (r4 === null) {
                        r4 = "";
                      } else {
                        r4 = null;
                        pos = r5;
                      }
                      if (r4 !== null) {
                        r0 = [r3, r4];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                    if (r0 === null) {
                      r2 = pos;
                      if (input.charCodeAt(pos) === 45) {
                        r3 = "-";
                        pos++;
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"-\"");
                        }
                      }
                      if (r3 !== null) {
                        r5 = pos;
                        reportFailures++;
                        if (input.charCodeAt(pos) === 45) {
                          r4 = "-";
                          pos++;
                        } else {
                          r4 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"-\"");
                          }
                        }
                        reportFailures--;
                        if (r4 === null) {
                          r4 = "";
                        } else {
                          r4 = null;
                          pos = r5;
                        }
                        if (r4 !== null) {
                          r0 = [r3, r4];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                      if (r0 === null) {
                        if (input.substr(pos, 2) === "<<") {
                          r0 = "<<";
                          pos += 2;
                        } else {
                          r0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"<<\"");
                          }
                        }
                        if (r0 === null) {
                          if (input.substr(pos, 3) === ">>>") {
                            r0 = ">>>";
                            pos += 3;
                          } else {
                            r0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\">>>\"");
                            }
                          }
                          if (r0 === null) {
                            if (input.substr(pos, 2) === ">>") {
                              r0 = ">>";
                              pos += 2;
                            } else {
                              r0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\">>\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_existsAssignmentOp() {
        var cacheKey = "existsAssignmentOp@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_CompoundAssignable();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.substr(pos, 2) === "?=") {
              r5 = "?=";
              pos += 2;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"?=\"");
              }
            }
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r8 = pos;
                r9 = pos;
                r10 = parse_TERMINDENT();
                if (r10 !== null) {
                  r11 = parse_secondaryExpression();
                  if (r11 !== null) {
                    r12 = parse_DEDENT();
                    if (r12 !== null) {
                      r7 = [r10, r11, r12];
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                } else {
                  r7 = null;
                  pos = r9;
                }
                if (r7 !== null) {
                  reportedPos = r8;
                  r7 = (function(e) { return e; })(r11);
                }
                if (r7 === null) {
                  pos = r8;
                }
                if (r7 === null) {
                  r8 = pos;
                  r9 = pos;
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_secondaryExpression();
                      if (r12 !== null) {
                        r7 = [r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                  if (r7 !== null) {
                    reportedPos = r8;
                    r7 = (function(e) { return e; })(r12);
                  }
                  if (r7 === null) {
                    pos = r8;
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(left, right) {
                return rp(new CS.CompoundAssignOp(constructorLookup['?'].prototype.className, left, right));
              })(r3, r7);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_assignmentExpressionNoImplicitObjectCall() {
        var cacheKey = "assignmentExpressionNoImplicitObjectCall@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_assignmentOpNoImplicitObjectCall();
        if (r0 === null) {
          r0 = parse_compoundAssignmentOpNoImplicitObjectCall();
          if (r0 === null) {
            r0 = parse_existsAssignmentOpNoImplicitObjectCall();
            if (r0 === null) {
              r0 = parse_binaryExpressionNoImplicitObjectCall();
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_assignmentOpNoImplicitObjectCall() {
        var cacheKey = "assignmentOpNoImplicitObjectCall@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_Assignable();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos) === 61) {
              r5 = "=";
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"=\"");
              }
            }
            if (r5 !== null) {
              r7 = pos;
              reportFailures++;
              if (input.charCodeAt(pos) === 61) {
                r6 = "=";
                pos++;
              } else {
                r6 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              reportFailures--;
              if (r6 === null) {
                r6 = "";
              } else {
                r6 = null;
                pos = r7;
              }
              if (r6 !== null) {
                r8 = pos;
                r9 = pos;
                r10 = parse_TERMINDENT();
                if (r10 !== null) {
                  r11 = parse_secondaryExpressionNoImplicitObjectCall();
                  if (r11 !== null) {
                    r12 = parse_DEDENT();
                    if (r12 !== null) {
                      r7 = [r10, r11, r12];
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                } else {
                  r7 = null;
                  pos = r9;
                }
                if (r7 !== null) {
                  reportedPos = r8;
                  r7 = (function(e) { return e; })(r11);
                }
                if (r7 === null) {
                  pos = r8;
                }
                if (r7 === null) {
                  r8 = pos;
                  r9 = pos;
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_secondaryExpressionNoImplicitObjectCall();
                      if (r12 !== null) {
                        r7 = [r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                  if (r7 !== null) {
                    reportedPos = r8;
                    r7 = (function(e) { return e; })(r12);
                  }
                  if (r7 === null) {
                    pos = r8;
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(left, right) {
                return rp(new CS.AssignOp(left, right));
              })(r3, r7);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_compoundAssignmentOpNoImplicitObjectCall() {
        var cacheKey = "compoundAssignmentOpNoImplicitObjectCall@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_CompoundAssignable();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r6 = pos;
            reportFailures++;
            if (input.charCodeAt(pos) === 63) {
              r5 = "?";
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"?\"");
              }
            }
            reportFailures--;
            if (r5 === null) {
              r5 = "";
            } else {
              r5 = null;
              pos = r6;
            }
            if (r5 !== null) {
              r6 = parse_CompoundAssignmentOperators();
              if (r6 !== null) {
                if (input.charCodeAt(pos) === 61) {
                  r7 = "=";
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"=\"");
                  }
                }
                if (r7 !== null) {
                  r9 = pos;
                  r10 = pos;
                  r11 = parse_TERMINDENT();
                  if (r11 !== null) {
                    r12 = parse_secondaryExpressionNoImplicitObjectCall();
                    if (r12 !== null) {
                      r13 = parse_DEDENT();
                      if (r13 !== null) {
                        r8 = [r11, r12, r13];
                      } else {
                        r8 = null;
                        pos = r10;
                      }
                    } else {
                      r8 = null;
                      pos = r10;
                    }
                  } else {
                    r8 = null;
                    pos = r10;
                  }
                  if (r8 !== null) {
                    reportedPos = r9;
                    r8 = (function(e) { return e; })(r12);
                  }
                  if (r8 === null) {
                    pos = r9;
                  }
                  if (r8 === null) {
                    r9 = pos;
                    r10 = pos;
                    r11 = parse_TERMINATOR();
                    r11 = r11 !== null ? r11 : "";
                    if (r11 !== null) {
                      r12 = parse__();
                      if (r12 !== null) {
                        r13 = parse_secondaryExpressionNoImplicitObjectCall();
                        if (r13 !== null) {
                          r8 = [r11, r12, r13];
                        } else {
                          r8 = null;
                          pos = r10;
                        }
                      } else {
                        r8 = null;
                        pos = r10;
                      }
                    } else {
                      r8 = null;
                      pos = r10;
                    }
                    if (r8 !== null) {
                      reportedPos = r9;
                      r8 = (function(e) { return e; })(r13);
                    }
                    if (r8 === null) {
                      pos = r9;
                    }
                  }
                  if (r8 !== null) {
                    r0 = [r3, r4, r5, r6, r7, r8];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(left, op, right) {
                return rp(new CS.CompoundAssignOp(constructorLookup[op].prototype.className, left, right));
              })(r3, r6, r8);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_existsAssignmentOpNoImplicitObjectCall() {
        var cacheKey = "existsAssignmentOpNoImplicitObjectCall@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_CompoundAssignable();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.substr(pos, 2) === "?=") {
              r5 = "?=";
              pos += 2;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"?=\"");
              }
            }
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r8 = pos;
                r9 = pos;
                r10 = parse_TERMINDENT();
                if (r10 !== null) {
                  r11 = parse_secondaryExpressionNoImplicitObjectCall();
                  if (r11 !== null) {
                    r12 = parse_DEDENT();
                    if (r12 !== null) {
                      r7 = [r10, r11, r12];
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                } else {
                  r7 = null;
                  pos = r9;
                }
                if (r7 !== null) {
                  reportedPos = r8;
                  r7 = (function(e) { return e; })(r11);
                }
                if (r7 === null) {
                  pos = r8;
                }
                if (r7 === null) {
                  r8 = pos;
                  r9 = pos;
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_secondaryExpressionNoImplicitObjectCall();
                      if (r12 !== null) {
                        r7 = [r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                  if (r7 !== null) {
                    reportedPos = r8;
                    r7 = (function(e) { return e; })(r12);
                  }
                  if (r7 === null) {
                    pos = r8;
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(left, right) {
                return rp(new CS.CompoundAssignOp(constructorLookup['?'].prototype.className, left, right));
              })(r3, r7);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_binaryExpression() {
        var cacheKey = "binaryExpression@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_prefixExpression();
        if (r3 !== null) {
          r4 = [];
          r6 = pos;
          r7 = pos;
          r8 = parse__();
          if (r8 !== null) {
            r9 = parse_binaryOperator();
            if (r9 !== null) {
              r10 = parse_TERMINATOR();
              r10 = r10 !== null ? r10 : "";
              if (r10 !== null) {
                r11 = parse__();
                if (r11 !== null) {
                  r12 = parse_expressionworthy();
                  if (r12 === null) {
                    r12 = parse_prefixExpression();
                  }
                  if (r12 !== null) {
                    r5 = [r8, r9, r10, r11, r12];
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                } else {
                  r5 = null;
                  pos = r7;
                }
              } else {
                r5 = null;
                pos = r7;
              }
            } else {
              r5 = null;
              pos = r7;
            }
          } else {
            r5 = null;
            pos = r7;
          }
          if (r5 !== null) {
            reportedPos = r6;
            r5 = (function(o, e) { return [o, e]; })(r9, r12);
          }
          if (r5 === null) {
            pos = r6;
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = pos;
            r7 = pos;
            r8 = parse__();
            if (r8 !== null) {
              r9 = parse_binaryOperator();
              if (r9 !== null) {
                r10 = parse_TERMINATOR();
                r10 = r10 !== null ? r10 : "";
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r12 = parse_expressionworthy();
                    if (r12 === null) {
                      r12 = parse_prefixExpression();
                    }
                    if (r12 !== null) {
                      r5 = [r8, r9, r10, r11, r12];
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                } else {
                  r5 = null;
                  pos = r7;
                }
              } else {
                r5 = null;
                pos = r7;
              }
            } else {
              r5 = null;
              pos = r7;
            }
            if (r5 !== null) {
              reportedPos = r6;
              r5 = (function(o, e) { return [o, e]; })(r9, r12);
            }
            if (r5 === null) {
              pos = r6;
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(left, rights) {
              switch(rights.length) {
                case 0: return left;
                case 1: return rp(new constructorLookup[rights[0][0]](left, rights[0][1]));
                default: return rp(foldBinaryExpr([].concat.apply([left], rights)));
              }
            })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_binaryOperator() {
        var cacheKey = "binaryOperator@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_CompoundAssignmentOperators();
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          if (input.charCodeAt(pos) === 61) {
            r4 = "=";
            pos++;
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        if (r0 === null) {
          if (input.substr(pos, 2) === "<=") {
            r0 = "<=";
            pos += 2;
          } else {
            r0 = null;
            if (reportFailures === 0) {
              matchFailed("\"<=\"");
            }
          }
          if (r0 === null) {
            if (input.substr(pos, 2) === ">=") {
              r0 = ">=";
              pos += 2;
            } else {
              r0 = null;
              if (reportFailures === 0) {
                matchFailed("\">=\"");
              }
            }
            if (r0 === null) {
              if (input.charCodeAt(pos) === 60) {
                r0 = "<";
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"<\"");
                }
              }
              if (r0 === null) {
                if (input.charCodeAt(pos) === 62) {
                  r0 = ">";
                  pos++;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\">\"");
                  }
                }
                if (r0 === null) {
                  if (input.substr(pos, 2) === "==") {
                    r0 = "==";
                    pos += 2;
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"==\"");
                    }
                  }
                  if (r0 === null) {
                    r0 = parse_IS();
                    if (r0 === null) {
                      if (input.substr(pos, 2) === "!=") {
                        r0 = "!=";
                        pos += 2;
                      } else {
                        r0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"!=\"");
                        }
                      }
                      if (r0 === null) {
                        r0 = parse_ISNT();
                        if (r0 === null) {
                          r0 = parse_EXTENDS();
                          if (r0 === null) {
                            r0 = parse_INSTANCEOF();
                            if (r0 === null) {
                              r0 = parse_IN();
                              if (r0 === null) {
                                r0 = parse_OF();
                                if (r0 === null) {
                                  r1 = pos;
                                  r2 = pos;
                                  r3 = parse_NOT();
                                  if (r3 !== null) {
                                    r4 = parse__();
                                    if (r4 !== null) {
                                      r5 = parse_INSTANCEOF();
                                      if (r5 === null) {
                                        r5 = parse_IN();
                                        if (r5 === null) {
                                          r5 = parse_OF();
                                        }
                                      }
                                      if (r5 !== null) {
                                        r0 = [r3, r4, r5];
                                      } else {
                                        r0 = null;
                                        pos = r2;
                                      }
                                    } else {
                                      r0 = null;
                                      pos = r2;
                                    }
                                  } else {
                                    r0 = null;
                                    pos = r2;
                                  }
                                  if (r0 !== null) {
                                    reportedPos = r1;
                                    r0 = (function(op) { return 'not ' + op;  })(r5);
                                  }
                                  if (r0 === null) {
                                    pos = r1;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_binaryExpressionNoImplicitObjectCall() {
        var cacheKey = "binaryExpressionNoImplicitObjectCall@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_prefixExpressionNoImplicitObjectCall();
        if (r3 !== null) {
          r4 = [];
          r6 = pos;
          r7 = pos;
          r8 = parse__();
          if (r8 !== null) {
            r9 = parse_binaryOperator();
            if (r9 !== null) {
              r10 = parse_TERMINATOR();
              r10 = r10 !== null ? r10 : "";
              if (r10 !== null) {
                r11 = parse__();
                if (r11 !== null) {
                  r12 = parse_expressionworthy();
                  if (r12 === null) {
                    r12 = parse_prefixExpressionNoImplicitObjectCall();
                  }
                  if (r12 !== null) {
                    r5 = [r8, r9, r10, r11, r12];
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                } else {
                  r5 = null;
                  pos = r7;
                }
              } else {
                r5 = null;
                pos = r7;
              }
            } else {
              r5 = null;
              pos = r7;
            }
          } else {
            r5 = null;
            pos = r7;
          }
          if (r5 !== null) {
            reportedPos = r6;
            r5 = (function(o, e) { return [o, e]; })(r9, r12);
          }
          if (r5 === null) {
            pos = r6;
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = pos;
            r7 = pos;
            r8 = parse__();
            if (r8 !== null) {
              r9 = parse_binaryOperator();
              if (r9 !== null) {
                r10 = parse_TERMINATOR();
                r10 = r10 !== null ? r10 : "";
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r12 = parse_expressionworthy();
                    if (r12 === null) {
                      r12 = parse_prefixExpressionNoImplicitObjectCall();
                    }
                    if (r12 !== null) {
                      r5 = [r8, r9, r10, r11, r12];
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                } else {
                  r5 = null;
                  pos = r7;
                }
              } else {
                r5 = null;
                pos = r7;
              }
            } else {
              r5 = null;
              pos = r7;
            }
            if (r5 !== null) {
              reportedPos = r6;
              r5 = (function(o, e) { return [o, e]; })(r9, r12);
            }
            if (r5 === null) {
              pos = r6;
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(left, rights) {
              switch(rights.length) {
                case 0: return left;
                case 1: return rp(new constructorLookup[rights[0][0]](left, rights[0][1]));
                default: return rp(foldBinaryExpr([].concat.apply([left], rights)));
              }
            })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_prefixExpression() {
        var cacheKey = "prefixExpression@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r0 = parse_postfixExpression();
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse_DO();
          if (r3 !== null) {
            r4 = parse__();
            if (r4 !== null) {
              r5 = parse_nfe();
              if (r5 === null) {
                r5 = parse_expressionworthy();
                if (r5 === null) {
                  r5 = parse_prefixExpression();
                }
              }
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(e) { return rp(new CS.DoOp(e)); })(r5);
          }
          if (r0 === null) {
            pos = r1;
          }
          if (r0 === null) {
            r1 = pos;
            r2 = pos;
            r5 = pos;
            r6 = parse_PrefixOperators();
            if (r6 !== null) {
              r7 = parse__();
              if (r7 !== null) {
                r4 = [r6, r7];
              } else {
                r4 = null;
                pos = r5;
              }
            } else {
              r4 = null;
              pos = r5;
            }
            if (r4 !== null) {
              r3 = [];
              while (r4 !== null) {
                r3.push(r4);
                r5 = pos;
                r6 = parse_PrefixOperators();
                if (r6 !== null) {
                  r7 = parse__();
                  if (r7 !== null) {
                    r4 = [r6, r7];
                  } else {
                    r4 = null;
                    pos = r5;
                  }
                } else {
                  r4 = null;
                  pos = r5;
                }
              }
            } else {
              r3 = null;
            }
            if (r3 !== null) {
              r4 = parse_expressionworthy();
              if (r4 === null) {
                r4 = parse_prefixExpression();
              }
              if (r4 !== null) {
                r0 = [r3, r4];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
            if (r0 !== null) {
              reportedPos = r1;
              r0 = (function(ops, e) {
                  return rp(foldr(function(e, op){
                    return new prefixConstructorLookup[op[0]](e);
                  }, e, ops));
                })(r3, r4);
            }
            if (r0 === null) {
              pos = r1;
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_PrefixOperators() {
        var cacheKey = "PrefixOperators@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        if (input.substr(pos, 2) === "++") {
          r0 = "++";
          pos += 2;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("\"++\"");
          }
        }
        if (r0 === null) {
          if (input.substr(pos, 2) === "--") {
            r0 = "--";
            pos += 2;
          } else {
            r0 = null;
            if (reportFailures === 0) {
              matchFailed("\"--\"");
            }
          }
          if (r0 === null) {
            if (input.charCodeAt(pos) === 43) {
              r0 = "+";
              pos++;
            } else {
              r0 = null;
              if (reportFailures === 0) {
                matchFailed("\"+\"");
              }
            }
            if (r0 === null) {
              if (input.charCodeAt(pos) === 45) {
                r0 = "-";
                pos++;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (r0 === null) {
                if (input.charCodeAt(pos) === 33) {
                  r0 = "!";
                  pos++;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"!\"");
                  }
                }
                if (r0 === null) {
                  r0 = parse_NOT();
                  if (r0 === null) {
                    if (input.charCodeAt(pos) === 126) {
                      r0 = "~";
                      pos++;
                    } else {
                      r0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"~\"");
                      }
                    }
                    if (r0 === null) {
                      r0 = parse_DO();
                      if (r0 === null) {
                        r0 = parse_TYPEOF();
                        if (r0 === null) {
                          r0 = parse_DELETE();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_nfe() {
        var cacheKey = "nfe@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = pos;
        r2 = pos;
        r4 = pos;
        reportFailures++;
        r3 = parse_unassignable();
        reportFailures--;
        if (r3 === null) {
          r3 = "";
        } else {
          r3 = null;
          pos = r4;
        }
        if (r3 !== null) {
          r4 = parse_Assignable();
          if (r4 !== null) {
            r5 = parse__();
            if (r5 !== null) {
              if (input.charCodeAt(pos) === 61) {
                r6 = "=";
                pos++;
              } else {
                r6 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              if (r6 !== null) {
                r7 = parse__();
                if (r7 !== null) {
                  r8 = parse_functionLiteral();
                  if (r8 !== null) {
                    r0 = [r3, r4, r5, r6, r7, r8];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(a, f) { return rp(new CS.AssignOp(a, f)); })(r4, r8);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_prefixExpressionNoImplicitObjectCall() {
        var cacheKey = "prefixExpressionNoImplicitObjectCall@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r0 = parse_postfixExpressionNoImplicitObjectCall();
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse_DO();
          if (r3 !== null) {
            r4 = parse__();
            if (r4 !== null) {
              r5 = parse_nfe();
              if (r5 === null) {
                r5 = parse_expressionworthy();
                if (r5 === null) {
                  r5 = parse_prefixExpressionNoImplicitObjectCall();
                }
              }
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(e) { return rp(new CS.DoOp(e)); })(r5);
          }
          if (r0 === null) {
            pos = r1;
          }
          if (r0 === null) {
            r1 = pos;
            r2 = pos;
            r5 = pos;
            r6 = parse_PrefixOperators();
            if (r6 !== null) {
              r7 = parse__();
              if (r7 !== null) {
                r4 = [r6, r7];
              } else {
                r4 = null;
                pos = r5;
              }
            } else {
              r4 = null;
              pos = r5;
            }
            if (r4 !== null) {
              r3 = [];
              while (r4 !== null) {
                r3.push(r4);
                r5 = pos;
                r6 = parse_PrefixOperators();
                if (r6 !== null) {
                  r7 = parse__();
                  if (r7 !== null) {
                    r4 = [r6, r7];
                  } else {
                    r4 = null;
                    pos = r5;
                  }
                } else {
                  r4 = null;
                  pos = r5;
                }
              }
            } else {
              r3 = null;
            }
            if (r3 !== null) {
              r4 = parse_expressionworthy();
              if (r4 === null) {
                r4 = parse_prefixExpressionNoImplicitObjectCall();
              }
              if (r4 !== null) {
                r0 = [r3, r4];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
            if (r0 !== null) {
              reportedPos = r1;
              r0 = (function(ops, e) {
                  return rp(foldr(function(e, op){
                    return new prefixConstructorLookup[op[0]](e);
                  }, e, ops));
                })(r3, r4);
            }
            if (r0 === null) {
              pos = r1;
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_postfixExpression() {
        var cacheKey = "postfixExpression@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_leftHandSideExpression();
        if (r3 !== null) {
          r4 = [];
          r5 = parse_PostfixOperators();
          while (r5 !== null) {
            r4.push(r5);
            r5 = parse_PostfixOperators();
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, ops) {
              return rp(foldl(function(e, op){
                return new postfixConstructorLookup[op](e);
              }, e, ops));
            })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_PostfixOperators() {
        var cacheKey = "PostfixOperators@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        if (input.charCodeAt(pos) === 63) {
          r0 = "?";
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("\"?\"");
          }
        }
        if (r0 === null) {
          if (input.substr(pos, 4) === "[..]") {
            r0 = "[..]";
            pos += 4;
          } else {
            r0 = null;
            if (reportFailures === 0) {
              matchFailed("\"[..]\"");
            }
          }
          if (r0 === null) {
            if (input.substr(pos, 2) === "++") {
              r0 = "++";
              pos += 2;
            } else {
              r0 = null;
              if (reportFailures === 0) {
                matchFailed("\"++\"");
              }
            }
            if (r0 === null) {
              if (input.substr(pos, 2) === "--") {
                r0 = "--";
                pos += 2;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"--\"");
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_postfixExpressionNoImplicitObjectCall() {
        var cacheKey = "postfixExpressionNoImplicitObjectCall@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_leftHandSideExpressionNoImplicitObjectCall();
        if (r3 !== null) {
          r4 = [];
          r5 = parse_PostfixOperators();
          while (r5 !== null) {
            r4.push(r5);
            r5 = parse_PostfixOperators();
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, ops) {
              return rp(foldl(function(e, op){
                return new postfixConstructorLookup[op](e);
              }, e, ops));
            })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_leftHandSideExpression() {
        var cacheKey = "leftHandSideExpression@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_callExpression();
        if (r0 === null) {
          r0 = parse_newExpression();
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_argumentList() {
        var cacheKey = "argumentList@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = pos;
        r2 = pos;
        if (input.charCodeAt(pos) === 63) {
          r3 = "?";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"?\"");
          }
        }
        r3 = r3 !== null ? r3 : "";
        if (r3 !== null) {
          if (input.charCodeAt(pos) === 40) {
            r4 = "(";
            pos++;
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"(\"");
            }
          }
          if (r4 !== null) {
            r5 = parse__();
            if (r5 !== null) {
              r6 = parse_argumentListContents();
              r6 = r6 !== null ? r6 : "";
              if (r6 !== null) {
                r7 = parse__();
                if (r7 !== null) {
                  if (input.charCodeAt(pos) === 41) {
                    r8 = ")";
                    pos++;
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed("\")\"");
                    }
                  }
                  if (r8 !== null) {
                    r0 = [r3, r4, r5, r6, r7, r8];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(soaked, a) {
                return rp(
                  { op: soaked ? CS.SoakedFunctionApplication : CS.FunctionApplication
                  , operands: [a || []]
                  }
                );
              })(r3, r6);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_argumentListContents() {
        var cacheKey = "argumentListContents@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_argument();
        if (r3 !== null) {
          r4 = [];
          r6 = pos;
          r7 = parse__();
          if (r7 !== null) {
            if (input.charCodeAt(pos) === 44) {
              r8 = ",";
              pos++;
            } else {
              r8 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            if (r8 === null) {
              r8 = parse_TERMINATOR();
            }
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_argument();
                if (r10 !== null) {
                  r5 = [r7, r8, r9, r10];
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          } else {
            r5 = null;
            pos = r6;
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = pos;
            r7 = parse__();
            if (r7 !== null) {
              if (input.charCodeAt(pos) === 44) {
                r8 = ",";
                pos++;
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              if (r8 === null) {
                r8 = parse_TERMINATOR();
              }
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_argument();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          }
          if (r4 !== null) {
            if (input.charCodeAt(pos) === 44) {
              r5 = ",";
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            if (r5 === null) {
              r5 = parse_TERMINATOR();
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, es) {
                return [e].concat(es.map(function(e){ return e[3]; }));
              })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse_TERMINDENT();
          if (r3 !== null) {
            r4 = parse_argumentListContents();
            if (r4 !== null) {
              r5 = parse_DEDENT();
              if (r5 !== null) {
                r6 = parse_TERMINATOR();
                r6 = r6 !== null ? r6 : "";
                if (r6 !== null) {
                  r0 = [r3, r4, r5, r6];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(a) { return a; })(r4);
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_argument() {
        var cacheKey = "argument@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_spread();
        if (r0 === null) {
          r0 = parse_expression();
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_secondaryArgumentList() {
        var cacheKey = "secondaryArgumentList@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14;
        
        r1 = pos;
        r2 = pos;
        r3 = parse___();
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r6 = pos;
          if (/^[+-\/]/.test(input.charAt(pos))) {
            r7 = input.charAt(pos);
            pos++;
          } else {
            r7 = null;
            if (reportFailures === 0) {
              matchFailed("[+-\\/]");
            }
          }
          if (r7 !== null) {
            r8 = parse___();
            if (r8 !== null) {
              r4 = [r7, r8];
            } else {
              r4 = null;
              pos = r6;
            }
          } else {
            r4 = null;
            pos = r6;
          }
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r5 = parse_secondaryArgument();
            if (r5 !== null) {
              r6 = [];
              r8 = pos;
              r9 = parse__();
              if (r9 !== null) {
                if (input.charCodeAt(pos) === 44) {
                  r10 = ",";
                  pos++;
                } else {
                  r10 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r12 = parse_TERMINATOR();
                    r12 = r12 !== null ? r12 : "";
                    if (r12 !== null) {
                      r13 = parse__();
                      if (r13 !== null) {
                        r14 = parse_secondaryArgument();
                        if (r14 !== null) {
                          r7 = [r9, r10, r11, r12, r13, r14];
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    } else {
                      r7 = null;
                      pos = r8;
                    }
                  } else {
                    r7 = null;
                    pos = r8;
                  }
                } else {
                  r7 = null;
                  pos = r8;
                }
              } else {
                r7 = null;
                pos = r8;
              }
              while (r7 !== null) {
                r6.push(r7);
                r8 = pos;
                r9 = parse__();
                if (r9 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    r10 = ",";
                    pos++;
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_TERMINATOR();
                      r12 = r12 !== null ? r12 : "";
                      if (r12 !== null) {
                        r13 = parse__();
                        if (r13 !== null) {
                          r14 = parse_secondaryArgument();
                          if (r14 !== null) {
                            r7 = [r9, r10, r11, r12, r13, r14];
                          } else {
                            r7 = null;
                            pos = r8;
                          }
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    } else {
                      r7 = null;
                      pos = r8;
                    }
                  } else {
                    r7 = null;
                    pos = r8;
                  }
                } else {
                  r7 = null;
                  pos = r8;
                }
              }
              if (r6 !== null) {
                r8 = pos;
                if (input.charCodeAt(pos) === 44) {
                  r9 = ",";
                  pos++;
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                r9 = r9 !== null ? r9 : "";
                if (r9 !== null) {
                  r10 = parse_TERMINDENT();
                  if (r10 !== null) {
                    r11 = parse_implicitObjectLiteral();
                    if (r11 !== null) {
                      r12 = parse_DEDENT();
                      if (r12 !== null) {
                        r7 = [r9, r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    } else {
                      r7 = null;
                      pos = r8;
                    }
                  } else {
                    r7 = null;
                    pos = r8;
                  }
                } else {
                  r7 = null;
                  pos = r8;
                }
                r7 = r7 !== null ? r7 : "";
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, es, obj) {
                es = [e].concat(es.map(function(e){ return e[5]; }));
                if(obj) es.push(obj[2]);
                return es;
              })(r5, r6, r7);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse_TERMINDENT();
          if (r3 !== null) {
            r4 = parse_implicitObjectLiteral();
            if (r4 !== null) {
              r5 = parse_DEDENT();
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(o) { return [o]; })(r4);
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_secondaryArgument() {
        var cacheKey = "secondaryArgument@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_spread();
        if (r0 === null) {
          r0 = parse_singleLineImplicitObjectLiteral();
          if (r0 === null) {
            r0 = parse_secondaryExpression();
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_leftHandSideExpressionNoImplicitObjectCall() {
        var cacheKey = "leftHandSideExpressionNoImplicitObjectCall@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_callExpressionNoImplicitObjectCall();
        if (r0 === null) {
          r0 = parse_newExpressionNoImplicitObjectCall();
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_secondaryArgumentListNoImplicitObjectCall() {
        var cacheKey = "secondaryArgumentListNoImplicitObjectCall@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14;
        
        r1 = pos;
        r2 = pos;
        r3 = parse___();
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r6 = pos;
          if (/^[+-\/]/.test(input.charAt(pos))) {
            r7 = input.charAt(pos);
            pos++;
          } else {
            r7 = null;
            if (reportFailures === 0) {
              matchFailed("[+-\\/]");
            }
          }
          if (r7 !== null) {
            r8 = parse___();
            if (r8 !== null) {
              r4 = [r7, r8];
            } else {
              r4 = null;
              pos = r6;
            }
          } else {
            r4 = null;
            pos = r6;
          }
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r5 = parse_secondaryArgumentNoImplicitObjectCall();
            if (r5 !== null) {
              r6 = [];
              r8 = pos;
              r9 = parse__();
              if (r9 !== null) {
                if (input.charCodeAt(pos) === 44) {
                  r10 = ",";
                  pos++;
                } else {
                  r10 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r12 = parse_TERMINATOR();
                    r12 = r12 !== null ? r12 : "";
                    if (r12 !== null) {
                      r13 = parse__();
                      if (r13 !== null) {
                        r14 = parse_secondaryArgumentNoImplicitObjectCall();
                        if (r14 !== null) {
                          r7 = [r9, r10, r11, r12, r13, r14];
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    } else {
                      r7 = null;
                      pos = r8;
                    }
                  } else {
                    r7 = null;
                    pos = r8;
                  }
                } else {
                  r7 = null;
                  pos = r8;
                }
              } else {
                r7 = null;
                pos = r8;
              }
              while (r7 !== null) {
                r6.push(r7);
                r8 = pos;
                r9 = parse__();
                if (r9 !== null) {
                  if (input.charCodeAt(pos) === 44) {
                    r10 = ",";
                    pos++;
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_TERMINATOR();
                      r12 = r12 !== null ? r12 : "";
                      if (r12 !== null) {
                        r13 = parse__();
                        if (r13 !== null) {
                          r14 = parse_secondaryArgumentNoImplicitObjectCall();
                          if (r14 !== null) {
                            r7 = [r9, r10, r11, r12, r13, r14];
                          } else {
                            r7 = null;
                            pos = r8;
                          }
                        } else {
                          r7 = null;
                          pos = r8;
                        }
                      } else {
                        r7 = null;
                        pos = r8;
                      }
                    } else {
                      r7 = null;
                      pos = r8;
                    }
                  } else {
                    r7 = null;
                    pos = r8;
                  }
                } else {
                  r7 = null;
                  pos = r8;
                }
              }
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, es) {
                es = [e].concat(es.map(function(e){ return e[5]; }));
                return es;
              })(r5, r6);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_secondaryArgumentNoImplicitObjectCall() {
        var cacheKey = "secondaryArgumentNoImplicitObjectCall@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_spreadNoImplicitObjectCall();
        if (r0 === null) {
          r0 = parse_secondaryExpressionNoImplicitObjectCall();
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_callExpression() {
        var cacheKey = "callExpression@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_memberExpression();
        if (r3 !== null) {
          r4 = parse_callExpressionAccesses();
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r6 = pos;
            if (input.charCodeAt(pos) === 63) {
              r7 = "?";
              pos++;
            } else {
              r7 = null;
              if (reportFailures === 0) {
                matchFailed("\"?\"");
              }
            }
            r7 = r7 !== null ? r7 : "";
            if (r7 !== null) {
              r8 = parse_secondaryArgumentList();
              if (r8 !== null) {
                r5 = [r7, r8];
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(fn, accesses, secondaryArgs) {
              if(accesses) fn = createMemberExpression(fn, accesses);
              var soaked, secondaryCtor;
              if(secondaryArgs) {
                soaked = secondaryArgs[0];
                secondaryCtor = soaked ? CS.SoakedFunctionApplication : CS.FunctionApplication;
                fn = rp(new secondaryCtor(fn, secondaryArgs[1]));
              }
              return fn;
            })(r3, r4, r5);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_callExpressionAccesses() {
        var cacheKey = "callExpressionAccesses@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_TERMINDENT();
        if (r3 !== null) {
          r4 = parse_callExpressionAccesses();
          if (r4 !== null) {
            r5 = parse_DEDENT();
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(as) { return as; })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r4 = parse_argumentList();
          if (r4 === null) {
            r4 = parse_MemberAccessOps();
          }
          if (r4 !== null) {
            r3 = [];
            while (r4 !== null) {
              r3.push(r4);
              r4 = parse_argumentList();
              if (r4 === null) {
                r4 = parse_MemberAccessOps();
              }
            }
          } else {
            r3 = null;
          }
          if (r3 !== null) {
            r4 = parse_callExpressionAccesses();
            r4 = r4 !== null ? r4 : "";
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(as, bs) { return as.concat(bs || []); })(r3, r4);
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_callExpressionNoImplicitObjectCall() {
        var cacheKey = "callExpressionNoImplicitObjectCall@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_memberExpressionNoImplicitObjectCall();
        if (r3 !== null) {
          r4 = [];
          r5 = parse_argumentList();
          if (r5 === null) {
            r5 = parse_MemberAccessOps();
          }
          while (r5 !== null) {
            r4.push(r5);
            r5 = parse_argumentList();
            if (r5 === null) {
              r5 = parse_MemberAccessOps();
            }
          }
          if (r4 !== null) {
            r6 = pos;
            if (input.charCodeAt(pos) === 63) {
              r7 = "?";
              pos++;
            } else {
              r7 = null;
              if (reportFailures === 0) {
                matchFailed("\"?\"");
              }
            }
            r7 = r7 !== null ? r7 : "";
            if (r7 !== null) {
              r8 = parse_secondaryArgumentListNoImplicitObjectCall();
              if (r8 !== null) {
                r5 = [r7, r8];
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(fn, accesses, secondaryArgs) {
              if(accesses) fn = createMemberExpression(fn, accesses);
              var soaked, secondaryCtor;
              if(secondaryArgs) {
                soaked = secondaryArgs[0];
                secondaryCtor = soaked ? CS.SoakedFunctionApplication : CS.FunctionApplication;
                fn = rp(new secondaryCtor(fn, secondaryArgs[1]));
              }
              return fn;
            })(r3, r4, r5);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_newExpression() {
        var cacheKey = "newExpression@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r0 = parse_memberExpression();
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse_NEW();
          if (r3 !== null) {
            r4 = parse___();
            if (r4 !== null) {
              r5 = parse_expressionworthy();
              if (r5 === null) {
                r5 = parse_newExpression();
                if (r5 === null) {
                  r5 = parse_prefixExpression();
                }
              }
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(e) {
                return rp(new CS.NewOp(e, []));
              })(r5);
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_newExpressionNoImplicitObjectCall() {
        var cacheKey = "newExpressionNoImplicitObjectCall@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r0 = parse_memberExpressionNoImplicitObjectCall();
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse_NEW();
          if (r3 !== null) {
            r4 = parse___();
            if (r4 !== null) {
              r5 = parse_expressionworthy();
              if (r5 === null) {
                r5 = parse_newExpressionNoImplicitObjectCall();
                if (r5 === null) {
                  r5 = parse_prefixExpressionNoImplicitObjectCall();
                }
              }
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(e) {
                return rp(new CS.NewOp(e, []));
              })(r5);
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_memberExpression() {
        var cacheKey = "memberExpression@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_primaryExpression();
        if (r3 === null) {
          r4 = pos;
          r5 = pos;
          r6 = parse_NEW();
          if (r6 !== null) {
            r7 = parse___();
            if (r7 !== null) {
              r8 = parse_memberExpression();
              if (r8 !== null) {
                r9 = parse_argumentList();
                if (r9 !== null) {
                  r3 = [r6, r7, r8, r9];
                } else {
                  r3 = null;
                  pos = r5;
                }
              } else {
                r3 = null;
                pos = r5;
              }
            } else {
              r3 = null;
              pos = r5;
            }
          } else {
            r3 = null;
            pos = r5;
          }
          if (r3 !== null) {
            reportedPos = r4;
            r3 = (function(e, args) { return rp(new CS.NewOp(e, args.operands[0])); })(r8, r9);
          }
          if (r3 === null) {
            pos = r4;
          }
        }
        if (r3 !== null) {
          r4 = [];
          r5 = parse_MemberAccessOps();
          while (r5 !== null) {
            r4.push(r5);
            r5 = parse_MemberAccessOps();
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, accesses) {
              return createMemberExpression(e, accesses || []);
            })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse_NEW();
          if (r3 !== null) {
            r4 = parse___();
            if (r4 !== null) {
              r5 = parse_memberExpression();
              if (r5 !== null) {
                r6 = parse_secondaryArgumentList();
                if (r6 !== null) {
                  r0 = [r3, r4, r5, r6];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(e, args) {
                return rp(new CS.NewOp(e, args));
              })(r5, r6);
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_memberAccess() {
        var cacheKey = "memberAccess@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_primaryExpression();
        if (r3 === null) {
          r4 = pos;
          r5 = pos;
          r6 = parse_NEW();
          if (r6 !== null) {
            r7 = parse___();
            if (r7 !== null) {
              r8 = parse_memberExpression();
              if (r8 !== null) {
                r9 = parse_argumentList();
                if (r9 !== null) {
                  r3 = [r6, r7, r8, r9];
                } else {
                  r3 = null;
                  pos = r5;
                }
              } else {
                r3 = null;
                pos = r5;
              }
            } else {
              r3 = null;
              pos = r5;
            }
          } else {
            r3 = null;
            pos = r5;
          }
          if (r3 !== null) {
            reportedPos = r4;
            r3 = (function(e, args) { return rp(new CS.NewOp(e, args.operands[0])); })(r8, r9);
          }
          if (r3 === null) {
            pos = r4;
          }
        }
        if (r3 !== null) {
          r6 = pos;
          r7 = parse_argumentList();
          if (r7 !== null) {
            r8 = parse_MemberAccessOps();
            if (r8 !== null) {
              r5 = [r7, r8];
            } else {
              r5 = null;
              pos = r6;
            }
          } else {
            r5 = null;
            pos = r6;
          }
          if (r5 === null) {
            r5 = parse_MemberAccessOps();
          }
          if (r5 !== null) {
            r4 = [];
            while (r5 !== null) {
              r4.push(r5);
              r6 = pos;
              r7 = parse_argumentList();
              if (r7 !== null) {
                r8 = parse_MemberAccessOps();
                if (r8 !== null) {
                  r5 = [r7, r8];
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
              if (r5 === null) {
                r5 = parse_MemberAccessOps();
              }
            }
          } else {
            r4 = null;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, accesses) {
                var acc = foldl(function(memo, a){ return memo.concat(a); }, [], accesses);
                return createMemberExpression(e, acc);
              })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r0 = parse_contextVar();
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_MemberAccessOps() {
        var cacheKey = "MemberAccessOps@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_TERMINDENT();
        if (r3 !== null) {
          if (input.charCodeAt(pos) === 46) {
            r4 = ".";
            pos++;
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (r4 !== null) {
            r5 = parse__();
            if (r5 !== null) {
              r6 = parse_identifierName();
              if (r6 !== null) {
                r7 = [];
                r8 = parse_MemberAccessOps();
                while (r8 !== null) {
                  r7.push(r8);
                  r8 = parse_MemberAccessOps();
                }
                if (r7 !== null) {
                  r8 = parse_DEDENT();
                  if (r8 !== null) {
                    r0 = [r3, r4, r5, r6, r7, r8];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e) { return rp({op: CS.MemberAccessOp, operands: [e]}); })(r6);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse_TERMINATOR();
          r3 = r3 !== null ? r3 : "";
          if (r3 !== null) {
            r4 = parse__();
            if (r4 !== null) {
              if (input.charCodeAt(pos) === 46) {
                r5 = ".";
                pos++;
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("\".\"");
                }
              }
              if (r5 !== null) {
                r6 = parse_TERMINATOR();
                r6 = r6 !== null ? r6 : "";
                if (r6 !== null) {
                  r7 = parse__();
                  if (r7 !== null) {
                    r8 = parse_identifierName();
                    if (r8 !== null) {
                      r0 = [r3, r4, r5, r6, r7, r8];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(e) { return rp({op: CS.MemberAccessOp, operands: [e]}); })(r8);
          }
          if (r0 === null) {
            pos = r1;
          }
          if (r0 === null) {
            r1 = pos;
            r2 = pos;
            if (input.substr(pos, 2) === "?.") {
              r3 = "?.";
              pos += 2;
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("\"?.\"");
              }
            }
            if (r3 !== null) {
              r4 = parse__();
              if (r4 !== null) {
                r5 = parse_identifierName();
                if (r5 !== null) {
                  r0 = [r3, r4, r5];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
            if (r0 !== null) {
              reportedPos = r1;
              r0 = (function(e) { return rp({op: CS.SoakedMemberAccessOp, operands: [e]}); })(r5);
            }
            if (r0 === null) {
              pos = r1;
            }
            if (r0 === null) {
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 91) {
                r3 = "[";
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"[\"");
                }
              }
              if (r3 !== null) {
                r4 = parse__();
                if (r4 !== null) {
                  r5 = parse_expression();
                  if (r5 !== null) {
                    r6 = parse__();
                    if (r6 !== null) {
                      if (input.charCodeAt(pos) === 93) {
                        r7 = "]";
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"]\"");
                        }
                      }
                      if (r7 !== null) {
                        r0 = [r3, r4, r5, r6, r7];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = (function(e) { return rp({op: CS.DynamicMemberAccessOp, operands: [e]}); })(r5);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (input.substr(pos, 2) === "?[") {
                  r3 = "?[";
                  pos += 2;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"?[\"");
                  }
                }
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r5 = parse_expression();
                    if (r5 !== null) {
                      r6 = parse__();
                      if (r6 !== null) {
                        if (input.charCodeAt(pos) === 93) {
                          r7 = "]";
                          pos++;
                        } else {
                          r7 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"]\"");
                          }
                        }
                        if (r7 !== null) {
                          r0 = [r3, r4, r5, r6, r7];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = (function(e) { return rp({op: CS.SoakedDynamicMemberAccessOp, operands: [e]}); })(r5);
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  r2 = pos;
                  if (input.substr(pos, 2) === "::") {
                    r3 = "::";
                    pos += 2;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"::\"");
                    }
                  }
                  if (r3 !== null) {
                    r4 = parse__();
                    if (r4 !== null) {
                      r5 = parse_identifierName();
                      if (r5 !== null) {
                        r0 = [r3, r4, r5];
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = (function(e) { return rp({op: CS.ProtoMemberAccessOp, operands: [e]}); })(r5);
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    r2 = pos;
                    if (input.substr(pos, 3) === "::[") {
                      r3 = "::[";
                      pos += 3;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"::[\"");
                      }
                    }
                    if (r3 !== null) {
                      r4 = parse__();
                      if (r4 !== null) {
                        r5 = parse_expression();
                        if (r5 !== null) {
                          r6 = parse__();
                          if (r6 !== null) {
                            if (input.charCodeAt(pos) === 93) {
                              r7 = "]";
                              pos++;
                            } else {
                              r7 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"]\"");
                              }
                            }
                            if (r7 !== null) {
                              r0 = [r3, r4, r5, r6, r7];
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = (function(e) { return rp({op: CS.DynamicProtoMemberAccessOp, operands: [e]}); })(r5);
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                    if (r0 === null) {
                      r1 = pos;
                      r2 = pos;
                      if (input.substr(pos, 3) === "?::") {
                        r3 = "?::";
                        pos += 3;
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"?::\"");
                        }
                      }
                      if (r3 !== null) {
                        r4 = parse__();
                        if (r4 !== null) {
                          r5 = parse_identifierName();
                          if (r5 !== null) {
                            r0 = [r3, r4, r5];
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                      if (r0 !== null) {
                        reportedPos = r1;
                        r0 = (function(e) { return rp({op: CS.SoakedProtoMemberAccessOp, operands: [e]}); })(r5);
                      }
                      if (r0 === null) {
                        pos = r1;
                      }
                      if (r0 === null) {
                        r1 = pos;
                        r2 = pos;
                        if (input.substr(pos, 4) === "?::[") {
                          r3 = "?::[";
                          pos += 4;
                        } else {
                          r3 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"?::[\"");
                          }
                        }
                        if (r3 !== null) {
                          r4 = parse__();
                          if (r4 !== null) {
                            r5 = parse_expression();
                            if (r5 !== null) {
                              r6 = parse__();
                              if (r6 !== null) {
                                if (input.charCodeAt(pos) === 93) {
                                  r7 = "]";
                                  pos++;
                                } else {
                                  r7 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"]\"");
                                  }
                                }
                                if (r7 !== null) {
                                  r0 = [r3, r4, r5, r6, r7];
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                        if (r0 !== null) {
                          reportedPos = r1;
                          r0 = (function(e) { return rp({op: CS.SoakedDynamicProtoMemberAccessOp, operands: [e]}); })(r5);
                        }
                        if (r0 === null) {
                          pos = r1;
                        }
                        if (r0 === null) {
                          r1 = pos;
                          r2 = pos;
                          if (input.charCodeAt(pos) === 91) {
                            r3 = "[";
                            pos++;
                          } else {
                            r3 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"[\"");
                            }
                          }
                          if (r3 !== null) {
                            r4 = parse__();
                            if (r4 !== null) {
                              r5 = parse_assignmentExpression();
                              r5 = r5 !== null ? r5 : "";
                              if (r5 !== null) {
                                r6 = parse__();
                                if (r6 !== null) {
                                  if (input.substr(pos, 2) === "..") {
                                    r7 = "..";
                                    pos += 2;
                                  } else {
                                    r7 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"..\"");
                                    }
                                  }
                                  if (r7 !== null) {
                                    if (input.charCodeAt(pos) === 46) {
                                      r8 = ".";
                                      pos++;
                                    } else {
                                      r8 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\".\"");
                                      }
                                    }
                                    r8 = r8 !== null ? r8 : "";
                                    if (r8 !== null) {
                                      r9 = parse__();
                                      if (r9 !== null) {
                                        r10 = parse_assignmentExpression();
                                        r10 = r10 !== null ? r10 : "";
                                        if (r10 !== null) {
                                          r11 = parse__();
                                          if (r11 !== null) {
                                            if (input.charCodeAt(pos) === 93) {
                                              r12 = "]";
                                              pos++;
                                            } else {
                                              r12 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\"]\"");
                                              }
                                            }
                                            if (r12 !== null) {
                                              r0 = [r3, r4, r5, r6, r7, r8, r9, r10, r11, r12];
                                            } else {
                                              r0 = null;
                                              pos = r2;
                                            }
                                          } else {
                                            r0 = null;
                                            pos = r2;
                                          }
                                        } else {
                                          r0 = null;
                                          pos = r2;
                                        }
                                      } else {
                                        r0 = null;
                                        pos = r2;
                                      }
                                    } else {
                                      r0 = null;
                                      pos = r2;
                                    }
                                  } else {
                                    r0 = null;
                                    pos = r2;
                                  }
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                          if (r0 !== null) {
                            reportedPos = r1;
                            r0 = (function(left, exclusive, right) {
                                  return rp({op: CS.Slice, operands: [!exclusive, left || null, right || null]});
                                })(r5, r8, r10);
                          }
                          if (r0 === null) {
                            pos = r1;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_memberExpressionNoImplicitObjectCall() {
        var cacheKey = "memberExpressionNoImplicitObjectCall@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_primaryExpression();
        if (r3 === null) {
          r4 = pos;
          r5 = pos;
          r6 = parse_NEW();
          if (r6 !== null) {
            r7 = parse___();
            if (r7 !== null) {
              r8 = parse_memberExpressionNoImplicitObjectCall();
              if (r8 !== null) {
                r9 = parse_argumentList();
                if (r9 !== null) {
                  r3 = [r6, r7, r8, r9];
                } else {
                  r3 = null;
                  pos = r5;
                }
              } else {
                r3 = null;
                pos = r5;
              }
            } else {
              r3 = null;
              pos = r5;
            }
          } else {
            r3 = null;
            pos = r5;
          }
          if (r3 !== null) {
            reportedPos = r4;
            r3 = (function(e, args) { return rp(new CS.NewOp(e, args.operands[0])); })(r8, r9);
          }
          if (r3 === null) {
            pos = r4;
          }
        }
        if (r3 !== null) {
          r4 = [];
          r5 = parse_MemberAccessOps();
          while (r5 !== null) {
            r4.push(r5);
            r5 = parse_MemberAccessOps();
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, accesses) {
              return createMemberExpression(e, accesses || []);
            })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse_NEW();
          if (r3 !== null) {
            r4 = parse___();
            if (r4 !== null) {
              r5 = parse_memberExpressionNoImplicitObjectCall();
              if (r5 !== null) {
                r6 = parse_secondaryArgumentListNoImplicitObjectCall();
                if (r6 !== null) {
                  r0 = [r3, r4, r5, r6];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(e, args) {
                return rp(new CS.NewOp(e, args));
              })(r5, r6);
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_primaryExpression() {
        var cacheKey = "primaryExpression@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
        
        r0 = parse_macro();
        if (r0 === null) {
          r0 = parse_Numbers();
          if (r0 === null) {
            r0 = parse_bool();
            if (r0 === null) {
              r0 = parse_null();
              if (r0 === null) {
                r0 = parse_undefined();
                if (r0 === null) {
                  r0 = parse_contextVar();
                  if (r0 === null) {
                    r1 = pos;
                    r0 = parse_THIS();
                    if (r0 === null) {
                      if (input.charCodeAt(pos) === 64) {
                        r0 = "@";
                        pos++;
                      } else {
                        r0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"@\"");
                        }
                      }
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = (function() { return rp(new CS.This); })();
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                    if (r0 === null) {
                      r0 = parse_identifier();
                      if (r0 === null) {
                        r0 = parse_range();
                        if (r0 === null) {
                          r0 = parse_arrayLiteral();
                          if (r0 === null) {
                            r0 = parse_objectLiteral();
                            if (r0 === null) {
                              r0 = parse_interpolation();
                              if (r0 === null) {
                                r0 = parse_JSLiteral();
                                if (r0 === null) {
                                  r0 = parse_string();
                                  if (r0 === null) {
                                    r0 = parse_regexp();
                                    if (r0 === null) {
                                      r1 = pos;
                                      r2 = pos;
                                      if (input.charCodeAt(pos) === 40) {
                                        r3 = "(";
                                        pos++;
                                      } else {
                                        r3 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"(\"");
                                        }
                                      }
                                      if (r3 !== null) {
                                        r4 = parse_TERMINDENT();
                                        if (r4 !== null) {
                                          r5 = parse_expression();
                                          if (r5 !== null) {
                                            r6 = parse_DEDENT();
                                            if (r6 !== null) {
                                              r7 = parse_TERMINATOR();
                                              r7 = r7 !== null ? r7 : "";
                                              if (r7 !== null) {
                                                if (input.charCodeAt(pos) === 41) {
                                                  r8 = ")";
                                                  pos++;
                                                } else {
                                                  r8 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed("\")\"");
                                                  }
                                                }
                                                if (r8 !== null) {
                                                  r0 = [r3, r4, r5, r6, r7, r8];
                                                } else {
                                                  r0 = null;
                                                  pos = r2;
                                                }
                                              } else {
                                                r0 = null;
                                                pos = r2;
                                              }
                                            } else {
                                              r0 = null;
                                              pos = r2;
                                            }
                                          } else {
                                            r0 = null;
                                            pos = r2;
                                          }
                                        } else {
                                          r0 = null;
                                          pos = r2;
                                        }
                                      } else {
                                        r0 = null;
                                        pos = r2;
                                      }
                                      if (r0 !== null) {
                                        reportedPos = r1;
                                        r0 = (function(e) { return r(e.clone()); })(r5);
                                      }
                                      if (r0 === null) {
                                        pos = r1;
                                      }
                                      if (r0 === null) {
                                        r1 = pos;
                                        r2 = pos;
                                        if (input.charCodeAt(pos) === 40) {
                                          r3 = "(";
                                          pos++;
                                        } else {
                                          r3 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"(\"");
                                          }
                                        }
                                        if (r3 !== null) {
                                          r4 = parse__();
                                          if (r4 !== null) {
                                            r5 = parse_expression();
                                            if (r5 !== null) {
                                              r6 = parse__();
                                              if (r6 !== null) {
                                                r7 = parse_TERMINATOR();
                                                r7 = r7 !== null ? r7 : "";
                                                if (r7 !== null) {
                                                  r8 = parse__();
                                                  if (r8 !== null) {
                                                    if (input.charCodeAt(pos) === 41) {
                                                      r9 = ")";
                                                      pos++;
                                                    } else {
                                                      r9 = null;
                                                      if (reportFailures === 0) {
                                                        matchFailed("\")\"");
                                                      }
                                                    }
                                                    if (r9 !== null) {
                                                      r0 = [r3, r4, r5, r6, r7, r8, r9];
                                                    } else {
                                                      r0 = null;
                                                      pos = r2;
                                                    }
                                                  } else {
                                                    r0 = null;
                                                    pos = r2;
                                                  }
                                                } else {
                                                  r0 = null;
                                                  pos = r2;
                                                }
                                              } else {
                                                r0 = null;
                                                pos = r2;
                                              }
                                            } else {
                                              r0 = null;
                                              pos = r2;
                                            }
                                          } else {
                                            r0 = null;
                                            pos = r2;
                                          }
                                        } else {
                                          r0 = null;
                                          pos = r2;
                                        }
                                        if (r0 !== null) {
                                          reportedPos = r1;
                                          r0 = (function(e) { return r(e.clone()); })(r5);
                                        }
                                        if (r0 === null) {
                                          pos = r1;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_contextVar() {
        var cacheKey = "contextVar@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = pos;
        r2 = pos;
        r4 = pos;
        if (input.charCodeAt(pos) === 64) {
          r3 = "@";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"@\"");
          }
        }
        if (r3 !== null) {
          reportedPos = r4;
          r3 = (function() { return rp(new CS.This); })();
        }
        if (r3 === null) {
          pos = r4;
        }
        if (r3 !== null) {
          r4 = parse_identifierName();
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(a, m) {
                return rp(new CS.MemberAccessOp(a, m));
              })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_JSLiteral() {
        var cacheKey = "JSLiteral@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = pos;
        r2 = pos;
        if (input.charCodeAt(pos) === 96) {
          r3 = "`";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"`\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          r4 = [];
          if (/^[^`]/.test(input.charAt(pos))) {
            r6 = input.charAt(pos);
            pos++;
          } else {
            r6 = null;
            if (reportFailures === 0) {
              matchFailed("[^`]");
            }
          }
          while (r6 !== null) {
            r4.push(r6);
            if (/^[^`]/.test(input.charAt(pos))) {
              r6 = input.charAt(pos);
              pos++;
            } else {
              r6 = null;
              if (reportFailures === 0) {
                matchFailed("[^`]");
              }
            }
          }
          if (r4 !== null) {
            r4 = input.substring(pos, r5);
          }
          if (r4 !== null) {
            if (input.charCodeAt(pos) === 96) {
              r5 = "`";
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"`\"");
              }
            }
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(d) { return rp(new CS.JavaScript(d)); })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_spread() {
        var cacheKey = "spread@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_postfixExpression();
        if (r3 !== null) {
          if (input.substr(pos, 3) === "...") {
            r4 = "...";
            pos += 3;
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"...\"");
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e) { return rp(new CS.Spread(e)); })(r3);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_spreadNoImplicitObjectCall() {
        var cacheKey = "spreadNoImplicitObjectCall@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_postfixExpressionNoImplicitObjectCall();
        if (r3 !== null) {
          if (input.substr(pos, 3) === "...") {
            r4 = "...";
            pos += 3;
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"...\"");
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e) { return rp(new CS.Spread(e)); })(r3);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_conditional() {
        var cacheKey = "conditional@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_IF();
        if (r3 === null) {
          r3 = parse_UNLESS();
        }
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_assignmentExpressionNoImplicitObjectCall();
            if (r5 !== null) {
              r6 = parse_conditionalBody();
              if (r6 !== null) {
                r7 = parse_elseClause();
                r7 = r7 !== null ? r7 : "";
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(kw, cond, body, elseClause) {
              var constructor = 'unless' === kw ? CS.NegatedConditional : CS.Conditional;
              if('unless' === kw) cond = new CS.LogicalNotOp(cond).g();
              return rp(new constructor(cond, body.block, elseClause || null));
            })(r3, r5, r6, r7);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_conditionalBody() {
        var cacheKey = "conditionalBody@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = pos;
        r2 = pos;
        r3 = parse__();
        if (r3 !== null) {
          r4 = parse_TERMINDENT();
          if (r4 !== null) {
            r5 = parse_block();
            if (r5 !== null) {
              r6 = parse_DEDENT();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(b) { return {block: b}; })(r5);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse_TERMINATOR();
          r3 = r3 !== null ? r3 : "";
          if (r3 !== null) {
            r4 = parse__();
            if (r4 !== null) {
              r5 = parse_THEN();
              if (r5 !== null) {
                r6 = parse__();
                if (r6 !== null) {
                  r7 = parse_statement();
                  if (r7 !== null) {
                    r0 = [r3, r4, r5, r6, r7];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(s) { return {block: s}; })(r7);
          }
          if (r0 === null) {
            pos = r1;
          }
          if (r0 === null) {
            r1 = pos;
            r2 = pos;
            r3 = parse__();
            if (r3 !== null) {
              r4 = parse_THEN();
              if (r4 !== null) {
                r0 = [r3, r4];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
            if (r0 !== null) {
              reportedPos = r1;
              r0 = (function() { return {block: null}; })();
            }
            if (r0 === null) {
              pos = r1;
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_elseClause() {
        var cacheKey = "elseClause@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = pos;
        r2 = pos;
        r3 = parse__();
        if (r3 !== null) {
          r4 = parse_TERMINATOR();
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r5 = parse__();
            if (r5 !== null) {
              r6 = parse_ELSE();
              if (r6 !== null) {
                r7 = parse_functionBody();
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(b) { return b; })(r7);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_while() {
        var cacheKey = "while@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_WHILE();
        if (r3 === null) {
          r3 = parse_UNTIL();
        }
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_assignmentExpressionNoImplicitObjectCall();
            if (r5 !== null) {
              r6 = parse_conditionalBody();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(kw, cond, body) {
              var constructor = 'until' === kw ? CS.NegatedWhile : CS.While;
              if('until' === kw) cond = new CS.LogicalNotOp(cond).g();
              return rp(new constructor(cond, body.block));
            })(r3, r5, r6);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_loop() {
        var cacheKey = "loop@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_LOOP();
        if (r3 !== null) {
          r4 = parse_conditionalBody();
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(body) {
              return rp(new CS.Loop(body.block));
            })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_try() {
        var cacheKey = "try@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_TRY();
        if (r3 !== null) {
          r4 = parse_tryBody();
          if (r4 !== null) {
            r5 = parse_catchClause();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse_finallyClause();
              r6 = r6 !== null ? r6 : "";
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(body, c, f) {
              return rp(new CS.Try(body.block, c ? c.assignee : null, c ? c.block : null, f ? f.block : null));
            })(r4, r5, r6);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_tryBody() {
        var cacheKey = "tryBody@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = pos;
        r0 = parse_functionBody();
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(b) { return {block: b}; })(r0);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_catchClause() {
        var cacheKey = "catchClause@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_TERMINATOR();
        r3 = r3 !== null ? r3 : "";
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_CATCH();
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r7 = parse_Assignable();
                r7 = r7 !== null ? r7 : "";
                if (r7 !== null) {
                  r8 = parse_conditionalBody();
                  r8 = r8 !== null ? r8 : "";
                  if (r8 !== null) {
                    r0 = [r3, r4, r5, r6, r7, r8];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, body) {
              return r({block: body ? body.block : new CS.Block([]), assignee: e || null});
            })(r7, r8);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_finallyClause() {
        var cacheKey = "finallyClause@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_TERMINATOR();
        r3 = r3 !== null ? r3 : "";
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_FINALLY();
            if (r5 !== null) {
              r6 = parse_tryBody();
              r6 = r6 !== null ? r6 : "";
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(body) {
              return r({block: body ? body.block : null});
            })(r6);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_class() {
        var cacheKey = "class@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_CLASS();
        if (r3 !== null) {
          r5 = pos;
          r6 = parse__();
          if (r6 !== null) {
            r7 = parse_Assignable();
            if (r7 !== null) {
              r4 = [r6, r7];
            } else {
              r4 = null;
              pos = r5;
            }
          } else {
            r4 = null;
            pos = r5;
          }
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r6 = pos;
            r7 = parse__();
            if (r7 !== null) {
              r8 = parse_EXTENDS();
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_secondaryExpressionNoImplicitObjectCall();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse_classBody();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(name, parent, body) {
              var ctor = null;
              name = name ? name[1] : null;
              parent = parent ? parent[3] : null;
              var boundMembers = [];
              var stmts = body ? body.statements || [body] : [];
              for(var i = 0, l = stmts.length; i < l; ++i) {
                var m = stmts[i];
                if(m.instanceof(CS.Constructor)) {
                  ctor = m;
                } else if(m.instanceof(CS.ClassProtoAssignOp) && m.expression.instanceof(CS.BoundFunction)) {
                  boundMembers.push(m);
                }
              }
              return rp(new CS.Class(name, parent, ctor, body, boundMembers));
            })(r4, r5, r6);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_classBody() {
        var cacheKey = "classBody@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = pos;
        r2 = pos;
        r3 = parse__();
        if (r3 !== null) {
          r4 = parse_TERMINDENT();
          if (r4 !== null) {
            r5 = parse_classBlock();
            if (r5 !== null) {
              r6 = parse_DEDENT();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(b) { return b; })(r5);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse__();
          if (r3 !== null) {
            r4 = parse_THEN();
            if (r4 !== null) {
              r5 = parse__();
              if (r5 !== null) {
                r6 = parse_classStatement();
                if (r6 !== null) {
                  r0 = [r3, r4, r5, r6];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(s) { return s; })(r6);
          }
          if (r0 === null) {
            pos = r1;
          }
          if (r0 === null) {
            r1 = pos;
            r2 = pos;
            r3 = parse__();
            if (r3 !== null) {
              r4 = parse_THEN();
              if (r4 !== null) {
                r0 = [r3, r4];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
            r0 = r0 !== null ? r0 : "";
            if (r0 !== null) {
              reportedPos = r1;
              r0 = (function() { return new CS.Block([]); })();
            }
            if (r0 === null) {
              pos = r1;
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_classBlock() {
        var cacheKey = "classBlock@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_classStatement();
        if (r3 !== null) {
          r4 = [];
          r6 = pos;
          r7 = parse__();
          if (r7 !== null) {
            r8 = parse_TERMINATOR();
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_classStatement();
                if (r10 !== null) {
                  r5 = [r7, r8, r9, r10];
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          } else {
            r5 = null;
            pos = r6;
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = pos;
            r7 = parse__();
            if (r7 !== null) {
              r8 = parse_TERMINATOR();
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_classStatement();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          }
          if (r4 !== null) {
            r5 = parse_TERMINATOR();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(s, ss) {
                return rp(new CS.Block([s].concat(ss.map(function(s){ return s[3]; }))));
              })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_classStatement() {
        var cacheKey = "classStatement@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_classProtoAssignment();
        if (r0 === null) {
          r0 = parse_staticAssignment();
          if (r0 === null) {
            r0 = parse_constructor();
            if (r0 === null) {
              r0 = parse_expression();
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_constructor() {
        var cacheKey = "constructor@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = pos;
        r2 = pos;
        r4 = pos;
        r3 = parse_ObjectInitialiserKeys();
        if (r3 !== null) {
          reportedPos = r4;
          r3 = (function(key) { return key.instanceof(CS.String, CS.Identifier) && 'constructor' === key.data || null; })(r3);
        }
        if (r3 === null) {
          pos = r4;
        }
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos) === 58) {
              r5 = ":";
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r8 = pos;
                r9 = pos;
                r10 = parse_TERMINDENT();
                if (r10 !== null) {
                  r11 = parse_expression();
                  if (r11 !== null) {
                    r12 = parse_DEDENT();
                    if (r12 !== null) {
                      r7 = [r10, r11, r12];
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                } else {
                  r7 = null;
                  pos = r9;
                }
                if (r7 !== null) {
                  reportedPos = r8;
                  r7 = (function(e) { return e; })(r11);
                }
                if (r7 === null) {
                  pos = r8;
                }
                if (r7 === null) {
                  r8 = pos;
                  r9 = pos;
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_expression();
                      if (r12 !== null) {
                        r7 = [r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                  if (r7 !== null) {
                    reportedPos = r8;
                    r7 = (function(e) { return e; })(r12);
                  }
                  if (r7 === null) {
                    pos = r8;
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e) {
                if(e.instanceof(CS.BoundFunction))
                  e = c(new CS.Function(e.parameters, e.body).r(e.raw), e);
                return rp(new CS.Constructor(e));
              })(r7);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_staticAssignment() {
        var cacheKey = "staticAssignment@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_contextVar();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos) === 58) {
              r5 = ":";
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r8 = pos;
                r9 = pos;
                r10 = parse_TERMINDENT();
                if (r10 !== null) {
                  r11 = parse_expression();
                  if (r11 !== null) {
                    r12 = parse_DEDENT();
                    if (r12 !== null) {
                      r7 = [r10, r11, r12];
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                } else {
                  r7 = null;
                  pos = r9;
                }
                if (r7 !== null) {
                  reportedPos = r8;
                  r7 = (function(e) { return r({expr: e}); })(r11);
                }
                if (r7 === null) {
                  pos = r8;
                }
                if (r7 === null) {
                  r8 = pos;
                  r9 = pos;
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_expression();
                      if (r12 !== null) {
                        r7 = [r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                  if (r7 !== null) {
                    reportedPos = r8;
                    r7 = (function(e) { return r({expr: e}); })(r12);
                  }
                  if (r7 === null) {
                    pos = r8;
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(key, e) {
                return rp(new CS.AssignOp(key, e.expr));
              })(r3, r7);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_classProtoAssignment() {
        var cacheKey = "classProtoAssignment@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_ObjectInitialiserKeys();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos) === 58) {
              r5 = ":";
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r8 = pos;
                r9 = pos;
                r10 = parse_TERMINDENT();
                if (r10 !== null) {
                  r11 = parse_expression();
                  if (r11 !== null) {
                    r12 = parse_DEDENT();
                    if (r12 !== null) {
                      r7 = [r10, r11, r12];
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                } else {
                  r7 = null;
                  pos = r9;
                }
                if (r7 !== null) {
                  reportedPos = r8;
                  r7 = (function(e) { return r({expr: e}); })(r11);
                }
                if (r7 === null) {
                  pos = r8;
                }
                if (r7 === null) {
                  r8 = pos;
                  r7 = parse_singleLineImplicitObjectLiteral();
                  if (r7 !== null) {
                    reportedPos = r8;
                    r7 = (function(e) { return r({expr: e}); })(r7);
                  }
                  if (r7 === null) {
                    pos = r8;
                  }
                  if (r7 === null) {
                    r8 = pos;
                    r9 = pos;
                    r10 = parse_TERMINATOR();
                    r10 = r10 !== null ? r10 : "";
                    if (r10 !== null) {
                      r11 = parse__();
                      if (r11 !== null) {
                        r12 = parse_secondaryExpression();
                        if (r12 !== null) {
                          r7 = [r10, r11, r12];
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                    if (r7 !== null) {
                      reportedPos = r8;
                      r7 = (function(e) { return r({expr: e}); })(r12);
                    }
                    if (r7 === null) {
                      pos = r8;
                    }
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(key, e) {
                if('constructor' === key.data) return null;
                return rp(new CS.ClassProtoAssignOp(key, e.expr));
              })(r3, r7);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_forOf() {
        var cacheKey = "forOf@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_FOR();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r6 = pos;
            r7 = parse_OWN();
            if (r7 !== null) {
              r8 = parse__();
              if (r8 !== null) {
                r5 = [r7, r8];
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse_Assignable();
              if (r6 !== null) {
                r7 = parse__();
                if (r7 !== null) {
                  r9 = pos;
                  if (input.charCodeAt(pos) === 44) {
                    r10 = ",";
                    pos++;
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_Assignable();
                      if (r12 !== null) {
                        r13 = parse__();
                        if (r13 !== null) {
                          r8 = [r10, r11, r12, r13];
                        } else {
                          r8 = null;
                          pos = r9;
                        }
                      } else {
                        r8 = null;
                        pos = r9;
                      }
                    } else {
                      r8 = null;
                      pos = r9;
                    }
                  } else {
                    r8 = null;
                    pos = r9;
                  }
                  r8 = r8 !== null ? r8 : "";
                  if (r8 !== null) {
                    r9 = parse_OF();
                    if (r9 !== null) {
                      r10 = parse__();
                      if (r10 !== null) {
                        r11 = parse_assignmentExpressionNoImplicitObjectCall();
                        if (r11 !== null) {
                          r12 = parse__();
                          if (r12 !== null) {
                            r14 = pos;
                            r15 = parse_WHEN();
                            if (r15 !== null) {
                              r16 = parse__();
                              if (r16 !== null) {
                                r17 = parse_assignmentExpressionNoImplicitObjectCall();
                                if (r17 !== null) {
                                  r18 = parse__();
                                  if (r18 !== null) {
                                    r13 = [r15, r16, r17, r18];
                                  } else {
                                    r13 = null;
                                    pos = r14;
                                  }
                                } else {
                                  r13 = null;
                                  pos = r14;
                                }
                              } else {
                                r13 = null;
                                pos = r14;
                              }
                            } else {
                              r13 = null;
                              pos = r14;
                            }
                            r13 = r13 !== null ? r13 : "";
                            if (r13 !== null) {
                              r14 = parse_conditionalBody();
                              if (r14 !== null) {
                                r0 = [r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14];
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                            } else {
                              r0 = null;
                              pos = r2;
                            }
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(own, key, maybeVal, obj, maybeFilter, body) {
              var val = maybeVal ? maybeVal[2] : null;
              var filter = maybeFilter ? maybeFilter[2] : null;
              return rp(new CS.ForOf(!!own, key, val, obj, filter, body.block));
            })(r5, r6, r8, r11, r13, r14);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_forIn() {
        var cacheKey = "forIn@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_FOR();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r6 = pos;
            r7 = parse_Assignable();
            if (r7 !== null) {
              r8 = parse__();
              if (r8 !== null) {
                r10 = pos;
                if (input.charCodeAt(pos) === 44) {
                  r11 = ",";
                  pos++;
                } else {
                  r11 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (r11 !== null) {
                  r12 = parse__();
                  if (r12 !== null) {
                    r13 = parse_Assignable();
                    if (r13 !== null) {
                      r14 = parse__();
                      if (r14 !== null) {
                        r9 = [r11, r12, r13, r14];
                      } else {
                        r9 = null;
                        pos = r10;
                      }
                    } else {
                      r9 = null;
                      pos = r10;
                    }
                  } else {
                    r9 = null;
                    pos = r10;
                  }
                } else {
                  r9 = null;
                  pos = r10;
                }
                r9 = r9 !== null ? r9 : "";
                if (r9 !== null) {
                  r5 = [r7, r8, r9];
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse_IN();
              if (r6 !== null) {
                r7 = parse__();
                if (r7 !== null) {
                  r8 = parse_assignmentExpressionNoImplicitObjectCall();
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r11 = pos;
                      r12 = parse_BY();
                      if (r12 !== null) {
                        r13 = parse__();
                        if (r13 !== null) {
                          r14 = parse_assignmentExpressionNoImplicitObjectCall();
                          if (r14 !== null) {
                            r15 = parse__();
                            if (r15 !== null) {
                              r10 = [r12, r13, r14, r15];
                            } else {
                              r10 = null;
                              pos = r11;
                            }
                          } else {
                            r10 = null;
                            pos = r11;
                          }
                        } else {
                          r10 = null;
                          pos = r11;
                        }
                      } else {
                        r10 = null;
                        pos = r11;
                      }
                      r10 = r10 !== null ? r10 : "";
                      if (r10 !== null) {
                        r12 = pos;
                        r13 = parse_WHEN();
                        if (r13 !== null) {
                          r14 = parse__();
                          if (r14 !== null) {
                            r15 = parse_assignmentExpressionNoImplicitObjectCall();
                            if (r15 !== null) {
                              r16 = parse__();
                              if (r16 !== null) {
                                r11 = [r13, r14, r15, r16];
                              } else {
                                r11 = null;
                                pos = r12;
                              }
                            } else {
                              r11 = null;
                              pos = r12;
                            }
                          } else {
                            r11 = null;
                            pos = r12;
                          }
                        } else {
                          r11 = null;
                          pos = r12;
                        }
                        r11 = r11 !== null ? r11 : "";
                        if (r11 !== null) {
                          r12 = parse_conditionalBody();
                          if (r12 !== null) {
                            r0 = [r3, r4, r5, r6, r7, r8, r9, r10, r11, r12];
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(maybeVal, list, maybeStep, maybeFilter, body) {
              var val = maybeVal ? maybeVal[0] : null;
              var key = maybeVal && maybeVal[2] ? maybeVal[2][2] : null;
              var step = maybeStep ? maybeStep[2] : new CS.Int(1).r('1').g();
              var filter = maybeFilter ? maybeFilter[2] : null;
              return rp(new CS.ForIn(val, key, list, step, filter, body.block));
            })(r5, r8, r10, r11, r12);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_switch() {
        var cacheKey = "switch@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_SWITCH();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_expressionworthy();
            if (r5 === null) {
              r5 = parse_assignmentExpression();
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse_switchBody();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, body) {
              return rp(new CS.Switch(e || null, body.cases, body['else'] || null));
            })(r5, r6);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_switchBody() {
        var cacheKey = "switchBody@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = pos;
        r2 = pos;
        r3 = parse__();
        if (r3 !== null) {
          r4 = parse_TERMINDENT();
          if (r4 !== null) {
            r5 = parse_switchBlock();
            if (r5 !== null) {
              r6 = parse_DEDENT();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(b) { return r({cases: b.cases, 'else': b['else']}); })(r5);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse__();
          if (r3 !== null) {
            r4 = parse_THEN();
            if (r4 !== null) {
              r5 = parse__();
              if (r5 !== null) {
                r6 = parse_case();
                if (r6 !== null) {
                  r0 = [r3, r4, r5, r6];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(c) { return r({cases: [c]}); })(r6);
          }
          if (r0 === null) {
            pos = r1;
          }
          if (r0 === null) {
            r1 = pos;
            r2 = pos;
            r3 = parse__();
            if (r3 !== null) {
              r4 = parse_THEN();
              if (r4 !== null) {
                r0 = [r3, r4];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
            if (r0 !== null) {
              reportedPos = r1;
              r0 = (function() { return r({cases: []}); })();
            }
            if (r0 === null) {
              pos = r1;
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_switchBlock() {
        var cacheKey = "switchBlock@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_case();
        if (r3 !== null) {
          r4 = [];
          r6 = pos;
          r7 = parse__();
          if (r7 !== null) {
            r8 = parse_TERMINATOR();
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_case();
                if (r10 !== null) {
                  r5 = [r7, r8, r9, r10];
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          } else {
            r5 = null;
            pos = r6;
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = pos;
            r7 = parse__();
            if (r7 !== null) {
              r8 = parse_TERMINATOR();
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_case();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          }
          if (r4 !== null) {
            r6 = pos;
            r7 = parse__();
            if (r7 !== null) {
              r8 = parse_TERMINATOR();
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_elseClause();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse_TERMINATOR();
              r6 = r6 !== null ? r6 : "";
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(c, cs, elseClause) {
                var cases = [c].concat(cs.map(function(w){ return w[3]; }));
                return r({cases: cases, 'else': elseClause ? elseClause[3] : null});
              })(r3, r4, r5);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_case() {
        var cacheKey = "case@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_WHEN();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_caseConditions();
            if (r5 !== null) {
              r6 = parse_conditionalBody();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(conditions, body) {
                return rp(new CS.SwitchCase(conditions, body.block));
              })(r5, r6);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_caseConditions() {
        var cacheKey = "caseConditions@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_assignmentExpressionNoImplicitObjectCall();
        if (r3 !== null) {
          r4 = [];
          r6 = pos;
          r7 = parse__();
          if (r7 !== null) {
            if (input.charCodeAt(pos) === 44) {
              r8 = ",";
              pos++;
            } else {
              r8 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_assignmentExpressionNoImplicitObjectCall();
                if (r10 !== null) {
                  r5 = [r7, r8, r9, r10];
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          } else {
            r5 = null;
            pos = r6;
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = pos;
            r7 = parse__();
            if (r7 !== null) {
              if (input.charCodeAt(pos) === 44) {
                r8 = ",";
                pos++;
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_assignmentExpressionNoImplicitObjectCall();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(c, cs) {
                return [c].concat(cs.map(function(c){ return c[3]; }));
              })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_functionLiteral() {
        var cacheKey = "functionLiteral@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13;
        
        r1 = pos;
        r2 = pos;
        r4 = pos;
        if (input.charCodeAt(pos) === 40) {
          r5 = "(";
          pos++;
        } else {
          r5 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (r5 !== null) {
          r6 = parse__();
          if (r6 !== null) {
            r8 = pos;
            r9 = pos;
            r10 = parse_TERMINDENT();
            if (r10 !== null) {
              r11 = parse_parameterList();
              if (r11 !== null) {
                r12 = parse_DEDENT();
                if (r12 !== null) {
                  r13 = parse_TERMINATOR();
                  if (r13 !== null) {
                    r7 = [r10, r11, r12, r13];
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                } else {
                  r7 = null;
                  pos = r9;
                }
              } else {
                r7 = null;
                pos = r9;
              }
            } else {
              r7 = null;
              pos = r9;
            }
            if (r7 !== null) {
              reportedPos = r8;
              r7 = (function(p) { return p; })(r11);
            }
            if (r7 === null) {
              pos = r8;
            }
            if (r7 === null) {
              r7 = parse_parameterList();
            }
            r7 = r7 !== null ? r7 : "";
            if (r7 !== null) {
              r8 = parse__();
              if (r8 !== null) {
                if (input.charCodeAt(pos) === 41) {
                  r9 = ")";
                  pos++;
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\")\"");
                  }
                }
                if (r9 !== null) {
                  r10 = parse__();
                  if (r10 !== null) {
                    r3 = [r5, r6, r7, r8, r9, r10];
                  } else {
                    r3 = null;
                    pos = r4;
                  }
                } else {
                  r3 = null;
                  pos = r4;
                }
              } else {
                r3 = null;
                pos = r4;
              }
            } else {
              r3 = null;
              pos = r4;
            }
          } else {
            r3 = null;
            pos = r4;
          }
        } else {
          r3 = null;
          pos = r4;
        }
        r3 = r3 !== null ? r3 : "";
        if (r3 !== null) {
          if (input.substr(pos, 2) === "->") {
            r4 = "->";
            pos += 2;
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"->\"");
            }
          }
          if (r4 === null) {
            if (input.substr(pos, 2) === "=>") {
              r4 = "=>";
              pos += 2;
            } else {
              r4 = null;
              if (reportFailures === 0) {
                matchFailed("\"=>\"");
              }
            }
          }
          if (r4 !== null) {
            r5 = parse_functionBody();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(params, arrow, body) {
              var constructor;
              switch(arrow) {
                case '->': constructor = CS.Function; break;
                case '=>': constructor = CS.BoundFunction; break;
                default: throw new Error('parsed function arrow ("' + arrow + '") not associated with a constructor');
              }
              return rp(new constructor(params && params[2] || [], body || null));
            })(r3, r4, r5);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_functionBody() {
        var cacheKey = "functionBody@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = pos;
        r2 = pos;
        r3 = parse__();
        if (r3 !== null) {
          r4 = parse_TERMINDENT();
          if (r4 !== null) {
            r5 = parse_block();
            if (r5 !== null) {
              r6 = parse_DEDENT();
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(b) { return b; })(r5);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse__();
          if (r3 !== null) {
            r4 = parse_statement();
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(s) { return s; })(r4);
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_parameter() {
        var cacheKey = "parameter@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_Assignable();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos) === 61) {
              r5 = "=";
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"=\"");
              }
            }
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r7 = parse_secondaryExpression();
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(param, default_) {
                return rp(new CS.DefaultParam(param, default_));
              })(r3, r7);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r0 = parse_rest();
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_rest() {
        var cacheKey = "rest@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_Assignable();
        if (r3 !== null) {
          if (input.substr(pos, 3) === "...") {
            r4 = "...";
            pos += 3;
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"...\"");
            }
          }
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(a, rest) {
                  return rp(rest ? new CS.Rest(a) : a);
                })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_parameterList() {
        var cacheKey = "parameterList@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_parameter();
        if (r3 !== null) {
          r4 = [];
          r6 = pos;
          r7 = parse__();
          if (r7 !== null) {
            r9 = pos;
            if (input.charCodeAt(pos) === 44) {
              r10 = ",";
              pos++;
            } else {
              r10 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            if (r10 !== null) {
              r11 = parse_TERMINATOR();
              r11 = r11 !== null ? r11 : "";
              if (r11 !== null) {
                r8 = [r10, r11];
              } else {
                r8 = null;
                pos = r9;
              }
            } else {
              r8 = null;
              pos = r9;
            }
            if (r8 === null) {
              r8 = parse_TERMINATOR();
            }
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_parameter();
                if (r10 !== null) {
                  r5 = [r7, r8, r9, r10];
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          } else {
            r5 = null;
            pos = r6;
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = pos;
            r7 = parse__();
            if (r7 !== null) {
              r9 = pos;
              if (input.charCodeAt(pos) === 44) {
                r10 = ",";
                pos++;
              } else {
                r10 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              if (r10 !== null) {
                r11 = parse_TERMINATOR();
                r11 = r11 !== null ? r11 : "";
                if (r11 !== null) {
                  r8 = [r10, r11];
                } else {
                  r8 = null;
                  pos = r9;
                }
              } else {
                r8 = null;
                pos = r9;
              }
              if (r8 === null) {
                r8 = parse_TERMINATOR();
              }
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_parameter();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, es) {
                return [e].concat(es.map(function(e){ return e[3]; }));
              })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_range() {
        var cacheKey = "range@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = pos;
        r2 = pos;
        if (input.charCodeAt(pos) === 91) {
          r3 = "[";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_secondaryExpression();
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                if (input.substr(pos, 2) === "..") {
                  r7 = "..";
                  pos += 2;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"..\"");
                  }
                }
                if (r7 !== null) {
                  if (input.charCodeAt(pos) === 46) {
                    r8 = ".";
                    pos++;
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed("\".\"");
                    }
                  }
                  r8 = r8 !== null ? r8 : "";
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_secondaryExpression();
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          if (input.charCodeAt(pos) === 93) {
                            r12 = "]";
                            pos++;
                          } else {
                            r12 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"]\"");
                            }
                          }
                          if (r12 !== null) {
                            r0 = [r3, r4, r5, r6, r7, r8, r9, r10, r11, r12];
                          } else {
                            r0 = null;
                            pos = r2;
                          }
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(left, exclusiveDot, right) {
              var inclusive = !exclusiveDot;
              return rp(new CS.Range(inclusive, left, right));
            })(r5, r8, r10);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_arrayLiteral() {
        var cacheKey = "arrayLiteral@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = pos;
        r2 = pos;
        if (input.charCodeAt(pos) === 91) {
          r3 = "[";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (r3 !== null) {
          r4 = parse_arrayLiteralBody();
          if (r4 !== null) {
            r5 = parse_TERMINATOR();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  r7 = "]";
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(members) {
              return rp(new CS.ArrayInitialiser(members));
            })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_arrayLiteralBody() {
        var cacheKey = "arrayLiteralBody@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_TERMINDENT();
        if (r3 !== null) {
          r4 = parse_arrayLiteralMemberList();
          if (r4 !== null) {
            r5 = parse_DEDENT();
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(members) { return members; })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse__();
          if (r3 !== null) {
            r4 = parse_arrayLiteralMemberList();
            r4 = r4 !== null ? r4 : "";
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(members) { return members || []; })(r4);
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_arrayLiteralMemberList() {
        var cacheKey = "arrayLiteralMemberList@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_arrayLiteralMember();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = [];
            r7 = pos;
            r8 = parse_arrayLiteralMemberSeparator();
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_arrayLiteralMember();
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r6 = [r8, r9, r10, r11];
                  } else {
                    r6 = null;
                    pos = r7;
                  }
                } else {
                  r6 = null;
                  pos = r7;
                }
              } else {
                r6 = null;
                pos = r7;
              }
            } else {
              r6 = null;
              pos = r7;
            }
            while (r6 !== null) {
              r5.push(r6);
              r7 = pos;
              r8 = parse_arrayLiteralMemberSeparator();
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_arrayLiteralMember();
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r6 = [r8, r9, r10, r11];
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                  } else {
                    r6 = null;
                    pos = r7;
                  }
                } else {
                  r6 = null;
                  pos = r7;
                }
              } else {
                r6 = null;
                pos = r7;
              }
            }
            if (r5 !== null) {
              r6 = parse_arrayLiteralMemberSeparator();
              r6 = r6 !== null ? r6 : "";
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, es) {
                return [e].concat(es.map(function(e){ return e[2]; }));
              })(r3, r5);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_arrayLiteralMember() {
        var cacheKey = "arrayLiteralMember@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r0 = parse_spread();
        if (r0 === null) {
          r0 = parse_expression();
          if (r0 === null) {
            r1 = pos;
            r2 = pos;
            r3 = parse_TERMINDENT();
            if (r3 !== null) {
              r4 = parse_implicitObjectLiteral();
              if (r4 !== null) {
                r5 = parse_DEDENT();
                if (r5 !== null) {
                  r0 = [r3, r4, r5];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
            if (r0 !== null) {
              reportedPos = r1;
              r0 = (function(o) { return o; })(r4);
            }
            if (r0 === null) {
              pos = r1;
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_arrayLiteralMemberSeparator() {
        var cacheKey = "arrayLiteralMemberSeparator@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_TERMINATOR();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos) === 44) {
              r5 = ",";
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          if (input.charCodeAt(pos) === 44) {
            r3 = ",";
            pos++;
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          if (r3 !== null) {
            r4 = parse_TERMINATOR();
            r4 = r4 !== null ? r4 : "";
            if (r4 !== null) {
              r5 = parse__();
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            r0 = input.substring(pos, r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_objectLiteral() {
        var cacheKey = "objectLiteral@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = pos;
        r2 = pos;
        if (input.charCodeAt(pos) === 123) {
          r3 = "{";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"{\"");
          }
        }
        if (r3 !== null) {
          r4 = parse_objectLiteralBody();
          if (r4 !== null) {
            r5 = parse_TERMINATOR();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                if (input.charCodeAt(pos) === 125) {
                  r7 = "}";
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"}\"");
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(members) {
            return rp(new CS.ObjectInitialiser(members));
          })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_objectLiteralBody() {
        var cacheKey = "objectLiteralBody@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_TERMINDENT();
        if (r3 !== null) {
          r4 = parse_objectLiteralMemberList();
          if (r4 !== null) {
            r5 = parse_DEDENT();
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(members) { return members; })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse__();
          if (r3 !== null) {
            r4 = parse_objectLiteralMemberList();
            r4 = r4 !== null ? r4 : "";
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(members) { return members || []; })(r4);
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_objectLiteralMemberList() {
        var cacheKey = "objectLiteralMemberList@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_objectLiteralMember();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = [];
            r7 = pos;
            r8 = parse_arrayLiteralMemberSeparator();
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_objectLiteralMember();
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r6 = [r8, r9, r10, r11];
                  } else {
                    r6 = null;
                    pos = r7;
                  }
                } else {
                  r6 = null;
                  pos = r7;
                }
              } else {
                r6 = null;
                pos = r7;
              }
            } else {
              r6 = null;
              pos = r7;
            }
            while (r6 !== null) {
              r5.push(r6);
              r7 = pos;
              r8 = parse_arrayLiteralMemberSeparator();
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_objectLiteralMember();
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r6 = [r8, r9, r10, r11];
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                  } else {
                    r6 = null;
                    pos = r7;
                  }
                } else {
                  r6 = null;
                  pos = r7;
                }
              } else {
                r6 = null;
                pos = r7;
              }
            }
            if (r5 !== null) {
              if (input.charCodeAt(pos) === 44) {
                r6 = ",";
                pos++;
              } else {
                r6 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              r6 = r6 !== null ? r6 : "";
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, es) {
                return [e].concat(es.map(function(e){ return e[2]; }));
              })(r3, r5);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_objectLiteralMember() {
        var cacheKey = "objectLiteralMember@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r0 = parse_implicitObjectLiteralMember();
        if (r0 === null) {
          r1 = pos;
          r0 = parse_contextVar();
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(v) {
                  var key = p(new CS.String(v.memberName).g());
                  return rp(new CS.ObjectInitialiserMember(key, v));
                })(r0);
          }
          if (r0 === null) {
            pos = r1;
          }
          if (r0 === null) {
            r1 = pos;
            r0 = parse_ObjectInitialiserKeys();
            if (r0 !== null) {
              reportedPos = r1;
              r0 = (function(v) {
                    return rp(new CS.ObjectInitialiserMember(v, v));
                  })(r0);
            }
            if (r0 === null) {
              pos = r1;
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_ObjectInitialiserKeys() {
        var cacheKey = "ObjectInitialiserKeys@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = pos;
        r0 = parse_identifierName();
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(i) { return rp(new CS.Identifier(i)); })(r0);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r0 = parse_string();
          if (r0 === null) {
            r0 = parse_Numbers();
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_implicitObjectLiteral() {
        var cacheKey = "implicitObjectLiteral@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = pos;
        r0 = parse_implicitObjectLiteralMemberList();
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(members) {
            return rp(new CS.ObjectInitialiser(members));
          })(r0);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_implicitObjectLiteralMemberList() {
        var cacheKey = "implicitObjectLiteralMemberList@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_implicitObjectLiteralMember();
        if (r3 !== null) {
          r4 = [];
          r6 = pos;
          r7 = parse_implicitObjectLiteralMemberSeparator();
          if (r7 !== null) {
            r8 = parse_implicitObjectLiteralMember();
            if (r8 !== null) {
              r5 = [r7, r8];
            } else {
              r5 = null;
              pos = r6;
            }
          } else {
            r5 = null;
            pos = r6;
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = pos;
            r7 = parse_implicitObjectLiteralMemberSeparator();
            if (r7 !== null) {
              r8 = parse_implicitObjectLiteralMember();
              if (r8 !== null) {
                r5 = [r7, r8];
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, es) {
                return [e].concat(es.map(function(e){ return e[1]; }));
              })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_implicitObjectLiteralMemberSeparator() {
        var cacheKey = "implicitObjectLiteralMemberSeparator@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = parse_TERMINATOR();
        if (r2 !== null) {
          if (input.charCodeAt(pos) === 44) {
            r3 = ",";
            pos++;
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          r3 = r3 !== null ? r3 : "";
          if (r3 !== null) {
            r4 = parse__();
            if (r4 !== null) {
              r0 = [r2, r3, r4];
            } else {
              r0 = null;
              pos = r1;
            }
          } else {
            r0 = null;
            pos = r1;
          }
        } else {
          r0 = null;
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = parse__();
          if (r2 !== null) {
            if (input.charCodeAt(pos) === 44) {
              r3 = ",";
              pos++;
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            if (r3 !== null) {
              r4 = parse_TERMINATOR();
              r4 = r4 !== null ? r4 : "";
              if (r4 !== null) {
                r5 = parse__();
                if (r5 !== null) {
                  r0 = [r2, r3, r4, r5];
                } else {
                  r0 = null;
                  pos = r1;
                }
              } else {
                r0 = null;
                pos = r1;
              }
            } else {
              r0 = null;
              pos = r1;
            }
          } else {
            r0 = null;
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_implicitObjectLiteralMember() {
        var cacheKey = "implicitObjectLiteralMember@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_ObjectInitialiserKeys();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos) === 58) {
              r5 = ":";
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r7 = parse_implicitObjectLiteralMemberValue();
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(key, val) {
                return rp(new CS.ObjectInitialiserMember(key, val));
              })(r3, r7);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_implicitObjectLiteralMemberValue() {
        var cacheKey = "implicitObjectLiteralMemberValue@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r0 = parse_singleLineImplicitObjectLiteral();
        if (r0 === null) {
          r0 = parse_expression();
          if (r0 === null) {
            r1 = pos;
            r2 = pos;
            r3 = parse_TERMINDENT();
            if (r3 !== null) {
              r4 = parse_expression();
              if (r4 !== null) {
                r5 = parse_DEDENT();
                if (r5 !== null) {
                  r0 = [r3, r4, r5];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
            if (r0 !== null) {
              reportedPos = r1;
              r0 = (function(o) { return o; })(r4);
            }
            if (r0 === null) {
              pos = r1;
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_singleLineImplicitObjectLiteral() {
        var cacheKey = "singleLineImplicitObjectLiteral@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = pos;
        r0 = parse_singleLineImplicitObjectLiteralMemberList();
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(members) {
            return rp(new CS.ObjectInitialiser(members));
          })(r0);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_singleLineImplicitObjectLiteralMemberList() {
        var cacheKey = "singleLineImplicitObjectLiteralMemberList@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_implicitObjectLiteralMember();
        if (r3 !== null) {
          r4 = [];
          r6 = pos;
          r7 = parse_singleLineImplicitObjectLiteralMemberSeparator();
          if (r7 !== null) {
            r8 = parse_implicitObjectLiteralMember();
            if (r8 !== null) {
              r5 = [r7, r8];
            } else {
              r5 = null;
              pos = r6;
            }
          } else {
            r5 = null;
            pos = r6;
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = pos;
            r7 = parse_singleLineImplicitObjectLiteralMemberSeparator();
            if (r7 !== null) {
              r8 = parse_implicitObjectLiteralMember();
              if (r8 !== null) {
                r5 = [r7, r8];
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, es) {
                return [e].concat(es.map(function(e){ return e[1]; }));
              })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_singleLineImplicitObjectLiteralMemberSeparator() {
        var cacheKey = "singleLineImplicitObjectLiteralMemberSeparator@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = pos;
        r2 = parse__();
        if (r2 !== null) {
          if (input.charCodeAt(pos) === 44) {
            r3 = ",";
            pos++;
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          if (r3 !== null) {
            r4 = parse__();
            if (r4 !== null) {
              r0 = [r2, r3, r4];
            } else {
              r0 = null;
              pos = r1;
            }
          } else {
            r0 = null;
            pos = r1;
          }
        } else {
          r0 = null;
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_macro() {
        var cacheKey = "macro@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = pos;
        if (input.substr(pos, 8) === "__LINE__") {
          r0 = "__LINE__";
          pos += 8;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("\"__LINE__\"");
          }
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function() { return rp(new CS.Int(line())); })();
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          if (input.substr(pos, 12) === "__FILENAME__") {
            r0 = "__FILENAME__";
            pos += 12;
          } else {
            r0 = null;
            if (reportFailures === 0) {
              matchFailed("\"__FILENAME__\"");
            }
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function() { return rp(new CS.String(options.inputSource || "")); })();
          }
          if (r0 === null) {
            pos = r1;
          }
          if (r0 === null) {
            r1 = pos;
            if (input.substr(pos, 8) === "__DATE__") {
              r0 = "__DATE__";
              pos += 8;
            } else {
              r0 = null;
              if (reportFailures === 0) {
                matchFailed("\"__DATE__\"");
              }
            }
            if (r0 !== null) {
              reportedPos = r1;
              r0 = (function() { return rp(new CS.String((new Date).toDateString().slice(4))); })();
            }
            if (r0 === null) {
              pos = r1;
            }
            if (r0 === null) {
              r1 = pos;
              if (input.substr(pos, 8) === "__TIME__") {
                r0 = "__TIME__";
                pos += 8;
              } else {
                r0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"__TIME__\"");
                }
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = (function() { return rp(new CS.String((new Date).toTimeString().slice(0, 8))); })();
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                if (input.substr(pos, 14) === "__DATETIMEMS__") {
                  r0 = "__DATETIMEMS__";
                  pos += 14;
                } else {
                  r0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"__DATETIMEMS__\"");
                  }
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = (function() { return rp(new CS.Int(+new Date)); })();
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  if (input.substr(pos, 18) === "__COFFEE_VERSION__") {
                    r0 = "__COFFEE_VERSION__";
                    pos += 18;
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"__COFFEE_VERSION__\"");
                    }
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = (function() { return rp(new CS.String(require("../package.json").version)); })();
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_bool() {
        var cacheKey = "bool@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = pos;
        r0 = parse_TRUE();
        if (r0 === null) {
          r0 = parse_YES();
          if (r0 === null) {
            r0 = parse_ON();
          }
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function() { return rp(new CS.Bool(true)); })();
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r0 = parse_FALSE();
          if (r0 === null) {
            r0 = parse_NO();
            if (r0 === null) {
              r0 = parse_OFF();
            }
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function() { return rp(new CS.Bool(false)); })();
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_Numbers() {
        var cacheKey = "Numbers@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 2) === "0b") {
          r3 = "0b";
          pos += 2;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"0b\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          r6 = parse_bit();
          if (r6 !== null) {
            r4 = [];
            while (r6 !== null) {
              r4.push(r6);
              r6 = parse_bit();
            }
          } else {
            r4 = null;
          }
          if (r4 !== null) {
            r4 = input.substring(pos, r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(bs) { return rp(new CS.Int(parseInt(bs, 2))); })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          if (input.substr(pos, 2) === "0o") {
            r3 = "0o";
            pos += 2;
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\"0o\"");
            }
          }
          if (r3 !== null) {
            r5 = pos;
            r6 = parse_octalDigit();
            if (r6 !== null) {
              r4 = [];
              while (r6 !== null) {
                r4.push(r6);
                r6 = parse_octalDigit();
              }
            } else {
              r4 = null;
            }
            if (r4 !== null) {
              r4 = input.substring(pos, r5);
            }
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(os) { return rp(new CS.Int(parseInt(os, 8))); })(r4);
          }
          if (r0 === null) {
            pos = r1;
          }
          if (r0 === null) {
            r1 = pos;
            r2 = pos;
            if (input.substr(pos, 2) === "0x") {
              r3 = "0x";
              pos += 2;
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("\"0x\"");
              }
            }
            if (r3 !== null) {
              r5 = pos;
              r6 = parse_hexDigit();
              if (r6 !== null) {
                r4 = [];
                while (r6 !== null) {
                  r4.push(r6);
                  r6 = parse_hexDigit();
                }
              } else {
                r4 = null;
              }
              if (r4 !== null) {
                r4 = input.substring(pos, r5);
              }
              if (r4 !== null) {
                r0 = [r3, r4];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
            if (r0 !== null) {
              reportedPos = r1;
              r0 = (function(hs) { return rp(new CS.Int(parseInt(hs, 16))); })(r4);
            }
            if (r0 === null) {
              pos = r1;
            }
            if (r0 === null) {
              r1 = pos;
              r2 = pos;
              r3 = parse_decimal();
              if (r3 !== null) {
                if (/^[eE]/.test(input.charAt(pos))) {
                  r4 = input.charAt(pos);
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed("[eE]");
                  }
                }
                if (r4 !== null) {
                  if (/^[+\-]/.test(input.charAt(pos))) {
                    r5 = input.charAt(pos);
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed("[+\\-]");
                    }
                  }
                  r5 = r5 !== null ? r5 : "";
                  if (r5 !== null) {
                    r6 = parse_decimal();
                    if (r6 !== null) {
                      r0 = [r3, r4, r5, r6];
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = (function(base, e, sign, exponent) {
                    return rp(new CS.Float(parseFloat('' + base.data + e + sign + exponent.data, 10)));
                  })(r3, r4, r5, r6);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r0 = parse_decimal();
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_decimal() {
        var cacheKey = "decimal@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_integer();
        if (r3 !== null) {
          r5 = pos;
          r6 = pos;
          if (input.charCodeAt(pos) === 46) {
            r7 = ".";
            pos++;
          } else {
            r7 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (r7 !== null) {
            r9 = parse_decimalDigit();
            if (r9 !== null) {
              r8 = [];
              while (r9 !== null) {
                r8.push(r9);
                r9 = parse_decimalDigit();
              }
            } else {
              r8 = null;
            }
            if (r8 !== null) {
              r4 = [r7, r8];
            } else {
              r4 = null;
              pos = r6;
            }
          } else {
            r4 = null;
            pos = r6;
          }
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r4 = input.substring(pos, r5);
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(integral, fractional) {
              return fractional
                ? rp(new CS.Float(parseFloat(integral + fractional, 10)))
                : rp(new CS.Int(+integral));
            })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_integer() {
        var cacheKey = "integer@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        if (input.charCodeAt(pos) === 48) {
          r0 = "0";
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("\"0\"");
          }
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          if (/^[1-9]/.test(input.charAt(pos))) {
            r3 = input.charAt(pos);
            pos++;
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("[1-9]");
            }
          }
          if (r3 !== null) {
            r4 = [];
            r5 = parse_decimalDigit();
            while (r5 !== null) {
              r4.push(r5);
              r5 = parse_decimalDigit();
            }
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            r0 = input.substring(pos, r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_decimalDigit() {
        var cacheKey = "decimalDigit@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        if (/^[0-9]/.test(input.charAt(pos))) {
          r0 = input.charAt(pos);
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_hexDigit() {
        var cacheKey = "hexDigit@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {
          r0 = input.charAt(pos);
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9a-fA-F]");
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_octalDigit() {
        var cacheKey = "octalDigit@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        if (/^[0-7]/.test(input.charAt(pos))) {
          r0 = input.charAt(pos);
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-7]");
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_bit() {
        var cacheKey = "bit@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        if (/^[01]/.test(input.charAt(pos))) {
          r0 = input.charAt(pos);
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[01]");
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_string() {
        var cacheKey = "string@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 3) === "\"\"\"") {
          r3 = "\"\"\"";
          pos += 3;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\\\"\\\"\"");
          }
        }
        if (r3 !== null) {
          r5 = parse_stringData();
          if (r5 === null) {
            if (input.charCodeAt(pos) === 39) {
              r5 = "'";
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"'\"");
              }
            }
            if (r5 === null) {
              r6 = pos;
              r7 = pos;
              if (input.charCodeAt(pos) === 34) {
                r8 = "\"";
                pos++;
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\"\"");
                }
              }
              if (r8 !== null) {
                if (input.charCodeAt(pos) === 34) {
                  r9 = "\"";
                  pos++;
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\\"\"");
                  }
                }
                r9 = r9 !== null ? r9 : "";
                if (r9 !== null) {
                  r11 = pos;
                  reportFailures++;
                  if (input.charCodeAt(pos) === 34) {
                    r10 = "\"";
                    pos++;
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\"\"");
                    }
                  }
                  reportFailures--;
                  if (r10 === null) {
                    r10 = "";
                  } else {
                    r10 = null;
                    pos = r11;
                  }
                  if (r10 !== null) {
                    r5 = [r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                } else {
                  r5 = null;
                  pos = r7;
                }
              } else {
                r5 = null;
                pos = r7;
              }
              if (r5 !== null) {
                r5 = input.substring(pos, r6);
              }
            }
          }
          if (r5 !== null) {
            r4 = [];
            while (r5 !== null) {
              r4.push(r5);
              r5 = parse_stringData();
              if (r5 === null) {
                if (input.charCodeAt(pos) === 39) {
                  r5 = "'";
                  pos++;
                } else {
                  r5 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"'\"");
                  }
                }
                if (r5 === null) {
                  r6 = pos;
                  r7 = pos;
                  if (input.charCodeAt(pos) === 34) {
                    r8 = "\"";
                    pos++;
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\"\"");
                    }
                  }
                  if (r8 !== null) {
                    if (input.charCodeAt(pos) === 34) {
                      r9 = "\"";
                      pos++;
                    } else {
                      r9 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"\\\"\"");
                      }
                    }
                    r9 = r9 !== null ? r9 : "";
                    if (r9 !== null) {
                      r11 = pos;
                      reportFailures++;
                      if (input.charCodeAt(pos) === 34) {
                        r10 = "\"";
                        pos++;
                      } else {
                        r10 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"\\\"\"");
                        }
                      }
                      reportFailures--;
                      if (r10 === null) {
                        r10 = "";
                      } else {
                        r10 = null;
                        pos = r11;
                      }
                      if (r10 !== null) {
                        r5 = [r8, r9, r10];
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                  if (r5 !== null) {
                    r5 = input.substring(pos, r6);
                  }
                }
              }
            }
          } else {
            r4 = null;
          }
          if (r4 !== null) {
            if (input.substr(pos, 3) === "\"\"\"") {
              r5 = "\"\"\"";
              pos += 3;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\"\\\"\\\"\"");
              }
            }
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(d) {
              return rp(new CS.String(stripLeadingWhitespace(d.join(''))));
            })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          if (input.substr(pos, 3) === "'''") {
            r3 = "'''";
            pos += 3;
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\"'''\"");
            }
          }
          if (r3 !== null) {
            r5 = parse_stringData();
            if (r5 === null) {
              if (input.charCodeAt(pos) === 34) {
                r5 = "\"";
                pos++;
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\"\"");
                }
              }
              if (r5 === null) {
                if (input.charCodeAt(pos) === 35) {
                  r5 = "#";
                  pos++;
                } else {
                  r5 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"#\"");
                  }
                }
                if (r5 === null) {
                  r6 = pos;
                  r7 = pos;
                  if (input.charCodeAt(pos) === 39) {
                    r8 = "'";
                    pos++;
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"'\"");
                    }
                  }
                  if (r8 !== null) {
                    if (input.charCodeAt(pos) === 39) {
                      r9 = "'";
                      pos++;
                    } else {
                      r9 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"'\"");
                      }
                    }
                    r9 = r9 !== null ? r9 : "";
                    if (r9 !== null) {
                      r11 = pos;
                      reportFailures++;
                      if (input.charCodeAt(pos) === 39) {
                        r10 = "'";
                        pos++;
                      } else {
                        r10 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"'\"");
                        }
                      }
                      reportFailures--;
                      if (r10 === null) {
                        r10 = "";
                      } else {
                        r10 = null;
                        pos = r11;
                      }
                      if (r10 !== null) {
                        r5 = [r8, r9, r10];
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                  if (r5 !== null) {
                    r5 = input.substring(pos, r6);
                  }
                }
              }
            }
            if (r5 !== null) {
              r4 = [];
              while (r5 !== null) {
                r4.push(r5);
                r5 = parse_stringData();
                if (r5 === null) {
                  if (input.charCodeAt(pos) === 34) {
                    r5 = "\"";
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\"\"");
                    }
                  }
                  if (r5 === null) {
                    if (input.charCodeAt(pos) === 35) {
                      r5 = "#";
                      pos++;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"#\"");
                      }
                    }
                    if (r5 === null) {
                      r6 = pos;
                      r7 = pos;
                      if (input.charCodeAt(pos) === 39) {
                        r8 = "'";
                        pos++;
                      } else {
                        r8 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"'\"");
                        }
                      }
                      if (r8 !== null) {
                        if (input.charCodeAt(pos) === 39) {
                          r9 = "'";
                          pos++;
                        } else {
                          r9 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"'\"");
                          }
                        }
                        r9 = r9 !== null ? r9 : "";
                        if (r9 !== null) {
                          r11 = pos;
                          reportFailures++;
                          if (input.charCodeAt(pos) === 39) {
                            r10 = "'";
                            pos++;
                          } else {
                            r10 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"'\"");
                            }
                          }
                          reportFailures--;
                          if (r10 === null) {
                            r10 = "";
                          } else {
                            r10 = null;
                            pos = r11;
                          }
                          if (r10 !== null) {
                            r5 = [r8, r9, r10];
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                      if (r5 !== null) {
                        r5 = input.substring(pos, r6);
                      }
                    }
                  }
                }
              }
            } else {
              r4 = null;
            }
            if (r4 !== null) {
              if (input.substr(pos, 3) === "'''") {
                r5 = "'''";
                pos += 3;
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("\"'''\"");
                }
              }
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(d) {
                return rp(new CS.String(stripLeadingWhitespace(d.join(''))));
              })(r4);
          }
          if (r0 === null) {
            pos = r1;
          }
          if (r0 === null) {
            r1 = pos;
            r2 = pos;
            if (input.charCodeAt(pos) === 34) {
              r3 = "\"";
              pos++;
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\"\"");
              }
            }
            if (r3 !== null) {
              r4 = [];
              r5 = parse_stringData();
              if (r5 === null) {
                if (input.charCodeAt(pos) === 39) {
                  r5 = "'";
                  pos++;
                } else {
                  r5 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"'\"");
                  }
                }
              }
              while (r5 !== null) {
                r4.push(r5);
                r5 = parse_stringData();
                if (r5 === null) {
                  if (input.charCodeAt(pos) === 39) {
                    r5 = "'";
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"'\"");
                    }
                  }
                }
              }
              if (r4 !== null) {
                if (input.charCodeAt(pos) === 34) {
                  r5 = "\"";
                  pos++;
                } else {
                  r5 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\\"\"");
                  }
                }
                if (r5 !== null) {
                  r0 = [r3, r4, r5];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
            if (r0 !== null) {
              reportedPos = r1;
              r0 = (function(d) { return rp(new CS.String(d.join(''))); })(r4);
            }
            if (r0 === null) {
              pos = r1;
            }
            if (r0 === null) {
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 39) {
                r3 = "'";
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"'\"");
                }
              }
              if (r3 !== null) {
                r4 = [];
                r5 = parse_stringData();
                if (r5 === null) {
                  if (input.charCodeAt(pos) === 34) {
                    r5 = "\"";
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\"\"");
                    }
                  }
                  if (r5 === null) {
                    if (input.charCodeAt(pos) === 35) {
                      r5 = "#";
                      pos++;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"#\"");
                      }
                    }
                  }
                }
                while (r5 !== null) {
                  r4.push(r5);
                  r5 = parse_stringData();
                  if (r5 === null) {
                    if (input.charCodeAt(pos) === 34) {
                      r5 = "\"";
                      pos++;
                    } else {
                      r5 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"\\\"\"");
                      }
                    }
                    if (r5 === null) {
                      if (input.charCodeAt(pos) === 35) {
                        r5 = "#";
                        pos++;
                      } else {
                        r5 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"#\"");
                        }
                      }
                    }
                  }
                }
                if (r4 !== null) {
                  if (input.charCodeAt(pos) === 39) {
                    r5 = "'";
                    pos++;
                  } else {
                    r5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"'\"");
                    }
                  }
                  if (r5 !== null) {
                    r0 = [r3, r4, r5];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = (function(d) { return rp(new CS.String(d.join(''))); })(r4);
              }
              if (r0 === null) {
                pos = r1;
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_stringData() {
        var cacheKey = "stringData@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        if (/^[^"'\\#]/.test(input.charAt(pos))) {
          r0 = input.charAt(pos);
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[^\"'\\\\#]");
          }
        }
        if (r0 === null) {
          r0 = parse_UnicodeEscapeSequence();
          if (r0 === null) {
            r1 = pos;
            r2 = pos;
            if (input.substr(pos, 2) === "\\x") {
              r3 = "\\x";
              pos += 2;
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\\x\"");
              }
            }
            if (r3 !== null) {
              r5 = pos;
              r6 = pos;
              r7 = parse_hexDigit();
              if (r7 !== null) {
                r8 = parse_hexDigit();
                if (r8 !== null) {
                  r4 = [r7, r8];
                } else {
                  r4 = null;
                  pos = r6;
                }
              } else {
                r4 = null;
                pos = r6;
              }
              if (r4 !== null) {
                r4 = input.substring(pos, r5);
              }
              if (r4 !== null) {
                r0 = [r3, r4];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
            if (r0 !== null) {
              reportedPos = r1;
              r0 = (function(h) { return String.fromCharCode(parseInt(h, 16)); })(r4);
            }
            if (r0 === null) {
              pos = r1;
            }
            if (r0 === null) {
              r1 = pos;
              r2 = pos;
              if (input.substr(pos, 2) === "\\0") {
                r3 = "\\0";
                pos += 2;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\\0\"");
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                r4 = parse_decimalDigit();
                reportFailures--;
                if (r4 === null) {
                  r4 = "";
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [r3, r4];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = (function() { return '\0'; })();
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (input.substr(pos, 2) === "\\0") {
                  r3 = "\\0";
                  pos += 2;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\\\0\"");
                  }
                }
                if (r3 !== null) {
                  r5 = pos;
                  reportFailures++;
                  r4 = parse_decimalDigit();
                  reportFailures--;
                  if (r4 !== null) {
                    r4 = "";
                    pos = r5;
                  } else {
                    r4 = null;
                  }
                  if (r4 !== null) {
                    r0 = [r3, r4];
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = (function() { throw new SyntaxError(['string data'], 'octal escape sequence', offset(), line(), column()); })();
                }
                if (r0 === null) {
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  if (input.substr(pos, 2) === "\\b") {
                    r0 = "\\b";
                    pos += 2;
                  } else {
                    r0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\\b\"");
                    }
                  }
                  if (r0 !== null) {
                    reportedPos = r1;
                    r0 = (function() { return '\b'; })();
                  }
                  if (r0 === null) {
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    if (input.substr(pos, 2) === "\\t") {
                      r0 = "\\t";
                      pos += 2;
                    } else {
                      r0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"\\\\t\"");
                      }
                    }
                    if (r0 !== null) {
                      reportedPos = r1;
                      r0 = (function() { return '\t'; })();
                    }
                    if (r0 === null) {
                      pos = r1;
                    }
                    if (r0 === null) {
                      r1 = pos;
                      if (input.substr(pos, 2) === "\\n") {
                        r0 = "\\n";
                        pos += 2;
                      } else {
                        r0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"\\\\n\"");
                        }
                      }
                      if (r0 !== null) {
                        reportedPos = r1;
                        r0 = (function() { return '\n'; })();
                      }
                      if (r0 === null) {
                        pos = r1;
                      }
                      if (r0 === null) {
                        r1 = pos;
                        if (input.substr(pos, 2) === "\\v") {
                          r0 = "\\v";
                          pos += 2;
                        } else {
                          r0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"\\\\v\"");
                          }
                        }
                        if (r0 !== null) {
                          reportedPos = r1;
                          r0 = (function() { return '\v'; })();
                        }
                        if (r0 === null) {
                          pos = r1;
                        }
                        if (r0 === null) {
                          r1 = pos;
                          if (input.substr(pos, 2) === "\\f") {
                            r0 = "\\f";
                            pos += 2;
                          } else {
                            r0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"\\\\f\"");
                            }
                          }
                          if (r0 !== null) {
                            reportedPos = r1;
                            r0 = (function() { return '\f'; })();
                          }
                          if (r0 === null) {
                            pos = r1;
                          }
                          if (r0 === null) {
                            r1 = pos;
                            if (input.substr(pos, 2) === "\\r") {
                              r0 = "\\r";
                              pos += 2;
                            } else {
                              r0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"\\\\r\"");
                              }
                            }
                            if (r0 !== null) {
                              reportedPos = r1;
                              r0 = (function() { return '\r'; })();
                            }
                            if (r0 === null) {
                              pos = r1;
                            }
                            if (r0 === null) {
                              r1 = pos;
                              r2 = pos;
                              if (input.charCodeAt(pos) === 92) {
                                r3 = "\\";
                                pos++;
                              } else {
                                r3 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"\\\\\"");
                                }
                              }
                              if (r3 !== null) {
                                if (input.length > pos) {
                                  r4 = input.charAt(pos);
                                  pos++;
                                } else {
                                  r4 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("any character");
                                  }
                                }
                                if (r4 !== null) {
                                  r0 = [r3, r4];
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                              } else {
                                r0 = null;
                                pos = r2;
                              }
                              if (r0 !== null) {
                                reportedPos = r1;
                                r0 = (function(c) { return c; })(r4);
                              }
                              if (r0 === null) {
                                pos = r1;
                              }
                              if (r0 === null) {
                                r1 = pos;
                                r2 = pos;
                                if (input.charCodeAt(pos) === 35) {
                                  r3 = "#";
                                  pos++;
                                } else {
                                  r3 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"#\"");
                                  }
                                }
                                if (r3 !== null) {
                                  r5 = pos;
                                  reportFailures++;
                                  if (input.charCodeAt(pos) === 123) {
                                    r4 = "{";
                                    pos++;
                                  } else {
                                    r4 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"{\"");
                                    }
                                  }
                                  reportFailures--;
                                  if (r4 === null) {
                                    r4 = "";
                                  } else {
                                    r4 = null;
                                    pos = r5;
                                  }
                                  if (r4 !== null) {
                                    r0 = [r3, r4];
                                  } else {
                                    r0 = null;
                                    pos = r2;
                                  }
                                } else {
                                  r0 = null;
                                  pos = r2;
                                }
                                if (r0 !== null) {
                                  reportedPos = r1;
                                  r0 = (function(c) { return c; })(r3);
                                }
                                if (r0 === null) {
                                  pos = r1;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_interpolation() {
        var cacheKey = "interpolation@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 3) === "\"\"\"") {
          r3 = "\"\"\"";
          pos += 3;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\\\"\\\"\"");
          }
        }
        if (r3 !== null) {
          r6 = pos;
          r7 = parse_stringData();
          if (r7 === null) {
            if (input.charCodeAt(pos) === 39) {
              r7 = "'";
              pos++;
            } else {
              r7 = null;
              if (reportFailures === 0) {
                matchFailed("\"'\"");
              }
            }
            if (r7 === null) {
              r8 = pos;
              r9 = pos;
              if (input.charCodeAt(pos) === 34) {
                r10 = "\"";
                pos++;
              } else {
                r10 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\"\"");
                }
              }
              if (r10 !== null) {
                if (input.charCodeAt(pos) === 34) {
                  r11 = "\"";
                  pos++;
                } else {
                  r11 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\\"\"");
                  }
                }
                r11 = r11 !== null ? r11 : "";
                if (r11 !== null) {
                  r13 = pos;
                  reportFailures++;
                  if (input.charCodeAt(pos) === 34) {
                    r12 = "\"";
                    pos++;
                  } else {
                    r12 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\"\"");
                    }
                  }
                  reportFailures--;
                  if (r12 === null) {
                    r12 = "";
                  } else {
                    r12 = null;
                    pos = r13;
                  }
                  if (r12 !== null) {
                    r7 = [r10, r11, r12];
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                } else {
                  r7 = null;
                  pos = r9;
                }
              } else {
                r7 = null;
                pos = r9;
              }
              if (r7 !== null) {
                r7 = input.substring(pos, r8);
              }
            }
          }
          if (r7 !== null) {
            r5 = [];
            while (r7 !== null) {
              r5.push(r7);
              r7 = parse_stringData();
              if (r7 === null) {
                if (input.charCodeAt(pos) === 39) {
                  r7 = "'";
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"'\"");
                  }
                }
                if (r7 === null) {
                  r8 = pos;
                  r9 = pos;
                  if (input.charCodeAt(pos) === 34) {
                    r10 = "\"";
                    pos++;
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\"\"");
                    }
                  }
                  if (r10 !== null) {
                    if (input.charCodeAt(pos) === 34) {
                      r11 = "\"";
                      pos++;
                    } else {
                      r11 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"\\\"\"");
                      }
                    }
                    r11 = r11 !== null ? r11 : "";
                    if (r11 !== null) {
                      r13 = pos;
                      reportFailures++;
                      if (input.charCodeAt(pos) === 34) {
                        r12 = "\"";
                        pos++;
                      } else {
                        r12 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"\\\"\"");
                        }
                      }
                      reportFailures--;
                      if (r12 === null) {
                        r12 = "";
                      } else {
                        r12 = null;
                        pos = r13;
                      }
                      if (r12 !== null) {
                        r7 = [r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                  if (r7 !== null) {
                    r7 = input.substring(pos, r8);
                  }
                }
              }
            }
          } else {
            r5 = null;
          }
          if (r5 !== null) {
            reportedPos = r6;
            r5 = (function(d) { return rp(new CS.String(d.join(''))); })(r5);
          }
          if (r5 === null) {
            pos = r6;
          }
          if (r5 === null) {
            r6 = pos;
            r7 = pos;
            if (input.substr(pos, 2) === "#{") {
              r8 = "#{";
              pos += 2;
            } else {
              r8 = null;
              if (reportFailures === 0) {
                matchFailed("\"#{\"");
              }
            }
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_expression();
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    if (input.charCodeAt(pos) === 125) {
                      r12 = "}";
                      pos++;
                    } else {
                      r12 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"}\"");
                      }
                    }
                    if (r12 !== null) {
                      r5 = [r8, r9, r10, r11, r12];
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                } else {
                  r5 = null;
                  pos = r7;
                }
              } else {
                r5 = null;
                pos = r7;
              }
            } else {
              r5 = null;
              pos = r7;
            }
            if (r5 !== null) {
              reportedPos = r6;
              r5 = (function(e) { return e; })(r10);
            }
            if (r5 === null) {
              pos = r6;
            }
          }
          if (r5 !== null) {
            r4 = [];
            while (r5 !== null) {
              r4.push(r5);
              r6 = pos;
              r7 = parse_stringData();
              if (r7 === null) {
                if (input.charCodeAt(pos) === 39) {
                  r7 = "'";
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"'\"");
                  }
                }
                if (r7 === null) {
                  r8 = pos;
                  r9 = pos;
                  if (input.charCodeAt(pos) === 34) {
                    r10 = "\"";
                    pos++;
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\\"\"");
                    }
                  }
                  if (r10 !== null) {
                    if (input.charCodeAt(pos) === 34) {
                      r11 = "\"";
                      pos++;
                    } else {
                      r11 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"\\\"\"");
                      }
                    }
                    r11 = r11 !== null ? r11 : "";
                    if (r11 !== null) {
                      r13 = pos;
                      reportFailures++;
                      if (input.charCodeAt(pos) === 34) {
                        r12 = "\"";
                        pos++;
                      } else {
                        r12 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"\\\"\"");
                        }
                      }
                      reportFailures--;
                      if (r12 === null) {
                        r12 = "";
                      } else {
                        r12 = null;
                        pos = r13;
                      }
                      if (r12 !== null) {
                        r7 = [r10, r11, r12];
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                    } else {
                      r7 = null;
                      pos = r9;
                    }
                  } else {
                    r7 = null;
                    pos = r9;
                  }
                  if (r7 !== null) {
                    r7 = input.substring(pos, r8);
                  }
                }
              }
              if (r7 !== null) {
                r5 = [];
                while (r7 !== null) {
                  r5.push(r7);
                  r7 = parse_stringData();
                  if (r7 === null) {
                    if (input.charCodeAt(pos) === 39) {
                      r7 = "'";
                      pos++;
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"'\"");
                      }
                    }
                    if (r7 === null) {
                      r8 = pos;
                      r9 = pos;
                      if (input.charCodeAt(pos) === 34) {
                        r10 = "\"";
                        pos++;
                      } else {
                        r10 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"\\\"\"");
                        }
                      }
                      if (r10 !== null) {
                        if (input.charCodeAt(pos) === 34) {
                          r11 = "\"";
                          pos++;
                        } else {
                          r11 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"\\\"\"");
                          }
                        }
                        r11 = r11 !== null ? r11 : "";
                        if (r11 !== null) {
                          r13 = pos;
                          reportFailures++;
                          if (input.charCodeAt(pos) === 34) {
                            r12 = "\"";
                            pos++;
                          } else {
                            r12 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"\\\"\"");
                            }
                          }
                          reportFailures--;
                          if (r12 === null) {
                            r12 = "";
                          } else {
                            r12 = null;
                            pos = r13;
                          }
                          if (r12 !== null) {
                            r7 = [r10, r11, r12];
                          } else {
                            r7 = null;
                            pos = r9;
                          }
                        } else {
                          r7 = null;
                          pos = r9;
                        }
                      } else {
                        r7 = null;
                        pos = r9;
                      }
                      if (r7 !== null) {
                        r7 = input.substring(pos, r8);
                      }
                    }
                  }
                }
              } else {
                r5 = null;
              }
              if (r5 !== null) {
                reportedPos = r6;
                r5 = (function(d) { return rp(new CS.String(d.join(''))); })(r5);
              }
              if (r5 === null) {
                pos = r6;
              }
              if (r5 === null) {
                r6 = pos;
                r7 = pos;
                if (input.substr(pos, 2) === "#{") {
                  r8 = "#{";
                  pos += 2;
                } else {
                  r8 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"#{\"");
                  }
                }
                if (r8 !== null) {
                  r9 = parse__();
                  if (r9 !== null) {
                    r10 = parse_expression();
                    if (r10 !== null) {
                      r11 = parse__();
                      if (r11 !== null) {
                        if (input.charCodeAt(pos) === 125) {
                          r12 = "}";
                          pos++;
                        } else {
                          r12 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"}\"");
                          }
                        }
                        if (r12 !== null) {
                          r5 = [r8, r9, r10, r11, r12];
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                } else {
                  r5 = null;
                  pos = r7;
                }
                if (r5 !== null) {
                  reportedPos = r6;
                  r5 = (function(e) { return e; })(r10);
                }
                if (r5 === null) {
                  pos = r6;
                }
              }
            }
          } else {
            r4 = null;
          }
          if (r4 !== null) {
            if (input.substr(pos, 3) === "\"\"\"") {
              r5 = "\"\"\"";
              pos += 3;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\"\\\"\\\"\"");
              }
            }
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(es) {
              return rp(createInterpolation(stripLeadingWhitespaceInterpolation(es)));
            })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          if (input.charCodeAt(pos) === 34) {
            r3 = "\"";
            pos++;
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\"\"");
            }
          }
          if (r3 !== null) {
            r6 = pos;
            r7 = parse_stringData();
            if (r7 === null) {
              if (input.charCodeAt(pos) === 39) {
                r7 = "'";
                pos++;
              } else {
                r7 = null;
                if (reportFailures === 0) {
                  matchFailed("\"'\"");
                }
              }
            }
            if (r7 !== null) {
              r5 = [];
              while (r7 !== null) {
                r5.push(r7);
                r7 = parse_stringData();
                if (r7 === null) {
                  if (input.charCodeAt(pos) === 39) {
                    r7 = "'";
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"'\"");
                    }
                  }
                }
              }
            } else {
              r5 = null;
            }
            if (r5 !== null) {
              reportedPos = r6;
              r5 = (function(d) { return rp(new CS.String(d.join(''))); })(r5);
            }
            if (r5 === null) {
              pos = r6;
            }
            if (r5 === null) {
              r6 = pos;
              r7 = pos;
              if (input.substr(pos, 2) === "#{") {
                r8 = "#{";
                pos += 2;
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\"#{\"");
                }
              }
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_expression();
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      if (input.charCodeAt(pos) === 125) {
                        r12 = "}";
                        pos++;
                      } else {
                        r12 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"}\"");
                        }
                      }
                      if (r12 !== null) {
                        r5 = [r8, r9, r10, r11, r12];
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                } else {
                  r5 = null;
                  pos = r7;
                }
              } else {
                r5 = null;
                pos = r7;
              }
              if (r5 !== null) {
                reportedPos = r6;
                r5 = (function(e) { return e; })(r10);
              }
              if (r5 === null) {
                pos = r6;
              }
            }
            if (r5 !== null) {
              r4 = [];
              while (r5 !== null) {
                r4.push(r5);
                r6 = pos;
                r7 = parse_stringData();
                if (r7 === null) {
                  if (input.charCodeAt(pos) === 39) {
                    r7 = "'";
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"'\"");
                    }
                  }
                }
                if (r7 !== null) {
                  r5 = [];
                  while (r7 !== null) {
                    r5.push(r7);
                    r7 = parse_stringData();
                    if (r7 === null) {
                      if (input.charCodeAt(pos) === 39) {
                        r7 = "'";
                        pos++;
                      } else {
                        r7 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"'\"");
                        }
                      }
                    }
                  }
                } else {
                  r5 = null;
                }
                if (r5 !== null) {
                  reportedPos = r6;
                  r5 = (function(d) { return rp(new CS.String(d.join(''))); })(r5);
                }
                if (r5 === null) {
                  pos = r6;
                }
                if (r5 === null) {
                  r6 = pos;
                  r7 = pos;
                  if (input.substr(pos, 2) === "#{") {
                    r8 = "#{";
                    pos += 2;
                  } else {
                    r8 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"#{\"");
                    }
                  }
                  if (r8 !== null) {
                    r9 = parse__();
                    if (r9 !== null) {
                      r10 = parse_expression();
                      if (r10 !== null) {
                        r11 = parse__();
                        if (r11 !== null) {
                          if (input.charCodeAt(pos) === 125) {
                            r12 = "}";
                            pos++;
                          } else {
                            r12 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"}\"");
                            }
                          }
                          if (r12 !== null) {
                            r5 = [r8, r9, r10, r11, r12];
                          } else {
                            r5 = null;
                            pos = r7;
                          }
                        } else {
                          r5 = null;
                          pos = r7;
                        }
                      } else {
                        r5 = null;
                        pos = r7;
                      }
                    } else {
                      r5 = null;
                      pos = r7;
                    }
                  } else {
                    r5 = null;
                    pos = r7;
                  }
                  if (r5 !== null) {
                    reportedPos = r6;
                    r5 = (function(e) { return e; })(r10);
                  }
                  if (r5 === null) {
                    pos = r6;
                  }
                }
              }
            } else {
              r4 = null;
            }
            if (r4 !== null) {
              if (input.charCodeAt(pos) === 34) {
                r5 = "\"";
                pos++;
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\\"\"");
                }
              }
              if (r5 !== null) {
                r0 = [r3, r4, r5];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(es) {
                return rp(createInterpolation(es));
              })(r4);
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_regexp() {
        var cacheKey = "regexp@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 3) === "///") {
          r3 = "///";
          pos += 3;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"///\"");
          }
        }
        if (r3 !== null) {
          r6 = pos;
          if (/^[ \r\n]/.test(input.charAt(pos))) {
            r7 = input.charAt(pos);
            pos++;
          } else {
            r7 = null;
            if (reportFailures === 0) {
              matchFailed("[ \\r\\n]");
            }
          }
          if (r7 !== null) {
            r5 = [];
            while (r7 !== null) {
              r5.push(r7);
              if (/^[ \r\n]/.test(input.charAt(pos))) {
                r7 = input.charAt(pos);
                pos++;
              } else {
                r7 = null;
                if (reportFailures === 0) {
                  matchFailed("[ \\r\\n]");
                }
              }
            }
          } else {
            r5 = null;
          }
          if (r5 !== null) {
            reportedPos = r6;
            r5 = (function() { return [rp(new CS.String('').g())]; })();
          }
          if (r5 === null) {
            pos = r6;
          }
          if (r5 === null) {
            r6 = pos;
            if (/^[^\\\/#[ \r\n]/.test(input.charAt(pos))) {
              r7 = input.charAt(pos);
              pos++;
            } else {
              r7 = null;
              if (reportFailures === 0) {
                matchFailed("[^\\\\\\/#[ \\r\\n]");
              }
            }
            if (r7 !== null) {
              r5 = [];
              while (r7 !== null) {
                r5.push(r7);
                if (/^[^\\\/#[ \r\n]/.test(input.charAt(pos))) {
                  r7 = input.charAt(pos);
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("[^\\\\\\/#[ \\r\\n]");
                  }
                }
              }
            } else {
              r5 = null;
            }
            if (r5 !== null) {
              reportedPos = r6;
              r5 = (function(s) { return [rp(new CS.String(s.join('')).g())]; })(r5);
            }
            if (r5 === null) {
              pos = r6;
            }
            if (r5 === null) {
              r5 = parse_hereregexpData();
            }
          }
          if (r5 !== null) {
            r4 = [];
            while (r5 !== null) {
              r4.push(r5);
              r6 = pos;
              if (/^[ \r\n]/.test(input.charAt(pos))) {
                r7 = input.charAt(pos);
                pos++;
              } else {
                r7 = null;
                if (reportFailures === 0) {
                  matchFailed("[ \\r\\n]");
                }
              }
              if (r7 !== null) {
                r5 = [];
                while (r7 !== null) {
                  r5.push(r7);
                  if (/^[ \r\n]/.test(input.charAt(pos))) {
                    r7 = input.charAt(pos);
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed("[ \\r\\n]");
                    }
                  }
                }
              } else {
                r5 = null;
              }
              if (r5 !== null) {
                reportedPos = r6;
                r5 = (function() { return [rp(new CS.String('').g())]; })();
              }
              if (r5 === null) {
                pos = r6;
              }
              if (r5 === null) {
                r6 = pos;
                if (/^[^\\\/#[ \r\n]/.test(input.charAt(pos))) {
                  r7 = input.charAt(pos);
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("[^\\\\\\/#[ \\r\\n]");
                  }
                }
                if (r7 !== null) {
                  r5 = [];
                  while (r7 !== null) {
                    r5.push(r7);
                    if (/^[^\\\/#[ \r\n]/.test(input.charAt(pos))) {
                      r7 = input.charAt(pos);
                      pos++;
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed("[^\\\\\\/#[ \\r\\n]");
                      }
                    }
                  }
                } else {
                  r5 = null;
                }
                if (r5 !== null) {
                  reportedPos = r6;
                  r5 = (function(s) { return [rp(new CS.String(s.join('')).g())]; })(r5);
                }
                if (r5 === null) {
                  pos = r6;
                }
                if (r5 === null) {
                  r5 = parse_hereregexpData();
                }
              }
            }
          } else {
            r4 = null;
          }
          if (r4 !== null) {
            if (input.substr(pos, 3) === "///") {
              r5 = "///";
              pos += 3;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"///\"");
              }
            }
            if (r5 !== null) {
              r6 = [];
              if (/^[gimy]/.test(input.charAt(pos))) {
                r7 = input.charAt(pos);
                pos++;
              } else {
                r7 = null;
                if (reportFailures === 0) {
                  matchFailed("[gimy]");
                }
              }
              while (r7 !== null) {
                r6.push(r7);
                if (/^[gimy]/.test(input.charAt(pos))) {
                  r7 = input.charAt(pos);
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("[gimy]");
                  }
                }
              }
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(es, flags) {
              if(!isValidRegExpFlags(flags))
                throw new SyntaxError(['regular expression flags'], 'regular expression flags', offset(), line(), column());
              if(!flags) flags = [];
              var interp = createInterpolation(foldl(function(memo, e){ return memo.concat(e); }, [], es));
              if(interp instanceof CS.String) return p(new CS.RegExp(interp.data, flags));
              return rp(new CS.HeregExp(interp, flags));
            })(r4, r6);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          if (input.charCodeAt(pos) === 47) {
            r3 = "/";
            pos++;
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (r3 !== null) {
            r4 = [];
            r5 = parse_regexpData();
            if (r5 === null) {
              r6 = pos;
              if (/^[^\/\\[\n]/.test(input.charAt(pos))) {
                r7 = input.charAt(pos);
                pos++;
              } else {
                r7 = null;
                if (reportFailures === 0) {
                  matchFailed("[^\\/\\\\[\\n]");
                }
              }
              if (r7 !== null) {
                r5 = [];
                while (r7 !== null) {
                  r5.push(r7);
                  if (/^[^\/\\[\n]/.test(input.charAt(pos))) {
                    r7 = input.charAt(pos);
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed("[^\\/\\\\[\\n]");
                    }
                  }
                }
              } else {
                r5 = null;
              }
              if (r5 !== null) {
                reportedPos = r6;
                r5 = (function(d) { return d.join(''); })(r5);
              }
              if (r5 === null) {
                pos = r6;
              }
            }
            while (r5 !== null) {
              r4.push(r5);
              r5 = parse_regexpData();
              if (r5 === null) {
                r6 = pos;
                if (/^[^\/\\[\n]/.test(input.charAt(pos))) {
                  r7 = input.charAt(pos);
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("[^\\/\\\\[\\n]");
                  }
                }
                if (r7 !== null) {
                  r5 = [];
                  while (r7 !== null) {
                    r5.push(r7);
                    if (/^[^\/\\[\n]/.test(input.charAt(pos))) {
                      r7 = input.charAt(pos);
                      pos++;
                    } else {
                      r7 = null;
                      if (reportFailures === 0) {
                        matchFailed("[^\\/\\\\[\\n]");
                      }
                    }
                  }
                } else {
                  r5 = null;
                }
                if (r5 !== null) {
                  reportedPos = r6;
                  r5 = (function(d) { return d.join(''); })(r5);
                }
                if (r5 === null) {
                  pos = r6;
                }
              }
            }
            if (r4 !== null) {
              if (input.charCodeAt(pos) === 47) {
                r5 = "/";
                pos++;
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("\"/\"");
                }
              }
              if (r5 !== null) {
                r6 = [];
                if (/^[gimy]/.test(input.charAt(pos))) {
                  r7 = input.charAt(pos);
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("[gimy]");
                  }
                }
                while (r7 !== null) {
                  r6.push(r7);
                  if (/^[gimy]/.test(input.charAt(pos))) {
                    r7 = input.charAt(pos);
                    pos++;
                  } else {
                    r7 = null;
                    if (reportFailures === 0) {
                      matchFailed("[gimy]");
                    }
                  }
                }
                if (r6 !== null) {
                  r0 = [r3, r4, r5, r6];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(d, flags) {
                if(!isValidRegExpFlags(flags))
                  throw new SyntaxError(['regular expression flags'], 'regular expression flags', offset(), line(), column());
                return rp(new CS.RegExp(d.join(''), flags));
              })(r4, r6);
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_regexpData() {
        var cacheKey = "regexpData@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.charCodeAt(pos) === 91) {
          r3 = "[";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (r3 !== null) {
          r4 = [];
          if (/^[^\\\]\n]/.test(input.charAt(pos))) {
            r5 = input.charAt(pos);
            pos++;
          } else {
            r5 = null;
            if (reportFailures === 0) {
              matchFailed("[^\\\\\\]\\n]");
            }
          }
          if (r5 === null) {
            r5 = parse_regexpData();
          }
          while (r5 !== null) {
            r4.push(r5);
            if (/^[^\\\]\n]/.test(input.charAt(pos))) {
              r5 = input.charAt(pos);
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("[^\\\\\\]\\n]");
              }
            }
            if (r5 === null) {
              r5 = parse_regexpData();
            }
          }
          if (r4 !== null) {
            if (input.charCodeAt(pos) === 93) {
              r5 = "]";
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"]\"");
              }
            }
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(d) { return '[' + d.join('') + ']'; })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          if (input.charCodeAt(pos) === 92) {
            r3 = "\\";
            pos++;
          } else {
            r3 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\\\"");
            }
          }
          if (r3 !== null) {
            if (input.length > pos) {
              r4 = input.charAt(pos);
              pos++;
            } else {
              r4 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            r0 = input.substring(pos, r1);
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_hereregexpData() {
        var cacheKey = "hereregexpData@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = pos;
        r2 = pos;
        if (input.charCodeAt(pos) === 91) {
          r3 = "[";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (r3 !== null) {
          r4 = [];
          r6 = pos;
          r5 = parse_hereregexpData();
          if (r5 !== null) {
            reportedPos = r6;
            r5 = (function(h) { return h[0]; })(r5);
          }
          if (r5 === null) {
            pos = r6;
          }
          if (r5 === null) {
            r6 = pos;
            if (/^[^\\\/\]]/.test(input.charAt(pos))) {
              r5 = input.charAt(pos);
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("[^\\\\\\/\\]]");
              }
            }
            if (r5 !== null) {
              reportedPos = r6;
              r5 = (function(s) { return p(new CS.String(s)); })(r5);
            }
            if (r5 === null) {
              pos = r6;
            }
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = pos;
            r5 = parse_hereregexpData();
            if (r5 !== null) {
              reportedPos = r6;
              r5 = (function(h) { return h[0]; })(r5);
            }
            if (r5 === null) {
              pos = r6;
            }
            if (r5 === null) {
              r6 = pos;
              if (/^[^\\\/\]]/.test(input.charAt(pos))) {
                r5 = input.charAt(pos);
                pos++;
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("[^\\\\\\/\\]]");
                }
              }
              if (r5 !== null) {
                reportedPos = r6;
                r5 = (function(s) { return p(new CS.String(s)); })(r5);
              }
              if (r5 === null) {
                pos = r6;
              }
            }
          }
          if (r4 !== null) {
            if (input.charCodeAt(pos) === 93) {
              r5 = "]";
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\"]\"");
              }
            }
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(d) {
                return [p(new CS.String("["))].concat(d || []).concat([p(new CS.String("]"))]);
              })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = pos;
          if (input.charCodeAt(pos) === 92) {
            r4 = "\\";
            pos++;
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\\\\"");
            }
          }
          if (r4 !== null) {
            if (input.length > pos) {
              r5 = input.charAt(pos);
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            if (r5 !== null) {
              r0 = [r4, r5];
            } else {
              r0 = null;
              pos = r3;
            }
          } else {
            r0 = null;
            pos = r3;
          }
          if (r0 !== null) {
            r0 = input.substring(pos, r2);
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(d) { return [rp(new CS.String(d))]; })(r0);
          }
          if (r0 === null) {
            pos = r1;
          }
          if (r0 === null) {
            r1 = pos;
            r2 = pos;
            r3 = pos;
            if (input.charCodeAt(pos) === 47) {
              r4 = "/";
              pos++;
            } else {
              r4 = null;
              if (reportFailures === 0) {
                matchFailed("\"/\"");
              }
            }
            if (r4 !== null) {
              if (input.charCodeAt(pos) === 47) {
                r5 = "/";
                pos++;
              } else {
                r5 = null;
                if (reportFailures === 0) {
                  matchFailed("\"/\"");
                }
              }
              r5 = r5 !== null ? r5 : "";
              if (r5 !== null) {
                r7 = pos;
                reportFailures++;
                if (input.charCodeAt(pos) === 47) {
                  r6 = "/";
                  pos++;
                } else {
                  r6 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"/\"");
                  }
                }
                reportFailures--;
                if (r6 === null) {
                  r6 = "";
                } else {
                  r6 = null;
                  pos = r7;
                }
                if (r6 !== null) {
                  r0 = [r4, r5, r6];
                } else {
                  r0 = null;
                  pos = r3;
                }
              } else {
                r0 = null;
                pos = r3;
              }
            } else {
              r0 = null;
              pos = r3;
            }
            if (r0 !== null) {
              r0 = input.substring(pos, r2);
            }
            if (r0 !== null) {
              reportedPos = r1;
              r0 = (function(s) { return [rp(new CS.String(s))]; })(r0);
            }
            if (r0 === null) {
              pos = r1;
            }
            if (r0 === null) {
              r1 = pos;
              r2 = pos;
              if (input.charCodeAt(pos) === 35) {
                r3 = "#";
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"#\"");
                }
              }
              if (r3 !== null) {
                r5 = pos;
                reportFailures++;
                if (input.charCodeAt(pos) === 123) {
                  r4 = "{";
                  pos++;
                } else {
                  r4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"{\"");
                  }
                }
                reportFailures--;
                if (r4 === null) {
                  r4 = "";
                } else {
                  r4 = null;
                  pos = r5;
                }
                if (r4 !== null) {
                  r0 = [r3, r4];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
              if (r0 !== null) {
                reportedPos = r1;
                r0 = (function(c) { return [rp(new CS.String(c))]; })(r3);
              }
              if (r0 === null) {
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                r2 = pos;
                if (input.substr(pos, 2) === "#{") {
                  r3 = "#{";
                  pos += 2;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"#{\"");
                  }
                }
                if (r3 !== null) {
                  r4 = parse__();
                  if (r4 !== null) {
                    r5 = parse_expression();
                    if (r5 !== null) {
                      r6 = parse__();
                      if (r6 !== null) {
                        if (input.charCodeAt(pos) === 125) {
                          r7 = "}";
                          pos++;
                        } else {
                          r7 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"}\"");
                          }
                        }
                        if (r7 !== null) {
                          r0 = [r3, r4, r5, r6, r7];
                        } else {
                          r0 = null;
                          pos = r2;
                        }
                      } else {
                        r0 = null;
                        pos = r2;
                      }
                    } else {
                      r0 = null;
                      pos = r2;
                    }
                  } else {
                    r0 = null;
                    pos = r2;
                  }
                } else {
                  r0 = null;
                  pos = r2;
                }
                if (r0 !== null) {
                  reportedPos = r1;
                  r0 = (function(e) { return [e]; })(r5);
                }
                if (r0 === null) {
                  pos = r1;
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_throw() {
        var cacheKey = "throw@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_THROW();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_secondaryExpression();
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e) { return rp(new CS.Throw(e)); })(r5);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_return() {
        var cacheKey = "return@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_RETURN();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            r5 = parse_secondaryExpression();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e) { return rp(new CS.Return(e || null)); })(r5);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_continue() {
        var cacheKey = "continue@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = pos;
        r0 = parse_CONTINUE();
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function() { return rp(new CS.Continue); })();
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_break() {
        var cacheKey = "break@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = pos;
        r0 = parse_BREAK();
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function() { return rp(new CS.Break); })();
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_debugger() {
        var cacheKey = "debugger@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = pos;
        r0 = parse_DEBUGGER();
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function() { return rp(new CS.Debugger); })();
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_undefined() {
        var cacheKey = "undefined@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = pos;
        r0 = parse_UNDEFINED();
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function() { return rp(new CS.Undefined); })();
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_null() {
        var cacheKey = "null@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = pos;
        r0 = parse_NULL();
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function() { return rp(new CS.Null); })();
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_unassignable() {
        var cacheKey = "unassignable@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = pos;
        if (input.substr(pos, 9) === "arguments") {
          r2 = "arguments";
          pos += 9;
        } else {
          r2 = null;
          if (reportFailures === 0) {
            matchFailed("\"arguments\"");
          }
        }
        if (r2 === null) {
          if (input.substr(pos, 4) === "eval") {
            r2 = "eval";
            pos += 4;
          } else {
            r2 = null;
            if (reportFailures === 0) {
              matchFailed("\"eval\"");
            }
          }
        }
        if (r2 !== null) {
          r4 = pos;
          reportFailures++;
          r3 = parse_identifierPart();
          reportFailures--;
          if (r3 === null) {
            r3 = "";
          } else {
            r3 = null;
            pos = r4;
          }
          if (r3 !== null) {
            r0 = [r2, r3];
          } else {
            r0 = null;
            pos = r1;
          }
        } else {
          r0 = null;
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_CompoundAssignable() {
        var cacheKey = "CompoundAssignable@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r0 = parse_memberAccess();
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r4 = pos;
          reportFailures++;
          r3 = parse_unassignable();
          reportFailures--;
          if (r3 === null) {
            r3 = "";
          } else {
            r3 = null;
            pos = r4;
          }
          if (r3 !== null) {
            r4 = parse_identifier();
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(i) { return i; })(r4);
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_Assignable() {
        var cacheKey = "Assignable@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r0 = parse_memberAccess();
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r4 = pos;
          reportFailures++;
          r3 = parse_unassignable();
          reportFailures--;
          if (r3 === null) {
            r3 = "";
          } else {
            r3 = null;
            pos = r4;
          }
          if (r3 !== null) {
            r4 = parse_identifier();
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(i) { return i; })(r4);
          }
          if (r0 === null) {
            pos = r1;
          }
          if (r0 === null) {
            r0 = parse_positionalDestructuring();
            if (r0 === null) {
              r0 = parse_namedDestructuring();
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_positionalDestructuring() {
        var cacheKey = "positionalDestructuring@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = pos;
        r2 = pos;
        if (input.charCodeAt(pos) === 91) {
          r3 = "[";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (r3 !== null) {
          r4 = parse_positionalDestructuringBody();
          if (r4 !== null) {
            r5 = parse_TERMINATOR();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  r7 = "]";
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(members) {
              return rp(new CS.ArrayInitialiser(members));
            })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_positionalDestructuringBody() {
        var cacheKey = "positionalDestructuringBody@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_TERMINDENT();
        if (r3 !== null) {
          r4 = parse_positionalDestructuringMemberList();
          if (r4 !== null) {
            r5 = parse_DEDENT();
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(members) { return members; })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse__();
          if (r3 !== null) {
            r4 = parse_positionalDestructuringMemberList();
            r4 = r4 !== null ? r4 : "";
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(members) { return members || []; })(r4);
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_positionalDestructuringMemberList() {
        var cacheKey = "positionalDestructuringMemberList@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_positionalDestructuringMember();
        if (r3 !== null) {
          r4 = [];
          r6 = pos;
          r7 = parse__();
          if (r7 !== null) {
            if (input.charCodeAt(pos) === 44) {
              r8 = ",";
              pos++;
            } else {
              r8 = null;
              if (reportFailures === 0) {
                matchFailed("\",\"");
              }
            }
            if (r8 !== null) {
              r9 = parse__();
              if (r9 !== null) {
                r10 = parse_positionalDestructuringMember();
                if (r10 !== null) {
                  r5 = [r7, r8, r9, r10];
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          } else {
            r5 = null;
            pos = r6;
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = pos;
            r7 = parse__();
            if (r7 !== null) {
              if (input.charCodeAt(pos) === 44) {
                r8 = ",";
                pos++;
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              if (r8 !== null) {
                r9 = parse__();
                if (r9 !== null) {
                  r10 = parse_positionalDestructuringMember();
                  if (r10 !== null) {
                    r5 = [r7, r8, r9, r10];
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, es) {
                return [e].concat(es.map(function(e){ return e[3]; }));
              })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_positionalDestructuringMember() {
        var cacheKey = "positionalDestructuringMember@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_rest();
        if (r0 === null) {
          r0 = parse_Assignable();
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_namedDestructuring() {
        var cacheKey = "namedDestructuring@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = pos;
        r2 = pos;
        if (input.charCodeAt(pos) === 123) {
          r3 = "{";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"{\"");
          }
        }
        if (r3 !== null) {
          r4 = parse_namedDestructuringBody();
          if (r4 !== null) {
            r5 = parse_TERMINATOR();
            r5 = r5 !== null ? r5 : "";
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                if (input.charCodeAt(pos) === 125) {
                  r7 = "}";
                  pos++;
                } else {
                  r7 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"}\"");
                  }
                }
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(members) {
            return rp(new CS.ObjectInitialiser(members));
          })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_namedDestructuringBody() {
        var cacheKey = "namedDestructuringBody@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_TERMINDENT();
        if (r3 !== null) {
          r4 = parse_namedDestructuringMemberList();
          if (r4 !== null) {
            r5 = parse_DEDENT();
            if (r5 !== null) {
              r0 = [r3, r4, r5];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(members) { return members; })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r2 = pos;
          r3 = parse__();
          if (r3 !== null) {
            r4 = parse_namedDestructuringMemberList();
            r4 = r4 !== null ? r4 : "";
            if (r4 !== null) {
              r0 = [r3, r4];
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(members) { return members || []; })(r4);
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_namedDestructuringMemberList() {
        var cacheKey = "namedDestructuringMemberList@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_namedDestructuringMember();
        if (r3 !== null) {
          r4 = [];
          r6 = pos;
          r7 = parse_TERMINATOR();
          r7 = r7 !== null ? r7 : "";
          if (r7 !== null) {
            r8 = parse__();
            if (r8 !== null) {
              if (input.charCodeAt(pos) === 44) {
                r9 = ",";
                pos++;
              } else {
                r9 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              if (r9 === null) {
                r9 = parse_TERMINATOR();
              }
              if (r9 !== null) {
                r10 = parse_TERMINATOR();
                r10 = r10 !== null ? r10 : "";
                if (r10 !== null) {
                  r11 = parse__();
                  if (r11 !== null) {
                    r12 = parse_namedDestructuringMember();
                    if (r12 !== null) {
                      r5 = [r7, r8, r9, r10, r11, r12];
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          } else {
            r5 = null;
            pos = r6;
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = pos;
            r7 = parse_TERMINATOR();
            r7 = r7 !== null ? r7 : "";
            if (r7 !== null) {
              r8 = parse__();
              if (r8 !== null) {
                if (input.charCodeAt(pos) === 44) {
                  r9 = ",";
                  pos++;
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (r9 === null) {
                  r9 = parse_TERMINATOR();
                }
                if (r9 !== null) {
                  r10 = parse_TERMINATOR();
                  r10 = r10 !== null ? r10 : "";
                  if (r10 !== null) {
                    r11 = parse__();
                    if (r11 !== null) {
                      r12 = parse_namedDestructuringMember();
                      if (r12 !== null) {
                        r5 = [r7, r8, r9, r10, r11, r12];
                      } else {
                        r5 = null;
                        pos = r6;
                      }
                    } else {
                      r5 = null;
                      pos = r6;
                    }
                  } else {
                    r5 = null;
                    pos = r6;
                  }
                } else {
                  r5 = null;
                  pos = r6;
                }
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(e, es) {
                return [e].concat(es.map(function(e){ return e[5]; }));
              })(r3, r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_namedDestructuringMember() {
        var cacheKey = "namedDestructuringMember@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_ObjectInitialiserKeys();
        if (r3 !== null) {
          r4 = parse__();
          if (r4 !== null) {
            if (input.charCodeAt(pos) === 58) {
              r5 = ":";
              pos++;
            } else {
              r5 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (r5 !== null) {
              r6 = parse__();
              if (r6 !== null) {
                r7 = parse_Assignable();
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(key, val) {
                return rp(new CS.ObjectInitialiserMember(key, val));
              })(r3, r7);
        }
        if (r0 === null) {
          pos = r1;
        }
        if (r0 === null) {
          r1 = pos;
          r0 = parse_contextVar();
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function(v) {
                  var key = rp(new CS.String(v.memberName));
                  return rp(new CS.ObjectInitialiserMember(key, v));
                })(r0);
          }
          if (r0 === null) {
            pos = r1;
          }
          if (r0 === null) {
            r1 = pos;
            r2 = pos;
            r4 = pos;
            reportFailures++;
            r3 = parse_unassignable();
            reportFailures--;
            if (r3 === null) {
              r3 = "";
            } else {
              r3 = null;
              pos = r4;
            }
            if (r3 !== null) {
              r4 = parse_identifier();
              if (r4 !== null) {
                r0 = [r3, r4];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
            if (r0 !== null) {
              reportedPos = r1;
              r0 = (function(i) {
                    return rp(new CS.ObjectInitialiserMember(i, i));
                  })(r4);
            }
            if (r0 === null) {
              pos = r1;
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_identifier() {
        var cacheKey = "identifier@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = pos;
        r2 = pos;
        r4 = pos;
        reportFailures++;
        r3 = parse_reserved();
        reportFailures--;
        if (r3 === null) {
          r3 = "";
        } else {
          r3 = null;
          pos = r4;
        }
        if (r3 !== null) {
          r4 = parse_identifierName();
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(i) { return rp(new CS.Identifier(i)); })(r4);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_identifierName() {
        var cacheKey = "identifierName@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_identifierStart();
        if (r3 !== null) {
          r4 = [];
          r5 = parse_identifierPart();
          while (r5 !== null) {
            r4.push(r5);
            r5 = parse_identifierPart();
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_identifierStart() {
        var cacheKey = "identifierStart@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_UnicodeLetter();
        if (r0 === null) {
          if (/^[$_]/.test(input.charAt(pos))) {
            r0 = input.charAt(pos);
            pos++;
          } else {
            r0 = null;
            if (reportFailures === 0) {
              matchFailed("[$_]");
            }
          }
          if (r0 === null) {
            r0 = parse_UnicodeEscapeSequence();
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_identifierPart() {
        var cacheKey = "identifierPart@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_identifierStart();
        if (r0 === null) {
          r0 = parse_UnicodeCombiningMark();
          if (r0 === null) {
            r0 = parse_UnicodeDigit();
            if (r0 === null) {
              r0 = parse_UnicodeConnectorPunctuation();
              if (r0 === null) {
                r0 = parse_ZWNJ();
                if (r0 === null) {
                  r0 = parse_ZWJ();
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse___() {
        var cacheKey = "__@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = pos;
        r2 = pos;
        r4 = parse_whitespace();
        if (r4 !== null) {
          r3 = [];
          while (r4 !== null) {
            r3.push(r4);
            r4 = parse_whitespace();
          }
        } else {
          r3 = null;
        }
        if (r3 !== null) {
          r5 = pos;
          r6 = parse_blockComment();
          if (r6 !== null) {
            r8 = parse_whitespace();
            if (r8 !== null) {
              r7 = [];
              while (r8 !== null) {
                r7.push(r8);
                r8 = parse_whitespace();
              }
            } else {
              r7 = null;
            }
            if (r7 !== null) {
              r4 = [r6, r7];
            } else {
              r4 = null;
              pos = r5;
            }
          } else {
            r4 = null;
            pos = r5;
          }
          r4 = r4 !== null ? r4 : "";
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse__() {
        var cacheKey = "_@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse___();
        r0 = r0 !== null ? r0 : "";
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_comment() {
        var cacheKey = "comment@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        r0 = parse_blockComment();
        if (r0 === null) {
          r0 = parse_singleLineComment();
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_singleLineComment() {
        var cacheKey = "singleLineComment@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8;
        
        r1 = pos;
        r2 = pos;
        if (input.charCodeAt(pos) === 35) {
          r3 = "#";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"#\"");
          }
        }
        if (r3 !== null) {
          r4 = [];
          r6 = pos;
          r8 = pos;
          reportFailures++;
          r7 = parse_TERM();
          reportFailures--;
          if (r7 === null) {
            r7 = "";
          } else {
            r7 = null;
            pos = r8;
          }
          if (r7 !== null) {
            if (input.length > pos) {
              r8 = input.charAt(pos);
              pos++;
            } else {
              r8 = null;
              if (reportFailures === 0) {
                matchFailed("any character");
              }
            }
            if (r8 !== null) {
              r5 = [r7, r8];
            } else {
              r5 = null;
              pos = r6;
            }
          } else {
            r5 = null;
            pos = r6;
          }
          while (r5 !== null) {
            r4.push(r5);
            r6 = pos;
            r8 = pos;
            reportFailures++;
            r7 = parse_TERM();
            reportFailures--;
            if (r7 === null) {
              r7 = "";
            } else {
              r7 = null;
              pos = r8;
            }
            if (r7 !== null) {
              if (input.length > pos) {
                r8 = input.charAt(pos);
                pos++;
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("any character");
                }
              }
              if (r8 !== null) {
                r5 = [r7, r8];
              } else {
                r5 = null;
                pos = r6;
              }
            } else {
              r5 = null;
              pos = r6;
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_blockComment() {
        var cacheKey = "blockComment@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 3) === "###") {
          r3 = "###";
          pos += 3;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"###\"");
          }
        }
        if (r3 !== null) {
          if (/^[^#]/.test(input.charAt(pos))) {
            r4 = input.charAt(pos);
            pos++;
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("[^#]");
            }
          }
          if (r4 !== null) {
            r5 = [];
            if (/^[^#]/.test(input.charAt(pos))) {
              r6 = input.charAt(pos);
              pos++;
            } else {
              r6 = null;
              if (reportFailures === 0) {
                matchFailed("[^#]");
              }
            }
            if (r6 === null) {
              r7 = pos;
              if (input.charCodeAt(pos) === 35) {
                r8 = "#";
                pos++;
              } else {
                r8 = null;
                if (reportFailures === 0) {
                  matchFailed("\"#\"");
                }
              }
              if (r8 !== null) {
                if (input.charCodeAt(pos) === 35) {
                  r9 = "#";
                  pos++;
                } else {
                  r9 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"#\"");
                  }
                }
                r9 = r9 !== null ? r9 : "";
                if (r9 !== null) {
                  r11 = pos;
                  reportFailures++;
                  if (input.charCodeAt(pos) === 35) {
                    r10 = "#";
                    pos++;
                  } else {
                    r10 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"#\"");
                    }
                  }
                  reportFailures--;
                  if (r10 === null) {
                    r10 = "";
                  } else {
                    r10 = null;
                    pos = r11;
                  }
                  if (r10 !== null) {
                    r6 = [r8, r9, r10];
                  } else {
                    r6 = null;
                    pos = r7;
                  }
                } else {
                  r6 = null;
                  pos = r7;
                }
              } else {
                r6 = null;
                pos = r7;
              }
            }
            while (r6 !== null) {
              r5.push(r6);
              if (/^[^#]/.test(input.charAt(pos))) {
                r6 = input.charAt(pos);
                pos++;
              } else {
                r6 = null;
                if (reportFailures === 0) {
                  matchFailed("[^#]");
                }
              }
              if (r6 === null) {
                r7 = pos;
                if (input.charCodeAt(pos) === 35) {
                  r8 = "#";
                  pos++;
                } else {
                  r8 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"#\"");
                  }
                }
                if (r8 !== null) {
                  if (input.charCodeAt(pos) === 35) {
                    r9 = "#";
                    pos++;
                  } else {
                    r9 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"#\"");
                    }
                  }
                  r9 = r9 !== null ? r9 : "";
                  if (r9 !== null) {
                    r11 = pos;
                    reportFailures++;
                    if (input.charCodeAt(pos) === 35) {
                      r10 = "#";
                      pos++;
                    } else {
                      r10 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"#\"");
                      }
                    }
                    reportFailures--;
                    if (r10 === null) {
                      r10 = "";
                    } else {
                      r10 = null;
                      pos = r11;
                    }
                    if (r10 !== null) {
                      r6 = [r8, r9, r10];
                    } else {
                      r6 = null;
                      pos = r7;
                    }
                  } else {
                    r6 = null;
                    pos = r7;
                  }
                } else {
                  r6 = null;
                  pos = r7;
                }
              }
            }
            if (r5 !== null) {
              if (input.substr(pos, 3) === "###") {
                r6 = "###";
                pos += 3;
              } else {
                r6 = null;
                if (reportFailures === 0) {
                  matchFailed("\"###\"");
                }
              }
              if (r6 !== null) {
                r0 = [r3, r4, r5, r6];
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_whitespace() {
        var cacheKey = "whitespace@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        if (/^[\t\x0B\f \xA0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/.test(input.charAt(pos))) {
          r0 = input.charAt(pos);
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\t\\x0B\\f \\xA0\\uFEFF\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]");
          }
        }
        if (r0 === null) {
          if (input.charCodeAt(pos) === 13) {
            r0 = "\r";
            pos++;
          } else {
            r0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\r\"");
            }
          }
          if (r0 === null) {
            r1 = pos;
            r2 = pos;
            if (input.charCodeAt(pos) === 92) {
              r3 = "\\";
              pos++;
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\\\\"");
              }
            }
            if (r3 !== null) {
              if (input.charCodeAt(pos) === 13) {
                r4 = "\r";
                pos++;
              } else {
                r4 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\r\"");
                }
              }
              r4 = r4 !== null ? r4 : "";
              if (r4 !== null) {
                if (input.charCodeAt(pos) === 10) {
                  r5 = "\n";
                  pos++;
                } else {
                  r5 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\n\"");
                  }
                }
                if (r5 !== null) {
                  r0 = [r3, r4, r5];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
            if (r0 !== null) {
              r0 = input.substring(pos, r1);
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_INDENT() {
        var cacheKey = "INDENT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = pos;
        r2 = pos;
        r3 = parse___();
        if (r3 !== null) {
          if (input.charCodeAt(pos) === 61423) {
            r4 = "\uEFEF";
            pos++;
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\uEFEF\"");
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(ws) { return ws; })(r3);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_DEDENT() {
        var cacheKey = "DEDENT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = pos;
        r2 = pos;
        r4 = pos;
        r5 = pos;
        r6 = parse_TERMINATOR();
        r6 = r6 !== null ? r6 : "";
        if (r6 !== null) {
          r7 = parse__();
          if (r7 !== null) {
            r3 = [r6, r7];
          } else {
            r3 = null;
            pos = r5;
          }
        } else {
          r3 = null;
          pos = r5;
        }
        if (r3 !== null) {
          r3 = input.substring(pos, r4);
        }
        if (r3 !== null) {
          if (input.charCodeAt(pos) === 61438) {
            r4 = "\uEFFE";
            pos++;
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\uEFFE\"");
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(ws) { return ws; })(r3);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_TERM() {
        var cacheKey = "TERM@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = pos;
        r2 = pos;
        if (input.charCodeAt(pos) === 13) {
          r3 = "\r";
          pos++;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\r\"");
          }
        }
        r3 = r3 !== null ? r3 : "";
        if (r3 !== null) {
          if (input.charCodeAt(pos) === 10) {
            r4 = "\n";
            pos++;
          } else {
            r4 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\n\"");
            }
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        if (r0 === null) {
          r1 = pos;
          if (input.charCodeAt(pos) === 61439) {
            r0 = "\uEFFF";
            pos++;
          } else {
            r0 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\uEFFF\"");
            }
          }
          if (r0 !== null) {
            reportedPos = r1;
            r0 = (function() { return ''; })();
          }
          if (r0 === null) {
            pos = r1;
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_TERMINATOR() {
        var cacheKey = "TERMINATOR@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = pos;
        r3 = pos;
        r4 = parse__();
        if (r4 !== null) {
          r5 = parse_comment();
          r5 = r5 !== null ? r5 : "";
          if (r5 !== null) {
            r6 = parse_TERM();
            if (r6 !== null) {
              r7 = parse_blockComment();
              r7 = r7 !== null ? r7 : "";
              if (r7 !== null) {
                r2 = [r4, r5, r6, r7];
              } else {
                r2 = null;
                pos = r3;
              }
            } else {
              r2 = null;
              pos = r3;
            }
          } else {
            r2 = null;
            pos = r3;
          }
        } else {
          r2 = null;
          pos = r3;
        }
        if (r2 !== null) {
          r0 = [];
          while (r2 !== null) {
            r0.push(r2);
            r3 = pos;
            r4 = parse__();
            if (r4 !== null) {
              r5 = parse_comment();
              r5 = r5 !== null ? r5 : "";
              if (r5 !== null) {
                r6 = parse_TERM();
                if (r6 !== null) {
                  r7 = parse_blockComment();
                  r7 = r7 !== null ? r7 : "";
                  if (r7 !== null) {
                    r2 = [r4, r5, r6, r7];
                  } else {
                    r2 = null;
                    pos = r3;
                  }
                } else {
                  r2 = null;
                  pos = r3;
                }
              } else {
                r2 = null;
                pos = r3;
              }
            } else {
              r2 = null;
              pos = r3;
            }
          }
        } else {
          r0 = null;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_TERMINDENT() {
        var cacheKey = "TERMINDENT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = pos;
        r2 = pos;
        r3 = parse_TERMINATOR();
        if (r3 !== null) {
          r4 = parse_INDENT();
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_AND() {
        var cacheKey = "AND@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 3) === "and") {
          r3 = "and";
          pos += 3;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"and\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_BREAK() {
        var cacheKey = "BREAK@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 5) === "break") {
          r3 = "break";
          pos += 5;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"break\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_BY() {
        var cacheKey = "BY@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 2) === "by") {
          r3 = "by";
          pos += 2;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"by\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_CATCH() {
        var cacheKey = "CATCH@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 5) === "catch") {
          r3 = "catch";
          pos += 5;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"catch\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_CONTINUE() {
        var cacheKey = "CONTINUE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 8) === "continue") {
          r3 = "continue";
          pos += 8;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"continue\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_CLASS() {
        var cacheKey = "CLASS@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 5) === "class") {
          r3 = "class";
          pos += 5;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"class\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_DELETE() {
        var cacheKey = "DELETE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 6) === "delete") {
          r3 = "delete";
          pos += 6;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"delete\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_DEBUGGER() {
        var cacheKey = "DEBUGGER@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 8) === "debugger") {
          r3 = "debugger";
          pos += 8;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"debugger\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_DO() {
        var cacheKey = "DO@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 2) === "do") {
          r3 = "do";
          pos += 2;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"do\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_ELSE() {
        var cacheKey = "ELSE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 4) === "else") {
          r3 = "else";
          pos += 4;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"else\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_EXTENDS() {
        var cacheKey = "EXTENDS@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 7) === "extends") {
          r3 = "extends";
          pos += 7;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"extends\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_FALSE() {
        var cacheKey = "FALSE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 5) === "false") {
          r3 = "false";
          pos += 5;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"false\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_FINALLY() {
        var cacheKey = "FINALLY@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 7) === "finally") {
          r3 = "finally";
          pos += 7;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"finally\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_FOR() {
        var cacheKey = "FOR@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 3) === "for") {
          r3 = "for";
          pos += 3;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"for\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_IF() {
        var cacheKey = "IF@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 2) === "if") {
          r3 = "if";
          pos += 2;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"if\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_IN() {
        var cacheKey = "IN@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 2) === "in") {
          r3 = "in";
          pos += 2;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"in\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_INSTANCEOF() {
        var cacheKey = "INSTANCEOF@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 10) === "instanceof") {
          r3 = "instanceof";
          pos += 10;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"instanceof\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_IS() {
        var cacheKey = "IS@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 2) === "is") {
          r3 = "is";
          pos += 2;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"is\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_ISNT() {
        var cacheKey = "ISNT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 4) === "isnt") {
          r3 = "isnt";
          pos += 4;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"isnt\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_LOOP() {
        var cacheKey = "LOOP@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 4) === "loop") {
          r3 = "loop";
          pos += 4;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"loop\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_NEW() {
        var cacheKey = "NEW@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 3) === "new") {
          r3 = "new";
          pos += 3;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"new\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_NO() {
        var cacheKey = "NO@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 2) === "no") {
          r3 = "no";
          pos += 2;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"no\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_NOT() {
        var cacheKey = "NOT@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 3) === "not") {
          r3 = "not";
          pos += 3;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"not\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_NULL() {
        var cacheKey = "NULL@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 4) === "null") {
          r3 = "null";
          pos += 4;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"null\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_OF() {
        var cacheKey = "OF@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 2) === "of") {
          r3 = "of";
          pos += 2;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"of\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_OFF() {
        var cacheKey = "OFF@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 3) === "off") {
          r3 = "off";
          pos += 3;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"off\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_ON() {
        var cacheKey = "ON@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 2) === "on") {
          r3 = "on";
          pos += 2;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"on\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_OR() {
        var cacheKey = "OR@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 2) === "or") {
          r3 = "or";
          pos += 2;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"or\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_OWN() {
        var cacheKey = "OWN@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 3) === "own") {
          r3 = "own";
          pos += 3;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"own\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_RETURN() {
        var cacheKey = "RETURN@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 6) === "return") {
          r3 = "return";
          pos += 6;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"return\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_SWITCH() {
        var cacheKey = "SWITCH@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 6) === "switch") {
          r3 = "switch";
          pos += 6;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"switch\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_THEN() {
        var cacheKey = "THEN@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 4) === "then") {
          r3 = "then";
          pos += 4;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"then\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_THIS() {
        var cacheKey = "THIS@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 4) === "this") {
          r3 = "this";
          pos += 4;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"this\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_THROW() {
        var cacheKey = "THROW@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 5) === "throw") {
          r3 = "throw";
          pos += 5;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"throw\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_TRUE() {
        var cacheKey = "TRUE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 4) === "true") {
          r3 = "true";
          pos += 4;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"true\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_TRY() {
        var cacheKey = "TRY@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 3) === "try") {
          r3 = "try";
          pos += 3;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"try\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_TYPEOF() {
        var cacheKey = "TYPEOF@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 6) === "typeof") {
          r3 = "typeof";
          pos += 6;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"typeof\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_UNDEFINED() {
        var cacheKey = "UNDEFINED@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 9) === "undefined") {
          r3 = "undefined";
          pos += 9;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"undefined\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_UNLESS() {
        var cacheKey = "UNLESS@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 6) === "unless") {
          r3 = "unless";
          pos += 6;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"unless\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_UNTIL() {
        var cacheKey = "UNTIL@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 5) === "until") {
          r3 = "until";
          pos += 5;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"until\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_WHEN() {
        var cacheKey = "WHEN@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 4) === "when") {
          r3 = "when";
          pos += 4;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"when\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_WHILE() {
        var cacheKey = "WHILE@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 5) === "while") {
          r3 = "while";
          pos += 5;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"while\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_YES() {
        var cacheKey = "YES@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 3) === "yes") {
          r3 = "yes";
          pos += 3;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"yes\"");
          }
        }
        if (r3 !== null) {
          r5 = pos;
          reportFailures++;
          r4 = parse_identifierPart();
          reportFailures--;
          if (r4 === null) {
            r4 = "";
          } else {
            r4 = null;
            pos = r5;
          }
          if (r4 !== null) {
            r0 = [r3, r4];
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_SharedKeywords() {
        var cacheKey = "SharedKeywords@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = pos;
        if (input.substr(pos, 4) === "true") {
          r2 = "true";
          pos += 4;
        } else {
          r2 = null;
          if (reportFailures === 0) {
            matchFailed("\"true\"");
          }
        }
        if (r2 === null) {
          if (input.substr(pos, 5) === "false") {
            r2 = "false";
            pos += 5;
          } else {
            r2 = null;
            if (reportFailures === 0) {
              matchFailed("\"false\"");
            }
          }
          if (r2 === null) {
            if (input.substr(pos, 4) === "null") {
              r2 = "null";
              pos += 4;
            } else {
              r2 = null;
              if (reportFailures === 0) {
                matchFailed("\"null\"");
              }
            }
            if (r2 === null) {
              if (input.substr(pos, 4) === "this") {
                r2 = "this";
                pos += 4;
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"this\"");
                }
              }
              if (r2 === null) {
                if (input.substr(pos, 3) === "new") {
                  r2 = "new";
                  pos += 3;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"new\"");
                  }
                }
                if (r2 === null) {
                  if (input.substr(pos, 6) === "delete") {
                    r2 = "delete";
                    pos += 6;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"delete\"");
                    }
                  }
                  if (r2 === null) {
                    if (input.substr(pos, 6) === "typeof") {
                      r2 = "typeof";
                      pos += 6;
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"typeof\"");
                      }
                    }
                    if (r2 === null) {
                      if (input.substr(pos, 10) === "instanceof") {
                        r2 = "instanceof";
                        pos += 10;
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"instanceof\"");
                        }
                      }
                      if (r2 === null) {
                        if (input.substr(pos, 2) === "in") {
                          r2 = "in";
                          pos += 2;
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"in\"");
                          }
                        }
                        if (r2 === null) {
                          if (input.substr(pos, 6) === "return") {
                            r2 = "return";
                            pos += 6;
                          } else {
                            r2 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"return\"");
                            }
                          }
                          if (r2 === null) {
                            if (input.substr(pos, 5) === "throw") {
                              r2 = "throw";
                              pos += 5;
                            } else {
                              r2 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"throw\"");
                              }
                            }
                            if (r2 === null) {
                              if (input.substr(pos, 5) === "break") {
                                r2 = "break";
                                pos += 5;
                              } else {
                                r2 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"break\"");
                                }
                              }
                              if (r2 === null) {
                                if (input.substr(pos, 8) === "continue") {
                                  r2 = "continue";
                                  pos += 8;
                                } else {
                                  r2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"continue\"");
                                  }
                                }
                                if (r2 === null) {
                                  if (input.substr(pos, 8) === "debugger") {
                                    r2 = "debugger";
                                    pos += 8;
                                  } else {
                                    r2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"debugger\"");
                                    }
                                  }
                                  if (r2 === null) {
                                    if (input.substr(pos, 2) === "if") {
                                      r2 = "if";
                                      pos += 2;
                                    } else {
                                      r2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\"if\"");
                                      }
                                    }
                                    if (r2 === null) {
                                      if (input.substr(pos, 4) === "else") {
                                        r2 = "else";
                                        pos += 4;
                                      } else {
                                        r2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"else\"");
                                        }
                                      }
                                      if (r2 === null) {
                                        if (input.substr(pos, 6) === "switch") {
                                          r2 = "switch";
                                          pos += 6;
                                        } else {
                                          r2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"switch\"");
                                          }
                                        }
                                        if (r2 === null) {
                                          if (input.substr(pos, 3) === "for") {
                                            r2 = "for";
                                            pos += 3;
                                          } else {
                                            r2 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\"for\"");
                                            }
                                          }
                                          if (r2 === null) {
                                            if (input.substr(pos, 5) === "while") {
                                              r2 = "while";
                                              pos += 5;
                                            } else {
                                              r2 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\"while\"");
                                              }
                                            }
                                            if (r2 === null) {
                                              if (input.substr(pos, 2) === "do") {
                                                r2 = "do";
                                                pos += 2;
                                              } else {
                                                r2 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed("\"do\"");
                                                }
                                              }
                                              if (r2 === null) {
                                                if (input.substr(pos, 3) === "try") {
                                                  r2 = "try";
                                                  pos += 3;
                                                } else {
                                                  r2 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed("\"try\"");
                                                  }
                                                }
                                                if (r2 === null) {
                                                  if (input.substr(pos, 5) === "catch") {
                                                    r2 = "catch";
                                                    pos += 5;
                                                  } else {
                                                    r2 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed("\"catch\"");
                                                    }
                                                  }
                                                  if (r2 === null) {
                                                    if (input.substr(pos, 7) === "finally") {
                                                      r2 = "finally";
                                                      pos += 7;
                                                    } else {
                                                      r2 = null;
                                                      if (reportFailures === 0) {
                                                        matchFailed("\"finally\"");
                                                      }
                                                    }
                                                    if (r2 === null) {
                                                      if (input.substr(pos, 5) === "class") {
                                                        r2 = "class";
                                                        pos += 5;
                                                      } else {
                                                        r2 = null;
                                                        if (reportFailures === 0) {
                                                          matchFailed("\"class\"");
                                                        }
                                                      }
                                                      if (r2 === null) {
                                                        if (input.substr(pos, 7) === "extends") {
                                                          r2 = "extends";
                                                          pos += 7;
                                                        } else {
                                                          r2 = null;
                                                          if (reportFailures === 0) {
                                                            matchFailed("\"extends\"");
                                                          }
                                                        }
                                                        if (r2 === null) {
                                                          if (input.substr(pos, 5) === "super") {
                                                            r2 = "super";
                                                            pos += 5;
                                                          } else {
                                                            r2 = null;
                                                            if (reportFailures === 0) {
                                                              matchFailed("\"super\"");
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (r2 !== null) {
          r4 = pos;
          reportFailures++;
          r3 = parse_identifierPart();
          reportFailures--;
          if (r3 === null) {
            r3 = "";
          } else {
            r3 = null;
            pos = r4;
          }
          if (r3 !== null) {
            r0 = [r2, r3];
          } else {
            r0 = null;
            pos = r1;
          }
        } else {
          r0 = null;
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_JSKeywords() {
        var cacheKey = "JSKeywords@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = pos;
        if (input.substr(pos, 4) === "case") {
          r2 = "case";
          pos += 4;
        } else {
          r2 = null;
          if (reportFailures === 0) {
            matchFailed("\"case\"");
          }
        }
        if (r2 === null) {
          if (input.substr(pos, 7) === "default") {
            r2 = "default";
            pos += 7;
          } else {
            r2 = null;
            if (reportFailures === 0) {
              matchFailed("\"default\"");
            }
          }
          if (r2 === null) {
            if (input.substr(pos, 8) === "function") {
              r2 = "function";
              pos += 8;
            } else {
              r2 = null;
              if (reportFailures === 0) {
                matchFailed("\"function\"");
              }
            }
            if (r2 === null) {
              if (input.substr(pos, 3) === "var") {
                r2 = "var";
                pos += 3;
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"var\"");
                }
              }
              if (r2 === null) {
                if (input.substr(pos, 4) === "void") {
                  r2 = "void";
                  pos += 4;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"void\"");
                  }
                }
                if (r2 === null) {
                  if (input.substr(pos, 4) === "with") {
                    r2 = "with";
                    pos += 4;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"with\"");
                    }
                  }
                  if (r2 === null) {
                    if (input.substr(pos, 5) === "const") {
                      r2 = "const";
                      pos += 5;
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"const\"");
                      }
                    }
                    if (r2 === null) {
                      if (input.substr(pos, 3) === "let") {
                        r2 = "let";
                        pos += 3;
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"let\"");
                        }
                      }
                      if (r2 === null) {
                        if (input.substr(pos, 4) === "enum") {
                          r2 = "enum";
                          pos += 4;
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"enum\"");
                          }
                        }
                        if (r2 === null) {
                          if (input.substr(pos, 6) === "export") {
                            r2 = "export";
                            pos += 6;
                          } else {
                            r2 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"export\"");
                            }
                          }
                          if (r2 === null) {
                            if (input.substr(pos, 6) === "import") {
                              r2 = "import";
                              pos += 6;
                            } else {
                              r2 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"import\"");
                              }
                            }
                            if (r2 === null) {
                              if (input.substr(pos, 6) === "native") {
                                r2 = "native";
                                pos += 6;
                              } else {
                                r2 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"native\"");
                                }
                              }
                              if (r2 === null) {
                                if (input.substr(pos, 10) === "implements") {
                                  r2 = "implements";
                                  pos += 10;
                                } else {
                                  r2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"implements\"");
                                  }
                                }
                                if (r2 === null) {
                                  if (input.substr(pos, 9) === "interface") {
                                    r2 = "interface";
                                    pos += 9;
                                  } else {
                                    r2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"interface\"");
                                    }
                                  }
                                  if (r2 === null) {
                                    if (input.substr(pos, 7) === "package") {
                                      r2 = "package";
                                      pos += 7;
                                    } else {
                                      r2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\"package\"");
                                      }
                                    }
                                    if (r2 === null) {
                                      if (input.substr(pos, 7) === "private") {
                                        r2 = "private";
                                        pos += 7;
                                      } else {
                                        r2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"private\"");
                                        }
                                      }
                                      if (r2 === null) {
                                        if (input.substr(pos, 9) === "protected") {
                                          r2 = "protected";
                                          pos += 9;
                                        } else {
                                          r2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"protected\"");
                                          }
                                        }
                                        if (r2 === null) {
                                          if (input.substr(pos, 6) === "public") {
                                            r2 = "public";
                                            pos += 6;
                                          } else {
                                            r2 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\"public\"");
                                            }
                                          }
                                          if (r2 === null) {
                                            if (input.substr(pos, 6) === "static") {
                                              r2 = "static";
                                              pos += 6;
                                            } else {
                                              r2 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\"static\"");
                                              }
                                            }
                                            if (r2 === null) {
                                              if (input.substr(pos, 5) === "yield") {
                                                r2 = "yield";
                                                pos += 5;
                                              } else {
                                                r2 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed("\"yield\"");
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (r2 !== null) {
          r4 = pos;
          reportFailures++;
          r3 = parse_identifierPart();
          reportFailures--;
          if (r3 === null) {
            r3 = "";
          } else {
            r3 = null;
            pos = r4;
          }
          if (r3 !== null) {
            r0 = [r2, r3];
          } else {
            r0 = null;
            pos = r1;
          }
        } else {
          r0 = null;
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_CSKeywords() {
        var cacheKey = "CSKeywords@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4;
        
        r1 = pos;
        if (input.substr(pos, 9) === "undefined") {
          r2 = "undefined";
          pos += 9;
        } else {
          r2 = null;
          if (reportFailures === 0) {
            matchFailed("\"undefined\"");
          }
        }
        if (r2 === null) {
          if (input.substr(pos, 4) === "then") {
            r2 = "then";
            pos += 4;
          } else {
            r2 = null;
            if (reportFailures === 0) {
              matchFailed("\"then\"");
            }
          }
          if (r2 === null) {
            if (input.substr(pos, 6) === "unless") {
              r2 = "unless";
              pos += 6;
            } else {
              r2 = null;
              if (reportFailures === 0) {
                matchFailed("\"unless\"");
              }
            }
            if (r2 === null) {
              if (input.substr(pos, 5) === "until") {
                r2 = "until";
                pos += 5;
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"until\"");
                }
              }
              if (r2 === null) {
                if (input.substr(pos, 4) === "loop") {
                  r2 = "loop";
                  pos += 4;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"loop\"");
                  }
                }
                if (r2 === null) {
                  if (input.substr(pos, 3) === "off") {
                    r2 = "off";
                    pos += 3;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"off\"");
                    }
                  }
                  if (r2 === null) {
                    if (input.substr(pos, 2) === "by") {
                      r2 = "by";
                      pos += 2;
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"by\"");
                      }
                    }
                    if (r2 === null) {
                      if (input.substr(pos, 4) === "when") {
                        r2 = "when";
                        pos += 4;
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"when\"");
                        }
                      }
                      if (r2 === null) {
                        if (input.substr(pos, 3) === "and") {
                          r2 = "and";
                          pos += 3;
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"and\"");
                          }
                        }
                        if (r2 === null) {
                          if (input.substr(pos, 2) === "or") {
                            r2 = "or";
                            pos += 2;
                          } else {
                            r2 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"or\"");
                            }
                          }
                          if (r2 === null) {
                            if (input.substr(pos, 4) === "isnt") {
                              r2 = "isnt";
                              pos += 4;
                            } else {
                              r2 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"isnt\"");
                              }
                            }
                            if (r2 === null) {
                              if (input.substr(pos, 2) === "is") {
                                r2 = "is";
                                pos += 2;
                              } else {
                                r2 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"is\"");
                                }
                              }
                              if (r2 === null) {
                                if (input.substr(pos, 3) === "not") {
                                  r2 = "not";
                                  pos += 3;
                                } else {
                                  r2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"not\"");
                                  }
                                }
                                if (r2 === null) {
                                  if (input.substr(pos, 3) === "yes") {
                                    r2 = "yes";
                                    pos += 3;
                                  } else {
                                    r2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"yes\"");
                                    }
                                  }
                                  if (r2 === null) {
                                    if (input.substr(pos, 2) === "no") {
                                      r2 = "no";
                                      pos += 2;
                                    } else {
                                      r2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\"no\"");
                                      }
                                    }
                                    if (r2 === null) {
                                      if (input.substr(pos, 2) === "on") {
                                        r2 = "on";
                                        pos += 2;
                                      } else {
                                        r2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"on\"");
                                        }
                                      }
                                      if (r2 === null) {
                                        if (input.substr(pos, 2) === "of") {
                                          r2 = "of";
                                          pos += 2;
                                        } else {
                                          r2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"of\"");
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (r2 !== null) {
          r4 = pos;
          reportFailures++;
          r3 = parse_identifierPart();
          reportFailures--;
          if (r3 === null) {
            r3 = "";
          } else {
            r3 = null;
            pos = r4;
          }
          if (r3 !== null) {
            r0 = [r2, r3];
          } else {
            r0 = null;
            pos = r1;
          }
        } else {
          r0 = null;
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_reserved() {
        var cacheKey = "reserved@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1;
        
        r1 = pos;
        r0 = parse_macro();
        if (r0 !== null) {
          r0 = input.substring(pos, r1);
        }
        if (r0 === null) {
          r0 = parse_SharedKeywords();
          if (r0 === null) {
            r0 = parse_CSKeywords();
            if (r0 === null) {
              r0 = parse_JSKeywords();
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_UnicodeEscapeSequence() {
        var cacheKey = "UnicodeEscapeSequence@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3, r4, r5, r6, r7;
        
        r1 = pos;
        r2 = pos;
        if (input.substr(pos, 2) === "\\u") {
          r3 = "\\u";
          pos += 2;
        } else {
          r3 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\u\"");
          }
        }
        if (r3 !== null) {
          r4 = parse_hexDigit();
          if (r4 !== null) {
            r5 = parse_hexDigit();
            if (r5 !== null) {
              r6 = parse_hexDigit();
              if (r6 !== null) {
                r7 = parse_hexDigit();
                if (r7 !== null) {
                  r0 = [r3, r4, r5, r6, r7];
                } else {
                  r0 = null;
                  pos = r2;
                }
              } else {
                r0 = null;
                pos = r2;
              }
            } else {
              r0 = null;
              pos = r2;
            }
          } else {
            r0 = null;
            pos = r2;
          }
        } else {
          r0 = null;
          pos = r2;
        }
        if (r0 !== null) {
          reportedPos = r1;
          r0 = (function(h0, h1, h2, h3) { return String.fromCharCode(parseInt(h0 + h1 + h2 + h3, 16)); })(r4, r5, r6, r7);
        }
        if (r0 === null) {
          pos = r1;
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_UnicodeLetter() {
        var cacheKey = "UnicodeLetter@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3;
        
        if (/^[A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0531-\u0556\u10A0-\u10C5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uFF21-\uFF3Aa-z\xAA\xB5\xBA\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0561-\u0587\u1D00-\u1D2B\u1D62-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7C\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2D00-\u2D25\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7FA\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A\u01C5\u01C8\u01CB\u01F2\u1F88-\u1F8F\u1F98-\u1F9F\u1FA8-\u1FAF\u1FBC\u1FCC\u1FFC\u02B0-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0374\u037A\u0559\u0640\u06E5\u06E6\u07F4\u07F5\u07FA\u081A\u0824\u0828\u0971\u0E46\u0EC6\u10FC\u17D7\u1843\u1AA7\u1C78-\u1C7D\u1D2C-\u1D61\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C\u2C7D\u2D6F\u2E2F\u3005\u3031-\u3035\u303B\u309D\u309E\u30FC-\u30FE\uA015\uA4F8-\uA4FD\uA60C\uA67F\uA717-\uA71F\uA770\uA788\uA9CF\uAA70\uAADD\uFF70\uFF9E\uFF9F\u01BB\u01C0-\u01C3\u0294\u05D0-\u05EA\u05F0-\u05F2\u0620-\u063F\u0641-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u0800-\u0815\u0840-\u0858\u0904-\u0939\u093D\u0950\u0958-\u0961\u0972-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E45\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EDC\u0EDD\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10D0-\u10FA\u1100-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17DC\u1820-\u1842\u1844-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BC0-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C77\u1CE9-\u1CEC\u1CEE-\u1CF1\u2135-\u2138\u2D30-\u2D65\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3006\u303C\u3041-\u3096\u309F\u30A1-\u30FA\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400\u4DB5\u4E00\u9FCB\uA000-\uA014\uA016-\uA48C\uA4D0-\uA4F7\uA500-\uA60B\uA610-\uA61F\uA62A\uA62B\uA66E\uA6A0-\uA6E5\uA7FB-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA6F\uAA71-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB\uAADC\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA2D\uFA30-\uFA6D\uFA70-\uFAD9\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF66-\uFF6F\uFF71-\uFF9D\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u16EE-\u16F0\u2160-\u2182\u2185-\u2188\u3007\u3021-\u3029\u3038-\u303A\uA6E6-\uA6EF]/.test(input.charAt(pos))) {
          r0 = input.charAt(pos);
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[A-Z\\xC0-\\xD6\\xD8-\\xDE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017B\\u017D\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019C\\u019D\\u019F\\u01A0\\u01A2\\u01A4\\u01A6\\u01A7\\u01A9\\u01AC\\u01AE\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A\\u023B\\u023D\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u0386\\u0388-\\u038A\\u038C\\u038E\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0531-\\u0556\\u10A0-\\u10C5\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uFF21-\\uFF3Aa-z\\xAA\\xB5\\xBA\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0561-\\u0587\\u1D00-\\u1D2B\\u1D62-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6\\u1FC7\\u1FD0-\\u1FD3\\u1FD6\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6\\u1FF7\\u210A\\u210E\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73\\u2C74\\u2C76-\\u2C7C\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3\\u2CE4\\u2CEC\\u2CEE\\u2D00-\\u2D25\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7FA\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5\\u06E6\\u07F4\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D61\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA717-\\uA71F\\uA770\\uA788\\uA9CF\\uAA70\\uAADD\\uFF70\\uFF9E\\uFF9F\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E45\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10D0-\\u10FA\\u1100-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BC0-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u2135-\\u2138\\u2D30-\\u2D65\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400\\u4DB5\\u4E00\\u9FCB\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB\\uAADC\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA2D\\uFA30-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF]");
          }
        }
        if (r0 === null) {
          r1 = pos;
          if (input.charCodeAt(pos) === 55340) {
            r2 = "\uD82C";
            pos++;
          } else {
            r2 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\uD82C\"");
            }
          }
          if (r2 !== null) {
            if (/^[\uDC00\uDC01]/.test(input.charAt(pos))) {
              r3 = input.charAt(pos);
              pos++;
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("[\\uDC00\\uDC01]");
              }
            }
            if (r3 !== null) {
              r0 = [r2, r3];
            } else {
              r0 = null;
              pos = r1;
            }
          } else {
            r0 = null;
            pos = r1;
          }
          if (r0 === null) {
            r1 = pos;
            if (input.charCodeAt(pos) === 55304) {
              r2 = "\uD808";
              pos++;
            } else {
              r2 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\uD808\"");
              }
            }
            if (r2 !== null) {
              if (/^[\uDC00-\uDF6E]/.test(input.charAt(pos))) {
                r3 = input.charAt(pos);
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\uDC00-\\uDF6E]");
                }
              }
              if (r3 !== null) {
                r0 = [r2, r3];
              } else {
                r0 = null;
                pos = r1;
              }
            } else {
              r0 = null;
              pos = r1;
            }
            if (r0 === null) {
              r1 = pos;
              if (input.charCodeAt(pos) === 55401) {
                r2 = "\uD869";
                pos++;
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\uD869\"");
                }
              }
              if (r2 !== null) {
                if (/^[\uDED6\uDF00]/.test(input.charAt(pos))) {
                  r3 = input.charAt(pos);
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed("[\\uDED6\\uDF00]");
                  }
                }
                if (r3 !== null) {
                  r0 = [r2, r3];
                } else {
                  r0 = null;
                  pos = r1;
                }
              } else {
                r0 = null;
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                if (input.charCodeAt(pos) === 55305) {
                  r2 = "\uD809";
                  pos++;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\uD809\"");
                  }
                }
                if (r2 !== null) {
                  if (/^[\uDC00-\uDC62]/.test(input.charAt(pos))) {
                    r3 = input.charAt(pos);
                    pos++;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed("[\\uDC00-\\uDC62]");
                    }
                  }
                  if (r3 !== null) {
                    r0 = [r2, r3];
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                } else {
                  r0 = null;
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  if (input.charCodeAt(pos) === 55349) {
                    r2 = "\uD835";
                    pos++;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\uD835\"");
                    }
                  }
                  if (r2 !== null) {
                    if (/^[\uDC00-\uDC19\uDC34-\uDC4D\uDC68-\uDC81\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB5\uDCD0-\uDCE9\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD38\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD6C-\uDD85\uDDA0-\uDDB9\uDDD4-\uDDED\uDE08-\uDE21\uDE3C-\uDE55\uDE70-\uDE89\uDEA8-\uDEC0\uDEE2-\uDEFA\uDF1C-\uDF34\uDF56-\uDF6E\uDF90-\uDFA8\uDFCA\uDC1A-\uDC33\uDC4E-\uDC54\uDC56-\uDC67\uDC82-\uDC9B\uDCB6-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDCEA-\uDD03\uDD1E-\uDD37\uDD52-\uDD6B\uDD86-\uDD9F\uDDBA-\uDDD3\uDDEE-\uDE07\uDE22-\uDE3B\uDE56-\uDE6F\uDE8A-\uDEA5\uDEC2-\uDEDA\uDEDC-\uDEE1\uDEFC-\uDF14\uDF16-\uDF1B\uDF36-\uDF4E\uDF50-\uDF55\uDF70-\uDF88\uDF8A-\uDF8F\uDFAA-\uDFC2\uDFC4-\uDFC9\uDFCB]/.test(input.charAt(pos))) {
                      r3 = input.charAt(pos);
                      pos++;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed("[\\uDC00-\\uDC19\\uDC34-\\uDC4D\\uDC68-\\uDC81\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB5\\uDCD0-\\uDCE9\\uDD04\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD38\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD6C-\\uDD85\\uDDA0-\\uDDB9\\uDDD4-\\uDDED\\uDE08-\\uDE21\\uDE3C-\\uDE55\\uDE70-\\uDE89\\uDEA8-\\uDEC0\\uDEE2-\\uDEFA\\uDF1C-\\uDF34\\uDF56-\\uDF6E\\uDF90-\\uDFA8\\uDFCA\\uDC1A-\\uDC33\\uDC4E-\\uDC54\\uDC56-\\uDC67\\uDC82-\\uDC9B\\uDCB6-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDCCF\\uDCEA-\\uDD03\\uDD1E-\\uDD37\\uDD52-\\uDD6B\\uDD86-\\uDD9F\\uDDBA-\\uDDD3\\uDDEE-\\uDE07\\uDE22-\\uDE3B\\uDE56-\\uDE6F\\uDE8A-\\uDEA5\\uDEC2-\\uDEDA\\uDEDC-\\uDEE1\\uDEFC-\\uDF14\\uDF16-\\uDF1B\\uDF36-\\uDF4E\\uDF50-\\uDF55\\uDF70-\\uDF88\\uDF8A-\\uDF8F\\uDFAA-\\uDFC2\\uDFC4-\\uDFC9\\uDFCB]");
                      }
                    }
                    if (r3 !== null) {
                      r0 = [r2, r3];
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                  if (r0 === null) {
                    r1 = pos;
                    if (input.charCodeAt(pos) === 55300) {
                      r2 = "\uD804";
                      pos++;
                    } else {
                      r2 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"\\uD804\"");
                      }
                    }
                    if (r2 !== null) {
                      if (/^[\uDC03-\uDC37\uDC83-\uDCAF]/.test(input.charAt(pos))) {
                        r3 = input.charAt(pos);
                        pos++;
                      } else {
                        r3 = null;
                        if (reportFailures === 0) {
                          matchFailed("[\\uDC03-\\uDC37\\uDC83-\\uDCAF]");
                        }
                      }
                      if (r3 !== null) {
                        r0 = [r2, r3];
                      } else {
                        r0 = null;
                        pos = r1;
                      }
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                    if (r0 === null) {
                      r1 = pos;
                      if (input.charCodeAt(pos) === 55296) {
                        r2 = "\uD800";
                        pos++;
                      } else {
                        r2 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"\\uD800\"");
                        }
                      }
                      if (r2 !== null) {
                        if (/^[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1E\uDF30-\uDF40\uDF42-\uDF49\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDD40-\uDD74\uDF41\uDF4A\uDFD1-\uDFD5]/.test(input.charAt(pos))) {
                          r3 = input.charAt(pos);
                          pos++;
                        } else {
                          r3 = null;
                          if (reportFailures === 0) {
                            matchFailed("[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1E\\uDF30-\\uDF40\\uDF42-\\uDF49\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDD40-\\uDD74\\uDF41\\uDF4A\\uDFD1-\\uDFD5]");
                          }
                        }
                        if (r3 !== null) {
                          r0 = [r2, r3];
                        } else {
                          r0 = null;
                          pos = r1;
                        }
                      } else {
                        r0 = null;
                        pos = r1;
                      }
                      if (r0 === null) {
                        r1 = pos;
                        if (input.charCodeAt(pos) === 55308) {
                          r2 = "\uD80C";
                          pos++;
                        } else {
                          r2 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"\\uD80C\"");
                          }
                        }
                        if (r2 !== null) {
                          if (/^[\uDC00-\uDFFF]/.test(input.charAt(pos))) {
                            r3 = input.charAt(pos);
                            pos++;
                          } else {
                            r3 = null;
                            if (reportFailures === 0) {
                              matchFailed("[\\uDC00-\\uDFFF]");
                            }
                          }
                          if (r3 !== null) {
                            r0 = [r2, r3];
                          } else {
                            r0 = null;
                            pos = r1;
                          }
                        } else {
                          r0 = null;
                          pos = r1;
                        }
                        if (r0 === null) {
                          r1 = pos;
                          if (input.charCodeAt(pos) === 55297) {
                            r2 = "\uD801";
                            pos++;
                          } else {
                            r2 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"\\uD801\"");
                            }
                          }
                          if (r2 !== null) {
                            if (/^[\uDC00-\uDC9D]/.test(input.charAt(pos))) {
                              r3 = input.charAt(pos);
                              pos++;
                            } else {
                              r3 = null;
                              if (reportFailures === 0) {
                                matchFailed("[\\uDC00-\\uDC9D]");
                              }
                            }
                            if (r3 !== null) {
                              r0 = [r2, r3];
                            } else {
                              r0 = null;
                              pos = r1;
                            }
                          } else {
                            r0 = null;
                            pos = r1;
                          }
                          if (r0 === null) {
                            r1 = pos;
                            if (input.charCodeAt(pos) === 55406) {
                              r2 = "\uD86E";
                              pos++;
                            } else {
                              r2 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"\\uD86E\"");
                              }
                            }
                            if (r2 !== null) {
                              if (/^[\uDC1D]/.test(input.charAt(pos))) {
                                r3 = input.charAt(pos);
                                pos++;
                              } else {
                                r3 = null;
                                if (reportFailures === 0) {
                                  matchFailed("[\\uDC1D]");
                                }
                              }
                              if (r3 !== null) {
                                r0 = [r2, r3];
                              } else {
                                r0 = null;
                                pos = r1;
                              }
                            } else {
                              r0 = null;
                              pos = r1;
                            }
                            if (r0 === null) {
                              r1 = pos;
                              if (input.charCodeAt(pos) === 55299) {
                                r2 = "\uD803";
                                pos++;
                              } else {
                                r2 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"\\uD803\"");
                                }
                              }
                              if (r2 !== null) {
                                if (/^[\uDC00-\uDC48]/.test(input.charAt(pos))) {
                                  r3 = input.charAt(pos);
                                  pos++;
                                } else {
                                  r3 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("[\\uDC00-\\uDC48]");
                                  }
                                }
                                if (r3 !== null) {
                                  r0 = [r2, r3];
                                } else {
                                  r0 = null;
                                  pos = r1;
                                }
                              } else {
                                r0 = null;
                                pos = r1;
                              }
                              if (r0 === null) {
                                r1 = pos;
                                if (input.charCodeAt(pos) === 55360) {
                                  r2 = "\uD840";
                                  pos++;
                                } else {
                                  r2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"\\uD840\"");
                                  }
                                }
                                if (r2 !== null) {
                                  if (/^[\uDC00]/.test(input.charAt(pos))) {
                                    r3 = input.charAt(pos);
                                    pos++;
                                  } else {
                                    r3 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("[\\uDC00]");
                                    }
                                  }
                                  if (r3 !== null) {
                                    r0 = [r2, r3];
                                  } else {
                                    r0 = null;
                                    pos = r1;
                                  }
                                } else {
                                  r0 = null;
                                  pos = r1;
                                }
                                if (r0 === null) {
                                  r1 = pos;
                                  if (input.charCodeAt(pos) === 55422) {
                                    r2 = "\uD87E";
                                    pos++;
                                  } else {
                                    r2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"\\uD87E\"");
                                    }
                                  }
                                  if (r2 !== null) {
                                    if (/^[\uDC00-\uDE1D]/.test(input.charAt(pos))) {
                                      r3 = input.charAt(pos);
                                      pos++;
                                    } else {
                                      r3 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("[\\uDC00-\\uDE1D]");
                                      }
                                    }
                                    if (r3 !== null) {
                                      r0 = [r2, r3];
                                    } else {
                                      r0 = null;
                                      pos = r1;
                                    }
                                  } else {
                                    r0 = null;
                                    pos = r1;
                                  }
                                  if (r0 === null) {
                                    r1 = pos;
                                    if (input.charCodeAt(pos) === 55405) {
                                      r2 = "\uD86D";
                                      pos++;
                                    } else {
                                      r2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\"\\uD86D\"");
                                      }
                                    }
                                    if (r2 !== null) {
                                      if (/^[\uDF34\uDF40]/.test(input.charAt(pos))) {
                                        r3 = input.charAt(pos);
                                        pos++;
                                      } else {
                                        r3 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("[\\uDF34\\uDF40]");
                                        }
                                      }
                                      if (r3 !== null) {
                                        r0 = [r2, r3];
                                      } else {
                                        r0 = null;
                                        pos = r1;
                                      }
                                    } else {
                                      r0 = null;
                                      pos = r1;
                                    }
                                    if (r0 === null) {
                                      r1 = pos;
                                      if (input.charCodeAt(pos) === 55322) {
                                        r2 = "\uD81A";
                                        pos++;
                                      } else {
                                        r2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"\\uD81A\"");
                                        }
                                      }
                                      if (r2 !== null) {
                                        if (/^[\uDC00-\uDE38]/.test(input.charAt(pos))) {
                                          r3 = input.charAt(pos);
                                          pos++;
                                        } else {
                                          r3 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("[\\uDC00-\\uDE38]");
                                          }
                                        }
                                        if (r3 !== null) {
                                          r0 = [r2, r3];
                                        } else {
                                          r0 = null;
                                          pos = r1;
                                        }
                                      } else {
                                        r0 = null;
                                        pos = r1;
                                      }
                                      if (r0 === null) {
                                        r1 = pos;
                                        if (input.charCodeAt(pos) === 55298) {
                                          r2 = "\uD802";
                                          pos++;
                                        } else {
                                          r2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"\\uD802\"");
                                          }
                                        }
                                        if (r2 !== null) {
                                          if (/^[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDD00-\uDD15\uDD20-\uDD39\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72]/.test(input.charAt(pos))) {
                                            r3 = input.charAt(pos);
                                            pos++;
                                          } else {
                                            r3 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72]");
                                            }
                                          }
                                          if (r3 !== null) {
                                            r0 = [r2, r3];
                                          } else {
                                            r0 = null;
                                            pos = r1;
                                          }
                                        } else {
                                          r0 = null;
                                          pos = r1;
                                        }
                                        if (r0 === null) {
                                          r1 = pos;
                                          if (input.charCodeAt(pos) === 55309) {
                                            r2 = "\uD80D";
                                            pos++;
                                          } else {
                                            r2 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\"\\uD80D\"");
                                            }
                                          }
                                          if (r2 !== null) {
                                            if (/^[\uDC00-\uDC2E]/.test(input.charAt(pos))) {
                                              r3 = input.charAt(pos);
                                              pos++;
                                            } else {
                                              r3 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("[\\uDC00-\\uDC2E]");
                                              }
                                            }
                                            if (r3 !== null) {
                                              r0 = [r2, r3];
                                            } else {
                                              r0 = null;
                                              pos = r1;
                                            }
                                          } else {
                                            r0 = null;
                                            pos = r1;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_UnicodeCombiningMark() {
        var cacheKey = "UnicodeCombiningMark@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3;
        
        if (/^[\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0900-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1DC0-\u1DE6\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F\uA67C\uA67D\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BE-\u09C0\u09C7\u09C8\u09CB\u09CC\u09D7\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD7\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0-\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0D02\u0D03\u0D3E-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D57\u0D82\u0D83\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DF2\u0DF3\u0F3E\u0F3F\u0F7F\u102B\u102C\u1031\u1038\u103B\u103C\u1056\u1057\u1062-\u1064\u1067-\u106D\u1083\u1084\u1087-\u108C\u108F\u109A-\u109C\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u19B0-\u19C0\u19C8\u19C9\u1A19-\u1A1B\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1B04\u1B35\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF2\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BD-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAA7B\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]/.test(input.charAt(pos))) {
          r0 = input.charAt(pos);
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0900-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2\\u09E3\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0CBC\\u0CBF\\u0CC6\\u0CCC\\u0CCD\\u0CE2\\u0CE3\\u0D41-\\u0D44\\u0D4D\\u0D62\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1DC0-\\u1DE6\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F\\uA67C\\uA67D\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE26\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BE-\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B3E\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0B57\\u0BBE\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0CD5\\u0CD6\\u0D02\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0F3E\\u0F3F\\u0F7F\\u102B\\u102C\\u1031\\u1038\\u103B\\u103C\\u1056\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A19-\\u1A1B\\u1A55\\u1A57\\u1A61\\u1A63\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF2\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BD-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAA7B\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]");
          }
        }
        if (r0 === null) {
          r1 = pos;
          if (input.charCodeAt(pos) === 56128) {
            r2 = "\uDB40";
            pos++;
          } else {
            r2 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\uDB40\"");
            }
          }
          if (r2 !== null) {
            if (/^[\uDD00-\uDDEF]/.test(input.charAt(pos))) {
              r3 = input.charAt(pos);
              pos++;
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("[\\uDD00-\\uDDEF]");
              }
            }
            if (r3 !== null) {
              r0 = [r2, r3];
            } else {
              r0 = null;
              pos = r1;
            }
          } else {
            r0 = null;
            pos = r1;
          }
          if (r0 === null) {
            r1 = pos;
            if (input.charCodeAt(pos) === 55348) {
              r2 = "\uD834";
              pos++;
            } else {
              r2 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\uD834\"");
              }
            }
            if (r2 !== null) {
              if (/^[\uDD67-\uDD69\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44\uDD65\uDD66\uDD6D-\uDD72]/.test(input.charAt(pos))) {
                r3 = input.charAt(pos);
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\uDD67-\\uDD69\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44\\uDD65\\uDD66\\uDD6D-\\uDD72]");
                }
              }
              if (r3 !== null) {
                r0 = [r2, r3];
              } else {
                r0 = null;
                pos = r1;
              }
            } else {
              r0 = null;
              pos = r1;
            }
            if (r0 === null) {
              r1 = pos;
              if (input.charCodeAt(pos) === 55300) {
                r2 = "\uD804";
                pos++;
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\uD804\"");
                }
              }
              if (r2 !== null) {
                if (/^[\uDC01\uDC38-\uDC46\uDC80\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8]/.test(input.charAt(pos))) {
                  r3 = input.charAt(pos);
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed("[\\uDC01\\uDC38-\\uDC46\\uDC80\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8]");
                  }
                }
                if (r3 !== null) {
                  r0 = [r2, r3];
                } else {
                  r0 = null;
                  pos = r1;
                }
              } else {
                r0 = null;
                pos = r1;
              }
              if (r0 === null) {
                r1 = pos;
                if (input.charCodeAt(pos) === 55296) {
                  r2 = "\uD800";
                  pos++;
                } else {
                  r2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"\\uD800\"");
                  }
                }
                if (r2 !== null) {
                  if (/^[\uDDFD]/.test(input.charAt(pos))) {
                    r3 = input.charAt(pos);
                    pos++;
                  } else {
                    r3 = null;
                    if (reportFailures === 0) {
                      matchFailed("[\\uDDFD]");
                    }
                  }
                  if (r3 !== null) {
                    r0 = [r2, r3];
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                } else {
                  r0 = null;
                  pos = r1;
                }
                if (r0 === null) {
                  r1 = pos;
                  if (input.charCodeAt(pos) === 55298) {
                    r2 = "\uD802";
                    pos++;
                  } else {
                    r2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"\\uD802\"");
                    }
                  }
                  if (r2 !== null) {
                    if (/^[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F]/.test(input.charAt(pos))) {
                      r3 = input.charAt(pos);
                      pos++;
                    } else {
                      r3 = null;
                      if (reportFailures === 0) {
                        matchFailed("[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F]");
                      }
                    }
                    if (r3 !== null) {
                      r0 = [r2, r3];
                    } else {
                      r0 = null;
                      pos = r1;
                    }
                  } else {
                    r0 = null;
                    pos = r1;
                  }
                }
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_UnicodeDigit() {
        var cacheKey = "UnicodeDigit@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0, r1, r2, r3;
        
        if (/^[0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]/.test(input.charAt(pos))) {
          r0 = input.charAt(pos);
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]");
          }
        }
        if (r0 === null) {
          r1 = pos;
          if (input.charCodeAt(pos) === 55349) {
            r2 = "\uD835";
            pos++;
          } else {
            r2 = null;
            if (reportFailures === 0) {
              matchFailed("\"\\uD835\"");
            }
          }
          if (r2 !== null) {
            if (/^[\uDFCE-\uDFFF]/.test(input.charAt(pos))) {
              r3 = input.charAt(pos);
              pos++;
            } else {
              r3 = null;
              if (reportFailures === 0) {
                matchFailed("[\\uDFCE-\\uDFFF]");
              }
            }
            if (r3 !== null) {
              r0 = [r2, r3];
            } else {
              r0 = null;
              pos = r1;
            }
          } else {
            r0 = null;
            pos = r1;
          }
          if (r0 === null) {
            r1 = pos;
            if (input.charCodeAt(pos) === 55300) {
              r2 = "\uD804";
              pos++;
            } else {
              r2 = null;
              if (reportFailures === 0) {
                matchFailed("\"\\uD804\"");
              }
            }
            if (r2 !== null) {
              if (/^[\uDC66-\uDC6F]/.test(input.charAt(pos))) {
                r3 = input.charAt(pos);
                pos++;
              } else {
                r3 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\uDC66-\\uDC6F]");
                }
              }
              if (r3 !== null) {
                r0 = [r2, r3];
              } else {
                r0 = null;
                pos = r1;
              }
            } else {
              r0 = null;
              pos = r1;
            }
            if (r0 === null) {
              r1 = pos;
              if (input.charCodeAt(pos) === 55297) {
                r2 = "\uD801";
                pos++;
              } else {
                r2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"\\uD801\"");
                }
              }
              if (r2 !== null) {
                if (/^[\uDCA0-\uDCA9]/.test(input.charAt(pos))) {
                  r3 = input.charAt(pos);
                  pos++;
                } else {
                  r3 = null;
                  if (reportFailures === 0) {
                    matchFailed("[\\uDCA0-\\uDCA9]");
                  }
                }
                if (r3 !== null) {
                  r0 = [r2, r3];
                } else {
                  r0 = null;
                  pos = r1;
                }
              } else {
                r0 = null;
                pos = r1;
              }
            }
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_UnicodeConnectorPunctuation() {
        var cacheKey = "UnicodeConnectorPunctuation@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        if (/^[_\u203F\u2040\u2054\uFE33\uFE34\uFE4D-\uFE4F\uFF3F]/.test(input.charAt(pos))) {
          r0 = input.charAt(pos);
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("[_\\u203F\\u2040\\u2054\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF3F]");
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_ZWNJ() {
        var cacheKey = "ZWNJ@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        if (input.charCodeAt(pos) === 8204) {
          r0 = "\u200C";
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u200C\"");
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      function parse_ZWJ() {
        var cacheKey = "ZWJ@" + pos;
        var cachedResult = cache[cacheKey];
        if (cachedResult) {
          pos = cachedResult.nextPos;
          return cachedResult.result;
        }
        
        var r0;
        
        if (input.charCodeAt(pos) === 8205) {
          r0 = "\u200D";
          pos++;
        } else {
          r0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\u200D\"");
          }
        }
        
        cache[cacheKey] = {
          nextPos: pos,
          result:  r0
        };
        return r0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      
      var CS = require("./nodes"),
      
        constructorLookup =
          { '||': CS.LogicalOrOp
          , or: CS.LogicalOrOp
          , '&&': CS.LogicalAndOp
          , and: CS.LogicalAndOp
          , '|': CS.BitOrOp
          , '^': CS.BitXorOp
          , '&': CS.BitAndOp
          , '?': CS.ExistsOp
          , '==': CS.EQOp
          , is: CS.EQOp
          , '!=': CS.NEQOp
          , isnt: CS.NEQOp
          , '<=': CS.LTEOp
          , '>=': CS.GTEOp
          , '<': CS.LTOp
          , '>': CS.GTOp
          , 'extends': CS.ExtendsOp
          , 'instanceof': CS.InstanceofOp
          , 'in': CS.InOp
          , 'of': CS.OfOp
          , '<<': CS.LeftShiftOp
          , '>>': CS.SignedRightShiftOp
          , '>>>': CS.UnsignedRightShiftOp
          , '+': CS.PlusOp
          , '-': CS.SubtractOp
          , '*': CS.MultiplyOp
          , '/': CS.DivideOp
          , '%': CS.RemOp
          , '**': CS.ExpOp
          },
      
        negatableOps = ['instanceof', 'in', 'of'],
        chainableComparisonOps = ['<=', '>=', '<', '>', '==', 'is', '!=', 'isnt'],
      
        rightAssocOps = [';', '=', '?', '**'],
        precedenceHierarchy =
          [ ['or', '||']
          , ['and', '&&']
          , ['|']
          , ['^']
          , ['&']
          , ['?']
          , ['is', '==', 'isnt', '!=']
          , ['instanceof', 'in', 'of', '<=', '>=', '<', '>']
          , ['<<', '>>', '>>>']
          , ['+', '-']
          , ['*', '/', '%']
          , ['**']
          ],
      
        precedenceTable = (function(){
          var table = {}, ops, op;
          for(var level = 0, l = precedenceHierarchy.length; level < l; ++level) {
            ops = precedenceHierarchy[level];
            for(var o = 0, k = ops.length; o < k; ++o) {
              op = ops[o];
              table[op] = level;
            }
          }
          return table;
        }()),
      
        RIGHT_ASSOCIATIVE = {},
        LEFT_ASSOCIATIVE = {},
      
        associativities = (function(){
          var result = {};
          for(var op in precedenceTable) {
            if(!{}.hasOwnProperty.call(precedenceTable, op)) continue;
            result[op] = LEFT_ASSOCIATIVE;
          }
          for(var i = 0, l = rightAssocOps.length; i < l; ++i) {
            result[rightAssocOps[i]] = RIGHT_ASSOCIATIVE;
          }
          return result;
        }());
      
        for(var i = 0, l = negatableOps.length; i < l; ++i) {
          (function(op){
            var fn = function(a, b){ return new CS.LogicalNotOp(new constructorLookup[op](a, b)); };
            fn.prototype = constructorLookup[op].prototype;
            var negatedOp = 'not ' + op;
            constructorLookup[negatedOp] = fn;
            precedenceTable[negatedOp] = precedenceTable[op];
            associativities[negatedOp] = associativities[op];
          }(negatableOps[i]));
        }
      
      
        var
        prefixConstructorLookup =
          { '++': CS.PreIncrementOp
          , '--': CS.PreDecrementOp
          , '+': CS.UnaryPlusOp
          , '-': CS.UnaryNegateOp
          , '!': CS.LogicalNotOp
          , 'not': CS.LogicalNotOp
          , '~': CS.BitNotOp
          , 'do': CS.DoOp
          , 'typeof': CS.TypeofOp
          , 'delete': CS.DeleteOp
          },
      
        postfixConstructorLookup =
          { '?': CS.UnaryExistsOp
          , '[..]': CS.ShallowCopyArray
          , '++': CS.PostIncrementOp
          , '--': CS.PostDecrementOp
          },
      
        foldl = function(fn, memo, list){
          for(var i = 0, l = list.length; i < l; ++i)
            memo = fn(memo, list[i]);
          return memo;
        },
        foldr = function(fn, memo, list){
          for(var i = list.length; i--;)
            memo = fn(memo, list[i]);
          return memo;
        },
      
        // TODO: clean up and use a functional approach; stack === recursion
        foldBinaryExpr = function(parts, ignoreChains) {
          var stack, chainStack, nextPrec, nextOp, className, ctor, prec, rightOperand, leftOperand, operator, i, expr;
          if(parts.length < 3) return parts[0]; // should never happen
          stack = [].slice.call(parts, 0, 3);
          parts = [].slice.call(parts, 3);
      
          while(parts.length > 0) {
            nextOp = parts[0];
      
            if(!ignoreChains && stack.length > 2) {
              operator = stack[stack.length - 2];
              // reduce chained comparisons
              if(chainableComparisonOps.indexOf(operator) >= 0 && chainableComparisonOps.indexOf(nextOp) >= 0) {
                chainStack = stack.slice(-3);
                stack = stack.slice(0, stack.length - 3);
                do {
                  operator = nextOp;
                  chainStack.push(parts.shift(), parts.shift());
                  nextOp = parts[0];
                  if(nextOp) {
                    nextPrec = precedenceTable[nextOp];
                    prec = precedenceTable[operator];
                  }
                // TODO: I would love `a < b is c < d` to instead denote `(a < b) is (c < d)`
                } while(nextOp != null && (nextPrec > prec || chainableComparisonOps.indexOf(nextOp) >= 0));
                stack.push(new CS.ChainedComparisonOp(foldBinaryExpr(chainStack, true)));
                continue;
              }
            }
      
            // reduce
            while(
              stack.length > 2 &&
              (
                operator = stack[stack.length - 2],
                prec = precedenceTable[operator],
                nextPrec = precedenceTable[nextOp],
                nextPrec < prec ||
                chainableComparisonOps.indexOf(operator) >= 0 && chainableComparisonOps.indexOf(nextOp) >= 0 ||
                nextPrec == prec && associativities[operator] === LEFT_ASSOCIATIVE
              )
            ) {
              rightOperand = stack.pop();
              stack.pop(); // operator
              leftOperand = stack.pop();
              stack.push(new constructorLookup[operator](leftOperand, rightOperand));
            }
            // shift
            stack.push(parts.shift()); // operator
            stack.push(parts.shift()); // next operand
          }
      
          // reduce the rest of the stack
          expr = stack.pop();
          while(stack.length > 0)
            expr = new constructorLookup[stack.pop()](stack.pop(), expr);
      
          return expr;
        },
      
        createInterpolation = function(es){
          var init = new CS.String('').g();
          return foldl(function(memo, s){
            if(s instanceof CS.String) {
              var left = memo;
              while(left)
                if(left instanceof CS.String) {
                  if(left === init) {
                    c(left, s);
                    delete left.generated;
                  }
                  left.data = left.data + s.data;
                  return memo;
                } else if(left instanceof CS.ConcatOp) {
                  left = left.right
                } else {
                  break;
                }
            }
            return new CS.ConcatOp(memo, s);
          }, init, es);
        },
      
        createMemberExpression = function(e, accesses){
          return foldl(function(left, access){
            var F = function(){};
            F.prototype = access.op.prototype;
            var o = new F;
            // rather safely assumes access.op is returning non-Object
            access.op.apply(o, [left].concat(access.operands));
            return c(o.r(left.raw + access.raw), access);
          }, e, accesses);
        },
      
        isValidRegExpFlags = function(flags) {
          if(!flags) return true;
          if(flags.length > 4) return false;
          flags.sort();
          var flag = null;
          for(var i = 0, l = flags.length; i < l; ++i)
            if(flag == flags[i]) return false;
            else flag = flags[i];
          return true;
        },
      
        // TODO: refactor this
        stripLeadingWhitespace = function(str){
          str = str.replace(/\s+$/, '');
          var attempt, match, matchStr = str, indent = null;
          while(match = /\n+([^\n\S]*)/.exec(matchStr)) {
            attempt = match[1];
            matchStr = matchStr.slice(match.index + match[0].length);
            if (indent == null || 0 < attempt.length && attempt.length < indent.length)
              indent = attempt;
          }
          if(indent) str = str.replace(new RegExp('\\n' + indent, 'g'), '\n');
          str = str.replace(/^\n/, '');
          return str;
        },
      
        // TODO: remove mutation?
        stripLeadingWhitespaceInterpolation = function(pieces){
          var indent = null, piece, match, i, l, attempt, matchStr;
          for(i = 0, l = pieces.length; i < l; ++i) {
            piece = pieces[i];
            if(piece instanceof CS.String) {
              if(i == l - 1) piece.data = piece.data.replace(/\s+$/, '');
              matchStr = piece.data;
              while(match = /\n+([^\n\S]*)/.exec(matchStr)) {
                attempt = match[1]
                matchStr = matchStr.slice(match.index + match[0].length);
                if (indent == null || 0 < attempt.length && attempt.length < indent.length)
                  indent = attempt;
              }
            }
          }
          if(indent) {
            for(i = 0, l = pieces.length; i < l; ++i) {
              piece = pieces[i];
              if(piece instanceof CS.String) {
                piece.data = piece.data.replace(new RegExp('\\n' + indent, 'g'), '\n');
                if(i === l - 1) piece.data = piece.data.replace(/(\n\s*)+$/, '');
                if(i === 0) piece.data = piece.data.replace(/^\n/, '');
              }
            }
          }
          return pieces;
        },
      
        // the identity function
        id = function(x){ return x; },
        // store raw parse information
        r = options.raw ? function(node){
          node.raw = text().replace(/[\uEFEF\uEFFE\uEFFF]/g, '');
          return node;
        } : id,
        // store position information
        p = options.raw ? function(node){
          node.line = line();
          node.column = column();
          node.offset = offset();
          return node;
        } : id,
        // composition of r and p
        rp = options.raw ? function(node){ return r(p(node)); } : id,
        // copy position information
        c = options.raw ? function(to, from){
          to.line = from.line;
          to.column = from.column;
          to.offset = from.offset;
          return to;
        } : id;
      
        // XXX: this overrides the function with the same name generated by PEGjs; see comment within
        function computeReportedPosDetails() {
          function advanceCachedReportedPos() {
            var ch;
      
            for (; cachedReportedPos < reportedPos; cachedReportedPos++) {
              ch = input.charAt(cachedReportedPos);
              if (ch === "\n") {
                if (!cachedReportedPosDetails.seenCR) { cachedReportedPosDetails.line++; }
                cachedReportedPosDetails.column = 1;
                cachedReportedPosDetails.seenCR = false;
              } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                cachedReportedPosDetails.line++;
                cachedReportedPosDetails.column = 1;
                cachedReportedPosDetails.seenCR = true;
              // XXX: strip control characters when calculating position information; see #117
              } else if(!/[\uEFEF\uEFFE\uEFFF]/.test(ch)) {
                cachedReportedPosDetails.column++;
                cachedReportedPosDetails.seenCR = false;
              }
            }
          }
      
          if (cachedReportedPos !== reportedPos) {
            if (cachedReportedPos > reportedPos) {
              cachedReportedPos = 0;
              cachedReportedPosDetails = { line: 1, column: 1, seenCR: false };
            }
            advanceCachedReportedPos();
          }
      
          return cachedReportedPosDetails;
        }
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        reportedPos = Math.max(pos, rightmostFailuresPos);
        var found = reportedPos < input.length ? input.charAt(reportedPos) : null;
        var reportedPosDetails = computeReportedPosDetails();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          reportedPos,
          reportedPosDetails.line,
          reportedPosDetails.column
        );
      }
      
      return result;
    }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  subclass(result.SyntaxError, Error);
  
  return result;
})();

},{"../package.json":48,"./nodes":27}],30:[function(require,module,exports){
// Generated by CoffeeScript 2.0.0-beta8
var DEDENT, INDENT, pointToErrorLocation, Preprocessor, StringScanner, TERM, ws;
pointToErrorLocation = require('./helpers').pointToErrorLocation;
StringScanner = require('StringScanner');
this.Preprocessor = Preprocessor = function () {
  ws = '\\t\\x0B\\f\\r \\xA0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF';
  INDENT = '\uefef';
  DEDENT = '\ueffe';
  TERM = '\uefff';
  function Preprocessor(param$) {
    if (null == param$)
      param$ = {};
    this.options = param$;
    this.preprocessed = '';
    this.base = null;
    this.indents = [];
    this.context = [];
  }
  Preprocessor.process = function (input, options) {
    if (null == options)
      options = {};
    return new Preprocessor(options).process(input);
  };
  Preprocessor.prototype.err = function (c) {
    var columns, context, lines, token;
    token = function () {
      switch (c) {
      case INDENT:
        return 'INDENT';
      case DEDENT:
        return 'DEDENT';
      case TERM:
        return 'TERM';
      default:
        return '"' + c.replace(/"/g, '\\"') + '"';
      }
    }.call(this);
    lines = this.ss.str.substr(0, this.ss.pos).split(/\n/) || [''];
    columns = null != lines[lines.length - 1] ? lines[lines.length - 1].length : 0;
    context = pointToErrorLocation(this.ss.str, lines.length, columns);
    throw new Error('Unexpected ' + token + '\n' + context);
  };
  Preprocessor.prototype.peek = function () {
    if (this.context.length) {
      return this.context[this.context.length - 1];
    } else {
      return null;
    }
  };
  Preprocessor.prototype.observe = function (c) {
    var top;
    top = this.peek();
    switch (c) {
    case '"""':
    case "'''":
    case '"':
    case "'":
    case '###':
    case '`':
    case '///':
    case '/':
      if (top === c) {
        this.context.pop();
      } else {
        this.context.push(c);
      }
      break;
    case INDENT:
    case '#':
    case '#{':
    case '[':
    case '(':
    case '{':
    case '\\':
    case 'regexp-[':
    case 'regexp-(':
    case 'regexp-{':
    case 'heregexp-#':
    case 'heregexp-[':
    case 'heregexp-(':
    case 'heregexp-{':
      this.context.push(c);
      break;
    case DEDENT:
      if (!(top === INDENT))
        this.err(c);
      this.indents.pop();
      this.context.pop();
      break;
    case '\n':
      if (!(top === '#' || top === 'heregexp-#'))
        this.err(c);
      this.context.pop();
      break;
    case ']':
      if (!(top === '[' || top === 'regexp-[' || top === 'heregexp-['))
        this.err(c);
      this.context.pop();
      break;
    case ')':
      if (!(top === '(' || top === 'regexp-(' || top === 'heregexp-('))
        this.err(c);
      this.context.pop();
      break;
    case '}':
      if (!(top === '#{' || top === '{' || top === 'regexp-{' || top === 'heregexp-{'))
        this.err(c);
      this.context.pop();
      break;
    case 'end-\\':
      if (!(top === '\\'))
        this.err(c);
      this.context.pop();
      break;
    default:
      throw new Error('undefined token observed: ' + c);
    }
    return this.context;
  };
  Preprocessor.prototype.p = function (s) {
    if (null != s)
      this.preprocessed = '' + this.preprocessed + s;
    return s;
  };
  Preprocessor.prototype.scan = function (r) {
    return this.p(this.ss.scan(r));
  };
  Preprocessor.prototype.consumeIndentation = function () {
    var context, indent, indentIndex, lineLen, lines, message;
    if (this.ss.bol() || this.scan(new RegExp('(?:[' + ws + ']*\\n)+'))) {
      this.scan(new RegExp('(?:[' + ws + ']*(\\#\\#?(?!\\#)[^\\n]*)?\\n)+'));
      if (null != this.base) {
        if (!(this.ss.eos() || null != this.scan(this.base))) {
          throw new Error('inconsistent base indentation');
        }
      } else {
        this.base = new RegExp('' + this.scan(new RegExp('[' + ws + ']*')) + '');
      }
      indentIndex = 0;
      while (indentIndex < this.indents.length) {
        indent = this.indents[indentIndex];
        if (this.ss.check(new RegExp('' + indent + ''))) {
          this.scan(new RegExp('' + indent + ''));
        } else if (this.ss.eos() || this.ss.check(new RegExp('[^' + ws + ']'))) {
          --indentIndex;
          this.p('' + DEDENT + TERM);
          this.observe(DEDENT);
        } else {
          lines = this.ss.str.substr(0, this.ss.pos).split(/\n/) || [''];
          message = 'Syntax error on line ' + lines.length + ': indentation is ambiguous';
          lineLen = this.indents.reduce(function (l, r) {
            return l + r.length;
          }, 0);
          context = pointToErrorLocation(this.ss.str, lines.length, lineLen);
          throw new Error('' + message + '\n' + context);
        }
        ++indentIndex;
      }
      if (this.ss.check(new RegExp('[' + ws + ']+[^' + ws + '#]'))) {
        this.indents.push(this.scan(new RegExp('[' + ws + ']+')));
        this.p(INDENT);
        return this.observe(INDENT);
      }
    }
  };
  Preprocessor.prototype.introduceContext = function () {
    var impliedRegexp, lastChar, pos, spaceBefore, tok;
    if (tok = this.scan(/"""|'''|\/\/\/|###|["'`#[({\\]/)) {
      return this.observe(tok);
    } else if (tok = this.scan(/\//)) {
      pos = this.ss.position();
      if (pos > 1) {
        lastChar = this.ss.string()[pos - 2];
        spaceBefore = new RegExp('[' + ws + ']').test(lastChar);
        impliedRegexp = /[;,=><*%^&|[(+!~-]/.test(lastChar);
      }
      if (pos === 1 || impliedRegexp || spaceBefore && !this.ss.check(new RegExp('[' + ws + '=]')) && this.ss.check(/[^\r\n]*\//))
        return this.observe('/');
    }
  };
  Preprocessor.prototype.process = function (input) {
    var tok;
    if (this.options.literate)
      input = input.replace(/^( {0,3}\S)/gm, '    #$1');
    this.ss = new StringScanner(input);
    while (!this.ss.eos()) {
      switch (this.peek()) {
      case null:
      case INDENT:
        this.consumeIndentation();
        this.scan(/[^\n'"\\\/#`[(){}\]]+/);
        if (this.ss.check(/[})\]]/)) {
          while (this.peek() === INDENT) {
            this.p('' + DEDENT + TERM);
            this.observe(DEDENT);
          }
          this.observe(this.scan(/[})\]]/));
        } else {
          this.introduceContext();
        }
        break;
      case '#{':
      case '{':
        this.scan(/[^\n'"\\\/#`[({}]+/);
        if (tok = this.scan(/\}/)) {
          this.observe(tok);
        } else {
          this.consumeIndentation();
          this.introduceContext();
        }
        break;
      case '[':
        this.scan(/[^\n'"\\\/#`[({\]]+/);
        if (tok = this.scan(/\]/)) {
          this.observe(tok);
        } else {
          this.consumeIndentation();
          this.introduceContext();
        }
        break;
      case '(':
        this.scan(/[^\n'"\\\/#`[({)]+/);
        if (tok = this.scan(/\)/)) {
          this.observe(tok);
        } else {
          this.consumeIndentation();
          this.introduceContext();
        }
        break;
      case '\\':
        if (this.scan(/[\s\S]/))
          this.observe('end-\\');
        break;
      case '"""':
        this.scan(/(?:[^"#\\]+|""?(?!")|#(?!{)|\\.)+/);
        this.ss.scan(/\\\n/);
        if (tok = this.scan(/#{|"""/)) {
          this.observe(tok);
        } else if (tok = this.scan(/#{|"""/)) {
          this.observe(tok);
        }
        break;
      case '"':
        this.scan(/(?:[^"#\\]+|#(?!{)|\\.)+/);
        this.ss.scan(/\\\n/);
        if (tok = this.scan(/#{|"/))
          this.observe(tok);
        break;
      case "'''":
        this.scan(/(?:[^'\\]+|''?(?!')|\\.)+/);
        this.ss.scan(/\\\n/);
        if (tok = this.scan(/'''/))
          this.observe(tok);
        break;
      case "'":
        this.scan(/(?:[^'\\]+|\\.)+/);
        this.ss.scan(/\\\n/);
        if (tok = this.scan(/'/))
          this.observe(tok);
        break;
      case '###':
        this.scan(/(?:[^#]+|##?(?!#))+/);
        if (tok = this.scan(/###/))
          this.observe(tok);
        break;
      case '#':
        this.scan(/[^\n]+/);
        if (tok = this.scan(/\n/))
          this.observe(tok);
        break;
      case '`':
        this.scan(/[^`]+/);
        if (tok = this.scan(/`/))
          this.observe(tok);
        break;
      case '///':
        this.scan(/(?:[^[/#\\]+|\/\/?(?!\/)|\\.)+/);
        if (tok = this.scan(/#{|\/\/\/|\\/)) {
          this.observe(tok);
        } else if (this.ss.scan(/#/)) {
          this.observe('heregexp-#');
        } else if (tok = this.scan(/[\[]/)) {
          this.observe('heregexp-' + tok);
        }
        break;
      case 'heregexp-[':
        this.scan(/(?:[^\]\/\\]+|\/\/?(?!\/))+/);
        if (tok = this.scan(/[\]\\]|#{|\/\/\//))
          this.observe(tok);
        break;
      case 'heregexp-#':
        this.ss.scan(/(?:[^\n/]+|\/\/?(?!\/))+/);
        if (tok = this.scan(/\n|\/\/\//))
          this.observe(tok);
        break;
      case '/':
        this.scan(/[^[/\\]+/);
        if (tok = this.scan(/[\/\\]/)) {
          this.observe(tok);
        } else if (tok = this.scan(/\[/)) {
          this.observe('regexp-' + tok);
        }
        break;
      case 'regexp-[':
        this.scan(/[^\]\\]+/);
        if (tok = this.scan(/[\]\\]/))
          this.observe(tok);
      }
    }
    this.scan(new RegExp('[' + ws + '\\n]*$'));
    while (this.context.length) {
      switch (this.peek()) {
      case INDENT:
        this.p('' + DEDENT + TERM);
        this.observe(DEDENT);
        break;
      case '#':
        this.p('\n');
        this.observe('\n');
        break;
      default:
        throw new Error('Unclosed "' + this.peek().replace(/"/g, '\\"') + '" at EOF');
      }
    }
    return this.preprocessed;
  };
  return Preprocessor;
}();

},{"./helpers":24,"StringScanner":33}],31:[function(require,module,exports){
// Generated by CoffeeScript 2.0.0-beta8
var child_process, coffeeBinary, CoffeeScript, fork, fs, path, runModule;
child_process = require('child_process');
fs = require('fs');
path = require('path');
CoffeeScript = require('./module');
runModule = require('./run').runModule;
module.exports = !(null != require.extensions['.coffee']);
if (null != require.extensions['.coffee'])
  require.extensions['.coffee'];
else
  require.extensions['.coffee'] = function (module, filename) {
    var csAst, input, js, jsAst;
    input = fs.readFileSync(filename, 'utf8');
    csAst = CoffeeScript.parse(input, { raw: true });
    jsAst = CoffeeScript.compile(csAst);
    js = CoffeeScript.js(jsAst);
    return runModule(module, js, jsAst, filename);
  };
if (null != require.extensions['.litcoffee'])
  require.extensions['.litcoffee'];
else
  require.extensions['.litcoffee'] = function (module, filename) {
    var csAst, input, js, jsAst;
    input = fs.readFileSync(filename, 'utf8');
    csAst = CoffeeScript.parse(input, {
      raw: true,
      literate: true
    });
    jsAst = CoffeeScript.compile(csAst);
    js = CoffeeScript.js(jsAst);
    return runModule(module, js, jsAst, filename);
  };
fork = child_process.fork;
if (!fork.coffeePatched) {
  coffeeBinary = path.resolve('bin', 'coffee');
  child_process.fork = function (file, args, options) {
    if (null == args)
      args = [];
    if (null == options)
      options = {};
    if (in$(path.extname(file), [
        '.coffee',
        '.litcoffee'
      ])) {
      if (!Array.isArray(args)) {
        args = [];
        options = args || {};
      }
      options.execPath || (options.execPath = coffeeBinary);
    }
    return fork(file, args, options);
  };
  child_process.fork.coffeePatched = true;
}
function in$(member, list) {
  for (var i = 0, length = list.length; i < length; ++i)
    if (i in list && list[i] === member)
      return true;
  return false;
}

},{"./module":26,"./run":32,"child_process":56,"fs":56,"path":63}],32:[function(require,module,exports){
(function (process){// Generated by CoffeeScript 2.0.0-beta8
var CoffeeScript, formatSourcePosition, Module, patched, patchStackTrace, path, runMain, runModule, SourceMapConsumer;
path = require('path');
Module = require('module');
CoffeeScript = require('./module');
SourceMapConsumer = require('source-map').SourceMapConsumer;
patched = false;
patchStackTrace = function () {
  if (patched)
    return;
  patched = true;
  if (null != Module._sourceMaps)
    Module._sourceMaps;
  else
    Module._sourceMaps = {};
  return Error.prepareStackTrace = function (err, stack) {
    var frame, frames, getSourceMapping, sourceFiles;
    sourceFiles = {};
    getSourceMapping = function (filename, line, column) {
      var mapString, sourceMap;
      mapString = 'function' === typeof Module._sourceMaps[filename] ? Module._sourceMaps[filename]() : void 0;
      if (mapString) {
        sourceMap = null != sourceFiles[filename] ? sourceFiles[filename] : sourceFiles[filename] = new SourceMapConsumer(mapString);
        return sourceMap.originalPositionFor({
          line: line,
          column: column
        });
      }
    };
    frames = function (accum$) {
      for (var i$ = 0, length$ = stack.length; i$ < length$; ++i$) {
        frame = stack[i$];
        if (frame.getFunction() === exports.runMain)
          break;
        accum$.push('  at ' + formatSourcePosition(frame, getSourceMapping));
      }
      return accum$;
    }.call(this, []);
    return '' + err.name + ': ' + (null != err.message ? err.message : '') + '\n' + frames.join('\n') + '\n';
  };
};
formatSourcePosition = function (frame, getSourceMapping) {
  var as, column, fileLocation, fileName, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;
  fileName = void 0;
  fileLocation = '';
  if (frame.isNative()) {
    fileLocation = 'native';
  } else {
    if (frame.isEval()) {
      fileName = frame.getScriptNameOrSourceURL();
      if (!fileName)
        fileLocation = '' + frame.getEvalOrigin() + ', ';
    } else {
      fileName = frame.getFileName();
    }
    fileName || (fileName = '<anonymous>');
    line = frame.getLineNumber();
    column = frame.getColumnNumber();
    source = getSourceMapping(fileName, line, column);
    fileLocation = source ? '' + fileName + ':' + source.line + ':' + (source.column + 1) + ', <js>:' + line + ':' + column : '' + fileName + ':' + line + ':' + column;
  }
  functionName = frame.getFunctionName();
  isConstructor = frame.isConstructor();
  isMethodCall = !(frame.isToplevel() || isConstructor);
  if (isMethodCall) {
    methodName = frame.getMethodName();
    typeName = frame.getTypeName();
    if (functionName) {
      tp = as = '';
      if (typeName && functionName.indexOf(typeName))
        tp = '' + typeName + '.';
      if (methodName && functionName.indexOf('.' + methodName) !== functionName.length - methodName.length - 1)
        as = ' [as ' + methodName + ']';
      return '' + tp + functionName + as + ' (' + fileLocation + ')';
    } else {
      return '' + typeName + '.' + (methodName || '<anonymous>') + ' (' + fileLocation + ')';
    }
  } else if (isConstructor) {
    return 'new ' + (functionName || '<anonymous>') + ' (' + fileLocation + ')';
  } else if (functionName) {
    return '' + functionName + ' (' + fileLocation + ')';
  } else {
    return fileLocation;
  }
};
runMain = function (csSource, jsSource, jsAst, filename) {
  var mainModule;
  mainModule = new Module('.');
  mainModule.filename = process.argv[1] = filename;
  process.mainModule = mainModule;
  Module._cache[mainModule.filename] = mainModule;
  mainModule.paths = Module._nodeModulePaths(path.dirname(filename));
  return runModule(mainModule, jsSource, jsAst, filename);
};
runModule = function (module, jsSource, jsAst, filename) {
  patchStackTrace();
  Module._sourceMaps[filename] = function () {
    return '' + CoffeeScript.sourceMap(jsAst, filename);
  };
  return module._compile(jsSource, filename);
};
module.exports = {
  runMain: runMain,
  runModule: runModule
};
}).call(this,require("/Users/honambang/git/aether/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./module":26,"/Users/honambang/git/aether/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":62,"module":56,"path":63,"source-map":38}],33:[function(require,module,exports){
(function() {
  var StringScanner;
  StringScanner = (function() {
    function StringScanner(str) {
      this.str = str != null ? str : '';
      this.str = '' + this.str;
      this.pos = 0;
      this.lastMatch = {
        reset: function() {
          this.str = null;
          this.captures = [];
          return this;
        }
      }.reset();
      this;
    }
    StringScanner.prototype.bol = function() {
      return this.pos <= 0 || (this.str[this.pos - 1] === "\n");
    };
    StringScanner.prototype.captures = function() {
      return this.lastMatch.captures;
    };
    StringScanner.prototype.check = function(pattern) {
      var matches;
      if (this.str.substr(this.pos).search(pattern) !== 0) {
        this.lastMatch.reset();
        return null;
      }
      matches = this.str.substr(this.pos).match(pattern);
      this.lastMatch.str = matches[0];
      this.lastMatch.captures = matches.slice(1);
      return this.lastMatch.str;
    };
    StringScanner.prototype.checkUntil = function(pattern) {
      var matches, patternPos;
      patternPos = this.str.substr(this.pos).search(pattern);
      if (patternPos < 0) {
        this.lastMatch.reset();
        return null;
      }
      matches = this.str.substr(this.pos + patternPos).match(pattern);
      this.lastMatch.captures = matches.slice(1);
      return this.lastMatch.str = this.str.substr(this.pos, patternPos) + matches[0];
    };
    StringScanner.prototype.clone = function() {
      var clone, prop, value, _ref;
      clone = new this.constructor(this.str);
      clone.pos = this.pos;
      clone.lastMatch = {};
      _ref = this.lastMatch;
      for (prop in _ref) {
        value = _ref[prop];
        clone.lastMatch[prop] = value;
      }
      return clone;
    };
    StringScanner.prototype.concat = function(str) {
      this.str += str;
      return this;
    };
    StringScanner.prototype.eos = function() {
      return this.pos === this.str.length;
    };
    StringScanner.prototype.exists = function(pattern) {
      var matches, patternPos;
      patternPos = this.str.substr(this.pos).search(pattern);
      if (patternPos < 0) {
        this.lastMatch.reset();
        return null;
      }
      matches = this.str.substr(this.pos + patternPos).match(pattern);
      this.lastMatch.str = matches[0];
      this.lastMatch.captures = matches.slice(1);
      return patternPos;
    };
    StringScanner.prototype.getch = function() {
      return this.scan(/./);
    };
    StringScanner.prototype.match = function() {
      return this.lastMatch.str;
    };
    StringScanner.prototype.matches = function(pattern) {
      this.check(pattern);
      return this.matchSize();
    };
    StringScanner.prototype.matched = function() {
      return this.lastMatch.str != null;
    };
    StringScanner.prototype.matchSize = function() {
      if (this.matched()) {
        return this.match().length;
      } else {
        return null;
      }
    };
    StringScanner.prototype.peek = function(len) {
      return this.str.substr(this.pos, len);
    };
    StringScanner.prototype.pointer = function() {
      return this.pos;
    };
    StringScanner.prototype.setPointer = function(pos) {
      pos = +pos;
      if (pos < 0) {
        pos = 0;
      }
      if (pos > this.str.length) {
        pos = this.str.length;
      }
      return this.pos = pos;
    };
    StringScanner.prototype.reset = function() {
      this.lastMatch.reset();
      this.pos = 0;
      return this;
    };
    StringScanner.prototype.rest = function() {
      return this.str.substr(this.pos);
    };
    StringScanner.prototype.scan = function(pattern) {
      var chk;
      chk = this.check(pattern);
      if (chk != null) {
        this.pos += chk.length;
      }
      return chk;
    };
    StringScanner.prototype.scanUntil = function(pattern) {
      var chk;
      chk = this.checkUntil(pattern);
      if (chk != null) {
        this.pos += chk.length;
      }
      return chk;
    };
    StringScanner.prototype.skip = function(pattern) {
      this.scan(pattern);
      return this.matchSize();
    };
    StringScanner.prototype.skipUntil = function(pattern) {
      this.scanUntil(pattern);
      return this.matchSize();
    };
    StringScanner.prototype.string = function() {
      return this.str;
    };
    StringScanner.prototype.terminate = function() {
      this.pos = this.str.length;
      this.lastMatch.reset();
      return this;
    };
    StringScanner.prototype.toString = function() {
      return "#<StringScanner " + (this.eos() ? 'fin' : "" + this.pos + "/" + this.str.length + " @ " + (this.str.length > 8 ? "" + (this.str.substr(0, 5)) + "..." : this.str)) + ">";
    };
    return StringScanner;
  })();
  StringScanner.prototype.beginningOfLine = StringScanner.prototype.bol;
  StringScanner.prototype.clear = StringScanner.prototype.terminate;
  StringScanner.prototype.dup = StringScanner.prototype.clone;
  StringScanner.prototype.endOfString = StringScanner.prototype.eos;
  StringScanner.prototype.exist = StringScanner.prototype.exists;
  StringScanner.prototype.getChar = StringScanner.prototype.getch;
  StringScanner.prototype.position = StringScanner.prototype.pointer;
  StringScanner.StringScanner = StringScanner;
  module.exports = StringScanner;
}).call(this);

},{}],34:[function(require,module,exports){
// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  (function(exports) {
    var TAB, clone, eq, formatInterpolation, formatStringData, generate, indent, levels, needsParensWhenOnLeft, operators, parens, precedence;
    TAB = '  ';
    indent = function(code) {
      var line;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = code.split('\n');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          _results.push("" + TAB + line);
        }
        return _results;
      })()).join('\n');
    };
    parens = function(code) {
      return "(" + code + ")";
    };
    formatStringData = function(data) {
      return data.replace(/[^\x20-\x7e]|['\\]/, function(c) {
        var escape, pad;
        switch (c) {
          case '\0':
            return '\\0';
          case '\b':
            return '\\b';
          case '\t':
            return '\\t';
          case '\n':
            return '\\n';
          case '\f':
            return '\\f';
          case '\r':
            return '\\r';
          case '\'':
            return '\\\'';
          case '\\':
            return '\\\\';
          default:
            escape = (c.charCodeAt(0)).toString(16);
            pad = "0000".slice(escape.length);
            return "\\u" + pad + escape;
        }
      });
    };
    formatInterpolation = function(ast, options) {
      var left, right;
      switch (ast.className) {
        case "ConcatOp":
          left = formatInterpolation(ast.left, options);
          right = formatInterpolation(ast.right, options);
          return "" + left + right;
        case "String":
          return formatStringData(ast.data);
        default:
          return "\#{" + (generate(ast, options)) + "}";
      }
    };
    needsParensWhenOnLeft = function(ast) {
      switch (ast.className) {
        case 'Function':
        case 'BoundFunction':
        case 'NewOp':
          return true;
        case 'Conditional':
        case 'Switch':
        case 'While':
        case 'Block':
          return true;
        case 'PreIncrementOp':
        case 'PreDecrementOp':
        case 'UnaryPlusOp':
        case 'UnaryNegateOp':
        case 'LogicalNotOp':
        case 'BitNotOp':
        case 'DoOp':
        case 'TypeofOp':
        case 'DeleteOp':
          return needsParensWhenOnLeft(ast.expression);
        case 'FunctionApplication':
          return ast["arguments"].length > 0;
        default:
          return false;
      }
    };
    eq = function(nodeA, nodeB) {
      var i, prop, v, val, _i, _len;
      for (prop in nodeA) {
        if (!__hasProp.call(nodeA, prop)) continue;
        val = nodeA[prop];
        if (prop === 'raw' || prop === 'line' || prop === 'column') {
          continue;
        }
        switch (Object.prototype.toString.call(val)) {
          case '[object Object]':
            if (!eq(nodeB[prop], val)) {
              return false;
            }
            break;
          case '[object Array]':
            for (i = _i = 0, _len = val.length; _i < _len; i = ++_i) {
              v = val[i];
              if (!eq(nodeB[prop][i], v)) {
                return false;
              }
            }
            break;
          default:
            if (nodeB[prop] !== val) {
              return false;
            }
        }
      }
      return true;
    };
    clone = function(obj, overrides) {
      var newObj, prop, val;
      if (overrides == null) {
        overrides = {};
      }
      newObj = {};
      for (prop in obj) {
        if (!__hasProp.call(obj, prop)) continue;
        val = obj[prop];
        newObj[prop] = val;
      }
      for (prop in overrides) {
        if (!__hasProp.call(overrides, prop)) continue;
        val = overrides[prop];
        newObj[prop] = val;
      }
      return newObj;
    };
    levels = [['SeqOp'], ['Conditional', 'ForIn', 'ForOf', 'While'], ['FunctionApplication', 'SoakedFunctionApplication'], ['AssignOp', 'CompoundAssignOp', 'ExistsAssignOp'], ['LogicalOrOp'], ['LogicalAndOp'], ['BitOrOp'], ['BitXorOp'], ['BitAndOp'], ['ExistsOp'], ['EQOp', 'NEQOp'], ['LTOp', 'LTEOp', 'GTOp', 'GTEOp', 'InOp', 'OfOp', 'InstanceofOp'], ['LeftShiftOp', 'SignedRightShiftOp', 'UnsignedRightShiftOp'], ['PlusOp', 'SubtractOp'], ['MultiplyOp', 'DivideOp', 'RemOp'], ['UnaryPlusOp', 'UnaryNegateOp', 'LogicalNotOp', 'BitNotOp', 'DoOp', 'TypeofOp', 'PreIncrementOp', 'PreDecrementOp', 'DeleteOp'], ['UnaryExistsOp', 'ShallowCopyArray', 'PostIncrementOp', 'PostDecrementOp', 'Spread'], ['NewOp'], ['MemberAccessOp', 'SoakedMemberAccessOp', 'DynamicMemberAccessOp', 'SoakedDynamicMemberAccessOp', 'ProtoMemberAccessOp', 'DynamicProtoMemberAccessOp', 'SoakedProtoMemberAccessOp', 'SoakedDynamicProtoMemberAccessOp']];
    precedence = {};
    (function() {
      var level, op, ops, _i, _len, _results;
      _results = [];
      for (level = _i = 0, _len = levels.length; _i < _len; level = ++_i) {
        ops = levels[level];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = ops.length; _j < _len1; _j++) {
            op = ops[_j];
            _results1.push(precedence[op] = level);
          }
          return _results1;
        })());
      }
      return _results;
    })();
    operators = {
      SeqOp: ';',
      LogicalOrOp: 'or',
      LogicalAndOp: 'and',
      BitOrOp: '|',
      BitXorOp: '^',
      BitAndOp: '&',
      EQOp: 'is',
      NEQOp: 'isnt',
      LTOp: '<',
      LTEOp: '<=',
      GTOp: '>',
      GTEOp: '>=',
      InOp: 'in',
      OfOp: 'of',
      InstanceofOp: 'instanceof',
      LeftShiftOp: '<<',
      SignedRightShiftOp: '>>',
      UnsignedRightShiftOp: '>>>',
      PlusOp: '+',
      SubtractOp: '-',
      MultiplyOp: '*',
      DivideOp: '/',
      RemOp: '%',
      UnaryPlusOp: '+',
      UnaryNegateOp: '-',
      LogicalNotOp: 'not ',
      BitNotOp: '~',
      DoOp: 'do ',
      NewOp: 'new ',
      TypeofOp: 'typeof ',
      PreIncrementOp: '++',
      PreDecrementOp: '--',
      UnaryExistsOp: '?',
      ShallowCopyArray: '[..]',
      PostIncrementOp: '++',
      PostDecrementOp: '--',
      Spread: '...',
      FunctionApplication: '',
      SoakedFunctionApplication: '?',
      MemberAccessOp: '.',
      SoakedMemberAccessOp: '?.',
      ProtoMemberAccessOp: '::',
      SoakedProtoMemberAccessOp: '?::',
      DynamicMemberAccessOp: '',
      SoakedDynamicMemberAccessOp: '?',
      DynamicProtoMemberAccessOp: '::',
      SoakedDynamicProtoMemberAccessOp: '?::'
    };
    return exports.generate = generate = function(ast, options) {
      var a, absNum, arg, args, expression_, hasAlternate, i, isMultiline, key_, m, memberAccessOps, members_, needsParens, p, parameters, parent, parentClassName, prec, s, sep, src, usedAsExpression, _alternate, _argList, _args, _assignee, _block, _body, _consequent, _ctor, _expr, _fn, _indexingExpr, _left, _op, _paramList, _ref, _ref1, _right;
      if (options == null) {
        options = {};
      }
      needsParens = false;
      if ((_ref = options.precedence) == null) {
        options.precedence = 0;
      }
      if ((_ref1 = options.ancestors) == null) {
        options.ancestors = [];
      }
      parent = options.ancestors[0];
      parentClassName = parent != null ? parent.className : void 0;
      usedAsExpression = (parent != null) && parentClassName !== 'Block';
      src = (function() {
        var _i, _len, _ref2, _ref3, _ref4, _ref5, _ref6;
        switch (ast.className) {
          case 'Program':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            if (ast.body != null) {
              return generate(ast.body, options);
            } else {
              return '';
            }
            break;
          case 'Block':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: 0
            });
            if (ast.statements.length === 0) {
              return generate((new Undefined).g(), options);
            } else {
              sep = parentClassName === 'Program' ? '\n\n' : '\n';
              return ((function() {
                var _i, _len, _ref2, _results;
                _ref2 = ast.statements;
                _results = [];
                for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                  s = _ref2[_i];
                  _results.push(generate(s, options));
                }
                return _results;
              })()).join(sep);
            }
            break;
          case 'Conditional':
            options.ancestors.unshift(ast);
            options.precedence = 0;
            hasAlternate = (ast.consequent != null) && (ast.alternate != null);
            _consequent = generate((_ref2 = ast.consequent) != null ? _ref2 : (new Undefined).g(), options);
            _alternate = hasAlternate ? generate(ast.alternate, options) : "";
            isMultiline = _consequent.length > 90 || _alternate.length > 90 || __indexOf.call(_alternate, '\n') >= 0 || __indexOf.call(_consequent, '\n') >= 0;
            _consequent = isMultiline ? "\n" + (indent(_consequent)) : " then " + _consequent;
            if (hasAlternate) {
              _alternate = isMultiline ? "\nelse\n" + (indent(_alternate)) : " else " + _alternate;
            }
            return "if " + (generate(ast.condition, options)) + _consequent + _alternate;
          case 'Identifier':
            return ast.data;
          case 'Null':
            return 'null';
          case 'This':
            return 'this';
          case 'Undefined':
            return 'undefined';
          case 'Int':
            absNum = ast.data < 0 ? -ast.data : ast.data;
            if (absNum >= 1e12 || (absNum >= 0x10 && 0 === (absNum & (absNum - 1)))) {
              return "0x" + (ast.data.toString(16));
            } else {
              return ast.data.toString(10);
            }
            break;
          case 'Float':
            return ast.data.toString(10);
          case 'String':
            return "'" + (formatStringData(ast.data)) + "'";
          case 'ArrayInitialiser':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: precedence.AssignmentExpression
            });
            members_ = (function() {
              var _i, _len, _ref3, _results;
              _ref3 = ast.members;
              _results = [];
              for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
                m = _ref3[_i];
                _results.push(generate(m, options));
              }
              return _results;
            })();
            switch (ast.members.length) {
              case 0:
                return '[]';
              case 1:
              case 2:
                for (i = _i = 0, _len = members_.length; _i < _len; i = ++_i) {
                  m = members_[i];
                  if (i + 1 !== members_.length) {
                    if (needsParensWhenOnLeft(ast.members[i])) {
                      members_[i] = parens(m);
                    }
                  }
                }
                return "[" + (members_.join(', ')) + "]";
              default:
                return "[\n" + (indent(members_.join('\n'))) + "\n]";
            }
            break;
          case 'ObjectInitialiser':
            options.ancestors = [ast].concat(__slice.call(options.ancestors));
            members_ = (function() {
              var _j, _len1, _ref3, _results;
              _ref3 = ast.members;
              _results = [];
              for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
                m = _ref3[_j];
                _results.push(generate(m, options));
              }
              return _results;
            })();
            switch (ast.members.length) {
              case 0:
                return '{}';
              case 1:
                return "{" + (members_.join(', ')) + "}";
              default:
                return "{\n" + (indent(members_.join('\n'))) + "\n}";
            }
            break;
          case 'ObjectInitialiserMember':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: precedence.AssignmentExpression
            });
            key_ = generate(ast.key, options);
            expression_ = generate(ast.expression, options);
            memberAccessOps = ['MemberAccessOp', 'ProtoMemberAccessOp', 'SoakedMemberAccessOp', 'SoakedProtoMemberAccessOp'];
            if (eq(ast.key, ast.expression)) {
              return "" + key_;
            } else if ((_ref3 = ast.expression.className, __indexOf.call(memberAccessOps, _ref3) >= 0) && ast.key.data === ast.expression.memberName) {
              return "" + expression_;
            } else {
              return "" + key_ + ": " + expression_;
            }
            break;
          case 'Function':
          case 'BoundFunction':
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: precedence.AssignmentExpression
            });
            parameters = (function() {
              var _j, _len1, _ref4, _results;
              _ref4 = ast.parameters;
              _results = [];
              for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
                p = _ref4[_j];
                _results.push(generate(p, options));
              }
              return _results;
            })();
            options.precedence = 0;
            _body = !(ast.body != null) || ast.body.className === 'Undefined' ? '' : generate(ast.body, options);
            _paramList = ast.parameters.length > 0 ? "(" + (parameters.join(', ')) + ") " : '';
            _block = _body.length === 0 ? '' : _paramList.length + _body.length < 100 && __indexOf.call(_body, '\n') < 0 ? " " + _body : "\n" + (indent(_body));
            switch (ast.className) {
              case 'Function':
                return "" + _paramList + "->" + _block;
              case 'BoundFunction':
                return "" + _paramList + "=>" + _block;
            }
            break;
          case 'AssignOp':
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _assignee = generate(ast.assignee, options);
            _expr = generate(ast.expression, options);
            return "" + _assignee + " = " + _expr;
          case 'CompoundAssignOp':
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _op = operators[ast.op.prototype.className];
            _assignee = generate(ast.assignee, options);
            _expr = generate(ast.expression, options);
            return "" + _assignee + " " + _op + "= " + _expr;
          case 'SeqOp':
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _left = generate(ast.left, options);
            _right = generate(ast.right, options);
            return "" + _left + "; " + _right;
          case 'LogicalOrOp':
          case 'LogicalAndOp':
          case 'BitOrOp':
          case 'BitXorOp':
          case 'BitAndOp':
          case 'LeftShiftOp':
          case 'SignedRightShiftOp':
          case 'UnsignedRightShiftOp':
          case 'EQOp':
          case 'NEQOp':
          case 'LTOp':
          case 'LTEOp':
          case 'GTOp':
          case 'GTEOp':
          case 'InOp':
          case 'OfOp':
          case 'InstanceofOp':
          case 'PlusOp':
          case 'SubtractOp':
          case 'MultiplyOp':
          case 'DivideOp':
          case 'RemOp':
          case 'ExistsOp':
            _op = operators[ast.className];
            if (((_ref4 = ast.className) === 'InOp' || _ref4 === 'OfOp' || _ref4 === 'InstanceofOp') && parentClassName === 'LogicalNotOp') {
              _op = "not " + _op;
            }
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _left = generate(ast.left, options);
            if (needsParensWhenOnLeft(ast.left)) {
              _left = parens(_left);
            }
            _right = generate(ast.right, options);
            return "" + _left + " " + _op + " " + _right;
          case 'UnaryPlusOp':
          case 'UnaryNegateOp':
          case 'LogicalNotOp':
          case 'BitNotOp':
          case 'DoOp':
          case 'TypeofOp':
          case 'PreIncrementOp':
          case 'PreDecrementOp':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            if (ast.className === 'LogicalNotOp') {
              if ((_ref5 = ast.expression.className) === 'InOp' || _ref5 === 'OfOp' || _ref5 === 'InstanceofOp') {
                _op = '';
                prec = precedence[ast.expression.className];
              }
              if ('LogicalNotOp' === parentClassName || 'LogicalNotOp' === ast.expression.className) {
                _op = '!';
              }
            }
            needsParens = prec < options.precedence;
            if (parentClassName === ast.className && ((_ref6 = ast.className) === 'UnaryPlusOp' || _ref6 === 'UnaryNegateOp')) {
              needsParens = true;
            }
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            return "" + _op + (generate(ast.expression, options));
          case 'UnaryExistsOp':
          case 'PostIncrementOp':
          case 'PostDecrementOp':
          case 'Spread':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _expr = generate(ast.expression, options);
            if (needsParensWhenOnLeft(ast.expression)) {
              _expr = parens(_expr);
            }
            return "" + _expr + _op;
          case 'NewOp':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            _ctor = generate(ast.ctor, options);
            if (ast["arguments"].length > 0 && needsParensWhenOnLeft(ast.ctor)) {
              _ctor = parens(_ctor);
            }
            options.precedence = precedence['AssignOp'];
            args = (function() {
              var _j, _len1, _ref7, _results;
              _ref7 = ast["arguments"];
              _results = [];
              for (i = _j = 0, _len1 = _ref7.length; _j < _len1; i = ++_j) {
                a = _ref7[i];
                arg = generate(a, options);
                if ((needsParensWhenOnLeft(a)) && i + 1 !== ast["arguments"].length) {
                  arg = parens(arg);
                }
                _results.push(arg);
              }
              return _results;
            })();
            _args = ast["arguments"].length === 0 ? '' : " " + (args.join(', '));
            return "" + _op + _ctor + _args;
          case 'FunctionApplication':
          case 'SoakedFunctionApplication':
            if (ast.className === 'FunctionApplication' && ast["arguments"].length === 0 && !usedAsExpression) {
              return generate(new DoOp(ast["function"]), options);
            } else {
              options = clone(options, {
                ancestors: [ast].concat(__slice.call(options.ancestors)),
                precedence: precedence[ast.className]
              });
              _op = operators[ast.className];
              _fn = generate(ast["function"], options);
              if (needsParensWhenOnLeft(ast["function"])) {
                _fn = parens(_fn);
              }
              args = (function() {
                var _j, _len1, _ref7, _results;
                _ref7 = ast["arguments"];
                _results = [];
                for (i = _j = 0, _len1 = _ref7.length; _j < _len1; i = ++_j) {
                  a = _ref7[i];
                  arg = generate(a, options);
                  if ((needsParensWhenOnLeft(a)) && i + 1 !== ast["arguments"].length) {
                    arg = parens(arg);
                  }
                  _results.push(arg);
                }
                return _results;
              })();
              _argList = ast["arguments"].length === 0 ? '()' : " " + (args.join(', '));
              return "" + _fn + _op + _argList;
            }
            break;
          case 'MemberAccessOp':
          case 'SoakedMemberAccessOp':
          case 'ProtoMemberAccessOp':
          case 'SoakedProtoMemberAccessOp':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            if (ast.expression.className === 'This') {
              _expr = '@';
              if (ast.className === 'MemberAccessOp') {
                _op = '';
              }
            } else {
              _expr = generate(ast.expression, options);
              if (needsParensWhenOnLeft(ast.expression)) {
                _expr = parens(_expr);
              }
            }
            return "" + _expr + _op + ast.memberName;
          case 'DynamicMemberAccessOp':
          case 'SoakedDynamicMemberAccessOp':
          case 'DynamicProtoMemberAccessOp':
          case 'SoakedDynamicProtoMemberAccessOp':
            _op = operators[ast.className];
            prec = precedence[ast.className];
            needsParens = prec < options.precedence;
            options = clone(options, {
              ancestors: [ast].concat(__slice.call(options.ancestors)),
              precedence: prec
            });
            if (ast.expression.className === 'This') {
              _expr = '@';
            } else {
              _expr = generate(ast.expression, options);
              if (needsParensWhenOnLeft(ast.expression)) {
                _expr = parens(_expr);
              }
            }
            options.precedence = 0;
            _indexingExpr = generate(ast.indexingExpr, options);
            return "" + _expr + _op + "[" + _indexingExpr + "]";
          case 'ConcatOp':
            _left = formatInterpolation(ast.left, options);
            _right = formatInterpolation(ast.right, options);
            return "\"" + _left + _right + "\"";
          default:
            throw new Error("Non-exhaustive patterns in case: " + ast.className);
        }
      })();
      if (needsParens) {
        return parens(src);
      } else {
        return src;
      }
    };
  })(typeof exports !== "undefined" && exports !== null ? exports : this.cscodegen = {});

}).call(this);

},{}],35:[function(require,module,exports){
(function (global){/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*global exports:true, generateStatement:true, generateExpression:true, require:true, global:true*/
(function () {
    'use strict';

    var Syntax,
        Precedence,
        BinaryPrecedence,
        Regex,
        SourceNode,
        estraverse,
        isArray,
        base,
        indent,
        json,
        renumber,
        hexadecimal,
        quotes,
        escapeless,
        newline,
        space,
        parentheses,
        semicolons,
        safeConcatenation,
        directive,
        extra,
        parse,
        sourceMap,
        FORMAT_MINIFY,
        FORMAT_DEFAULTS;

    estraverse = require('estraverse');

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ComprehensionBlock: 'ComprehensionBlock',
        ComprehensionExpression: 'ComprehensionExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'

    };

    Precedence = {
        Sequence: 0,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Unary: 13,
        Postfix: 14,
        Call: 15,
        New: 16,
        Member: 17,
        Primary: 18
    };

    BinaryPrecedence = {
        '||': Precedence.LogicalOR,
        '&&': Precedence.LogicalAND,
        '|': Precedence.BitwiseOR,
        '^': Precedence.BitwiseXOR,
        '&': Precedence.BitwiseAND,
        '==': Precedence.Equality,
        '!=': Precedence.Equality,
        '===': Precedence.Equality,
        '!==': Precedence.Equality,
        'is': Precedence.Equality,
        'isnt': Precedence.Equality,
        '<': Precedence.Relational,
        '>': Precedence.Relational,
        '<=': Precedence.Relational,
        '>=': Precedence.Relational,
        'in': Precedence.Relational,
        'instanceof': Precedence.Relational,
        '<<': Precedence.BitwiseSHIFT,
        '>>': Precedence.BitwiseSHIFT,
        '>>>': Precedence.BitwiseSHIFT,
        '+': Precedence.Additive,
        '-': Precedence.Additive,
        '*': Precedence.Multiplicative,
        '%': Precedence.Multiplicative,
        '/': Precedence.Multiplicative
    };

    Regex = {
        NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')
    };

    function getDefaultOptions() {
        // default options
        return {
            indent: null,
            base: null,
            parse: null,
            comment: false,
            format: {
                indent: {
                    style: '    ',
                    base: 0,
                    adjustMultilineComment: false
                },
                newline: '\n',
                space: ' ',
                json: false,
                renumber: false,
                hexadecimal: false,
                quotes: 'single',
                escapeless: false,
                compact: false,
                parentheses: true,
                semicolons: true,
                safeConcatenation: false
            },
            moz: {
                starlessGenerator: false,
                parenthesizedComprehensionBlock: false
            },
            sourceMap: null,
            sourceMapRoot: null,
            sourceMapWithCode: false,
            directive: false,
            verbatim: null
        };
    }

    function stringToArray(str) {
        var length = str.length,
            result = [],
            i;
        for (i = 0; i < length; i += 1) {
            result[i] = str.charAt(i);
        }
        return result;
    }

    function stringRepeat(str, num) {
        var result = '';

        for (num |= 0; num > 0; num >>>= 1, str += str) {
            if (num & 1) {
                result += str;
            }
        }

        return result;
    }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    // Fallback for the non SourceMap environment
    function SourceNodeMock(line, column, filename, chunk) {
        var result = [];

        function flatten(input) {
            var i, iz;
            if (isArray(input)) {
                for (i = 0, iz = input.length; i < iz; ++i) {
                    flatten(input[i]);
                }
            } else if (input instanceof SourceNodeMock) {
                result.push(input);
            } else if (typeof input === 'string' && input) {
                result.push(input);
            }
        }

        flatten(chunk);
        this.children = result;
    }

    SourceNodeMock.prototype.toString = function toString() {
        var res = '', i, iz, node;
        for (i = 0, iz = this.children.length; i < iz; ++i) {
            node = this.children[i];
            if (node instanceof SourceNodeMock) {
                res += node.toString();
            } else {
                res += node;
            }
        }
        return res;
    };

    SourceNodeMock.prototype.replaceRight = function replaceRight(pattern, replacement) {
        var last = this.children[this.children.length - 1];
        if (last instanceof SourceNodeMock) {
            last.replaceRight(pattern, replacement);
        } else if (typeof last === 'string') {
            this.children[this.children.length - 1] = last.replace(pattern, replacement);
        } else {
            this.children.push(''.replace(pattern, replacement));
        }
        return this;
    };

    SourceNodeMock.prototype.join = function join(sep) {
        var i, iz, result;
        result = [];
        iz = this.children.length;
        if (iz > 0) {
            for (i = 0, iz -= 1; i < iz; ++i) {
                result.push(this.children[i], sep);
            }
            result.push(this.children[iz]);
            this.children = result;
        }
        return this;
    };

    function hasLineTerminator(str) {
        return (/[\r\n]/g).test(str);
    }

    function endsWithLineTerminator(str) {
        var ch = str.charAt(str.length - 1);
        return ch && isLineTerminator(ch);
    }

    function updateDeeply(target, override) {
        var key, val;

        function isHashObject(target) {
            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }

        for (key in override) {
            if (override.hasOwnProperty(key)) {
                val = override[key];
                if (isHashObject(val)) {
                    if (isHashObject(target[key])) {
                        updateDeeply(target[key], val);
                    } else {
                        target[key] = updateDeeply({}, val);
                    }
                } else {
                    target[key] = val;
                }
            }
        }
        return target;
    }

    function generateNumber(value) {
        var result, point, temp, exponent, pos;

        if (value !== value) {
            throw new Error('Numeric literal whose value is NaN');
        }
        if (value < 0 || (value === 0 && 1 / value < 0)) {
            throw new Error('Numeric literal whose value is negative');
        }

        if (value === 1 / 0) {
            return json ? 'null' : renumber ? '1e400' : '1e+400';
        }

        result = '' + value;
        if (!renumber || result.length < 3) {
            return result;
        }

        point = result.indexOf('.');
        if (!json && result.charAt(0) === '0' && point === 1) {
            point = 0;
            result = result.slice(1);
        }
        temp = result;
        result = result.replace('e+', 'e');
        exponent = 0;
        if ((pos = temp.indexOf('e')) > 0) {
            exponent = +temp.slice(pos + 1);
            temp = temp.slice(0, pos);
        }
        if (point >= 0) {
            exponent -= temp.length - point - 1;
            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
        }
        pos = 0;
        while (temp.charAt(temp.length + pos - 1) === '0') {
            pos -= 1;
        }
        if (pos !== 0) {
            exponent -= pos;
            temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
            temp += 'e' + exponent;
        }
        if ((temp.length < result.length ||
                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&
                +temp === value) {
            result = temp;
        }

        return result;
    }

    // Generate valid RegExp expression.
    // This function is based on https://github.com/Constellation/iv Engine

    function escapeRegExpCharacter(ch, previousIsBackslash) {
        // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
        if ((ch & ~1) === 0x2028) {
            return (previousIsBackslash ? 'u' : '\\u') + ((ch === 0x2028) ? '2028' : '2029');
        } else if (ch === 10 || ch === 13) {  // \n, \r
            return (previousIsBackslash ? '' : '\\') + ((ch === 10) ? 'n' : 'r');
        }
        return String.fromCharCode(ch);
    }

    function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;

        result = reg.toString();

        if (reg.source) {
            // extract flag from toString result
            match = result.match(/\/([^/]*)$/);
            if (!match) {
                return result;
            }

            flags = match[1];
            result = '';

            characterInBrack = false;
            previousIsBackslash = false;
            for (i = 0, iz = reg.source.length; i < iz; ++i) {
                ch = reg.source.charCodeAt(i);

                if (!previousIsBackslash) {
                    if (characterInBrack) {
                        if (ch === 93) {  // ]
                            characterInBrack = false;
                        }
                    } else {
                        if (ch === 47) {  // /
                            result += '\\';
                        } else if (ch === 91) {  // [
                            characterInBrack = true;
                        }
                    }
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    previousIsBackslash = ch === 92;  // \
                } else {
                    // if new RegExp("\\\n') is provided, create /\n/
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    // prevent like /\\[/]/
                    previousIsBackslash = false;
                }
            }

            return '/' + result + '/' + flags;
        }

        return result;
    }

    function escapeAllowedCharacter(ch, next) {
        var code = ch.charCodeAt(0), hex = code.toString(16), result = '\\';

        switch (ch) {
        case '\b':
            result += 'b';
            break;
        case '\f':
            result += 'f';
            break;
        case '\t':
            result += 't';
            break;
        default:
            if (json || code > 0xff) {
                result += 'u' + '0000'.slice(hex.length) + hex;
            } else if (ch === '\u0000' && '0123456789'.indexOf(next) < 0) {
                result += '0';
            } else if (ch === '\x0B') { // '\v'
                result += 'x0B';
            } else {
                result += 'x' + '00'.slice(hex.length) + hex;
            }
            break;
        }

        return result;
    }

    function escapeDisallowedCharacter(ch) {
        var result = '\\';
        switch (ch) {
        case '\\':
            result += '\\';
            break;
        case '\n':
            result += 'n';
            break;
        case '\r':
            result += 'r';
            break;
        case '\u2028':
            result += 'u2028';
            break;
        case '\u2029':
            result += 'u2029';
            break;
        default:
            throw new Error('Incorrectly classified character');
        }

        return result;
    }

    function escapeDirective(str) {
        var i, iz, ch, buf, quote;

        buf = str;
        if (typeof buf[0] === 'undefined') {
            buf = stringToArray(buf);
        }

        quote = quotes === 'double' ? '"' : '\'';
        for (i = 0, iz = buf.length; i < iz; i += 1) {
            ch = buf[i];
            if (ch === '\'') {
                quote = '"';
                break;
            } else if (ch === '"') {
                quote = '\'';
                break;
            } else if (ch === '\\') {
                i += 1;
            }
        }

        return quote + str + quote;
    }

    function escapeString(str) {
        var result = '', i, len, ch, singleQuotes = 0, doubleQuotes = 0, single;

        if (typeof str[0] === 'undefined') {
            str = stringToArray(str);
        }

        for (i = 0, len = str.length; i < len; i += 1) {
            ch = str[i];
            if (ch === '\'') {
                singleQuotes += 1;
            } else if (ch === '"') {
                doubleQuotes += 1;
            } else if (ch === '/' && json) {
                result += '\\';
            } else if ('\\\n\r\u2028\u2029'.indexOf(ch) >= 0) {
                result += escapeDisallowedCharacter(ch);
                continue;
            } else if ((json && ch < ' ') || !(json || escapeless || (ch >= ' ' && ch <= '~'))) {
                result += escapeAllowedCharacter(ch, str[i + 1]);
                continue;
            }
            result += ch;
        }

        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
        str = result;
        result = single ? '\'' : '"';

        if (typeof str[0] === 'undefined') {
            str = stringToArray(str);
        }

        for (i = 0, len = str.length; i < len; i += 1) {
            ch = str[i];
            if ((ch === '\'' && single) || (ch === '"' && !single)) {
                result += '\\';
            }
            result += ch;
        }

        return result + (single ? '\'' : '"');
    }

    function isWhiteSpace(ch) {
        // Use `\x0B` instead of `\v` for IE < 9 compatibility
        return '\t\x0B\f \xa0'.indexOf(ch) >= 0 || (ch.charCodeAt(0) >= 0x1680 && '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\ufeff'.indexOf(ch) >= 0);
    }

    function isLineTerminator(ch) {
        return '\n\r\u2028\u2029'.indexOf(ch) >= 0;
    }

    function isIdentifierPart(ch) {
        return (ch === '$') || (ch === '_') || (ch === '\\') ||
            (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') ||
            ((ch >= '0') && (ch <= '9')) ||
            ((ch.charCodeAt(0) >= 0x80) && Regex.NonAsciiIdentifierPart.test(ch));
    }

    // takes char code
    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function toSourceNode(generated, node) {
        if (node == null) {
            if (generated instanceof SourceNode) {
                return generated;
            } else {
                node = {};
            }
        }
        if (node.loc == null) {
            return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
    }

    function noEmptySpace() {
        return (space) ? space : ' ';
    }

    function join(left, right) {
        var leftSource = toSourceNode(left).toString(),
            rightSource = toSourceNode(right).toString(),
            leftChar = leftSource.charAt(leftSource.length - 1),
            rightChar = rightSource.charAt(0);

        if ((leftChar === '+' || leftChar === '-') && leftChar === rightChar ||
        isIdentifierPart(leftChar) && isIdentifierPart(rightChar) ||
        leftChar === '/' && rightChar === 'i') { // infix word operators all start with `i`
            return [left, noEmptySpace(), right];
        } else if (isWhiteSpace(leftChar) || isLineTerminator(leftChar) || isWhiteSpace(rightChar) || isLineTerminator(rightChar)) {
            return [left, right];
        }
        return [left, space, right];
    }

    function addIndent(stmt) {
        return [base, stmt];
    }

    function withIndent(fn) {
        var previousBase, result;
        previousBase = base;
        base += indent;
        result = fn.call(this, base);
        base = previousBase;
        return result;
    }

    function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; i -= 1) {
            if (isLineTerminator(str.charAt(i))) {
                break;
            }
        }
        return (str.length - 1) - i;
    }

    function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase;

        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;

        // first line doesn't have indentation
        for (i = 1, len = array.length; i < len; i += 1) {
            line = array[i];
            j = 0;
            while (j < line.length && isWhiteSpace(line[j])) {
                j += 1;
            }
            if (spaces > j) {
                spaces = j;
            }
        }

        if (typeof specialBase !== 'undefined') {
            // pattern like
            // {
            //   var t = 20;  /*
            //                 * this is comment
            //                 */
            // }
            previousBase = base;
            if (array[1][spaces] === '*') {
                specialBase += ' ';
            }
            base = specialBase;
        } else {
            if (spaces & 1) {
                // /*
                //  *
                //  */
                // If spaces are odd number, above pattern is considered.
                // We waste 1 space.
                spaces -= 1;
            }
            previousBase = base;
        }

        for (i = 1, len = array.length; i < len; i += 1) {
            array[i] = toSourceNode(addIndent(array[i].slice(spaces))).join('');
        }

        base = previousBase;

        return array.join('\n');
    }

    function generateComment(comment, specialBase) {
        if (comment.type === 'Line') {
            if (endsWithLineTerminator(comment.value)) {
                return '//' + comment.value;
            } else {
                // Always use LineTerminator
                return '//' + comment.value + '\n';
            }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
        }
        return '/*' + comment.value + '*/';
    }

    function addCommentsToStatement(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment;

        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
            save = result;

            comment = stmt.leadingComments[0];
            result = [];
            if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                result.push('\n');
            }
            result.push(generateComment(comment));
            if (!endsWithLineTerminator(toSourceNode(result).toString())) {
                result.push('\n');
            }

            for (i = 1, len = stmt.leadingComments.length; i < len; i += 1) {
                comment = stmt.leadingComments[i];
                fragment = [generateComment(comment)];
                if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {
                    fragment.push('\n');
                }
                result.push(addIndent(fragment));
            }

            result.push(addIndent(save));
        }

        if (stmt.trailingComments) {
            tailingToStatement = !endsWithLineTerminator(toSourceNode(result).toString());
            specialBase = stringRepeat(' ', calculateSpaces(toSourceNode([base, result, indent]).toString()));
            for (i = 0, len = stmt.trailingComments.length; i < len; i += 1) {
                comment = stmt.trailingComments[i];
                if (tailingToStatement) {
                    // We assume target like following script
                    //
                    // var t = 20;  /**
                    //               * This is comment of t
                    //               */
                    if (i === 0) {
                        // first case
                        result = [result, indent];
                    } else {
                        result = [result, specialBase];
                    }
                    result.push(generateComment(comment, specialBase));
                } else {
                    result = [result, addIndent(generateComment(comment))];
                }
                if (i !== len - 1 && !endsWithLineTerminator(toSourceNode(result).toString())) {
                    result = [result, '\n'];
                }
            }
        }

        return result;
    }

    function parenthesize(text, current, should) {
        if (current < should) {
            return ['(', text, ')'];
        }
        return text;
    }

    function maybeBlock(stmt, semicolonOptional, functionBody) {
        var result, noLeadingComment;

        noLeadingComment = !extra.comment || !stmt.leadingComments;

        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
            return [space, generateStatement(stmt, { functionBody: functionBody })];
        }

        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
            return ';';
        }

        withIndent(function () {
            result = [newline, addIndent(generateStatement(stmt, { semicolonOptional: semicolonOptional, functionBody: functionBody }))];
        });

        return result;
    }

    function maybeBlockSuffix(stmt, result) {
        var ends = endsWithLineTerminator(toSourceNode(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
            return [result, space];
        }
        if (ends) {
            return [result, base];
        }
        return [result, newline, base];
    }

    function generateVerbatim(expr, option) {
        var i, result;
        result = expr[extra.verbatim].split(/\r\n|\n/);
        for (i = 1; i < result.length; i++) {
            result[i] = newline + base + result[i];
        }

        result = parenthesize(result, Precedence.Sequence, option.precedence);
        return toSourceNode(result, expr);
    }

    function generateIdentifier(node) {
        return toSourceNode(node.name, node);
    }

    function generateFunctionBody(node) {
        var result, i, len, expr, arrow;

        arrow = node.type === Syntax.ArrowFunctionExpression;

        if (arrow && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
            // arg => { } case
            result = [generateIdentifier(node.params[0])];
        } else {
            result = ['('];
            for (i = 0, len = node.params.length; i < len; i += 1) {
                result.push(generateIdentifier(node.params[i]));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result.push(')');
        }

        if (arrow) {
            result.push(space, '=>');
        }

        if (node.expression) {
            result.push(space);
            expr = generateExpression(node.body, {
                precedence: Precedence.Assignment,
                allowIn: true,
                allowCall: true
            });
            if (expr.toString().charAt(0) === '{') {
                expr = ['(', expr, ')'];
            }
            result.push(expr);
        } else {
            result.push(maybeBlock(node.body, false, true));
        }
        return result;
    }

    function generateExpression(expr, option) {
        var result,
            precedence,
            type,
            currentPrecedence,
            i,
            len,
            raw,
            fragment,
            multiline,
            leftChar,
            leftSource,
            rightChar,
            allowIn,
            allowCall,
            allowUnparenthesizedNew,
            property;

        precedence = option.precedence;
        allowIn = option.allowIn;
        allowCall = option.allowCall;
        type = expr.type || option.type;

        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
            return generateVerbatim(expr, option);
        }

        switch (type) {
        case Syntax.SequenceExpression:
            result = [];
            allowIn |= (Precedence.Sequence < precedence);
            for (i = 0, len = expr.expressions.length; i < len; i += 1) {
                result.push(generateExpression(expr.expressions[i], {
                    precedence: Precedence.Assignment,
                    allowIn: allowIn,
                    allowCall: true
                }));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result = parenthesize(result, Precedence.Sequence, precedence);
            break;

        case Syntax.AssignmentExpression:
            allowIn |= (Precedence.Assignment < precedence);
            result = parenthesize(
                [
                    generateExpression(expr.left, {
                        precedence: Precedence.Call,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + expr.operator + space,
                    generateExpression(expr.right, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ],
                Precedence.Assignment,
                precedence
            );
            break;

        case Syntax.ArrowFunctionExpression:
            allowIn |= (Precedence.ArrowFunction < precedence);
            result = parenthesize(generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
            break;

        case Syntax.ConditionalExpression:
            allowIn |= (Precedence.Conditional < precedence);
            result = parenthesize(
                [
                    generateExpression(expr.test, {
                        precedence: Precedence.LogicalOR,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + '?' + space,
                    generateExpression(expr.consequent, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + ':' + space,
                    generateExpression(expr.alternate, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ],
                Precedence.Conditional,
                precedence
            );
            break;

        case Syntax.LogicalExpression:
        case Syntax.BinaryExpression:
            currentPrecedence = BinaryPrecedence[expr.operator];

            allowIn |= (currentPrecedence < precedence);

            fragment = generateExpression(expr.left, {
                precedence: currentPrecedence,
                allowIn: allowIn,
                allowCall: true
            });

            leftSource = fragment.toString();

            if (leftSource.charAt(leftSource.length - 1) === '/' && isIdentifierPart(expr.operator.charAt(0))) {
                result = [fragment, noEmptySpace(), expr.operator];
            } else {
                result = join(fragment, expr.operator);
            }

            fragment = generateExpression(expr.right, {
                precedence: currentPrecedence + 1,
                allowIn: allowIn,
                allowCall: true
            });

            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||
            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
                result.push(noEmptySpace(), fragment);
            } else {
                result = join(result, fragment);
            }

            if (expr.operator === 'in' && !allowIn) {
                result = ['(', result, ')'];
            } else {
                result = parenthesize(result, currentPrecedence, precedence);
            }

            break;

        case Syntax.CallExpression:
            result = [generateExpression(expr.callee, {
                precedence: Precedence.Call,
                allowIn: true,
                allowCall: true,
                allowUnparenthesizedNew: false
            })];

            result.push('(');
            for (i = 0, len = expr['arguments'].length; i < len; i += 1) {
                result.push(generateExpression(expr['arguments'][i], {
                    precedence: Precedence.Assignment,
                    allowIn: true,
                    allowCall: true
                }));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result.push(')');

            if (!allowCall) {
                result = ['(', result, ')'];
            } else {
                result = parenthesize(result, Precedence.Call, precedence);
            }
            break;

        case Syntax.NewExpression:
            len = expr['arguments'].length;
            allowUnparenthesizedNew = option.allowUnparenthesizedNew === undefined || option.allowUnparenthesizedNew;

            result = join(
                'new',
                generateExpression(expr.callee, {
                    precedence: Precedence.New,
                    allowIn: true,
                    allowCall: false,
                    allowUnparenthesizedNew: allowUnparenthesizedNew && !parentheses && len === 0
                })
            );

            if (!allowUnparenthesizedNew || parentheses || len > 0) {
                result.push('(');
                for (i = 0; i < len; i += 1) {
                    result.push(generateExpression(expr['arguments'][i], {
                        precedence: Precedence.Assignment,
                        allowIn: true,
                        allowCall: true
                    }));
                    if (i + 1 < len) {
                        result.push(',' + space);
                    }
                }
                result.push(')');
            }

            result = parenthesize(result, Precedence.New, precedence);
            break;

        case Syntax.MemberExpression:
            result = [generateExpression(expr.object, {
                precedence: Precedence.Call,
                allowIn: true,
                allowCall: allowCall,
                allowUnparenthesizedNew: false
            })];

            if (expr.computed) {
                result.push('[', generateExpression(expr.property, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: allowCall
                }), ']');
            } else {
                if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                    fragment = toSourceNode(result).toString();
                    // When the following conditions are all true,
                    //   1. No floating point
                    //   2. Don't have exponents
                    //   3. The last character is a decimal digit
                    //   4. Not hexadecimal OR octal number literal
                    // we should add a floating point.
                    if (
                            fragment.indexOf('.') < 0 &&
                            !/[eExX]/.test(fragment) &&
                            isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&
                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'
                            ) {
                        result.push('.');
                    }
                }
                result.push('.', generateIdentifier(expr.property));
            }

            result = parenthesize(result, Precedence.Member, precedence);
            break;

        case Syntax.UnaryExpression:
            fragment = generateExpression(expr.argument, {
                precedence: Precedence.Unary,
                allowIn: true,
                allowCall: true
            });

            if (space === '') {
                result = join(expr.operator, fragment);
            } else {
                result = [expr.operator];
                if (expr.operator.length > 2) {
                    // delete, void, typeof
                    // get `typeof []`, not `typeof[]`
                    result = join(result, fragment);
                } else {
                    // Prevent inserting spaces between operator and argument if it is unnecessary
                    // like, `!cond`
                    leftSource = toSourceNode(result).toString();
                    leftChar = leftSource.charAt(leftSource.length - 1);
                    rightChar = fragment.toString().charAt(0);

                    if (((leftChar === '+' || leftChar === '-') && leftChar === rightChar) || (isIdentifierPart(leftChar) && isIdentifierPart(rightChar))) {
                        result.push(noEmptySpace(), fragment);
                    } else {
                        result.push(fragment);
                    }
                }
            }
            result = parenthesize(result, Precedence.Unary, precedence);
            break;

        case Syntax.YieldExpression:
            if (expr.delegate) {
                result = 'yield*';
            } else {
                result = 'yield';
            }
            if (expr.argument) {
                result = join(
                    result,
                    generateExpression(expr.argument, {
                        precedence: Precedence.Assignment,
                        allowIn: true,
                        allowCall: true
                    })
                );
            }
            break;

        case Syntax.UpdateExpression:
            if (expr.prefix) {
                result = parenthesize(
                    [
                        expr.operator,
                        generateExpression(expr.argument, {
                            precedence: Precedence.Unary,
                            allowIn: true,
                            allowCall: true
                        })
                    ],
                    Precedence.Unary,
                    precedence
                );
            } else {
                result = parenthesize(
                    [
                        generateExpression(expr.argument, {
                            precedence: Precedence.Postfix,
                            allowIn: true,
                            allowCall: true
                        }),
                        expr.operator
                    ],
                    Precedence.Postfix,
                    precedence
                );
            }
            break;

        case Syntax.FunctionExpression:
            result = 'function';

            if (expr.id) {
                result = [result, noEmptySpace(),
                          generateIdentifier(expr.id),
                          generateFunctionBody(expr)];
            } else {
                result = [result + space, generateFunctionBody(expr)];
            }

            break;

        case Syntax.ArrayPattern:
        case Syntax.ArrayExpression:
            if (!expr.elements.length) {
                result = '[]';
                break;
            }
            multiline = expr.elements.length > 1;
            result = ['[', multiline ? newline : ''];
            withIndent(function (indent) {
                for (i = 0, len = expr.elements.length; i < len; i += 1) {
                    if (!expr.elements[i]) {
                        if (multiline) {
                            result.push(indent);
                        }
                        if (i + 1 === len) {
                            result.push(',');
                        }
                    } else {
                        result.push(multiline ? indent : '', generateExpression(expr.elements[i], {
                            precedence: Precedence.Assignment,
                            allowIn: true,
                            allowCall: true
                        }));
                    }
                    if (i + 1 < len) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });
            if (multiline && !endsWithLineTerminator(toSourceNode(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '', ']');
            break;

        case Syntax.Property:
            if (expr.kind === 'get' || expr.kind === 'set') {
                result = [
                    expr.kind, noEmptySpace(),
                    generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    generateFunctionBody(expr.value)
                ];
            } else {
                if (expr.shorthand) {
                    result = generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    });
                } else if (expr.method) {
                    result = [];
                    if (expr.value.generator) {
                        result.push('*');
                    }
                    result.push(generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }), generateFunctionBody(expr.value));
                } else {
                    result = [
                        generateExpression(expr.key, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        }),
                        ':' + space,
                        generateExpression(expr.value, {
                            precedence: Precedence.Assignment,
                            allowIn: true,
                            allowCall: true
                        })
                    ];
                }
            }
            break;

        case Syntax.ObjectExpression:
            if (!expr.properties.length) {
                result = '{}';
                break;
            }
            multiline = expr.properties.length > 1;

            withIndent(function () {
                fragment = generateExpression(expr.properties[0], {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true,
                    type: Syntax.Property
                });
            });

            if (!multiline) {
                // issues 4
                // Do not transform from
                //   dejavu.Class.declare({
                //       method2: function () {}
                //   });
                // to
                //   dejavu.Class.declare({method2: function () {
                //       }});
                if (!hasLineTerminator(toSourceNode(fragment).toString())) {
                    result = [ '{', space, fragment, space, '}' ];
                    break;
                }
            }

            withIndent(function (indent) {
                result = [ '{', newline, indent, fragment ];

                if (multiline) {
                    result.push(',' + newline);
                    for (i = 1, len = expr.properties.length; i < len; i += 1) {
                        result.push(indent, generateExpression(expr.properties[i], {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true,
                            type: Syntax.Property
                        }));
                        if (i + 1 < len) {
                            result.push(',' + newline);
                        }
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNode(result).toString())) {
                result.push(newline);
            }
            result.push(base, '}');
            break;

        case Syntax.ObjectPattern:
            if (!expr.properties.length) {
                result = '{}';
                break;
            }

            multiline = false;
            if (expr.properties.length === 1) {
                property = expr.properties[0];
                if (property.value.type !== Syntax.Identifier) {
                    multiline = true;
                }
            } else {
                for (i = 0, len = expr.properties.length; i < len; i += 1) {
                    property = expr.properties[i];
                    if (!property.shorthand) {
                        multiline = true;
                        break;
                    }
                }
            }
            result = ['{', multiline ? newline : '' ];

            withIndent(function (indent) {
                for (i = 0, len = expr.properties.length; i < len; i += 1) {
                    result.push(multiline ? indent : '', generateExpression(expr.properties[i], {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }));
                    if (i + 1 < len) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });

            if (multiline && !endsWithLineTerminator(toSourceNode(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '', '}');
            break;

        case Syntax.ThisExpression:
            result = 'this';
            break;

        case Syntax.Identifier:
            result = generateIdentifier(expr);
            break;

        case Syntax.Literal:
            if (expr.hasOwnProperty('raw') && parse) {
                try {
                    raw = parse(expr.raw).body[0].expression;
                    if (raw.type === Syntax.Literal) {
                        if (raw.value === expr.value) {
                            result = expr.raw;
                            break;
                        }
                    }
                } catch (e) {
                    // not use raw property
                }
            }

            if (expr.value === null) {
                result = 'null';
                break;
            }

            if (typeof expr.value === 'string') {
                result = escapeString(expr.value);
                break;
            }

            if (typeof expr.value === 'number') {
                result = generateNumber(expr.value);
                break;
            }

            if (typeof expr.value === 'boolean') {
                result = expr.value ? 'true' : 'false';
                break;
            }

            result = generateRegExp(expr.value);
            break;

        case Syntax.ComprehensionExpression:
            result = [
                '[',
                generateExpression(expr.body, {
                    precedence: Precedence.Assignment,
                    allowIn: true,
                    allowCall: true
                })
            ];

            if (expr.blocks) {
                for (i = 0, len = expr.blocks.length; i < len; i += 1) {
                    fragment = generateExpression(expr.blocks[i], {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    });
                    result = join(result, fragment);
                }
            }

            if (expr.filter) {
                result = join(result, 'if' + space);
                fragment = generateExpression(expr.filter, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                });
                if (extra.moz.parenthesizedComprehensionBlock) {
                    result = join(result, [ '(', fragment, ')' ]);
                } else {
                    result = join(result, fragment);
                }
            }
            result.push(']');
            break;

        case Syntax.ComprehensionBlock:
            if (expr.left.type === Syntax.VariableDeclaration) {
                fragment = [
                    expr.left.kind, noEmptySpace(),
                    generateStatement(expr.left.declarations[0], {
                        allowIn: false
                    })
                ];
            } else {
                fragment = generateExpression(expr.left, {
                    precedence: Precedence.Call,
                    allowIn: true,
                    allowCall: true
                });
            }

            fragment = join(fragment, expr.of ? 'of' : 'in');
            fragment = join(fragment, generateExpression(expr.right, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            }));

            if (extra.moz.parenthesizedComprehensionBlock) {
                result = [ 'for' + space + '(', fragment, ')' ];
            } else {
                result = join('for' + space, fragment);
            }
            break;

        default:
            throw new Error('Unknown expression type: ' + expr.type);
        }

        return toSourceNode(result, expr);
    }

    function generateStatement(stmt, option) {
        var i, len, result, node, allowIn, functionBody, directiveContext, fragment, semicolon;

        allowIn = true;
        semicolon = ';';
        functionBody = false;
        directiveContext = false;
        if (option) {
            allowIn = option.allowIn === undefined || option.allowIn;
            if (!semicolons && option.semicolonOptional === true) {
                semicolon = '';
            }
            functionBody = option.functionBody;
            directiveContext = option.directiveContext;
        }

        switch (stmt.type) {
        case Syntax.BlockStatement:
            result = ['{', newline];

            withIndent(function () {
                for (i = 0, len = stmt.body.length; i < len; i += 1) {
                    fragment = addIndent(generateStatement(stmt.body[i], {
                        semicolonOptional: i === len - 1,
                        directiveContext: functionBody
                    }));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });

            result.push(addIndent('}'));
            break;

        case Syntax.BreakStatement:
            if (stmt.label) {
                result = 'break ' + stmt.label.name + semicolon;
            } else {
                result = 'break' + semicolon;
            }
            break;

        case Syntax.ContinueStatement:
            if (stmt.label) {
                result = 'continue ' + stmt.label.name + semicolon;
            } else {
                result = 'continue' + semicolon;
            }
            break;

        case Syntax.DirectiveStatement:
            if (stmt.raw) {
                result = stmt.raw + semicolon;
            } else {
                result = escapeDirective(stmt.directive) + semicolon;
            }
            break;

        case Syntax.DoWhileStatement:
            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
            result = join('do', maybeBlock(stmt.body));
            result = maybeBlockSuffix(stmt.body, result);
            result = join(result, [
                'while' + space + '(',
                generateExpression(stmt.test, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                }),
                ')' + semicolon
            ]);
            break;

        case Syntax.CatchClause:
            withIndent(function () {
                result = [
                    'catch' + space + '(',
                    generateExpression(stmt.param, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            result.push(maybeBlock(stmt.body));
            break;

        case Syntax.DebuggerStatement:
            result = 'debugger' + semicolon;
            break;

        case Syntax.EmptyStatement:
            result = ';';
            break;

        case Syntax.ExpressionStatement:
            result = [generateExpression(stmt.expression, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            })];
            // 12.4 '{', 'function' is not allowed in this position.
            // wrap expression with parentheses
            fragment = toSourceNode(result).toString();
            if (fragment.charAt(0) === '{' || (fragment.slice(0, 8) === 'function' && ' ('.indexOf(fragment.charAt(8)) >= 0) || (directive && directiveContext && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {
                result = ['(', result, ')' + semicolon];
            } else {
                result.push(semicolon);
            }
            break;

        case Syntax.VariableDeclarator:
            if (stmt.init) {
                result = [
                    generateExpression(stmt.id, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space,
                    '=',
                    space,
                    generateExpression(stmt.init, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ];
            } else {
                result = generateIdentifier(stmt.id);
            }
            break;

        case Syntax.VariableDeclaration:
            result = [stmt.kind];
            // special path for
            // var x = function () {
            // };
            if (stmt.declarations.length === 1 && stmt.declarations[0].init &&
                    stmt.declarations[0].init.type === Syntax.FunctionExpression) {
                result.push(noEmptySpace(), generateStatement(stmt.declarations[0], {
                    allowIn: allowIn
                }));
            } else {
                // VariableDeclarator is typed as Statement,
                // but joined with comma (not LineTerminator).
                // So if comment is attached to target node, we should specialize.
                withIndent(function () {
                    node = stmt.declarations[0];
                    if (extra.comment && node.leadingComments) {
                        result.push('\n', addIndent(generateStatement(node, {
                            allowIn: allowIn
                        })));
                    } else {
                        result.push(noEmptySpace(), generateStatement(node, {
                            allowIn: allowIn
                        }));
                    }

                    for (i = 1, len = stmt.declarations.length; i < len; i += 1) {
                        node = stmt.declarations[i];
                        if (extra.comment && node.leadingComments) {
                            result.push(',' + newline, addIndent(generateStatement(node, {
                                allowIn: allowIn
                            })));
                        } else {
                            result.push(',' + space, generateStatement(node, {
                                allowIn: allowIn
                            }));
                        }
                    }
                });
            }
            result.push(semicolon);
            break;

        case Syntax.ThrowStatement:
            result = [join(
                'throw',
                generateExpression(stmt.argument, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                })
            ), semicolon];
            break;

        case Syntax.TryStatement:
            result = ['try', maybeBlock(stmt.block)];
            result = maybeBlockSuffix(stmt.block, result);
            if (stmt.handlers) {
                // old interface
                for (i = 0, len = stmt.handlers.length; i < len; i += 1) {
                    result = join(result, generateStatement(stmt.handlers[i]));
                    if (stmt.finalizer || i + 1 !== len) {
                        result = maybeBlockSuffix(stmt.handlers[i].body, result);
                    }
                }
            } else {
                // new interface
                if (stmt.handler) {
                    result = join(result, generateStatement(stmt.handler));
                    if (stmt.finalizer || stmt.guardedHandlers.length > 0) {
                        result = maybeBlockSuffix(stmt.handler.body, result);
                    }
                }

                for (i = 0, len = stmt.guardedHandlers.length; i < len; i += 1) {
                    result = join(result, generateStatement(stmt.guardedHandlers[i]));
                    if (stmt.finalizer || i + 1 !== len) {
                        result = maybeBlockSuffix(stmt.guardedHandlers[i].body, result);
                    }
                }
            }
            if (stmt.finalizer) {
                result = join(result, ['finally', maybeBlock(stmt.finalizer)]);
            }
            break;

        case Syntax.SwitchStatement:
            withIndent(function () {
                result = [
                    'switch' + space + '(',
                    generateExpression(stmt.discriminant, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')' + space + '{' + newline
                ];
            });
            if (stmt.cases) {
                for (i = 0, len = stmt.cases.length; i < len; i += 1) {
                    fragment = addIndent(generateStatement(stmt.cases[i], {semicolonOptional: i === len - 1}));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNode(fragment).toString())) {
                        result.push(newline);
                    }
                }
            }
            result.push(addIndent('}'));
            break;

        case Syntax.SwitchCase:
            withIndent(function () {
                if (stmt.test) {
                    result = [
                        join('case', generateExpression(stmt.test, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        })),
                        ':'
                    ];
                } else {
                    result = ['default:'];
                }

                i = 0;
                len = stmt.consequent.length;
                if (len && stmt.consequent[0].type === Syntax.BlockStatement) {
                    fragment = maybeBlock(stmt.consequent[0]);
                    result.push(fragment);
                    i = 1;
                }

                if (i !== len && !endsWithLineTerminator(toSourceNode(result).toString())) {
                    result.push(newline);
                }

                for (; i < len; i += 1) {
                    fragment = addIndent(generateStatement(stmt.consequent[i], {semicolonOptional: i === len - 1 && semicolon === ''}));
                    result.push(fragment);
                    if (i + 1 !== len && !endsWithLineTerminator(toSourceNode(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });
            break;

        case Syntax.IfStatement:
            withIndent(function () {
                result = [
                    'if' + space + '(',
                    generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            if (stmt.alternate) {
                result.push(maybeBlock(stmt.consequent));
                result = maybeBlockSuffix(stmt.consequent, result);
                if (stmt.alternate.type === Syntax.IfStatement) {
                    result = join(result, ['else ', generateStatement(stmt.alternate, {semicolonOptional: semicolon === ''})]);
                } else {
                    result = join(result, join('else', maybeBlock(stmt.alternate, semicolon === '')));
                }
            } else {
                result.push(maybeBlock(stmt.consequent, semicolon === ''));
            }
            break;

        case Syntax.ForStatement:
            withIndent(function () {
                result = ['for' + space + '('];
                if (stmt.init) {
                    if (stmt.init.type === Syntax.VariableDeclaration) {
                        result.push(generateStatement(stmt.init, {allowIn: false}));
                    } else {
                        result.push(generateExpression(stmt.init, {
                            precedence: Precedence.Sequence,
                            allowIn: false,
                            allowCall: true
                        }), ';');
                    }
                } else {
                    result.push(';');
                }

                if (stmt.test) {
                    result.push(space, generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }), ';');
                } else {
                    result.push(';');
                }

                if (stmt.update) {
                    result.push(space, generateExpression(stmt.update, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }), ')');
                } else {
                    result.push(')');
                }
            });

            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        case Syntax.ForInStatement:
            result = ['for' + space + '('];
            withIndent(function () {
                if (stmt.left.type === Syntax.VariableDeclaration) {
                    withIndent(function () {
                        result.push(stmt.left.kind + noEmptySpace(), generateStatement(stmt.left.declarations[0], {
                            allowIn: false
                        }));
                    });
                } else {
                    result.push(generateExpression(stmt.left, {
                        precedence: Precedence.Call,
                        allowIn: true,
                        allowCall: true
                    }));
                }

                result = join(result, 'in');
                result = [join(
                    result,
                    generateExpression(stmt.right, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    })
                ), ')'];
            });
            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        case Syntax.LabeledStatement:
            result = [stmt.label.name + ':', maybeBlock(stmt.body, semicolon === '')];
            break;

        case Syntax.Program:
            len = stmt.body.length;
            result = [safeConcatenation && len > 0 ? '\n' : ''];
            for (i = 0; i < len; i += 1) {
                fragment = addIndent(
                    generateStatement(stmt.body[i], {
                        semicolonOptional: !safeConcatenation && i === len - 1,
                        directiveContext: true
                    })
                );
                result.push(fragment);
                if (i + 1 < len && !endsWithLineTerminator(toSourceNode(fragment).toString())) {
                    result.push(newline);
                }
            }
            break;

        case Syntax.FunctionDeclaration:
            result = [(stmt.generator && !extra.moz.starlessGenerator ? 'function* ' : 'function '),
                      generateIdentifier(stmt.id),
                      generateFunctionBody(stmt)];
            break;

        case Syntax.ReturnStatement:
            if (stmt.argument) {
                result = [join(
                    'return',
                    generateExpression(stmt.argument, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    })
                ), semicolon];
            } else {
                result = ['return' + semicolon];
            }
            break;

        case Syntax.WhileStatement:
            withIndent(function () {
                result = [
                    'while' + space + '(',
                    generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        case Syntax.WithStatement:
            withIndent(function () {
                result = [
                    'with' + space + '(',
                    generateExpression(stmt.object, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        default:
            throw new Error('Unknown statement type: ' + stmt.type);
        }

        // Attach comments

        if (extra.comment) {
            result = addCommentsToStatement(stmt, result);
        }

        fragment = toSourceNode(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\n') {
            result = toSourceNode(result).replaceRight(/\s+$/, '');
        }

        return toSourceNode(result, stmt);
    }

    function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;

        if (options != null) {
            // Obsolete options
            //
            //   `options.indent`
            //   `options.base`
            //
            // Instead of them, we can use `option.format.indent`.
            if (typeof options.indent === 'string') {
                defaultOptions.format.indent.style = options.indent;
            }
            if (typeof options.base === 'number') {
                defaultOptions.format.indent.base = options.base;
            }
            options = updateDeeply(defaultOptions, options);
            indent = options.format.indent.style;
            if (typeof options.base === 'string') {
                base = options.base;
            } else {
                base = stringRepeat(indent, options.format.indent.base);
            }
        } else {
            options = defaultOptions;
            indent = options.format.indent.style;
            base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? 'double' : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
            newline = space = indent = base = '';
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse = json ? null : options.parse;
        sourceMap = options.sourceMap;
        extra = options;

        if (sourceMap) {
            if (!exports.browser) {
                // We assume environment is node.js
                // And prevent from including source-map by browserify
                SourceNode = require('source-map').SourceNode;
            } else {
                SourceNode = global.sourceMap.SourceNode;
            }
        } else {
            SourceNode = SourceNodeMock;
        }

        switch (node.type) {
        case Syntax.BlockStatement:
        case Syntax.BreakStatement:
        case Syntax.CatchClause:
        case Syntax.ContinueStatement:
        case Syntax.DirectiveStatement:
        case Syntax.DoWhileStatement:
        case Syntax.DebuggerStatement:
        case Syntax.EmptyStatement:
        case Syntax.ExpressionStatement:
        case Syntax.ForStatement:
        case Syntax.ForInStatement:
        case Syntax.FunctionDeclaration:
        case Syntax.IfStatement:
        case Syntax.LabeledStatement:
        case Syntax.Program:
        case Syntax.ReturnStatement:
        case Syntax.SwitchStatement:
        case Syntax.SwitchCase:
        case Syntax.ThrowStatement:
        case Syntax.TryStatement:
        case Syntax.VariableDeclaration:
        case Syntax.VariableDeclarator:
        case Syntax.WhileStatement:
        case Syntax.WithStatement:
            result = generateStatement(node);
            break;

        case Syntax.AssignmentExpression:
        case Syntax.ArrayExpression:
        case Syntax.ArrayPattern:
        case Syntax.BinaryExpression:
        case Syntax.CallExpression:
        case Syntax.ConditionalExpression:
        case Syntax.FunctionExpression:
        case Syntax.Identifier:
        case Syntax.Literal:
        case Syntax.LogicalExpression:
        case Syntax.MemberExpression:
        case Syntax.NewExpression:
        case Syntax.ObjectExpression:
        case Syntax.ObjectPattern:
        case Syntax.Property:
        case Syntax.SequenceExpression:
        case Syntax.ThisExpression:
        case Syntax.UnaryExpression:
        case Syntax.UpdateExpression:
        case Syntax.YieldExpression:

            result = generateExpression(node, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            });
            break;

        default:
            throw new Error('Unknown node type: ' + node.type);
        }

        if (!sourceMap) {
            return result.toString();
        }

        pair = result.toStringWithSourceMap({
            file: options.file,
            sourceRoot: options.sourceMapRoot
        });

        if (options.sourceMapWithCode) {
            return pair;
        }
        return pair.map.toString();
    }

    FORMAT_MINIFY = {
        indent: {
            style: '',
            base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: 'auto',
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
    };

    FORMAT_DEFAULTS = getDefaultOptions().format;

    exports.version = require('./package.json').version;
    exports.generate = generate;
    exports.attachComments = estraverse.attachComments;
    exports.browser = false;
    exports.FORMAT_MINIFY = FORMAT_MINIFY;
    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
}());
/* vim: set sw=4 ts=4 et tw=80 : */
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./package.json":37,"estraverse":36,"source-map":38}],36:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true, define:true*/
(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // and plain browser loading,
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.estraverse = {}));
    }
}(this, function (exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        BREAK,
        SKIP;

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrowFunctionExpression: ['params', 'body'],
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'body', 'superClass'],
        ClassExpression: ['id', 'body', 'superClass'],
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'body'],
        FunctionExpression: ['id', 'params', 'body'],
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MethodDefinition: ['key', 'value'],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handlers', 'handler', 'guardedHandlers', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
    };

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = element.wrap || node.type;
                candidates = VisitorKeys[nodeType];

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (!isArray(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                        continue;
                    }

                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                            element = new Element(candidate[current2], [key, current2], 'Property', null);
                        } else {
                            element = new Element(candidate[current2], [key, current2], null, null);
                        }
                        worklist.push(element);
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = element.wrap || node.type;
            candidates = VisitorKeys[nodeType];

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (!isArray(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                    continue;
                }

                current2 = candidate.length;
                while ((current2 -= 1) >= 0) {
                    if (!candidate[current2]) {
                        continue;
                    }
                    if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                        element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                    } else {
                        element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                    }
                    worklist.push(element);
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = '1.3.2';
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],37:[function(require,module,exports){
module.exports={
  "name": "escodegen",
  "description": "ECMAScript code generator",
  "homepage": "http://github.com/Constellation/escodegen.html",
  "main": "escodegen.js",
  "bin": {
    "esgenerate": "./bin/esgenerate.js",
    "escodegen": "./bin/escodegen.js"
  },
  "version": "0.0.28",
  "engines": {
    "node": ">=0.4.0"
  },
  "maintainers": [
    {
      "name": "Yusuke Suzuki",
      "email": "utatane.tea@gmail.com",
      "url": "http://github.com/Constellation"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/Constellation/escodegen.git"
  },
  "dependencies": {
    "esprima": "~1.0.2",
    "estraverse": "~1.3.0",
    "source-map": ">= 0.1.2"
  },
  "optionalDependencies": {
    "source-map": ">= 0.1.2"
  },
  "devDependencies": {
    "esprima-moz": "*",
    "commonjs-everywhere": "~0.8.0",
    "q": "*",
    "bower": "*",
    "semver": "*",
    "chai": "~1.7.2",
    "grunt-contrib-jshint": "~0.5.0",
    "grunt-cli": "~0.1.9",
    "grunt": "~0.4.1",
    "grunt-mocha-test": "~0.6.2"
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "http://github.com/Constellation/escodegen/raw/master/LICENSE.BSD"
    }
  ],
  "scripts": {
    "test": "grunt travis",
    "unit-test": "grunt test",
    "lint": "grunt lint",
    "release": "node tools/release.js",
    "build-min": "cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
    "build": "cjsify -a path: tools/entry-point.js > escodegen.browser.js"
  },
  "readme": "\n### Escodegen [![Build Status](https://secure.travis-ci.org/Constellation/escodegen.png)](http://travis-ci.org/Constellation/escodegen) [![Build Status](https://drone.io/github.com/Constellation/escodegen/status.png)](https://drone.io/github.com/Constellation/escodegen/latest)\n\nEscodegen ([escodegen](http://github.com/Constellation/escodegen)) is\n[ECMAScript](http://www.ecma-international.org/publications/standards/Ecma-262.htm)\n(also popularly known as [JavaScript](http://en.wikipedia.org/wiki/JavaScript>JavaScript))\ncode generator from [Parser API](https://developer.mozilla.org/en/SpiderMonkey/Parser_API) AST.\nSee [online generator demo](http://constellation.github.com/escodegen/demo/index.html).\n\n\n### Install\n\nEscodegen can be used in a web browser:\n\n    <script src=\"escodegen.browser.js\"></script>\n\nescodegen.browser.js is found in tagged-revision. See Tags on GitHub.\n\nOr in a Node.js application via the package manager:\n\n    npm install escodegen\n\n### Usage\n\nA simple example: the program\n\n    escodegen.generate({\n        type: 'BinaryExpression',\n        operator: '+',\n        left: { type: 'Literal', value: 40 },\n        right: { type: 'Literal', value: 2 }\n    });\n\nproduces the string `'40 + 2'`\n\nSee the [API page](https://github.com/Constellation/escodegen/wiki/API) for\noptions. To run the tests, execute `npm test` in the root directory.\n\n### License\n\n#### Escodegen\n\nCopyright (C) 2012 [Yusuke Suzuki](http://github.com/Constellation)\n (twitter: [@Constellation](http://twitter.com/Constellation)) and other contributors.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#### source-map\n\nSourceNodeMocks has a limited interface of mozilla/source-map SourceNode implementations.\n\nCopyright (c) 2009-2011, Mozilla Foundation and contributors\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the names of the Mozilla Foundation nor the names of project\n  contributors may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/Constellation/escodegen/issues"
  },
  "_id": "escodegen@0.0.28",
  "_from": "escodegen@~0.0.24"
}

},{}],38:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./source-map/source-node').SourceNode;

},{"./source-map/source-map-consumer":43,"./source-map/source-map-generator":44,"./source-map/source-node":45}],39:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i]);
    }
    return set;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr) {
    if (this.has(aStr)) {
      // Already a member; nothing to do.
      return;
    }
    var idx = this._array.length;
    this._array.push(aStr);
    this._set[util.toSetString(aStr)] = idx;
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":46,"amdefine":47}],40:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string.
   */
  exports.decode = function base64VLQ_decode(aStr) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    return {
      value: fromVLQSigned(result),
      rest: aStr.slice(i)
    };
  };

});

},{"./base64":41,"amdefine":47}],41:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}
define(function (require, exports, module) {

  var charToIntMap = {};
  var intToCharMap = {};

  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    .split('')
    .forEach(function (ch, index) {
      charToIntMap[ch] = index;
      intToCharMap[index] = ch;
    });

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function base64_encode(aNumber) {
    if (aNumber in intToCharMap) {
      return intToCharMap[aNumber];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 digit to an integer.
   */
  exports.decode = function base64_decode(aChar) {
    if (aChar in charToIntMap) {
      return charToIntMap[aChar];
    }
    throw new TypeError("Not a valid base 64 digit: " + aChar);
  };

});

},{"amdefine":47}],42:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}
define(function (require, exports, module) {

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the next
    //      closest element that is less than that element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element which is less than the one we are searching for, so we
    //      return null.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid]);
    if (cmp === 0) {
      // Found the element we are looking for.
      return aHaystack[mid];
    }
    else if (cmp > 0) {
      // aHaystack[mid] is greater than our needle.
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      // We did not find an exact match, return the next closest one
      // (termination case 2).
      return aHaystack[mid];
    }
    else {
      // aHaystack[mid] is less than our needle.
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (2) or (3) and return the appropriate thing.
      return aLow < 0
        ? null
        : aHaystack[aLow];
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the next lowest value checked if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare) {
    return aHaystack.length > 0
      ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
      : null;
  };

});

},{"amdefine":47}],43:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');

  /**
   * A SourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    var names = util.getArg(sourceMap, 'names');
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file');

    if (version !== this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    this._names = ArraySet.fromArray(names);
    this._sources = ArraySet.fromArray(sources);
    this._sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this.file = file;

    // `this._generatedMappings` and `this._originalMappings` hold the parsed
    // mapping coordinates from the source map's "mappings" attribute. Each
    // object in the array is of the form
    //
    //     {
    //       generatedLine: The line number in the generated code,
    //       generatedColumn: The column number in the generated code,
    //       source: The path to the original source file that generated this
    //               chunk of code,
    //       originalLine: The line number in the original source that
    //                     corresponds to this chunk of generated code,
    //       originalColumn: The column number in the original source that
    //                       corresponds to this chunk of generated code,
    //       name: The name of the original symbol which generated this chunk of
    //             code.
    //     }
    //
    // All properties except for `generatedLine` and `generatedColumn` can be
    // `null`.
    //
    // `this._generatedMappings` is ordered by the generated positions.
    //
    // `this._originalMappings` is ordered by the original positions.
    this._generatedMappings = [];
    this._originalMappings = [];
    this._parseMappings(mappings, sourceRoot);
  }

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this._sourceRoot ? util.join(this._sourceRoot, s) : s;
      }, this);
    }
  });

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (an ordered list in this._generatedMappings).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var mappingSeparator = /^[,;]/;
      var str = aStr;
      var mapping;
      var temp;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          temp = base64VLQ.decode(str);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
            // Original source.
            temp = base64VLQ.decode(str);
            if (aSourceRoot) {
              mapping.source = util.join(aSourceRoot, this._sources.at(previousSource + temp.value));
            }
            else {
              mapping.source = this._sources.at(previousSource + temp.value);
            }
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            temp = base64VLQ.decode(str);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            temp = base64VLQ.decode(str);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
              // Original name.
              temp = base64VLQ.decode(str);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this._generatedMappings.push(mapping);
          this._originalMappings.push(mapping);
        }
      }

      this._originalMappings.sort(this._compareOriginalPositions);
    };

  /**
   * Comparator between two mappings where the original positions are compared.
   */
  SourceMapConsumer.prototype._compareOriginalPositions =
    function SourceMapConsumer_compareOriginalPositions(mappingA, mappingB) {
      if (mappingA.source > mappingB.source) {
        return 1;
      }
      else if (mappingA.source < mappingB.source) {
        return -1;
      }
      else {
        var cmp = mappingA.originalLine - mappingB.originalLine;
        return cmp === 0
          ? mappingA.originalColumn - mappingB.originalColumn
          : cmp;
      }
    };

  /**
   * Comparator between two mappings where the generated positions are compared.
   */
  SourceMapConsumer.prototype._compareGeneratedPositions =
    function SourceMapConsumer_compareGeneratedPositions(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      return cmp === 0
        ? mappingA.generatedColumn - mappingB.generatedColumn
        : cmp;
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  SourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  SourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var mapping = this._findMapping(needle,
                                      this._generatedMappings,
                                      "generatedLine",
                                      "generatedColumn",
                                      this._compareGeneratedPositions)

      if (mapping) {
        return {
          source: util.getArg(mapping, 'source', null),
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: util.getArg(mapping, 'name', null)
        };
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is
   * the url of the original source file. Returns null if no
   * original source content is availible.
   */
  SourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource) {
      if(!this.sourcesContent) {
        return null;
      }

      if(this._sourceRoot) {
        // Try to remove the sourceRoot
        var relativeUrl = util.relative(this._sourceRoot, aSource);
        if(relativeUrl !== aSource && this._sources.has(relativeUrl)) {
          return this.sourcesContent[this._sources.indexOf(relativeUrl)];
        }
      }

      if(this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      var mapping = this._findMapping(needle,
                                      this._originalMappings,
                                      "originalLine",
                                      "originalColumn",
                                      this._compareOriginalPositions)

      if (mapping) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null)
        };
      }

      return {
        line: null,
        column: null
      };
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping. This function should
   *        not mutate the mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      mappings.forEach(aCallback, context);
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./array-set":39,"./base64-vlq":40,"./binary-search":42,"./util":46,"amdefine":47}],44:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. To create a new one, you must pass an object
   * with the following properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: An optional root for all URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    this._file = util.getArg(aArgs, 'file');
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = [];
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      this._validateMapping(generated, original, source, name);

      if (source && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.push({
        generated: generated,
        original: original,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      if(aSourceContent !== null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if(!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(aSourceFile)] = aSourceContent;
      } else {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(aSourceFile)];
        if(Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping.');
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      // The mappings must be guarenteed to be in sorted order before we start
      // serializing them or else the generated line numbers (which are defined
      // via the ';' separators) will be all messed up. Note: it might be more
      // performant to maintain the sorting as we insert them, rather than as we
      // serialize them, but the big O is the same either way.
      this._mappings.sort(function (mappingA, mappingB) {
        var cmp = mappingA.generated.line - mappingB.generated.line;
        return cmp === 0
          ? mappingA.generated.column - mappingB.generated.column
          : cmp;
      });

      for (var i = 0, len = this._mappings.length; i < len; i++) {
        mapping = this._mappings[i];

        if (mapping.generated.line !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generated.line !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generated.column
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generated.column;

        if (mapping.source && mapping.original) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.original.line - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.original.line - 1;

          result += base64VLQ.encode(mapping.original.column
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.original.column;

          if (mapping.name) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        file: this._file,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._sourceRoot) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = map.sources.map(function(source) {
          return Object.prototype.hasOwnProperty.call(
            this._sourcesContents, util.toSetString(source))
            ? this._sourcesContents[util.toSetString(source)]
            : null;
        }, this);
      }
      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":39,"./base64-vlq":40,"./util":46,"amdefine":47}],45:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.line = aLine === undefined ? null : aLine;
    this.column = aColumn === undefined ? null : aColumn;
    this.source = aSource === undefined ? null : aSource;
    this.name = aName === undefined ? null : aName;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    this.children.forEach(function (chunk) {
      if (chunk instanceof SourceNode) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }, this);
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild instanceof SourceNode) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      chunk.split('').forEach(function (ch) {
        if (ch === '\n') {
          generated.line++;
          generated.column = 0;
        } else {
          generated.column++;
        }
      });
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":44,"amdefine":47}],46:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  function join(aRoot, aPath) {
    return aPath.charAt(0) === '/'
      ? aPath
      : aRoot.replace(/\/*$/, '') + '/' + aPath;
  }
  exports.join = join;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr
  }
  exports.toSetString = toSetString;

  function relative(aRoot, aPath) {
    return aPath.indexOf(aRoot.replace(/\/*$/, '') + '/') === 0
      ? aPath.substr(aRoot.length + 1)
      : aPath;
  }
  exports.relative = relative;

});

},{"amdefine":47}],47:[function(require,module,exports){
(function (process,__filename){/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                process.nextTick(function () {
                    callback.apply(null, deps);
                });
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;
}).call(this,require("/Users/honambang/git/aether/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),"/../node_modules/coffee-script-redux/node_modules/source-map/node_modules/amdefine/amdefine.js")
},{"/Users/honambang/git/aether/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":62,"path":63}],48:[function(require,module,exports){
module.exports={
  "name": "coffee-script-redux",
  "author": {
    "name": "Michael Ficarra"
  },
  "version": "2.0.0-beta8",
  "homepage": "https://github.com/michaelficarra/CoffeeScriptRedux",
  "bugs": {
    "url": "https://github.com/michaelficarra/CoffeeScriptRedux/issues"
  },
  "description": "Unfancy JavaScript",
  "keywords": [
    "coffeescript",
    "javascript",
    "language",
    "compiler"
  ],
  "main": "./lib/module",
  "bin": {
    "coffee": "./bin/coffee"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/michaelficarra/CoffeeScriptRedux.git"
  },
  "scripts": {
    "build": "make -j build",
    "test": "make -j test"
  },
  "devDependencies": {
    "mocha": "~1.12.0",
    "pegjs": "git://github.com/dmajda/pegjs.git#bea6b1fde74c8aebf802f9bcc3380c65b241e1b7",
    "commonjs-everywhere": "~0.9.0",
    "cluster": "~0.7.7",
    "semver": "~2.1.0"
  },
  "dependencies": {
    "StringScanner": "~0.0.3",
    "nopt": "~2.1.2",
    "esmangle": "~0.0.8",
    "source-map": "0.1.11",
    "escodegen": "~0.0.24",
    "cscodegen": "git://github.com/michaelficarra/cscodegen.git#73fd7202ac086c26f18c9d56f025b18b3c6f5383"
  },
  "optionalDependencies": {
    "esmangle": "~0.0.8",
    "source-map": "0.1.11",
    "escodegen": "~0.0.24",
    "cscodegen": "git://github.com/michaelficarra/cscodegen.git#73fd7202ac086c26f18c9d56f025b18b3c6f5383"
  },
  "engines": {
    "node": "0.8.x || 0.10.x"
  },
  "licenses": [
    {
      "type": "3-clause BSD",
      "url": "https://raw.github.com/michaelficarra/CoffeeScriptRedux/master/LICENSE"
    }
  ],
  "license": "3-clause BSD",
  "readme": "CoffeeScript II: The Wrath of Khan\n==================================\n\n```\n          {\n       }   }   {\n      {   {  }  }\n       }   }{  {\n      {  }{  }  }             _____       __  __\n     ( }{ }{  { )            / ____|     / _|/ _|\n   .- { { }  { }} -.        | |     ___ | |_| |_ ___  ___\n  (  ( } { } { } }  )       | |    / _ \\|  _|  _/ _ \\/ _ \\\n  |`-..________ ..-'|       | |___| (_) | | | ||  __/  __/\n  |                 |        \\_____\\___/|_| |_| \\___|\\___|       .-''-.\n  |                 ;--.                                       .' .-.  )\n  |                (__  \\     _____           _       _       / .'  / /\n  |                 | )  )   / ____|         (_)     | |     (_/   / /\n  |                 |/  /   | (___   ___ _ __ _ _ __ | |_         / /\n  |                 (  /     \\___ \\ / __| '__| | '_ \\| __|       / /\n  |                 |/       ____) | (__| |  | | |_) | |_       . '\n  |                 |       |_____/ \\___|_|  |_| .__/ \\__|     / /    _.-')\n   `-.._________..-'                           | |           .' '  _.'.-''\n                                               |_|          /  /.-'_.'\n                                                           /    _.'\n                                                          ( _.-'\n```\n\n### Status\n\nComplete enough to use for nearly every project. See the [roadmap to 2.0](https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Roadmap).\n\n### Getting Started\n\n    npm install -g coffee-script-redux\n    coffee --help\n    coffee --js <input.coffee >output.js\n\nBefore transitioning from Jeremy's compiler, see the\n[intentional deviations from jashkenas/coffee-script](https://github.com/michaelficarra/CoffeeScriptRedux/wiki/Intentional-Deviations-From-jashkenas-coffee-script)\nwiki page.\n\n### Development\n\n    git clone git://github.com/michaelficarra/CoffeeScriptRedux.git && cd CoffeeScriptRedux && npm install\n    make clean && git checkout -- lib && make -j build && make test\n\n### Notable Contributors\n\nI'd like to thank the following financial contributors for their large\ndonations to [the Kickstarter project](http://www.kickstarter.com/projects/michaelficarra/make-a-better-coffeescript-compiler)\nthat funded the initial work on this compiler.\nTogether, you donated over $10,000. Without you, I wouldn't have been able to do this.\n\n* [Groupon](http://groupon.com/), who is generously allowing me to work in their offices\n* [Trevor Burnham](http://trevorburnham.com)\n* [Shopify](http://www.shopify.com)\n* [Abakas](http://abakas.com)\n* [37signals](http://37signals.com)\n* [Brightcove](http://www.brightcove.com)\n* [Gaslight](http://gaslight.co)\n* [Pantheon](https://www.getpantheon.com)\n* Benbria\n* Sam Stephenson\n* Bevan Hunt\n* Meryn Stol\n* Rob Tsuk\n* Dion Almaer\n* Andrew Davey\n* Thomas Burleson\n* Michael Kedzierski\n* Jeremy Kemper\n* Kyle Cordes\n* Jason R. Lauman\n* Martin Drenovac (Envizion Systems - Aust)\n* Julian Bilcke\n* Michael Edmondson\n\nAnd of course, thank you [Jeremy](https://github.com/jashkenas) (and all the other\n[contributors](https://github.com/jashkenas/coffee-script/graphs/contributors))\nfor making [the original CoffeeScript compiler](https://github.com/jashkenas/coffee-script).\n",
  "readmeFilename": "README.md",
  "_id": "coffee-script-redux@2.0.0-beta8",
  "dist": {
    "shasum": "ee7a2f0668b11ac9930f9008fda65b08f3d34600"
  },
  "_from": "coffee-script-redux@~2.0.0-beta8",
  "_resolved": "https://registry.npmjs.org/coffee-script-redux/-/coffee-script-redux-2.0.0-beta8.tgz"
}

},{}],49:[function(require,module,exports){
(function (global){/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*global exports:true, generateStatement:true, generateExpression:true, require:true, global:true*/
(function () {
    'use strict';

    var Syntax,
        Precedence,
        BinaryPrecedence,
        SourceNode,
        estraverse,
        esutils,
        isArray,
        base,
        indent,
        json,
        renumber,
        hexadecimal,
        quotes,
        escapeless,
        newline,
        space,
        parentheses,
        semicolons,
        safeConcatenation,
        directive,
        extra,
        parse,
        sourceMap,
        FORMAT_MINIFY,
        FORMAT_DEFAULTS;

    estraverse = require('estraverse');
    esutils = require('esutils');

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ComprehensionBlock: 'ComprehensionBlock',
        ComprehensionExpression: 'ComprehensionExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExportDeclaration: 'ExportDeclaration',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    Precedence = {
        Sequence: 0,
        Yield: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Unary: 13,
        Postfix: 14,
        Call: 15,
        New: 16,
        Member: 17,
        Primary: 18
    };

    BinaryPrecedence = {
        '||': Precedence.LogicalOR,
        '&&': Precedence.LogicalAND,
        '|': Precedence.BitwiseOR,
        '^': Precedence.BitwiseXOR,
        '&': Precedence.BitwiseAND,
        '==': Precedence.Equality,
        '!=': Precedence.Equality,
        '===': Precedence.Equality,
        '!==': Precedence.Equality,
        'is': Precedence.Equality,
        'isnt': Precedence.Equality,
        '<': Precedence.Relational,
        '>': Precedence.Relational,
        '<=': Precedence.Relational,
        '>=': Precedence.Relational,
        'in': Precedence.Relational,
        'instanceof': Precedence.Relational,
        '<<': Precedence.BitwiseSHIFT,
        '>>': Precedence.BitwiseSHIFT,
        '>>>': Precedence.BitwiseSHIFT,
        '+': Precedence.Additive,
        '-': Precedence.Additive,
        '*': Precedence.Multiplicative,
        '%': Precedence.Multiplicative,
        '/': Precedence.Multiplicative
    };

    function getDefaultOptions() {
        // default options
        return {
            indent: null,
            base: null,
            parse: null,
            comment: false,
            format: {
                indent: {
                    style: '    ',
                    base: 0,
                    adjustMultilineComment: false
                },
                newline: '\n',
                space: ' ',
                json: false,
                renumber: false,
                hexadecimal: false,
                quotes: 'single',
                escapeless: false,
                compact: false,
                parentheses: true,
                semicolons: true,
                safeConcatenation: false
            },
            moz: {
                comprehensionExpressionStartsWithAssignment: false,
                starlessGenerator: false,
                parenthesizedComprehensionBlock: false
            },
            sourceMap: null,
            sourceMapRoot: null,
            sourceMapWithCode: false,
            directive: false,
            verbatim: null
        };
    }

    function stringRepeat(str, num) {
        var result = '';

        for (num |= 0; num > 0; num >>>= 1, str += str) {
            if (num & 1) {
                result += str;
            }
        }

        return result;
    }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function hasLineTerminator(str) {
        return (/[\r\n]/g).test(str);
    }

    function endsWithLineTerminator(str) {
        var len = str.length;
        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
    }

    function updateDeeply(target, override) {
        var key, val;

        function isHashObject(target) {
            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }

        for (key in override) {
            if (override.hasOwnProperty(key)) {
                val = override[key];
                if (isHashObject(val)) {
                    if (isHashObject(target[key])) {
                        updateDeeply(target[key], val);
                    } else {
                        target[key] = updateDeeply({}, val);
                    }
                } else {
                    target[key] = val;
                }
            }
        }
        return target;
    }

    function generateNumber(value) {
        var result, point, temp, exponent, pos;

        if (value !== value) {
            throw new Error('Numeric literal whose value is NaN');
        }
        if (value < 0 || (value === 0 && 1 / value < 0)) {
            throw new Error('Numeric literal whose value is negative');
        }

        if (value === 1 / 0) {
            return json ? 'null' : renumber ? '1e400' : '1e+400';
        }

        result = '' + value;
        if (!renumber || result.length < 3) {
            return result;
        }

        point = result.indexOf('.');
        if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {
            point = 0;
            result = result.slice(1);
        }
        temp = result;
        result = result.replace('e+', 'e');
        exponent = 0;
        if ((pos = temp.indexOf('e')) > 0) {
            exponent = +temp.slice(pos + 1);
            temp = temp.slice(0, pos);
        }
        if (point >= 0) {
            exponent -= temp.length - point - 1;
            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {
            --pos;
        }
        if (pos !== 0) {
            exponent -= pos;
            temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
            temp += 'e' + exponent;
        }
        if ((temp.length < result.length ||
                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&
                +temp === value) {
            result = temp;
        }

        return result;
    }

    // Generate valid RegExp expression.
    // This function is based on https://github.com/Constellation/iv Engine

    function escapeRegExpCharacter(ch, previousIsBackslash) {
        // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
        if ((ch & ~1) === 0x2028) {
            return (previousIsBackslash ? 'u' : '\\u') + ((ch === 0x2028) ? '2028' : '2029');
        } else if (ch === 10 || ch === 13) {  // \n, \r
            return (previousIsBackslash ? '' : '\\') + ((ch === 10) ? 'n' : 'r');
        }
        return String.fromCharCode(ch);
    }

    function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;

        result = reg.toString();

        if (reg.source) {
            // extract flag from toString result
            match = result.match(/\/([^/]*)$/);
            if (!match) {
                return result;
            }

            flags = match[1];
            result = '';

            characterInBrack = false;
            previousIsBackslash = false;
            for (i = 0, iz = reg.source.length; i < iz; ++i) {
                ch = reg.source.charCodeAt(i);

                if (!previousIsBackslash) {
                    if (characterInBrack) {
                        if (ch === 93) {  // ]
                            characterInBrack = false;
                        }
                    } else {
                        if (ch === 47) {  // /
                            result += '\\';
                        } else if (ch === 91) {  // [
                            characterInBrack = true;
                        }
                    }
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    previousIsBackslash = ch === 92;  // \
                } else {
                    // if new RegExp("\\\n') is provided, create /\n/
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    // prevent like /\\[/]/
                    previousIsBackslash = false;
                }
            }

            return '/' + result + '/' + flags;
        }

        return result;
    }

    function escapeAllowedCharacter(code, next) {
        var hex, result = '\\';

        switch (code) {
        case 0x08  /* \b */:
            result += 'b';
            break;
        case 0x0C  /* \f */:
            result += 'f';
            break;
        case 0x09  /* \t */:
            result += 't';
            break;
        default:
            hex = code.toString(16).toUpperCase();
            if (json || code > 0xFF) {
                result += 'u' + '0000'.slice(hex.length) + hex;
            } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {
                result += '0';
            } else if (code === 0x000B  /* \v */) { // '\v'
                result += 'x0B';
            } else {
                result += 'x' + '00'.slice(hex.length) + hex;
            }
            break;
        }

        return result;
    }

    function escapeDisallowedCharacter(code) {
        var result = '\\';
        switch (code) {
        case 0x5C  /* \ */:
            result += '\\';
            break;
        case 0x0A  /* \n */:
            result += 'n';
            break;
        case 0x0D  /* \r */:
            result += 'r';
            break;
        case 0x2028:
            result += 'u2028';
            break;
        case 0x2029:
            result += 'u2029';
            break;
        default:
            throw new Error('Incorrectly classified character');
        }

        return result;
    }

    function escapeDirective(str) {
        var i, iz, code, quote;

        quote = quotes === 'double' ? '"' : '\'';
        for (i = 0, iz = str.length; i < iz; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                quote = '"';
                break;
            } else if (code === 0x22  /* " */) {
                quote = '\'';
                break;
            } else if (code === 0x5C  /* \ */) {
                ++i;
            }
        }

        return quote + str + quote;
    }

    function escapeString(str) {
        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                ++singleQuotes;
            } else if (code === 0x22  /* " */) {
                ++doubleQuotes;
            } else if (code === 0x2F  /* / */ && json) {
                result += '\\';
            } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \ */) {
                result += escapeDisallowedCharacter(code);
                continue;
            } else if ((json && code < 0x20  /* SP */) || !(json || escapeless || (code >= 0x20  /* SP */ && code <= 0x7E  /* ~ */))) {
                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
                continue;
            }
            result += String.fromCharCode(code);
        }

        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
        quote = single ? '\'' : '"';

        if (!(single ? singleQuotes : doubleQuotes)) {
            return quote + result + quote;
        }

        str = result;
        result = quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* " */ && !single)) {
                result += '\\';
            }
            result += String.fromCharCode(code);
        }

        return result + quote;
    }

    /**
     * flatten an array to a string, where the array can contain
     * either strings or nested arrays
     */
    function flattenToString(arr) {
        var i, iz, elem, result = '';
        for (i = 0, iz = arr.length; i < iz; ++i) {
            elem = arr[i];
            result += isArray(elem) ? flattenToString(elem) : elem;
        }
        return result;
    }

    /**
     * convert generated to a SourceNode when source maps are enabled.
     */
    function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap) {
            // with no source maps, generated is either an
            // array or a string.  if an array, flatten it.
            // if a string, just return it
            if (isArray(generated)) {
                return flattenToString(generated);
            } else {
                return generated;
            }
        }
        if (node == null) {
            if (generated instanceof SourceNode) {
                return generated;
            } else {
                node = {};
            }
        }
        if (node.loc == null) {
            return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
    }

    function noEmptySpace() {
        return (space) ? space : ' ';
    }

    function join(left, right) {
        var leftSource = toSourceNodeWhenNeeded(left).toString(),
            rightSource = toSourceNodeWhenNeeded(right).toString(),
            leftCharCode = leftSource.charCodeAt(leftSource.length - 1),
            rightCharCode = rightSource.charCodeAt(0);

        if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||
        esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode) ||
        leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`
            return [left, noEmptySpace(), right];
        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||
                esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
            return [left, right];
        }
        return [left, space, right];
    }

    function addIndent(stmt) {
        return [base, stmt];
    }

    function withIndent(fn) {
        var previousBase, result;
        previousBase = base;
        base += indent;
        result = fn.call(this, base);
        base = previousBase;
        return result;
    }

    function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; --i) {
            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
                break;
            }
        }
        return (str.length - 1) - i;
    }

    function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase, sn;

        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;

        // first line doesn't have indentation
        for (i = 1, len = array.length; i < len; ++i) {
            line = array[i];
            j = 0;
            while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
                ++j;
            }
            if (spaces > j) {
                spaces = j;
            }
        }

        if (typeof specialBase !== 'undefined') {
            // pattern like
            // {
            //   var t = 20;  /*
            //                 * this is comment
            //                 */
            // }
            previousBase = base;
            if (array[1][spaces] === '*') {
                specialBase += ' ';
            }
            base = specialBase;
        } else {
            if (spaces & 1) {
                // /*
                //  *
                //  */
                // If spaces are odd number, above pattern is considered.
                // We waste 1 space.
                --spaces;
            }
            previousBase = base;
        }

        for (i = 1, len = array.length; i < len; ++i) {
            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
            array[i] = sourceMap ? sn.join('') : sn;
        }

        base = previousBase;

        return array.join('\n');
    }

    function generateComment(comment, specialBase) {
        if (comment.type === 'Line') {
            if (endsWithLineTerminator(comment.value)) {
                return '//' + comment.value;
            } else {
                // Always use LineTerminator
                return '//' + comment.value + '\n';
            }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
        }
        return '/*' + comment.value + '*/';
    }

    function addCommentsToStatement(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment;

        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
            save = result;

            comment = stmt.leadingComments[0];
            result = [];
            if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                result.push('\n');
            }
            result.push(generateComment(comment));
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push('\n');
            }

            for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
                comment = stmt.leadingComments[i];
                fragment = [generateComment(comment)];
                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    fragment.push('\n');
                }
                result.push(addIndent(fragment));
            }

            result.push(addIndent(save));
        }

        if (stmt.trailingComments) {
            tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
            specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
            for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
                comment = stmt.trailingComments[i];
                if (tailingToStatement) {
                    // We assume target like following script
                    //
                    // var t = 20;  /**
                    //               * This is comment of t
                    //               */
                    if (i === 0) {
                        // first case
                        result = [result, indent];
                    } else {
                        result = [result, specialBase];
                    }
                    result.push(generateComment(comment, specialBase));
                } else {
                    result = [result, addIndent(generateComment(comment))];
                }
                if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result = [result, '\n'];
                }
            }
        }

        return result;
    }

    function parenthesize(text, current, should) {
        if (current < should) {
            return ['(', text, ')'];
        }
        return text;
    }

    function maybeBlock(stmt, semicolonOptional, functionBody) {
        var result, noLeadingComment;

        noLeadingComment = !extra.comment || !stmt.leadingComments;

        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
            return [space, generateStatement(stmt, { functionBody: functionBody })];
        }

        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
            return ';';
        }

        withIndent(function () {
            result = [newline, addIndent(generateStatement(stmt, { semicolonOptional: semicolonOptional, functionBody: functionBody }))];
        });

        return result;
    }

    function maybeBlockSuffix(stmt, result) {
        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
            return [result, space];
        }
        if (ends) {
            return [result, base];
        }
        return [result, newline, base];
    }

    function generateVerbatimString(string) {
        var i, iz, result;
        result = string.split(/\r\n|\n/);
        for (i = 1, iz = result.length; i < iz; i++) {
            result[i] = newline + base + result[i];
        }
        return result;
    }

    function generateVerbatim(expr, option) {
        var verbatim, result, prec;
        verbatim = expr[extra.verbatim];

        if (typeof verbatim === 'string') {
            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, option.precedence);
        } else {
            // verbatim is object
            result = generateVerbatimString(verbatim.content);
            prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;
            result = parenthesize(result, prec, option.precedence);
        }

        return toSourceNodeWhenNeeded(result, expr);
    }

    function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
    }

    function generatePattern(node, options) {
        var result;

        if (node.type === Syntax.Identifier) {
            result = generateIdentifier(node);
        } else {
            result = generateExpression(node, {
                precedence: options.precedence,
                allowIn: options.allowIn,
                allowCall: true
            });
        }

        return result;
    }

    function generateFunctionBody(node) {
        var result, i, len, expr, arrow;

        arrow = node.type === Syntax.ArrowFunctionExpression;

        if (arrow && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
            // arg => { } case
            result = [generateIdentifier(node.params[0])];
        } else {
            result = ['('];
            for (i = 0, len = node.params.length; i < len; ++i) {
                result.push(generatePattern(node.params[i], {
                    precedence: Precedence.Assignment,
                    allowIn: true
                }));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result.push(')');
        }

        if (arrow) {
            result.push(space);
            result.push('=>');
        }

        if (node.expression) {
            result.push(space);
            expr = generateExpression(node.body, {
                precedence: Precedence.Assignment,
                allowIn: true,
                allowCall: true
            });
            if (expr.toString().charAt(0) === '{') {
                expr = ['(', expr, ')'];
            }
            result.push(expr);
        } else {
            result.push(maybeBlock(node.body, false, true));
        }
        return result;
    }

    function generateIterationForStatement(operator, stmt, semicolonIsNotNeeded) {
        var result = ['for' + space + '('];
        withIndent(function () {
            if (stmt.left.type === Syntax.VariableDeclaration) {
                withIndent(function () {
                    result.push(stmt.left.kind + noEmptySpace());
                    result.push(generateStatement(stmt.left.declarations[0], {
                        allowIn: false
                    }));
                });
            } else {
                result.push(generateExpression(stmt.left, {
                    precedence: Precedence.Call,
                    allowIn: true,
                    allowCall: true
                }));
            }

            result = join(result, operator);
            result = [join(
                result,
                generateExpression(stmt.right, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                })
            ), ')'];
        });
        result.push(maybeBlock(stmt.body, semicolonIsNotNeeded));
        return result;
    }

    function generateExpression(expr, option) {
        var result,
            precedence,
            type,
            currentPrecedence,
            i,
            len,
            raw,
            fragment,
            multiline,
            leftCharCode,
            leftSource,
            rightCharCode,
            allowIn,
            allowCall,
            allowUnparenthesizedNew,
            property,
            isGenerator;

        precedence = option.precedence;
        allowIn = option.allowIn;
        allowCall = option.allowCall;
        type = expr.type || option.type;

        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
            return generateVerbatim(expr, option);
        }

        switch (type) {
        case Syntax.SequenceExpression:
            result = [];
            allowIn |= (Precedence.Sequence < precedence);
            for (i = 0, len = expr.expressions.length; i < len; ++i) {
                result.push(generateExpression(expr.expressions[i], {
                    precedence: Precedence.Assignment,
                    allowIn: allowIn,
                    allowCall: true
                }));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result = parenthesize(result, Precedence.Sequence, precedence);
            break;

        case Syntax.AssignmentExpression:
            allowIn |= (Precedence.Assignment < precedence);
            result = parenthesize(
                [
                    generateExpression(expr.left, {
                        precedence: Precedence.Call,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + expr.operator + space,
                    generateExpression(expr.right, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ],
                Precedence.Assignment,
                precedence
            );
            break;

        case Syntax.ArrowFunctionExpression:
            allowIn |= (Precedence.ArrowFunction < precedence);
            result = parenthesize(generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
            break;

        case Syntax.ConditionalExpression:
            allowIn |= (Precedence.Conditional < precedence);
            result = parenthesize(
                [
                    generateExpression(expr.test, {
                        precedence: Precedence.LogicalOR,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + '?' + space,
                    generateExpression(expr.consequent, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + ':' + space,
                    generateExpression(expr.alternate, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ],
                Precedence.Conditional,
                precedence
            );
            break;

        case Syntax.LogicalExpression:
        case Syntax.BinaryExpression:
            currentPrecedence = BinaryPrecedence[expr.operator];

            allowIn |= (currentPrecedence < precedence);

            fragment = generateExpression(expr.left, {
                precedence: currentPrecedence,
                allowIn: allowIn,
                allowCall: true
            });

            leftSource = fragment.toString();

            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPart(expr.operator.charCodeAt(0))) {
                result = [fragment, noEmptySpace(), expr.operator];
            } else {
                result = join(fragment, expr.operator);
            }

            fragment = generateExpression(expr.right, {
                precedence: currentPrecedence + 1,
                allowIn: allowIn,
                allowCall: true
            });

            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||
            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
                result.push(noEmptySpace());
                result.push(fragment);
            } else {
                result = join(result, fragment);
            }

            if (expr.operator === 'in' && !allowIn) {
                result = ['(', result, ')'];
            } else {
                result = parenthesize(result, currentPrecedence, precedence);
            }

            break;

        case Syntax.CallExpression:
            result = [generateExpression(expr.callee, {
                precedence: Precedence.Call,
                allowIn: true,
                allowCall: true,
                allowUnparenthesizedNew: false
            })];

            result.push('(');
            for (i = 0, len = expr['arguments'].length; i < len; ++i) {
                result.push(generateExpression(expr['arguments'][i], {
                    precedence: Precedence.Assignment,
                    allowIn: true,
                    allowCall: true
                }));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result.push(')');

            if (!allowCall) {
                result = ['(', result, ')'];
            } else {
                result = parenthesize(result, Precedence.Call, precedence);
            }
            break;

        case Syntax.NewExpression:
            len = expr['arguments'].length;
            allowUnparenthesizedNew = option.allowUnparenthesizedNew === undefined || option.allowUnparenthesizedNew;

            result = join(
                'new',
                generateExpression(expr.callee, {
                    precedence: Precedence.New,
                    allowIn: true,
                    allowCall: false,
                    allowUnparenthesizedNew: allowUnparenthesizedNew && !parentheses && len === 0
                })
            );

            if (!allowUnparenthesizedNew || parentheses || len > 0) {
                result.push('(');
                for (i = 0; i < len; ++i) {
                    result.push(generateExpression(expr['arguments'][i], {
                        precedence: Precedence.Assignment,
                        allowIn: true,
                        allowCall: true
                    }));
                    if (i + 1 < len) {
                        result.push(',' + space);
                    }
                }
                result.push(')');
            }

            result = parenthesize(result, Precedence.New, precedence);
            break;

        case Syntax.MemberExpression:
            result = [generateExpression(expr.object, {
                precedence: Precedence.Call,
                allowIn: true,
                allowCall: allowCall,
                allowUnparenthesizedNew: false
            })];

            if (expr.computed) {
                result.push('[');
                result.push(generateExpression(expr.property, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: allowCall
                }));
                result.push(']');
            } else {
                if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                    fragment = toSourceNodeWhenNeeded(result).toString();
                    // When the following conditions are all true,
                    //   1. No floating point
                    //   2. Don't have exponents
                    //   3. The last character is a decimal digit
                    //   4. Not hexadecimal OR octal number literal
                    // we should add a floating point.
                    if (
                            fragment.indexOf('.') < 0 &&
                            !/[eExX]/.test(fragment) &&
                            esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&
                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'
                            ) {
                        result.push('.');
                    }
                }
                result.push('.');
                result.push(generateIdentifier(expr.property));
            }

            result = parenthesize(result, Precedence.Member, precedence);
            break;

        case Syntax.UnaryExpression:
            fragment = generateExpression(expr.argument, {
                precedence: Precedence.Unary,
                allowIn: true,
                allowCall: true
            });

            if (space === '') {
                result = join(expr.operator, fragment);
            } else {
                result = [expr.operator];
                if (expr.operator.length > 2) {
                    // delete, void, typeof
                    // get `typeof []`, not `typeof[]`
                    result = join(result, fragment);
                } else {
                    // Prevent inserting spaces between operator and argument if it is unnecessary
                    // like, `!cond`
                    leftSource = toSourceNodeWhenNeeded(result).toString();
                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                    rightCharCode = fragment.toString().charCodeAt(0);

                    if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||
                            (esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode))) {
                        result.push(noEmptySpace());
                        result.push(fragment);
                    } else {
                        result.push(fragment);
                    }
                }
            }
            result = parenthesize(result, Precedence.Unary, precedence);
            break;

        case Syntax.YieldExpression:
            if (expr.delegate) {
                result = 'yield*';
            } else {
                result = 'yield';
            }
            if (expr.argument) {
                result = join(
                    result,
                    generateExpression(expr.argument, {
                        precedence: Precedence.Yield,
                        allowIn: true,
                        allowCall: true
                    })
                );
            }
            result = parenthesize(result, Precedence.Yield, precedence);
            break;

        case Syntax.UpdateExpression:
            if (expr.prefix) {
                result = parenthesize(
                    [
                        expr.operator,
                        generateExpression(expr.argument, {
                            precedence: Precedence.Unary,
                            allowIn: true,
                            allowCall: true
                        })
                    ],
                    Precedence.Unary,
                    precedence
                );
            } else {
                result = parenthesize(
                    [
                        generateExpression(expr.argument, {
                            precedence: Precedence.Postfix,
                            allowIn: true,
                            allowCall: true
                        }),
                        expr.operator
                    ],
                    Precedence.Postfix,
                    precedence
                );
            }
            break;

        case Syntax.FunctionExpression:
            isGenerator = expr.generator && !extra.moz.starlessGenerator;
            result = isGenerator ? 'function*' : 'function';

            if (expr.id) {
                result = [result, (isGenerator) ? space : noEmptySpace(),
                          generateIdentifier(expr.id),
                          generateFunctionBody(expr)];
            } else {
                result = [result + space, generateFunctionBody(expr)];
            }

            break;

        case Syntax.ArrayPattern:
        case Syntax.ArrayExpression:
            if (!expr.elements.length) {
                result = '[]';
                break;
            }
            multiline = expr.elements.length > 1;
            result = ['[', multiline ? newline : ''];
            withIndent(function (indent) {
                for (i = 0, len = expr.elements.length; i < len; ++i) {
                    if (!expr.elements[i]) {
                        if (multiline) {
                            result.push(indent);
                        }
                        if (i + 1 === len) {
                            result.push(',');
                        }
                    } else {
                        result.push(multiline ? indent : '');
                        result.push(generateExpression(expr.elements[i], {
                            precedence: Precedence.Assignment,
                            allowIn: true,
                            allowCall: true
                        }));
                    }
                    if (i + 1 < len) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });
            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push(']');
            break;

        case Syntax.Property:
            if (expr.kind === 'get' || expr.kind === 'set') {
                result = [
                    expr.kind, noEmptySpace(),
                    generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    generateFunctionBody(expr.value)
                ];
            } else {
                if (expr.shorthand) {
                    result = generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    });
                } else if (expr.method) {
                    result = [];
                    if (expr.value.generator) {
                        result.push('*');
                    }
                    result.push(generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }));
                    result.push(generateFunctionBody(expr.value));
                } else {
                    result = [
                        generateExpression(expr.key, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        }),
                        ':' + space,
                        generateExpression(expr.value, {
                            precedence: Precedence.Assignment,
                            allowIn: true,
                            allowCall: true
                        })
                    ];
                }
            }
            break;

        case Syntax.ObjectExpression:
            if (!expr.properties.length) {
                result = '{}';
                break;
            }
            multiline = expr.properties.length > 1;

            withIndent(function () {
                fragment = generateExpression(expr.properties[0], {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true,
                    type: Syntax.Property
                });
            });

            if (!multiline) {
                // issues 4
                // Do not transform from
                //   dejavu.Class.declare({
                //       method2: function () {}
                //   });
                // to
                //   dejavu.Class.declare({method2: function () {
                //       }});
                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    result = [ '{', space, fragment, space, '}' ];
                    break;
                }
            }

            withIndent(function (indent) {
                result = [ '{', newline, indent, fragment ];

                if (multiline) {
                    result.push(',' + newline);
                    for (i = 1, len = expr.properties.length; i < len; ++i) {
                        result.push(indent);
                        result.push(generateExpression(expr.properties[i], {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true,
                            type: Syntax.Property
                        }));
                        if (i + 1 < len) {
                            result.push(',' + newline);
                        }
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            break;

        case Syntax.ObjectPattern:
            if (!expr.properties.length) {
                result = '{}';
                break;
            }

            multiline = false;
            if (expr.properties.length === 1) {
                property = expr.properties[0];
                if (property.value.type !== Syntax.Identifier) {
                    multiline = true;
                }
            } else {
                for (i = 0, len = expr.properties.length; i < len; ++i) {
                    property = expr.properties[i];
                    if (!property.shorthand) {
                        multiline = true;
                        break;
                    }
                }
            }
            result = ['{', multiline ? newline : '' ];

            withIndent(function (indent) {
                for (i = 0, len = expr.properties.length; i < len; ++i) {
                    result.push(multiline ? indent : '');
                    result.push(generateExpression(expr.properties[i], {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }));
                    if (i + 1 < len) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });

            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push('}');
            break;

        case Syntax.ThisExpression:
            result = 'this';
            break;

        case Syntax.Identifier:
            result = generateIdentifier(expr);
            break;

        case Syntax.Literal:
            if (expr.hasOwnProperty('raw') && parse) {
                try {
                    raw = parse(expr.raw).body[0].expression;
                    if (raw.type === Syntax.Literal) {
                        if (raw.value === expr.value) {
                            result = expr.raw;
                            break;
                        }
                    }
                } catch (e) {
                    // not use raw property
                }
            }

            if (expr.value === null) {
                result = 'null';
                break;
            }

            if (typeof expr.value === 'string') {
                result = escapeString(expr.value);
                break;
            }

            if (typeof expr.value === 'number') {
                result = generateNumber(expr.value);
                break;
            }

            if (typeof expr.value === 'boolean') {
                result = expr.value ? 'true' : 'false';
                break;
            }

            result = generateRegExp(expr.value);
            break;

        case Syntax.GeneratorExpression:
        case Syntax.ComprehensionExpression:
            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]
            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6
            result = (type === Syntax.GeneratorExpression) ? ['('] : ['['];

            if (extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = generateExpression(expr.body, {
                    precedence: Precedence.Assignment,
                    allowIn: true,
                    allowCall: true
                });

                result.push(fragment);
            }

            if (expr.blocks) {
                withIndent(function () {
                    for (i = 0, len = expr.blocks.length; i < len; ++i) {
                        fragment = generateExpression(expr.blocks[i], {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        });

                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                            result = join(result, fragment);
                        } else {
                            result.push(fragment);
                        }
                    }
                });
            }

            if (expr.filter) {
                result = join(result, 'if' + space);
                fragment = generateExpression(expr.filter, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                });
                if (extra.moz.parenthesizedComprehensionBlock) {
                    result = join(result, [ '(', fragment, ')' ]);
                } else {
                    result = join(result, fragment);
                }
            }

            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = generateExpression(expr.body, {
                    precedence: Precedence.Assignment,
                    allowIn: true,
                    allowCall: true
                });

                result = join(result, fragment);
            }

            result.push((type === Syntax.GeneratorExpression) ? ')' : ']');
            break;

        case Syntax.ComprehensionBlock:
            if (expr.left.type === Syntax.VariableDeclaration) {
                fragment = [
                    expr.left.kind, noEmptySpace(),
                    generateStatement(expr.left.declarations[0], {
                        allowIn: false
                    })
                ];
            } else {
                fragment = generateExpression(expr.left, {
                    precedence: Precedence.Call,
                    allowIn: true,
                    allowCall: true
                });
            }

            fragment = join(fragment, expr.of ? 'of' : 'in');
            fragment = join(fragment, generateExpression(expr.right, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            }));

            if (extra.moz.parenthesizedComprehensionBlock) {
                result = [ 'for' + space + '(', fragment, ')' ];
            } else {
                result = join('for' + space, fragment);
            }
            break;

        default:
            throw new Error('Unknown expression type: ' + expr.type);
        }

        return toSourceNodeWhenNeeded(result, expr);
    }

    function generateStatement(stmt, option) {
        var i,
            len,
            result,
            node,
            allowIn,
            functionBody,
            directiveContext,
            fragment,
            semicolon,
            isGenerator;

        allowIn = true;
        semicolon = ';';
        functionBody = false;
        directiveContext = false;
        if (option) {
            allowIn = option.allowIn === undefined || option.allowIn;
            if (!semicolons && option.semicolonOptional === true) {
                semicolon = '';
            }
            functionBody = option.functionBody;
            directiveContext = option.directiveContext;
        }

        switch (stmt.type) {
        case Syntax.BlockStatement:
            result = ['{', newline];

            withIndent(function () {
                for (i = 0, len = stmt.body.length; i < len; ++i) {
                    fragment = addIndent(generateStatement(stmt.body[i], {
                        semicolonOptional: i === len - 1,
                        directiveContext: functionBody
                    }));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });

            result.push(addIndent('}'));
            break;

        case Syntax.BreakStatement:
            if (stmt.label) {
                result = 'break ' + stmt.label.name + semicolon;
            } else {
                result = 'break' + semicolon;
            }
            break;

        case Syntax.ContinueStatement:
            if (stmt.label) {
                result = 'continue ' + stmt.label.name + semicolon;
            } else {
                result = 'continue' + semicolon;
            }
            break;

        case Syntax.DirectiveStatement:
            if (stmt.raw) {
                result = stmt.raw + semicolon;
            } else {
                result = escapeDirective(stmt.directive) + semicolon;
            }
            break;

        case Syntax.DoWhileStatement:
            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
            result = join('do', maybeBlock(stmt.body));
            result = maybeBlockSuffix(stmt.body, result);
            result = join(result, [
                'while' + space + '(',
                generateExpression(stmt.test, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                }),
                ')' + semicolon
            ]);
            break;

        case Syntax.CatchClause:
            withIndent(function () {
                var guard;

                result = [
                    'catch' + space + '(',
                    generateExpression(stmt.param, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];

                if (stmt.guard) {
                    guard = generateExpression(stmt.guard, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    });

                    result.splice(2, 0, ' if ', guard);
                }
            });
            result.push(maybeBlock(stmt.body));
            break;

        case Syntax.DebuggerStatement:
            result = 'debugger' + semicolon;
            break;

        case Syntax.EmptyStatement:
            result = ';';
            break;

        case Syntax.ExportDeclaration:
            result = 'export ';
            if (stmt.declaration) {
                // FunctionDeclaration or VariableDeclaration
                result = [result, generateStatement(stmt.declaration, { semicolonOptional: semicolon === '' })];
                break;
            }
            break;

        case Syntax.ExpressionStatement:
            result = [generateExpression(stmt.expression, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            })];
            // 12.4 '{', 'function' is not allowed in this position.
            // wrap expression with parentheses
            fragment = toSourceNodeWhenNeeded(result).toString();
            if (fragment.charAt(0) === '{' ||  // ObjectExpression
                    (fragment.slice(0, 8) === 'function' && '* ('.indexOf(fragment.charAt(8)) >= 0) ||  // function or generator
                    (directive && directiveContext && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {
                result = ['(', result, ')' + semicolon];
            } else {
                result.push(semicolon);
            }
            break;

        case Syntax.VariableDeclarator:
            if (stmt.init) {
                result = [
                    generateExpression(stmt.id, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space,
                    '=',
                    space,
                    generateExpression(stmt.init, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ];
            } else {
                result = generatePattern(stmt.id, {
                    precedence: Precedence.Assignment,
                    allowIn: allowIn
                });
            }
            break;

        case Syntax.VariableDeclaration:
            result = [stmt.kind];
            // special path for
            // var x = function () {
            // };
            if (stmt.declarations.length === 1 && stmt.declarations[0].init &&
                    stmt.declarations[0].init.type === Syntax.FunctionExpression) {
                result.push(noEmptySpace());
                result.push(generateStatement(stmt.declarations[0], {
                    allowIn: allowIn
                }));
            } else {
                // VariableDeclarator is typed as Statement,
                // but joined with comma (not LineTerminator).
                // So if comment is attached to target node, we should specialize.
                withIndent(function () {
                    node = stmt.declarations[0];
                    if (extra.comment && node.leadingComments) {
                        result.push('\n');
                        result.push(addIndent(generateStatement(node, {
                            allowIn: allowIn
                        })));
                    } else {
                        result.push(noEmptySpace());
                        result.push(generateStatement(node, {
                            allowIn: allowIn
                        }));
                    }

                    for (i = 1, len = stmt.declarations.length; i < len; ++i) {
                        node = stmt.declarations[i];
                        if (extra.comment && node.leadingComments) {
                            result.push(',' + newline);
                            result.push(addIndent(generateStatement(node, {
                                allowIn: allowIn
                            })));
                        } else {
                            result.push(',' + space);
                            result.push(generateStatement(node, {
                                allowIn: allowIn
                            }));
                        }
                    }
                });
            }
            result.push(semicolon);
            break;

        case Syntax.ThrowStatement:
            result = [join(
                'throw',
                generateExpression(stmt.argument, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                })
            ), semicolon];
            break;

        case Syntax.TryStatement:
            result = ['try', maybeBlock(stmt.block)];
            result = maybeBlockSuffix(stmt.block, result);

            if (stmt.handlers) {
                // old interface
                for (i = 0, len = stmt.handlers.length; i < len; ++i) {
                    result = join(result, generateStatement(stmt.handlers[i]));
                    if (stmt.finalizer || i + 1 !== len) {
                        result = maybeBlockSuffix(stmt.handlers[i].body, result);
                    }
                }
            } else {
                stmt.guardedHandlers = stmt.guardedHandlers || [];

                for (i = 0, len = stmt.guardedHandlers.length; i < len; ++i) {
                    result = join(result, generateStatement(stmt.guardedHandlers[i]));
                    if (stmt.finalizer || i + 1 !== len) {
                        result = maybeBlockSuffix(stmt.guardedHandlers[i].body, result);
                    }
                }

                // new interface
                if (stmt.handler) {
                    if (isArray(stmt.handler)) {
                        for (i = 0, len = stmt.handler.length; i < len; ++i) {
                            result = join(result, generateStatement(stmt.handler[i]));
                            if (stmt.finalizer || i + 1 !== len) {
                                result = maybeBlockSuffix(stmt.handler[i].body, result);
                            }
                        }
                    } else {
                        result = join(result, generateStatement(stmt.handler));
                        if (stmt.finalizer) {
                            result = maybeBlockSuffix(stmt.handler.body, result);
                        }
                    }
                }
            }
            if (stmt.finalizer) {
                result = join(result, ['finally', maybeBlock(stmt.finalizer)]);
            }
            break;

        case Syntax.SwitchStatement:
            withIndent(function () {
                result = [
                    'switch' + space + '(',
                    generateExpression(stmt.discriminant, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')' + space + '{' + newline
                ];
            });
            if (stmt.cases) {
                for (i = 0, len = stmt.cases.length; i < len; ++i) {
                    fragment = addIndent(generateStatement(stmt.cases[i], {semicolonOptional: i === len - 1}));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            }
            result.push(addIndent('}'));
            break;

        case Syntax.SwitchCase:
            withIndent(function () {
                if (stmt.test) {
                    result = [
                        join('case', generateExpression(stmt.test, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        })),
                        ':'
                    ];
                } else {
                    result = ['default:'];
                }

                i = 0;
                len = stmt.consequent.length;
                if (len && stmt.consequent[0].type === Syntax.BlockStatement) {
                    fragment = maybeBlock(stmt.consequent[0]);
                    result.push(fragment);
                    i = 1;
                }

                if (i !== len && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(newline);
                }

                for (; i < len; ++i) {
                    fragment = addIndent(generateStatement(stmt.consequent[i], {semicolonOptional: i === len - 1 && semicolon === ''}));
                    result.push(fragment);
                    if (i + 1 !== len && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });
            break;

        case Syntax.IfStatement:
            withIndent(function () {
                result = [
                    'if' + space + '(',
                    generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            if (stmt.alternate) {
                result.push(maybeBlock(stmt.consequent));
                result = maybeBlockSuffix(stmt.consequent, result);
                if (stmt.alternate.type === Syntax.IfStatement) {
                    result = join(result, ['else ', generateStatement(stmt.alternate, {semicolonOptional: semicolon === ''})]);
                } else {
                    result = join(result, join('else', maybeBlock(stmt.alternate, semicolon === '')));
                }
            } else {
                result.push(maybeBlock(stmt.consequent, semicolon === ''));
            }
            break;

        case Syntax.ForStatement:
            withIndent(function () {
                result = ['for' + space + '('];
                if (stmt.init) {
                    if (stmt.init.type === Syntax.VariableDeclaration) {
                        result.push(generateStatement(stmt.init, {allowIn: false}));
                    } else {
                        result.push(generateExpression(stmt.init, {
                            precedence: Precedence.Sequence,
                            allowIn: false,
                            allowCall: true
                        }));
                        result.push(';');
                    }
                } else {
                    result.push(';');
                }

                if (stmt.test) {
                    result.push(space);
                    result.push(generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }));
                    result.push(';');
                } else {
                    result.push(';');
                }

                if (stmt.update) {
                    result.push(space);
                    result.push(generateExpression(stmt.update, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }));
                    result.push(')');
                } else {
                    result.push(')');
                }
            });

            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        case Syntax.ForInStatement:
            result = generateIterationForStatement('in', stmt, semicolon === '');
            break;

        case Syntax.ForOfStatement:
            result = generateIterationForStatement('of', stmt, semicolon === '');
            break;

        case Syntax.LabeledStatement:
            result = [stmt.label.name + ':', maybeBlock(stmt.body, semicolon === '')];
            break;

        case Syntax.Program:
            len = stmt.body.length;
            result = [safeConcatenation && len > 0 ? '\n' : ''];
            for (i = 0; i < len; ++i) {
                fragment = addIndent(
                    generateStatement(stmt.body[i], {
                        semicolonOptional: !safeConcatenation && i === len - 1,
                        directiveContext: true
                    })
                );
                result.push(fragment);
                if (i + 1 < len && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    result.push(newline);
                }
            }
            break;

        case Syntax.FunctionDeclaration:
            isGenerator = stmt.generator && !extra.moz.starlessGenerator;
            result = [
                (isGenerator ? 'function*' : 'function'),
                (isGenerator ? space : noEmptySpace()),
                generateIdentifier(stmt.id),
                generateFunctionBody(stmt)
            ];
            break;

        case Syntax.ReturnStatement:
            if (stmt.argument) {
                result = [join(
                    'return',
                    generateExpression(stmt.argument, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    })
                ), semicolon];
            } else {
                result = ['return' + semicolon];
            }
            break;

        case Syntax.WhileStatement:
            withIndent(function () {
                result = [
                    'while' + space + '(',
                    generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        case Syntax.WithStatement:
            withIndent(function () {
                result = [
                    'with' + space + '(',
                    generateExpression(stmt.object, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        default:
            throw new Error('Unknown statement type: ' + stmt.type);
        }

        // Attach comments

        if (extra.comment) {
            result = addCommentsToStatement(stmt, result);
        }

        fragment = toSourceNodeWhenNeeded(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\n') {
            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
        }

        return toSourceNodeWhenNeeded(result, stmt);
    }

    function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;

        if (options != null) {
            // Obsolete options
            //
            //   `options.indent`
            //   `options.base`
            //
            // Instead of them, we can use `option.format.indent`.
            if (typeof options.indent === 'string') {
                defaultOptions.format.indent.style = options.indent;
            }
            if (typeof options.base === 'number') {
                defaultOptions.format.indent.base = options.base;
            }
            options = updateDeeply(defaultOptions, options);
            indent = options.format.indent.style;
            if (typeof options.base === 'string') {
                base = options.base;
            } else {
                base = stringRepeat(indent, options.format.indent.base);
            }
        } else {
            options = defaultOptions;
            indent = options.format.indent.style;
            base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? 'double' : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
            newline = space = indent = base = '';
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse = json ? null : options.parse;
        sourceMap = options.sourceMap;
        extra = options;

        if (sourceMap) {
            if (!exports.browser) {
                // We assume environment is node.js
                // And prevent from including source-map by browserify
                SourceNode = require('source-map').SourceNode;
            } else {
                SourceNode = global.sourceMap.SourceNode;
            }
        }

        switch (node.type) {
        case Syntax.BlockStatement:
        case Syntax.BreakStatement:
        case Syntax.CatchClause:
        case Syntax.ContinueStatement:
        case Syntax.DirectiveStatement:
        case Syntax.DoWhileStatement:
        case Syntax.DebuggerStatement:
        case Syntax.EmptyStatement:
        case Syntax.ExpressionStatement:
        case Syntax.ForStatement:
        case Syntax.ForInStatement:
        case Syntax.ForOfStatement:
        case Syntax.FunctionDeclaration:
        case Syntax.IfStatement:
        case Syntax.LabeledStatement:
        case Syntax.Program:
        case Syntax.ReturnStatement:
        case Syntax.SwitchStatement:
        case Syntax.SwitchCase:
        case Syntax.ThrowStatement:
        case Syntax.TryStatement:
        case Syntax.VariableDeclaration:
        case Syntax.VariableDeclarator:
        case Syntax.WhileStatement:
        case Syntax.WithStatement:
            result = generateStatement(node);
            break;

        case Syntax.AssignmentExpression:
        case Syntax.ArrayExpression:
        case Syntax.ArrayPattern:
        case Syntax.BinaryExpression:
        case Syntax.CallExpression:
        case Syntax.ConditionalExpression:
        case Syntax.FunctionExpression:
        case Syntax.Identifier:
        case Syntax.Literal:
        case Syntax.LogicalExpression:
        case Syntax.MemberExpression:
        case Syntax.NewExpression:
        case Syntax.ObjectExpression:
        case Syntax.ObjectPattern:
        case Syntax.Property:
        case Syntax.SequenceExpression:
        case Syntax.ThisExpression:
        case Syntax.UnaryExpression:
        case Syntax.UpdateExpression:
        case Syntax.YieldExpression:

            result = generateExpression(node, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            });
            break;

        default:
            throw new Error('Unknown node type: ' + node.type);
        }

        if (!sourceMap) {
            return result.toString();
        }


        pair = result.toStringWithSourceMap({
            file: options.file,
            sourceRoot: options.sourceMapRoot
        });

        if (options.sourceContent) {
            pair.map.setSourceContent(options.sourceMap,
                                      options.sourceContent);
        }

        if (options.sourceMapWithCode) {
            return pair;
        }

        return pair.map.toString();
    }

    FORMAT_MINIFY = {
        indent: {
            style: '',
            base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: 'auto',
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
    };

    FORMAT_DEFAULTS = getDefaultOptions().format;

    exports.version = require('./package.json').version;
    exports.generate = generate;
    exports.attachComments = estraverse.attachComments;
    exports.Precedence = updateDeeply({}, Precedence);
    exports.browser = false;
    exports.FORMAT_MINIFY = FORMAT_MINIFY;
    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
}());
/* vim: set sw=4 ts=4 et tw=80 : */
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./package.json":53,"estraverse":55,"esutils":52,"source-map":78}],50:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var Regex;

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {
        return isDecimalDigit(ch) || (97 <= ch && ch <= 102) || (65 <= ch && ch <= 70);
    }

    function isOctalDigit(ch) {
        return (ch >= 48 && ch <= 55);   // 0..7
    }

    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch >= 48 && ch <= 57) ||         // 0..9
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStart: isIdentifierStart,
        isIdentifierPart: isIdentifierPart
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],51:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierName(id) {
        var i, iz, ch;

        if (id.length === 0) {
            return false;
        }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStart(ch) || ch === 92) {  // \ (backslash)
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPart(ch) || ch === 92) {  // \ (backslash)
                return false;
            }
        }
        return true;
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierName: isIdentifierName
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":50}],52:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.code = require('./code');
    exports.keyword = require('./keyword');
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":50,"./keyword":51}],53:[function(require,module,exports){
module.exports={
  "name": "escodegen",
  "description": "ECMAScript code generator",
  "homepage": "http://github.com/Constellation/escodegen",
  "main": "escodegen.js",
  "bin": {
    "esgenerate": "./bin/esgenerate.js",
    "escodegen": "./bin/escodegen.js"
  },
  "version": "1.3.0",
  "engines": {
    "node": ">=0.4.0"
  },
  "maintainers": [
    {
      "name": "Yusuke Suzuki",
      "email": "utatane.tea@gmail.com",
      "url": "http://github.com/Constellation"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/Constellation/escodegen.git"
  },
  "dependencies": {
    "esprima": "~1.0.4",
    "estraverse": "~1.5.0",
    "esutils": "~1.0.0",
    "source-map": "~0.1.30"
  },
  "optionalDependencies": {
    "source-map": "~0.1.30"
  },
  "devDependencies": {
    "esprima-moz": "*",
    "q": "*",
    "bower": "*",
    "semver": "*",
    "chai": "~1.7.2",
    "gulp": "~3.5.0",
    "gulp-mocha": "~0.4.1",
    "gulp-eslint": "~0.1.2",
    "jshint-stylish": "~0.1.5",
    "gulp-jshint": "~1.4.0",
    "commonjs-everywhere": "~0.9.6"
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "http://github.com/Constellation/escodegen/raw/master/LICENSE.BSD"
    }
  ],
  "scripts": {
    "test": "gulp travis",
    "unit-test": "gulp test",
    "lint": "gulp lint",
    "release": "node tools/release.js",
    "build-min": "cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
    "build": "cjsify -a path: tools/entry-point.js > escodegen.browser.js"
  },
  "readme": "\n### Escodegen [![Build Status](https://secure.travis-ci.org/Constellation/escodegen.png)](http://travis-ci.org/Constellation/escodegen) [![Build Status](https://drone.io/github.com/Constellation/escodegen/status.png)](https://drone.io/github.com/Constellation/escodegen/latest)\n\nEscodegen ([escodegen](http://github.com/Constellation/escodegen)) is\n[ECMAScript](http://www.ecma-international.org/publications/standards/Ecma-262.htm)\n(also popularly known as [JavaScript](http://en.wikipedia.org/wiki/JavaScript>JavaScript))\ncode generator from [Parser API](https://developer.mozilla.org/en/SpiderMonkey/Parser_API) AST.\nSee [online generator demo](http://constellation.github.com/escodegen/demo/index.html).\n\n\n### Install\n\nEscodegen can be used in a web browser:\n\n    <script src=\"escodegen.browser.js\"></script>\n\nescodegen.browser.js is found in tagged-revision. See Tags on GitHub.\n\nOr in a Node.js application via the package manager:\n\n    npm install escodegen\n\n### Usage\n\nA simple example: the program\n\n    escodegen.generate({\n        type: 'BinaryExpression',\n        operator: '+',\n        left: { type: 'Literal', value: 40 },\n        right: { type: 'Literal', value: 2 }\n    });\n\nproduces the string `'40 + 2'`\n\nSee the [API page](https://github.com/Constellation/escodegen/wiki/API) for\noptions. To run the tests, execute `npm test` in the root directory.\n\n### Building browser bundle / minified browser bundle\n\nAt first, executing `npm install` to install the all dev dependencies.\nAfter that,\n\n    npm run-script build\n\nwill generate `escodegen.browser.js`, it is used on the browser environment.\n\nAnd,\n\n    npm run-script build-min\n\nwill generate minified `escodegen.browser.min.js`.\n\n### License\n\n#### Escodegen\n\nCopyright (C) 2012 [Yusuke Suzuki](http://github.com/Constellation)\n (twitter: [@Constellation](http://twitter.com/Constellation)) and other contributors.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright\n    notice, this list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the\n    documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\nTHIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#### source-map\n\nSourceNodeMocks has a limited interface of mozilla/source-map SourceNode implementations.\n\nCopyright (c) 2009-2011, Mozilla Foundation and contributors\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\n* Neither the names of the Mozilla Foundation nor the names of project\n  contributors may be used to endorse or promote products derived from this\n  software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/Constellation/escodegen/issues"
  },
  "_id": "escodegen@1.3.0",
  "_from": "escodegen@~1.3.0"
}

},{}],54:[function(require,module,exports){
/*
  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*jslint bitwise:true plusplus:true */
/*global esprima:true, define:true, exports:true, window: true,
throwError: true, generateStatement: true, peek: true,
parseAssignmentExpression: true, parseBlock: true,
parseClassExpression: true, parseClassDeclaration: true, parseExpression: true,
parseForStatement: true,
parseFunctionDeclaration: true, parseFunctionExpression: true,
parseFunctionSourceElements: true, parseVariableIdentifier: true,
parseImportSpecifier: true,
parseLeftHandSideExpression: true, parseParams: true, validateParam: true,
parseSpreadOrAssignmentExpression: true,
parseStatement: true, parseSourceElement: true, parseModuleBlock: true, parseConciseBody: true,
parseYieldExpression: true
*/

(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    'use strict';

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PropertyKind,
        Messages,
        Regex,
        SyntaxTreeDelegate,
        ClassPropertyType,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        length,
        delegate,
        lookahead,
        state,
        extra;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9,
        Template: 10
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.RegularExpression] = 'RegularExpression';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                    'return', 'case', 'delete', 'throw', 'void',
                    // assignment operators
                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                    '&=', '|=', '^=', ',',
                    // binary/unary operators
                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                    '<=', '<', '>', '!=', '!=='];

    Syntax = {
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        AssignmentExpression: 'AssignmentExpression',
        BinaryExpression: 'BinaryExpression',
        BlockStatement: 'BlockStatement',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ClassHeritage: 'ClassHeritage',
        ComprehensionBlock: 'ComprehensionBlock',
        ComprehensionExpression: 'ComprehensionExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExportDeclaration: 'ExportDeclaration',
        ExportBatchSpecifier: 'ExportBatchSpecifier',
        ExportSpecifier: 'ExportSpecifier',
        ExpressionStatement: 'ExpressionStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        ForStatement: 'ForStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        ImportSpecifier: 'ImportSpecifier',
        LabeledStatement: 'LabeledStatement',
        Literal: 'Literal',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        ModuleDeclaration: 'ModuleDeclaration',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SpreadElement: 'SpreadElement',
        SwitchCase: 'SwitchCase',
        SwitchStatement: 'SwitchStatement',
        TaggedTemplateExpression: 'TaggedTemplateExpression',
        TemplateElement: 'TemplateElement',
        TemplateLiteral: 'TemplateLiteral',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
    };

    ClassPropertyType = {
        'static': 'static',
        prototype: 'prototype'
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken:  'Unexpected token %0',
        UnexpectedNumber:  'Unexpected number',
        UnexpectedString:  'Unexpected string',
        UnexpectedIdentifier:  'Unexpected identifier',
        UnexpectedReserved:  'Unexpected reserved word',
        UnexpectedTemplate:  'Unexpected quasi %0',
        UnexpectedEOS:  'Unexpected end of input',
        NewlineAfterThrow:  'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp:  'Invalid regular expression: missing /',
        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',
        InvalidLHSInFormalsList:  'Invalid left-hand side in formals list',
        InvalidLHSInForIn:  'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally:  'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalDuplicateClassProperty: 'Illegal duplicate property in class definition',
        IllegalReturn: 'Illegal return statement',
        IllegalYield: 'Illegal yield expression',
        IllegalSpread: 'Illegal spread element',
        StrictModeWith:  'Strict mode code may not include a with statement',
        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',
        StrictVarName:  'Variable name may not be eval or arguments in strict mode',
        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        ParameterAfterRestParameter: 'Rest parameter must be final parameter of an argument list',
        DefaultRestParameter: 'Rest parameter can not have a default value',
        ElementAfterSpreadElement: 'Spread must be the final element of an element list',
        ObjectPatternAsRestParameter: 'Invalid rest parameter',
        ObjectPatternAsSpread: 'Invalid spread argument',
        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',
        StrictDelete:  'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',
        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord:  'Use of future reserved word in strict mode',
        NewlineAfterModule:  'Illegal newline after module',
        NoFromAfterImport: 'Missing from after import',
        InvalidModuleSpecifier: 'Invalid module specifier',
        NestedModule: 'Module declaration can not be nested',
        NoYieldInGenerator: 'Missing yield in generator',
        NoUnintializedConst: 'Const must be initialized',
        ComprehensionRequiresBlock: 'Comprehension must have at least one block',
        ComprehensionError:  'Comprehension Error',
        EachNotAllowed:  'Each is not supported'
    };

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'),
        NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]')
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 32) ||  // space
            (ch === 9) ||      // tab
            (ch === 0xB) ||
            (ch === 0xC) ||
            (ch === 0xA0) ||
            (ch >= 0x1680 && '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch >= 48 && ch <= 57) ||         // 0..9
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    // 7.6.1.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
        case 'class':
        case 'enum':
        case 'export':
        case 'extends':
        case 'import':
        case 'super':
            return true;
        default:
            return false;
        }
    }

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        if (strict && isStrictModeReservedWord(id)) {
            return true;
        }

        // 'const' is specialized as Keyword in V8.
        // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.
        // Some others are from future reserved words.

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // 7.4 Comments

    function skipComment() {
        var ch, blockComment, lineComment;

        blockComment = false;
        lineComment = false;

        while (index < length) {
            ch = source.charCodeAt(index);

            if (lineComment) {
                ++index;
                if (isLineTerminator(ch)) {
                    lineComment = false;
                    if (ch === 13 && source.charCodeAt(index) === 10) {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                }
            } else if (blockComment) {
                if (isLineTerminator(ch)) {
                    if (ch === 13 && source.charCodeAt(index + 1) === 10) {
                        ++index;
                    }
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    ch = source.charCodeAt(index++);
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    // Block comment ends with '*/' (char #42, char #47).
                    if (ch === 42) {
                        ch = source.charCodeAt(index);
                        if (ch === 47) {
                            ++index;
                            blockComment = false;
                        }
                    }
                }
            } else if (ch === 47) {
                ch = source.charCodeAt(index + 1);
                // Line comment starts with '//' (char #47, char #47).
                if (ch === 47) {
                    index += 2;
                    lineComment = true;
                } else if (ch === 42) {
                    // Block comment starts with '/*' (char #47, char #42).
                    index += 2;
                    blockComment = true;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    break;
                }
            } else if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanUnicodeCodePointEscape() {
        var ch, code, cu1, cu2;

        ch = source[index];
        code = 0;

        // At least, one hex digit is required.
        if (ch === '}') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        while (index < length) {
            ch = source[index++];
            if (!isHexDigit(ch)) {
                break;
            }
            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
        }

        if (code > 0x10FFFF || ch !== '}') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        // UTF-16 Encoding
        if (code <= 0xFFFF) {
            return String.fromCharCode(code);
        }
        cu1 = ((code - 0x10000) >> 10) + 0xD800;
        cu2 = ((code - 0x10000) & 1023) + 0xDC00;
        return String.fromCharCode(cu1, cu2);
    }

    function getEscapedIdentifier() {
        var ch, id;

        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);

        // '\u' (char #92, char #117) denotes an escaped character.
        if (ch === 92) {
            if (source.charCodeAt(index) !== 117) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            ++index;
            ch = scanHexEscape('u');
            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            id = ch;
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (!isIdentifierPart(ch)) {
                break;
            }
            ++index;
            id += String.fromCharCode(ch);

            // '\u' (char #92, char #117) denotes an escaped character.
            if (ch === 92) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 117) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                ++index;
                ch = scanHexEscape('u');
                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 92) {
                // Blackslash (char #92) marks Unicode escape sequence.
                index = start;
                return getEscapedIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (char #92) starts an escaped character.
        id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;

        switch (code) {
        // Check for most common single-character punctuators.
        case 40:   // ( open bracket
        case 41:   // ) close bracket
        case 59:   // ; semicolon
        case 44:   // , comma
        case 123:  // { open curly brace
        case 125:  // } close curly brace
        case 91:   // [
        case 93:   // ]
        case 58:   // :
        case 63:   // ?
        case 126:  // ~
            ++index;
            if (extra.tokenize) {
                if (code === 40) {
                    extra.openParenToken = extra.tokens.length;
                } else if (code === 123) {
                    extra.openCurlyToken = extra.tokens.length;
                }
            }
            return {
                type: Token.Punctuator,
                value: String.fromCharCode(code),
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };

        default:
            code2 = source.charCodeAt(index + 1);

            // '=' (char #61) marks an assignment or comparison operator.
            if (code2 === 61) {
                switch (code) {
                case 37:  // %
                case 38:  // &
                case 42:  // *:
                case 43:  // +
                case 45:  // -
                case 47:  // /
                case 60:  // <
                case 62:  // >
                case 94:  // ^
                case 124: // |
                    index += 2;
                    return {
                        type: Token.Punctuator,
                        value: String.fromCharCode(code) + String.fromCharCode(code2),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };

                case 33: // !
                case 61: // =
                    index += 2;

                    // !== and ===
                    if (source.charCodeAt(index) === 61) {
                        ++index;
                    }
                    return {
                        type: Token.Punctuator,
                        value: source.slice(start, index),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };
                default:
                    break;
                }
            }
            break;
        }

        // Peek more characters.

        ch2 = source[index + 1];
        ch3 = source[index + 2];
        ch4 = source[index + 3];

        // 4-character punctuator: >>>=

        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
            if (ch4 === '=') {
                index += 4;
                return {
                    type: Token.Punctuator,
                    value: '>>>=',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        // 3-character punctuators: === !== >>> <<= >>=

        if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '>>>',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '<' && ch2 === '<' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '<<=',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '>' && ch2 === '>' && ch3 === '=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '>>=',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '.' && ch2 === '.' && ch3 === '.') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: '...',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        // Other 2-character punctuators: ++ -- << >> && ||

        if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0)) {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch1 + ch2,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '=' && ch2 === '>') {
            index += 2;
            return {
                type: Token.Punctuator,
                value: '=>',
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        if (ch1 === '.') {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    // 7.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanOctalLiteral(prefix, start) {
        var number, octal;

        if (isOctalDigit(prefix)) {
            octal = true;
            number = '0' + source[index++];
        } else {
            octal = false;
            ++index;
            number = '';
        }

        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (!octal && number.length === 0) {
            // only 0o or 0O
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanNumericLiteral() {
        var number, start, ch, octal;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            // Octal number in ES6 starts with '0o'.
            // Binary number in ES6 starts with '0b'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (ch === 'b' || ch === 'B') {
                    ++index;
                    number = '';

                    while (index < length) {
                        ch = source[index];
                        if (ch !== '0' && ch !== '1') {
                            break;
                        }
                        number += source[index++];
                    }

                    if (number.length === 0) {
                        // only 0b or 0B
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }

                    if (index < length) {
                        ch = source.charCodeAt(index);
                        if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                        }
                    }
                    return {
                        type: Token.NumericLiteral,
                        value: parseInt(number, 2),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };
                }
                if (ch === 'o' || ch === 'O' || isOctalDigit(ch)) {
                    return scanOctalLiteral(ch, start);
                }
                // decimal number starts with '0' such as '09' is illegal.
                if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, code, unescaped, restore, octal = false;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            str += scanUnicodeCodePointEscape();
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                str += unescaped;
                            } else {
                                index = restore;
                                str += ch;
                            }
                        }
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            code = '01234567'.indexOf(ch);

                            // \0 is not octal escape sequence
                            if (code !== 0) {
                                octal = true;
                            }

                            if (index < length && isOctalDigit(source[index])) {
                                octal = true;
                                code = code * 8 + '01234567'.indexOf(source[index++]);

                                // 3 digits are only allowed when string starts
                                // with 0, 1, 2, 3
                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        isOctalDigit(source[index])) {
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                }
                            }
                            str += String.fromCharCode(code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch ===  '\r' && source[index] === '\n') {
                        ++index;
                    }
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanTemplate() {
        var cooked = '', ch, start, terminated, tail, restore, unescaped, code, octal;

        terminated = false;
        tail = false;
        start = index;

        ++index;

        while (index < length) {
            ch = source[index++];
            if (ch === '`') {
                tail = true;
                terminated = true;
                break;
            } else if (ch === '$') {
                if (source[index] === '{') {
                    ++index;
                    terminated = true;
                    break;
                }
                cooked += ch;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'n':
                        cooked += '\n';
                        break;
                    case 'r':
                        cooked += '\r';
                        break;
                    case 't':
                        cooked += '\t';
                        break;
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            cooked += scanUnicodeCodePointEscape();
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                cooked += unescaped;
                            } else {
                                index = restore;
                                cooked += ch;
                            }
                        }
                        break;
                    case 'b':
                        cooked += '\b';
                        break;
                    case 'f':
                        cooked += '\f';
                        break;
                    case 'v':
                        cooked += '\v';
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            code = '01234567'.indexOf(ch);

                            // \0 is not octal escape sequence
                            if (code !== 0) {
                                octal = true;
                            }

                            if (index < length && isOctalDigit(source[index])) {
                                octal = true;
                                code = code * 8 + '01234567'.indexOf(source[index++]);

                                // 3 digits are only allowed when string starts
                                // with 0, 1, 2, 3
                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        isOctalDigit(source[index])) {
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                }
                            }
                            cooked += String.fromCharCode(code);
                        } else {
                            cooked += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch ===  '\r' && source[index] === '\n') {
                        ++index;
                    }
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                ++lineNumber;
                if (ch ===  '\r' && source[index] === '\n') {
                    ++index;
                }
                cooked += '\n';
            } else {
                cooked += ch;
            }
        }

        if (!terminated) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.Template,
            value: {
                cooked: cooked,
                raw: source.slice(start + 1, index - ((tail) ? 1 : 2))
            },
            tail: tail,
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    function scanTemplateElement(option) {
        var startsWith, template;

        lookahead = null;
        skipComment();

        startsWith = (option.head) ? '`' : '}';

        if (source[index] !== startsWith) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        template = scanTemplate();

        peek();

        return template;
    }

    function scanRegExp() {
        var str, ch, start, pattern, flags, value, classMarker = false, restore, terminated = false;

        lookahead = null;
        skipComment();

        start = index;
        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        while (index < length) {
            ch = source[index++];
            str += ch;
            if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '\\') {
                    ch = source[index++];
                    // ECMA-262 7.8.5
                    if (isLineTerminator(ch.charCodeAt(0))) {
                        throwError({}, Messages.UnterminatedRegExp);
                    }
                    str += ch;
                } else if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                } else if (isLineTerminator(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
            }
        }

        if (!terminated) {
            throwError({}, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        pattern = str.substr(1, str.length - 2);

        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                } else {
                    str += '\\';
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        try {
            value = new RegExp(pattern, flags);
        } catch (e) {
            throwError({}, Messages.InvalidRegExp);
        }

        peek();


        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
        return {
            literal: str,
            value: value,
            range: [start, index]
        };
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advanceSlash() {
        var prevToken,
            checkToken;
        // Using the following algorithm:
        // https://github.com/mozilla/sweet.js/wiki/design
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
            // Nothing before that: it cannot be a division.
            return scanRegExp();
        }
        if (prevToken.type === 'Punctuator') {
            if (prevToken.value === ')') {
                checkToken = extra.tokens[extra.openParenToken - 1];
                if (checkToken &&
                        checkToken.type === 'Keyword' &&
                        (checkToken.value === 'if' ||
                         checkToken.value === 'while' ||
                         checkToken.value === 'for' ||
                         checkToken.value === 'with')) {
                    return scanRegExp();
                }
                return scanPunctuator();
            }
            if (prevToken.value === '}') {
                // Dividing a function by anything makes little sense,
                // but we have to check for that.
                if (extra.tokens[extra.openCurlyToken - 3] &&
                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                    // Anonymous function.
                    checkToken = extra.tokens[extra.openCurlyToken - 4];
                    if (!checkToken) {
                        return scanPunctuator();
                    }
                } else if (extra.tokens[extra.openCurlyToken - 4] &&
                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                    // Named function.
                    checkToken = extra.tokens[extra.openCurlyToken - 5];
                    if (!checkToken) {
                        return scanRegExp();
                    }
                } else {
                    return scanPunctuator();
                }
                // checkToken determines whether the function is
                // a declaration or an expression.
                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                    // It is an expression.
                    return scanPunctuator();
                }
                // It is a declaration.
                return scanRegExp();
            }
            return scanRegExp();
        }
        if (prevToken.type === 'Keyword') {
            return scanRegExp();
        }
        return scanPunctuator();
    }

    function advance() {
        var ch;

        skipComment();

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [index, index]
            };
        }

        ch = source.charCodeAt(index);

        // Very common: ( and ) and ;
        if (ch === 40 || ch === 41 || ch === 58) {
            return scanPunctuator();
        }

        // String literal starts with single quote (#39) or double quote (#34).
        if (ch === 39 || ch === 34) {
            return scanStringLiteral();
        }

        if (ch === 96) {
            return scanTemplate();
        }
        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }

        // Dot (.) char #46 can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 46) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        // Slash (/) char #47 can also start a regex.
        if (extra.tokenize && ch === 47) {
            return advanceSlash();
        }

        return scanPunctuator();
    }

    function lex() {
        var token;

        token = lookahead;
        index = token.range[1];
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        lookahead = advance();

        index = token.range[1];
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        return token;
    }

    function peek() {
        var pos, line, start;

        pos = index;
        line = lineNumber;
        start = lineStart;
        lookahead = advance();
        index = pos;
        lineNumber = line;
        lineStart = start;
    }

    function lookahead2() {
        var adv, pos, line, start, result;

        // If we are collecting the tokens, don't grab the next one yet.
        adv = (typeof extra.advance === 'function') ? extra.advance : advance;

        pos = index;
        line = lineNumber;
        start = lineStart;

        // Scan for the next immediate token.
        if (lookahead === null) {
            lookahead = adv();
        }
        index = lookahead.range[1];
        lineNumber = lookahead.lineNumber;
        lineStart = lookahead.lineStart;

        // Grab the token right after.
        result = adv();
        index = pos;
        lineNumber = line;
        lineStart = start;

        return result;
    }

    SyntaxTreeDelegate = {

        name: 'SyntaxTree',

        postProcess: function (node) {
            return node;
        },

        createArrayExpression: function (elements) {
            return {
                type: Syntax.ArrayExpression,
                elements: elements
            };
        },

        createAssignmentExpression: function (operator, left, right) {
            return {
                type: Syntax.AssignmentExpression,
                operator: operator,
                left: left,
                right: right
            };
        },

        createBinaryExpression: function (operator, left, right) {
            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :
                        Syntax.BinaryExpression;
            return {
                type: type,
                operator: operator,
                left: left,
                right: right
            };
        },

        createBlockStatement: function (body) {
            return {
                type: Syntax.BlockStatement,
                body: body
            };
        },

        createBreakStatement: function (label) {
            return {
                type: Syntax.BreakStatement,
                label: label
            };
        },

        createCallExpression: function (callee, args) {
            return {
                type: Syntax.CallExpression,
                callee: callee,
                'arguments': args
            };
        },

        createCatchClause: function (param, body) {
            return {
                type: Syntax.CatchClause,
                param: param,
                body: body
            };
        },

        createConditionalExpression: function (test, consequent, alternate) {
            return {
                type: Syntax.ConditionalExpression,
                test: test,
                consequent: consequent,
                alternate: alternate
            };
        },

        createContinueStatement: function (label) {
            return {
                type: Syntax.ContinueStatement,
                label: label
            };
        },

        createDebuggerStatement: function () {
            return {
                type: Syntax.DebuggerStatement
            };
        },

        createDoWhileStatement: function (body, test) {
            return {
                type: Syntax.DoWhileStatement,
                body: body,
                test: test
            };
        },

        createEmptyStatement: function () {
            return {
                type: Syntax.EmptyStatement
            };
        },

        createExpressionStatement: function (expression) {
            return {
                type: Syntax.ExpressionStatement,
                expression: expression
            };
        },

        createForStatement: function (init, test, update, body) {
            return {
                type: Syntax.ForStatement,
                init: init,
                test: test,
                update: update,
                body: body
            };
        },

        createForInStatement: function (left, right, body) {
            return {
                type: Syntax.ForInStatement,
                left: left,
                right: right,
                body: body,
                each: false
            };
        },

        createForOfStatement: function (left, right, body) {
            return {
                type: Syntax.ForOfStatement,
                left: left,
                right: right,
                body: body
            };
        },

        createFunctionDeclaration: function (id, params, defaults, body, rest, generator, expression) {
            return {
                type: Syntax.FunctionDeclaration,
                id: id,
                params: params,
                defaults: defaults,
                body: body,
                rest: rest,
                generator: generator,
                expression: expression
            };
        },

        createFunctionExpression: function (id, params, defaults, body, rest, generator, expression) {
            return {
                type: Syntax.FunctionExpression,
                id: id,
                params: params,
                defaults: defaults,
                body: body,
                rest: rest,
                generator: generator,
                expression: expression
            };
        },

        createIdentifier: function (name) {
            return {
                type: Syntax.Identifier,
                name: name
            };
        },

        createIfStatement: function (test, consequent, alternate) {
            return {
                type: Syntax.IfStatement,
                test: test,
                consequent: consequent,
                alternate: alternate
            };
        },

        createLabeledStatement: function (label, body) {
            return {
                type: Syntax.LabeledStatement,
                label: label,
                body: body
            };
        },

        createLiteral: function (token) {
            return {
                type: Syntax.Literal,
                value: token.value,
                raw: source.slice(token.range[0], token.range[1])
            };
        },

        createMemberExpression: function (accessor, object, property) {
            return {
                type: Syntax.MemberExpression,
                computed: accessor === '[',
                object: object,
                property: property
            };
        },

        createNewExpression: function (callee, args) {
            return {
                type: Syntax.NewExpression,
                callee: callee,
                'arguments': args
            };
        },

        createObjectExpression: function (properties) {
            return {
                type: Syntax.ObjectExpression,
                properties: properties
            };
        },

        createPostfixExpression: function (operator, argument) {
            return {
                type: Syntax.UpdateExpression,
                operator: operator,
                argument: argument,
                prefix: false
            };
        },

        createProgram: function (body) {
            return {
                type: Syntax.Program,
                body: body
            };
        },

        createProperty: function (kind, key, value, method, shorthand) {
            return {
                type: Syntax.Property,
                key: key,
                value: value,
                kind: kind,
                method: method,
                shorthand: shorthand
            };
        },

        createReturnStatement: function (argument) {
            return {
                type: Syntax.ReturnStatement,
                argument: argument
            };
        },

        createSequenceExpression: function (expressions) {
            return {
                type: Syntax.SequenceExpression,
                expressions: expressions
            };
        },

        createSwitchCase: function (test, consequent) {
            return {
                type: Syntax.SwitchCase,
                test: test,
                consequent: consequent
            };
        },

        createSwitchStatement: function (discriminant, cases) {
            return {
                type: Syntax.SwitchStatement,
                discriminant: discriminant,
                cases: cases
            };
        },

        createThisExpression: function () {
            return {
                type: Syntax.ThisExpression
            };
        },

        createThrowStatement: function (argument) {
            return {
                type: Syntax.ThrowStatement,
                argument: argument
            };
        },

        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {
            return {
                type: Syntax.TryStatement,
                block: block,
                guardedHandlers: guardedHandlers,
                handlers: handlers,
                finalizer: finalizer
            };
        },

        createUnaryExpression: function (operator, argument) {
            if (operator === '++' || operator === '--') {
                return {
                    type: Syntax.UpdateExpression,
                    operator: operator,
                    argument: argument,
                    prefix: true
                };
            }
            return {
                type: Syntax.UnaryExpression,
                operator: operator,
                argument: argument
            };
        },

        createVariableDeclaration: function (declarations, kind) {
            return {
                type: Syntax.VariableDeclaration,
                declarations: declarations,
                kind: kind
            };
        },

        createVariableDeclarator: function (id, init) {
            return {
                type: Syntax.VariableDeclarator,
                id: id,
                init: init
            };
        },

        createWhileStatement: function (test, body) {
            return {
                type: Syntax.WhileStatement,
                test: test,
                body: body
            };
        },

        createWithStatement: function (object, body) {
            return {
                type: Syntax.WithStatement,
                object: object,
                body: body
            };
        },

        createTemplateElement: function (value, tail) {
            return {
                type: Syntax.TemplateElement,
                value: value,
                tail: tail
            };
        },

        createTemplateLiteral: function (quasis, expressions) {
            return {
                type: Syntax.TemplateLiteral,
                quasis: quasis,
                expressions: expressions
            };
        },

        createSpreadElement: function (argument) {
            return {
                type: Syntax.SpreadElement,
                argument: argument
            };
        },

        createTaggedTemplateExpression: function (tag, quasi) {
            return {
                type: Syntax.TaggedTemplateExpression,
                tag: tag,
                quasi: quasi
            };
        },

        createArrowFunctionExpression: function (params, defaults, body, rest, expression) {
            return {
                type: Syntax.ArrowFunctionExpression,
                id: null,
                params: params,
                defaults: defaults,
                body: body,
                rest: rest,
                generator: false,
                expression: expression
            };
        },

        createMethodDefinition: function (propertyType, kind, key, value) {
            return {
                type: Syntax.MethodDefinition,
                key: key,
                value: value,
                kind: kind,
                'static': propertyType === ClassPropertyType.static
            };
        },

        createClassBody: function (body) {
            return {
                type: Syntax.ClassBody,
                body: body
            };
        },

        createClassExpression: function (id, superClass, body) {
            return {
                type: Syntax.ClassExpression,
                id: id,
                superClass: superClass,
                body: body
            };
        },

        createClassDeclaration: function (id, superClass, body) {
            return {
                type: Syntax.ClassDeclaration,
                id: id,
                superClass: superClass,
                body: body
            };
        },

        createExportSpecifier: function (id, name) {
            return {
                type: Syntax.ExportSpecifier,
                id: id,
                name: name
            };
        },

        createExportBatchSpecifier: function () {
            return {
                type: Syntax.ExportBatchSpecifier
            };
        },

        createExportDeclaration: function (declaration, specifiers, source) {
            return {
                type: Syntax.ExportDeclaration,
                declaration: declaration,
                specifiers: specifiers,
                source: source
            };
        },

        createImportSpecifier: function (id, name) {
            return {
                type: Syntax.ImportSpecifier,
                id: id,
                name: name
            };
        },

        createImportDeclaration: function (specifiers, kind, source) {
            return {
                type: Syntax.ImportDeclaration,
                specifiers: specifiers,
                kind: kind,
                source: source
            };
        },

        createYieldExpression: function (argument, delegate) {
            return {
                type: Syntax.YieldExpression,
                argument: argument,
                delegate: delegate
            };
        },

        createModuleDeclaration: function (id, source, body) {
            return {
                type: Syntax.ModuleDeclaration,
                id: id,
                source: source,
                body: body
            };
        }


    };

    // Return true if there is a line terminator before the next token.

    function peekLineTerminator() {
        var pos, line, start, found;

        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;

        return found;
    }

    // Throw an exception

    function throwError(token, messageFormat) {
        var error,
            args = Array.prototype.slice.call(arguments, 2),
            msg = messageFormat.replace(
                /%(\d)/g,
                function (whole, index) {
                    assert(index < args.length, 'Message reference must be in range');
                    return args[index];
                }
            );

        if (typeof token.lineNumber === 'number') {
            error = new Error('Line ' + token.lineNumber + ': ' + msg);
            error.index = token.range[0];
            error.lineNumber = token.lineNumber;
            error.column = token.range[0] - lineStart + 1;
        } else {
            error = new Error('Line ' + lineNumber + ': ' + msg);
            error.index = index;
            error.lineNumber = lineNumber;
            error.column = index - lineStart + 1;
        }

        error.description = msg;
        throw error;
    }

    function throwErrorTolerant() {
        try {
            throwError.apply(null, arguments);
        } catch (e) {
            if (extra.errors) {
                extra.errors.push(e);
            } else {
                throw e;
            }
        }
    }


    // Throw an exception because of the token.

    function throwUnexpected(token) {
        if (token.type === Token.EOF) {
            throwError(token, Messages.UnexpectedEOS);
        }

        if (token.type === Token.NumericLiteral) {
            throwError(token, Messages.UnexpectedNumber);
        }

        if (token.type === Token.StringLiteral) {
            throwError(token, Messages.UnexpectedString);
        }

        if (token.type === Token.Identifier) {
            throwError(token, Messages.UnexpectedIdentifier);
        }

        if (token.type === Token.Keyword) {
            if (isFutureReservedWord(token.value)) {
                throwError(token, Messages.UnexpectedReserved);
            } else if (strict && isStrictModeReservedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictReservedWord);
                return;
            }
            throwError(token, Messages.UnexpectedToken, token.value);
        }

        if (token.type === Token.Template) {
            throwError(token, Messages.UnexpectedTemplate, token.value.raw);
        }

        // BooleanLiteral, NullLiteral, or Punctuator.
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpected(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }


    // Return true if the next token matches the specified contextual keyword

    function matchContextualKeyword(keyword) {
        return lookahead.type === Token.Identifier && lookahead.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        var line;

        // Catch the very common case first: immediately a semicolon (char #59).
        if (source.charCodeAt(index) === 59) {
            lex();
            return;
        }

        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
            return;
        }

        if (match(';')) {
            lex();
            return;
        }

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpected(lookahead);
        }
    }

    // Return true if provided expression is LeftHandSideExpression

    function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
    }

    function isAssignableLeftHandSide(expr) {
        return isLeftHandSide(expr) || expr.type === Syntax.ObjectPattern || expr.type === Syntax.ArrayPattern;
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [], blocks = [], filter = null, tmp, possiblecomprehension = true, body;

        expect('[');
        while (!match(']')) {
            if (lookahead.value === 'for' &&
                    lookahead.type === Token.Keyword) {
                if (!possiblecomprehension) {
                    throwError({}, Messages.ComprehensionError);
                }
                matchKeyword('for');
                tmp = parseForStatement({ignoreBody: true});
                tmp.of = tmp.type === Syntax.ForOfStatement;
                tmp.type = Syntax.ComprehensionBlock;
                if (tmp.left.kind) { // can't be let or const
                    throwError({}, Messages.ComprehensionError);
                }
                blocks.push(tmp);
            } else if (lookahead.value === 'if' &&
                           lookahead.type === Token.Keyword) {
                if (!possiblecomprehension) {
                    throwError({}, Messages.ComprehensionError);
                }
                expectKeyword('if');
                expect('(');
                filter = parseExpression();
                expect(')');
            } else if (lookahead.value === ',' &&
                           lookahead.type === Token.Punctuator) {
                possiblecomprehension = false; // no longer allowed.
                lex();
                elements.push(null);
            } else {
                tmp = parseSpreadOrAssignmentExpression();
                elements.push(tmp);
                if (tmp && tmp.type === Syntax.SpreadElement) {
                    if (!match(']')) {
                        throwError({}, Messages.ElementAfterSpreadElement);
                    }
                } else if (!(match(']') || matchKeyword('for') || matchKeyword('if'))) {
                    expect(','); // this lexes.
                    possiblecomprehension = false;
                }
            }
        }

        expect(']');

        if (filter && !blocks.length) {
            throwError({}, Messages.ComprehensionRequiresBlock);
        }

        if (blocks.length) {
            if (elements.length !== 1) {
                throwError({}, Messages.ComprehensionError);
            }
            return {
                type:  Syntax.ComprehensionExpression,
                filter: filter,
                blocks: blocks,
                body: elements[0]
            };
        }
        return delegate.createArrayExpression(elements);
    }

    // 11.1.5 Object Initialiser

    function parsePropertyFunction(options) {
        var previousStrict, previousYieldAllowed, params, defaults, body;

        previousStrict = strict;
        previousYieldAllowed = state.yieldAllowed;
        state.yieldAllowed = options.generator;
        params = options.params || [];
        defaults = options.defaults || [];

        body = parseConciseBody();
        if (options.name && strict && isRestrictedWord(params[0].name)) {
            throwErrorTolerant(options.name, Messages.StrictParamName);
        }
        if (state.yieldAllowed && !state.yieldFound) {
            throwErrorTolerant({}, Messages.NoYieldInGenerator);
        }
        strict = previousStrict;
        state.yieldAllowed = previousYieldAllowed;

        return delegate.createFunctionExpression(null, params, defaults, body, options.rest || null, options.generator, body.type !== Syntax.BlockStatement);
    }


    function parsePropertyMethodFunction(options) {
        var previousStrict, tmp, method;

        previousStrict = strict;
        strict = true;

        tmp = parseParams();

        if (tmp.stricted) {
            throwErrorTolerant(tmp.stricted, tmp.message);
        }


        method = parsePropertyFunction({
            params: tmp.params,
            defaults: tmp.defaults,
            rest: tmp.rest,
            generator: options.generator
        });

        strict = previousStrict;

        return method;
    }


    function parseObjectPropertyKey() {
        var token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            if (strict && token.octal) {
                throwErrorTolerant(token, Messages.StrictOctalLiteral);
            }
            return delegate.createLiteral(token);
        }

        return delegate.createIdentifier(token.value);
    }

    function parseObjectProperty() {
        var token, key, id, value, param;

        token = lookahead;

        if (token.type === Token.Identifier) {

            id = parseObjectPropertyKey();

            // Property Assignment: Getter and Setter.

            if (token.value === 'get' && !(match(':') || match('('))) {
                key = parseObjectPropertyKey();
                expect('(');
                expect(')');
                return delegate.createProperty('get', key, parsePropertyFunction({ generator: false }), false, false);
            }
            if (token.value === 'set' && !(match(':') || match('('))) {
                key = parseObjectPropertyKey();
                expect('(');
                token = lookahead;
                param = [ parseVariableIdentifier() ];
                expect(')');
                return delegate.createProperty('set', key, parsePropertyFunction({ params: param, generator: false, name: token }), false, false);
            }
            if (match(':')) {
                lex();
                return delegate.createProperty('init', id, parseAssignmentExpression(), false, false);
            }
            if (match('(')) {
                return delegate.createProperty('init', id, parsePropertyMethodFunction({ generator: false }), true, false);
            }
            return delegate.createProperty('init', id, id, false, true);
        }
        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            if (!match('*')) {
                throwUnexpected(token);
            }
            lex();

            id = parseObjectPropertyKey();

            if (!match('(')) {
                throwUnexpected(lex());
            }

            return delegate.createProperty('init', id, parsePropertyMethodFunction({ generator: true }), true, false);
        }
        key = parseObjectPropertyKey();
        if (match(':')) {
            lex();
            return delegate.createProperty('init', key, parseAssignmentExpression(), false, false);
        }
        if (match('(')) {
            return delegate.createProperty('init', key, parsePropertyMethodFunction({ generator: false }), true, false);
        }
        throwUnexpected(lex());
    }

    function parseObjectInitialiser() {
        var properties = [], property, name, key, kind, map = {}, toString = String;

        expect('{');

        while (!match('}')) {
            property = parseObjectProperty();

            if (property.key.type === Syntax.Identifier) {
                name = property.key.name;
            } else {
                name = toString(property.key.value);
            }
            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;

            key = '$' + name;
            if (Object.prototype.hasOwnProperty.call(map, key)) {
                if (map[key] === PropertyKind.Data) {
                    if (strict && kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                    } else if (kind !== PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    }
                } else {
                    if (kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    } else if (map[key] & kind) {
                        throwErrorTolerant({}, Messages.AccessorGetSet);
                    }
                }
                map[key] |= kind;
            } else {
                map[key] = kind;
            }

            properties.push(property);

            if (!match('}')) {
                expect(',');
            }
        }

        expect('}');

        return delegate.createObjectExpression(properties);
    }

    function parseTemplateElement(option) {
        var token = scanTemplateElement(option);
        if (strict && token.octal) {
            throwError(token, Messages.StrictOctalLiteral);
        }
        return delegate.createTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);
    }

    function parseTemplateLiteral() {
        var quasi, quasis, expressions;

        quasi = parseTemplateElement({ head: true });
        quasis = [ quasi ];
        expressions = [];

        while (!quasi.tail) {
            expressions.push(parseExpression());
            quasi = parseTemplateElement({ head: false });
            quasis.push(quasi);
        }

        return delegate.createTemplateLiteral(quasis, expressions);
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr;

        expect('(');

        ++state.parenthesizedCount;

        expr = parseExpression();

        expect(')');

        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var type, token;

        token = lookahead;
        type = lookahead.type;

        if (type === Token.Identifier) {
            lex();
            return delegate.createIdentifier(token.value);
        }

        if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            if (strict && lookahead.octal) {
                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
            }
            return delegate.createLiteral(lex());
        }

        if (type === Token.Keyword) {
            if (matchKeyword('this')) {
                lex();
                return delegate.createThisExpression();
            }

            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }

            if (matchKeyword('class')) {
                return parseClassExpression();
            }

            if (matchKeyword('super')) {
                lex();
                return delegate.createIdentifier('super');
            }
        }

        if (type === Token.BooleanLiteral) {
            token = lex();
            token.value = (token.value === 'true');
            return delegate.createLiteral(token);
        }

        if (type === Token.NullLiteral) {
            token = lex();
            token.value = null;
            return delegate.createLiteral(token);
        }

        if (match('[')) {
            return parseArrayInitialiser();
        }

        if (match('{')) {
            return parseObjectInitialiser();
        }

        if (match('(')) {
            return parseGroupExpression();
        }

        if (match('/') || match('/=')) {
            return delegate.createLiteral(scanRegExp());
        }

        if (type === Token.Template) {
            return parseTemplateLiteral();
        }

        return throwUnexpected(lex());
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [], arg;

        expect('(');

        if (!match(')')) {
            while (index < length) {
                arg = parseSpreadOrAssignmentExpression();
                args.push(arg);

                if (match(')')) {
                    break;
                } else if (arg.type === Syntax.SpreadElement) {
                    throwError({}, Messages.ElementAfterSpreadElement);
                }

                expect(',');
            }
        }

        expect(')');

        return args;
    }

    function parseSpreadOrAssignmentExpression() {
        if (match('...')) {
            lex();
            return delegate.createSpreadElement(parseAssignmentExpression());
        }
        return parseAssignmentExpression();
    }

    function parseNonComputedProperty() {
        var token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        return delegate.createIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseNewExpression() {
        var callee, args;

        expectKeyword('new');
        callee = parseLeftHandSideExpression();
        args = match('(') ? parseArguments() : [];

        return delegate.createNewExpression(callee, args);
    }

    function parseLeftHandSideExpressionAllowCall() {
        var expr, args, property;

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[') || match('(') || lookahead.type === Token.Template) {
            if (match('(')) {
                args = parseArguments();
                expr = delegate.createCallExpression(expr, args);
            } else if (match('[')) {
                expr = delegate.createMemberExpression('[', expr, parseComputedMember());
            } else if (match('.')) {
                expr = delegate.createMemberExpression('.', expr, parseNonComputedMember());
            } else {
                expr = delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral());
            }
        }

        return expr;
    }


    function parseLeftHandSideExpression() {
        var expr, property;

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[') || lookahead.type === Token.Template) {
            if (match('[')) {
                expr = delegate.createMemberExpression('[', expr, parseComputedMember());
            } else if (match('.')) {
                expr = delegate.createMemberExpression('.', expr, parseNonComputedMember());
            } else {
                expr = delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral());
            }
        }

        return expr;
    }

    // 11.3 Postfix Expressions

    function parsePostfixExpression() {
        var expr = parseLeftHandSideExpressionAllowCall(),
            token = lookahead;

        if (lookahead.type !== Token.Punctuator) {
            return expr;
        }

        if ((match('++') || match('--')) && !peekLineTerminator()) {
            // 11.3.1, 11.3.2
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPostfix);
            }

            if (!isLeftHandSide(expr)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }

            token = lex();
            expr = delegate.createPostfixExpression(token.value, expr);
        }

        return expr;
    }

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            return parsePostfixExpression();
        }

        if (match('++') || match('--')) {
            token = lex();
            expr = parseUnaryExpression();
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPrefix);
            }

            if (!isLeftHandSide(expr)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }

            return delegate.createUnaryExpression(token.value, expr);
        }

        if (match('+') || match('-') || match('~') || match('!')) {
            token = lex();
            expr = parseUnaryExpression();
            return delegate.createUnaryExpression(token.value, expr);
        }

        if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            token = lex();
            expr = parseUnaryExpression();
            expr = delegate.createUnaryExpression(token.value, expr);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                throwErrorTolerant({}, Messages.StrictDelete);
            }
            return expr;
        }

        return parsePostfixExpression();
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var expr, token, prec, previousAllowIn, stack, right, operator, left, i;

        previousAllowIn = state.allowIn;
        state.allowIn = true;

        expr = parseUnaryExpression();

        token = lookahead;
        prec = binaryPrecedence(token, previousAllowIn);
        if (prec === 0) {
            return expr;
        }
        token.prec = prec;
        lex();

        stack = [expr, token, parseUnaryExpression()];

        while ((prec = binaryPrecedence(lookahead, previousAllowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                stack.push(delegate.createBinaryExpression(operator, left, right));
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            stack.push(parseUnaryExpression());
        }

        state.allowIn = previousAllowIn;

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        while (i > 1) {
            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }
        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate;

        expr = parseBinaryExpression();

        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = parseAssignmentExpression();
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = parseAssignmentExpression();

            expr = delegate.createConditionalExpression(expr, consequent, alternate);
        }

        return expr;
    }

    // 11.13 Assignment Operators

    function reinterpretAsAssignmentBindingPattern(expr) {
        var i, len, property, element;

        if (expr.type === Syntax.ObjectExpression) {
            expr.type = Syntax.ObjectPattern;
            for (i = 0, len = expr.properties.length; i < len; i += 1) {
                property = expr.properties[i];
                if (property.kind !== 'init') {
                    throwError({}, Messages.InvalidLHSInAssignment);
                }
                reinterpretAsAssignmentBindingPattern(property.value);
            }
        } else if (expr.type === Syntax.ArrayExpression) {
            expr.type = Syntax.ArrayPattern;
            for (i = 0, len = expr.elements.length; i < len; i += 1) {
                element = expr.elements[i];
                if (element) {
                    reinterpretAsAssignmentBindingPattern(element);
                }
            }
        } else if (expr.type === Syntax.Identifier) {
            if (isRestrictedWord(expr.name)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }
        } else if (expr.type === Syntax.SpreadElement) {
            reinterpretAsAssignmentBindingPattern(expr.argument);
            if (expr.argument.type === Syntax.ObjectPattern) {
                throwError({}, Messages.ObjectPatternAsSpread);
            }
        } else {
            if (expr.type !== Syntax.MemberExpression && expr.type !== Syntax.CallExpression && expr.type !== Syntax.NewExpression) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }
        }
    }


    function reinterpretAsDestructuredParameter(options, expr) {
        var i, len, property, element;

        if (expr.type === Syntax.ObjectExpression) {
            expr.type = Syntax.ObjectPattern;
            for (i = 0, len = expr.properties.length; i < len; i += 1) {
                property = expr.properties[i];
                if (property.kind !== 'init') {
                    throwError({}, Messages.InvalidLHSInFormalsList);
                }
                reinterpretAsDestructuredParameter(options, property.value);
            }
        } else if (expr.type === Syntax.ArrayExpression) {
            expr.type = Syntax.ArrayPattern;
            for (i = 0, len = expr.elements.length; i < len; i += 1) {
                element = expr.elements[i];
                if (element) {
                    reinterpretAsDestructuredParameter(options, element);
                }
            }
        } else if (expr.type === Syntax.Identifier) {
            validateParam(options, expr, expr.name);
        } else {
            if (expr.type !== Syntax.MemberExpression) {
                throwError({}, Messages.InvalidLHSInFormalsList);
            }
        }
    }

    function reinterpretAsCoverFormalsList(expressions) {
        var i, len, param, params, defaults, defaultCount, options, rest;

        params = [];
        defaults = [];
        defaultCount = 0;
        rest = null;
        options = {
            paramSet: {}
        };

        for (i = 0, len = expressions.length; i < len; i += 1) {
            param = expressions[i];
            if (param.type === Syntax.Identifier) {
                params.push(param);
                defaults.push(null);
                validateParam(options, param, param.name);
            } else if (param.type === Syntax.ObjectExpression || param.type === Syntax.ArrayExpression) {
                reinterpretAsDestructuredParameter(options, param);
                params.push(param);
                defaults.push(null);
            } else if (param.type === Syntax.SpreadElement) {
                assert(i === len - 1, 'It is guaranteed that SpreadElement is last element by parseExpression');
                reinterpretAsDestructuredParameter(options, param.argument);
                rest = param.argument;
            } else if (param.type === Syntax.AssignmentExpression) {
                params.push(param.left);
                defaults.push(param.right);
                ++defaultCount;
                validateParam(options, param.left, param.left.name);
            } else {
                return null;
            }
        }

        if (options.message === Messages.StrictParamDupe) {
            throwError(
                strict ? options.stricted : options.firstRestricted,
                options.message
            );
        }

        if (defaultCount === 0) {
            defaults = [];
        }

        return {
            params: params,
            defaults: defaults,
            rest: rest,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseArrowFunctionExpression(options) {
        var previousStrict, previousYieldAllowed, body;

        expect('=>');

        previousStrict = strict;
        previousYieldAllowed = state.yieldAllowed;
        state.yieldAllowed = false;
        body = parseConciseBody();

        if (strict && options.firstRestricted) {
            throwError(options.firstRestricted, options.message);
        }
        if (strict && options.stricted) {
            throwErrorTolerant(options.stricted, options.message);
        }

        strict = previousStrict;
        state.yieldAllowed = previousYieldAllowed;

        return delegate.createArrowFunctionExpression(options.params, options.defaults, body, options.rest, body.type !== Syntax.BlockStatement);
    }

    function parseAssignmentExpression() {
        var expr, token, params, oldParenthesizedCount;

        if (matchKeyword('yield')) {
            return parseYieldExpression();
        }

        oldParenthesizedCount = state.parenthesizedCount;

        if (match('(')) {
            token = lookahead2();
            if ((token.type === Token.Punctuator && token.value === ')') || token.value === '...') {
                params = parseParams();
                if (!match('=>')) {
                    throwUnexpected(lex());
                }
                return parseArrowFunctionExpression(params);
            }
        }

        token = lookahead;
        expr = parseConditionalExpression();

        if (match('=>') &&
                (state.parenthesizedCount === oldParenthesizedCount ||
                state.parenthesizedCount === (oldParenthesizedCount + 1))) {
            if (expr.type === Syntax.Identifier) {
                params = reinterpretAsCoverFormalsList([ expr ]);
            } else if (expr.type === Syntax.SequenceExpression) {
                params = reinterpretAsCoverFormalsList(expr.expressions);
            }
            if (params) {
                return parseArrowFunctionExpression(params);
            }
        }

        if (matchAssign()) {
            // 11.13.1
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant(token, Messages.StrictLHSAssignment);
            }

            // ES.next draf 11.13 Runtime Semantics step 1
            if (match('=') && (expr.type === Syntax.ObjectExpression || expr.type === Syntax.ArrayExpression)) {
                reinterpretAsAssignmentBindingPattern(expr);
            } else if (!isLeftHandSide(expr)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }

            expr = delegate.createAssignmentExpression(lex().value, expr, parseAssignmentExpression());
        }

        return expr;
    }

    // 11.14 Comma Operator

    function parseExpression() {
        var expr, expressions, sequence, coverFormalsList, spreadFound, oldParenthesizedCount;

        oldParenthesizedCount = state.parenthesizedCount;

        expr = parseAssignmentExpression();
        expressions = [ expr ];

        if (match(',')) {
            while (index < length) {
                if (!match(',')) {
                    break;
                }

                lex();
                expr = parseSpreadOrAssignmentExpression();
                expressions.push(expr);

                if (expr.type === Syntax.SpreadElement) {
                    spreadFound = true;
                    if (!match(')')) {
                        throwError({}, Messages.ElementAfterSpreadElement);
                    }
                    break;
                }
            }

            sequence = delegate.createSequenceExpression(expressions);
        }

        if (match('=>')) {
            // Do not allow nested parentheses on the LHS of the =>.
            if (state.parenthesizedCount === oldParenthesizedCount || state.parenthesizedCount === (oldParenthesizedCount + 1)) {
                expr = expr.type === Syntax.SequenceExpression ? expr.expressions : expressions;
                coverFormalsList = reinterpretAsCoverFormalsList(expr);
                if (coverFormalsList) {
                    return parseArrowFunctionExpression(coverFormalsList);
                }
            }
            throwUnexpected(lex());
        }

        if (spreadFound && lookahead2().value !== '=>') {
            throwError({}, Messages.IllegalSpread);
        }

        return sequence || expr;
    }

    // 12.1 Block

    function parseStatementList() {
        var list = [],
            statement;

        while (index < length) {
            if (match('}')) {
                break;
            }
            statement = parseSourceElement();
            if (typeof statement === 'undefined') {
                break;
            }
            list.push(statement);
        }

        return list;
    }

    function parseBlock() {
        var block;

        expect('{');

        block = parseStatementList();

        expect('}');

        return delegate.createBlockStatement(block);
    }

    // 12.2 Variable Statement

    function parseVariableIdentifier() {
        var token = lex();

        if (token.type !== Token.Identifier) {
            throwUnexpected(token);
        }

        return delegate.createIdentifier(token.value);
    }

    function parseVariableDeclaration(kind) {
        var id,
            init = null;
        if (match('{')) {
            id = parseObjectInitialiser();
            reinterpretAsAssignmentBindingPattern(id);
        } else if (match('[')) {
            id = parseArrayInitialiser();
            reinterpretAsAssignmentBindingPattern(id);
        } else {
            id = state.allowKeyword ? parseNonComputedProperty() : parseVariableIdentifier();
            // 12.2.1
            if (strict && isRestrictedWord(id.name)) {
                throwErrorTolerant({}, Messages.StrictVarName);
            }
        }

        if (kind === 'const') {
            if (!match('=')) {
                throwError({}, Messages.NoUnintializedConst);
            }
            expect('=');
            init = parseAssignmentExpression();
        } else if (match('=')) {
            lex();
            init = parseAssignmentExpression();
        }

        return delegate.createVariableDeclarator(id, init);
    }

    function parseVariableDeclarationList(kind) {
        var list = [];

        do {
            list.push(parseVariableDeclaration(kind));
            if (!match(',')) {
                break;
            }
            lex();
        } while (index < length);

        return list;
    }

    function parseVariableStatement() {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        return delegate.createVariableDeclaration(declarations, 'var');
    }

    // kind may be `const` or `let`
    // Both are experimental and not in the specification yet.
    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
    function parseConstLetDeclaration(kind) {
        var declarations;

        expectKeyword(kind);

        declarations = parseVariableDeclarationList(kind);

        consumeSemicolon();

        return delegate.createVariableDeclaration(declarations, kind);
    }

    // http://wiki.ecmascript.org/doku.php?id=harmony:modules

    function parseModuleDeclaration() {
        var id, src, body;

        lex();   // 'module'

        if (peekLineTerminator()) {
            throwError({}, Messages.NewlineAfterModule);
        }

        switch (lookahead.type) {

        case Token.StringLiteral:
            id = parsePrimaryExpression();
            body = parseModuleBlock();
            src = null;
            break;

        case Token.Identifier:
            id = parseVariableIdentifier();
            body = null;
            if (!matchContextualKeyword('from')) {
                throwUnexpected(lex());
            }
            lex();
            src = parsePrimaryExpression();
            if (src.type !== Syntax.Literal) {
                throwError({}, Messages.InvalidModuleSpecifier);
            }
            break;
        }

        consumeSemicolon();
        return delegate.createModuleDeclaration(id, src, body);
    }

    function parseExportBatchSpecifier() {
        expect('*');
        return delegate.createExportBatchSpecifier();
    }

    function parseExportSpecifier() {
        var id, name = null;

        id = parseVariableIdentifier();
        if (matchContextualKeyword('as')) {
            lex();
            name = parseNonComputedProperty();
        }

        return delegate.createExportSpecifier(id, name);
    }

    function parseExportDeclaration() {
        var previousAllowKeyword, decl, def, src, specifiers;

        expectKeyword('export');

        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'let':
            case 'const':
            case 'var':
            case 'class':
            case 'function':
                return delegate.createExportDeclaration(parseSourceElement(), null, null);
            }
        }

        if (isIdentifierName(lookahead)) {
            previousAllowKeyword = state.allowKeyword;
            state.allowKeyword = true;
            decl = parseVariableDeclarationList('let');
            state.allowKeyword = previousAllowKeyword;
            return delegate.createExportDeclaration(decl, null, null);
        }

        specifiers = [];
        src = null;

        if (match('*')) {
            specifiers.push(parseExportBatchSpecifier());
        } else {
            expect('{');
            do {
                specifiers.push(parseExportSpecifier());
            } while (match(',') && lex());
            expect('}');
        }

        if (matchContextualKeyword('from')) {
            lex();
            src = parsePrimaryExpression();
            if (src.type !== Syntax.Literal) {
                throwError({}, Messages.InvalidModuleSpecifier);
            }
        }

        consumeSemicolon();

        return delegate.createExportDeclaration(null, specifiers, src);
    }

    function parseImportDeclaration() {
        var specifiers, kind, src;

        expectKeyword('import');
        specifiers = [];

        if (isIdentifierName(lookahead)) {
            kind = 'default';
            specifiers.push(parseImportSpecifier());

            if (!matchContextualKeyword('from')) {
                throwError({}, Messages.NoFromAfterImport);
            }
            lex();
        } else if (match('{')) {
            kind = 'named';
            lex();
            do {
                specifiers.push(parseImportSpecifier());
            } while (match(',') && lex());
            expect('}');

            if (!matchContextualKeyword('from')) {
                throwError({}, Messages.NoFromAfterImport);
            }
            lex();
        }

        src = parsePrimaryExpression();
        if (src.type !== Syntax.Literal) {
            throwError({}, Messages.InvalidModuleSpecifier);
        }

        consumeSemicolon();

        return delegate.createImportDeclaration(specifiers, kind, src);
    }

    function parseImportSpecifier() {
        var id, name = null;

        id = parseNonComputedProperty();
        if (matchContextualKeyword('as')) {
            lex();
            name = parseVariableIdentifier();
        }

        return delegate.createImportSpecifier(id, name);
    }

    // 12.3 Empty Statement

    function parseEmptyStatement() {
        expect(';');
        return delegate.createEmptyStatement();
    }

    // 12.4 Expression Statement

    function parseExpressionStatement() {
        var expr = parseExpression();
        consumeSemicolon();
        return delegate.createExpressionStatement(expr);
    }

    // 12.5 If statement

    function parseIfStatement() {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return delegate.createIfStatement(test, consequent, alternate);
    }

    // 12.6 Iteration Statements

    function parseDoWhileStatement() {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return delegate.createDoWhileStatement(body, test);
    }

    function parseWhileStatement() {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return delegate.createWhileStatement(test, body);
    }

    function parseForVariableDeclaration() {
        var token = lex(),
            declarations = parseVariableDeclarationList();

        return delegate.createVariableDeclaration(declarations, token.value);
    }

    function parseForStatement(opts) {
        var init, test, update, left, right, body, operator, oldInIteration;
        init = test = update = null;
        expectKeyword('for');

        // http://wiki.ecmascript.org/doku.php?id=proposals:iterators_and_generators&s=each
        if (matchContextualKeyword('each')) {
            throwError({}, Messages.EachNotAllowed);
        }

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var') || matchKeyword('let') || matchKeyword('const')) {
                state.allowIn = false;
                init = parseForVariableDeclaration();
                state.allowIn = true;

                if (init.declarations.length === 1) {
                    if (matchKeyword('in') || matchContextualKeyword('of')) {
                        operator = lookahead;
                        if (!((operator.value === 'in' || init.kind !== 'var') && init.declarations[0].init)) {
                            lex();
                            left = init;
                            right = parseExpression();
                            init = null;
                        }
                    }
                }
            } else {
                state.allowIn = false;
                init = parseExpression();
                state.allowIn = true;

                if (matchContextualKeyword('of')) {
                    operator = lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                } else if (matchKeyword('in')) {
                    // LeftHandSideExpression
                    if (!isAssignableLeftHandSide(init)) {
                        throwError({}, Messages.InvalidLHSInForIn);
                    }
                    operator = lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            }

            if (typeof left === 'undefined') {
                expect(';');
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        if (!(opts !== undefined && opts.ignoreBody)) {
            body = parseStatement();
        }

        state.inIteration = oldInIteration;

        if (typeof left === 'undefined') {
            return delegate.createForStatement(init, test, update, body);
        }

        if (operator.value === 'in') {
            return delegate.createForInStatement(left, right, body);
        }
        return delegate.createForOfStatement(left, right, body);
    }

    // 12.7 The continue statement

    function parseContinueStatement() {
        var label = null, key;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(index) === 59) {
            lex();

            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return delegate.createContinueStatement(null);
        }

        if (peekLineTerminator()) {
            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return delegate.createContinueStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError({}, Messages.IllegalContinue);
        }

        return delegate.createContinueStatement(label);
    }

    // 12.8 The break statement

    function parseBreakStatement() {
        var label = null, key;

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (char #59).
        if (source.charCodeAt(index) === 59) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return delegate.createBreakStatement(null);
        }

        if (peekLineTerminator()) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return delegate.createBreakStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
        }

        return delegate.createBreakStatement(label);
    }

    // 12.9 The return statement

    function parseReturnStatement() {
        var argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            throwErrorTolerant({}, Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(index) === 32) {
            if (isIdentifierStart(source.charCodeAt(index + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return delegate.createReturnStatement(argument);
            }
        }

        if (peekLineTerminator()) {
            return delegate.createReturnStatement(null);
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return delegate.createReturnStatement(argument);
    }

    // 12.10 The with statement

    function parseWithStatement() {
        var object, body;

        if (strict) {
            throwErrorTolerant({}, Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return delegate.createWithStatement(object, body);
    }

    // 12.10 The swith statement

    function parseSwitchCase() {
        var test,
            consequent = [],
            sourceElement;

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (index < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            consequent.push(sourceElement);
        }

        return delegate.createSwitchCase(test, consequent);
    }

    function parseSwitchStatement() {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return delegate.createSwitchStatement(discriminant, cases);
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (index < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError({}, Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return delegate.createSwitchStatement(discriminant, cases);
    }

    // 12.13 The throw statement

    function parseThrowStatement() {
        var argument;

        expectKeyword('throw');

        if (peekLineTerminator()) {
            throwError({}, Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return delegate.createThrowStatement(argument);
    }

    // 12.14 The try statement

    function parseCatchClause() {
        var param, body;

        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpected(lookahead);
        }

        param = parseExpression();
        // 12.14.1
        if (strict && param.type === Syntax.Identifier && isRestrictedWord(param.name)) {
            throwErrorTolerant({}, Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return delegate.createCatchClause(param, body);
    }

    function parseTryStatement() {
        var block, handlers = [], finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handlers.push(parseCatchClause());
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (handlers.length === 0 && !finalizer) {
            throwError({}, Messages.NoCatchOrFinally);
        }

        return delegate.createTryStatement(block, [], handlers, finalizer);
    }

    // 12.15 The debugger statement

    function parseDebuggerStatement() {
        expectKeyword('debugger');

        consumeSemicolon();

        return delegate.createDebuggerStatement();
    }

    // 12 Statements

    function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key;

        if (type === Token.EOF) {
            throwUnexpected(lookahead);
        }

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return parseEmptyStatement();
            case '{':
                return parseBlock();
            case '(':
                return parseExpressionStatement();
            default:
                break;
            }
        }

        if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return parseBreakStatement();
            case 'continue':
                return parseContinueStatement();
            case 'debugger':
                return parseDebuggerStatement();
            case 'do':
                return parseDoWhileStatement();
            case 'for':
                return parseForStatement();
            case 'function':
                return parseFunctionDeclaration();
            case 'class':
                return parseClassDeclaration();
            case 'if':
                return parseIfStatement();
            case 'return':
                return parseReturnStatement();
            case 'switch':
                return parseSwitchStatement();
            case 'throw':
                return parseThrowStatement();
            case 'try':
                return parseTryStatement();
            case 'var':
                return parseVariableStatement();
            case 'while':
                return parseWhileStatement();
            case 'with':
                return parseWithStatement();
            default:
                break;
            }
        }

        expr = parseExpression();

        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return delegate.createLabeledStatement(expr, labeledBody);
        }

        consumeSemicolon();

        return delegate.createExpressionStatement(expr);
    }

    // 13 Function Definition

    function parseConciseBody() {
        if (match('{')) {
            return parseFunctionSourceElements();
        }
        return parseAssignmentExpression();
    }

    function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesizedCount;

        expect('{');

        while (index < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.range[0] + 1, token.range[1] - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        oldParenthesizedCount = state.parenthesizedCount;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        state.parenthesizedCount = 0;

        while (index < length) {
            if (match('}')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        state.parenthesizedCount = oldParenthesizedCount;

        return delegate.createBlockStatement(sourceElements);
    }

    function validateParam(options, param, name) {
        var key = '$' + name;
        if (strict) {
            if (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName;
            }
            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        } else if (!options.firstRestricted) {
            if (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName;
            } else if (isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictReservedWord;
            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        options.paramSet[key] = true;
    }

    function parseParam(options) {
        var token, rest, param, def;

        token = lookahead;
        if (token.value === '...') {
            token = lex();
            rest = true;
        }

        if (match('[')) {
            param = parseArrayInitialiser();
            reinterpretAsDestructuredParameter(options, param);
        } else if (match('{')) {
            if (rest) {
                throwError({}, Messages.ObjectPatternAsRestParameter);
            }
            param = parseObjectInitialiser();
            reinterpretAsDestructuredParameter(options, param);
        } else {
            param = parseVariableIdentifier();
            validateParam(options, token, token.value);
            if (match('=')) {
                if (rest) {
                    throwErrorTolerant(lookahead, Messages.DefaultRestParameter);
                }
                lex();
                def = parseAssignmentExpression();
                ++options.defaultCount;
            }
        }

        if (rest) {
            if (!match(')')) {
                throwError({}, Messages.ParameterAfterRestParameter);
            }
            options.rest = param;
            return false;
        }

        options.params.push(param);
        options.defaults.push(def);
        return !match(')');
    }

    function parseParams(firstRestricted) {
        var options;

        options = {
            params: [],
            defaultCount: 0,
            defaults: [],
            rest: null,
            firstRestricted: firstRestricted
        };

        expect('(');

        if (!match(')')) {
            options.paramSet = {};
            while (index < length) {
                if (!parseParam(options)) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        if (options.defaultCount === 0) {
            options.defaults = [];
        }

        return options;
    }

    function parseFunctionDeclaration() {
        var id, body, token, tmp, firstRestricted, message, previousStrict, previousYieldAllowed, generator;

        expectKeyword('function');

        generator = false;
        if (match('*')) {
            lex();
            generator = true;
        }

        token = lookahead;

        id = parseVariableIdentifier();

        if (strict) {
            if (isRestrictedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictFunctionName);
            }
        } else {
            if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
            }
        }

        tmp = parseParams(firstRestricted);
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        previousYieldAllowed = state.yieldAllowed;
        state.yieldAllowed = generator;

        body = parseFunctionSourceElements();

        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && tmp.stricted) {
            throwErrorTolerant(tmp.stricted, message);
        }
        if (state.yieldAllowed && !state.yieldFound) {
            throwErrorTolerant({}, Messages.NoYieldInGenerator);
        }
        strict = previousStrict;
        state.yieldAllowed = previousYieldAllowed;

        return delegate.createFunctionDeclaration(id, tmp.params, tmp.defaults, body, tmp.rest, generator, false);
    }

    function parseFunctionExpression() {
        var token, id = null, firstRestricted, message, tmp, body, previousStrict, previousYieldAllowed, generator;

        expectKeyword('function');

        generator = false;

        if (match('*')) {
            lex();
            generator = true;
        }

        if (!match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        previousYieldAllowed = state.yieldAllowed;
        state.yieldAllowed = generator;

        body = parseFunctionSourceElements();

        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && tmp.stricted) {
            throwErrorTolerant(tmp.stricted, message);
        }
        if (state.yieldAllowed && !state.yieldFound) {
            throwErrorTolerant({}, Messages.NoYieldInGenerator);
        }
        strict = previousStrict;
        state.yieldAllowed = previousYieldAllowed;

        return delegate.createFunctionExpression(id, tmp.params, tmp.defaults, body, tmp.rest, generator, false);
    }

    function parseYieldExpression() {
        var delegateFlag, expr;

        expectKeyword('yield');

        if (!state.yieldAllowed) {
            throwErrorTolerant({}, Messages.IllegalYield);
        }

        delegateFlag = false;
        if (match('*')) {
            lex();
            delegateFlag = true;
        }

        expr = parseAssignmentExpression();
        state.yieldFound = true;

        return delegate.createYieldExpression(expr, delegateFlag);
    }

    // 14 Classes

    function parseMethodDefinition(existingPropNames) {
        var token, key, param, propType, isValidDuplicateProp = false;

        if (lookahead.value === 'static') {
            propType = ClassPropertyType.static;
            lex();
        } else {
            propType = ClassPropertyType.prototype;
        }

        if (match('*')) {
            lex();
            return delegate.createMethodDefinition(
                propType,
                '',
                parseObjectPropertyKey(),
                parsePropertyMethodFunction({ generator: true })
            );
        }

        token = lookahead;
        key = parseObjectPropertyKey();

        if (token.value === 'get' && !match('(')) {
            key = parseObjectPropertyKey();

            // It is a syntax error if any other properties have a name
            // duplicating this one unless they are a setter
            if (existingPropNames[propType].hasOwnProperty(key.name)) {
                isValidDuplicateProp =
                    // There isn't already a getter for this prop
                    existingPropNames[propType][key.name].get === undefined
                    // There isn't already a data prop by this name
                    && existingPropNames[propType][key.name].data === undefined
                    // The only existing prop by this name is a setter
                    && existingPropNames[propType][key.name].set !== undefined;
                if (!isValidDuplicateProp) {
                    throwError(key, Messages.IllegalDuplicateClassProperty);
                }
            } else {
                existingPropNames[propType][key.name] = {};
            }
            existingPropNames[propType][key.name].get = true;

            expect('(');
            expect(')');
            return delegate.createMethodDefinition(
                propType,
                'get',
                key,
                parsePropertyFunction({ generator: false })
            );
        }
        if (token.value === 'set' && !match('(')) {
            key = parseObjectPropertyKey();

            // It is a syntax error if any other properties have a name
            // duplicating this one unless they are a getter
            if (existingPropNames[propType].hasOwnProperty(key.name)) {
                isValidDuplicateProp =
                    // There isn't already a setter for this prop
                    existingPropNames[propType][key.name].set === undefined
                    // There isn't already a data prop by this name
                    && existingPropNames[propType][key.name].data === undefined
                    // The only existing prop by this name is a getter
                    && existingPropNames[propType][key.name].get !== undefined;
                if (!isValidDuplicateProp) {
                    throwError(key, Messages.IllegalDuplicateClassProperty);
                }
            } else {
                existingPropNames[propType][key.name] = {};
            }
            existingPropNames[propType][key.name].set = true;

            expect('(');
            token = lookahead;
            param = [ parseVariableIdentifier() ];
            expect(')');
            return delegate.createMethodDefinition(
                propType,
                'set',
                key,
                parsePropertyFunction({ params: param, generator: false, name: token })
            );
        }

        // It is a syntax error if any other properties have the same name as a
        // non-getter, non-setter method
        if (existingPropNames[propType].hasOwnProperty(key.name)) {
            throwError(key, Messages.IllegalDuplicateClassProperty);
        } else {
            existingPropNames[propType][key.name] = {};
        }
        existingPropNames[propType][key.name].data = true;

        return delegate.createMethodDefinition(
            propType,
            '',
            key,
            parsePropertyMethodFunction({ generator: false })
        );
    }

    function parseClassElement(existingProps) {
        if (match(';')) {
            lex();
            return;
        }
        return parseMethodDefinition(existingProps);
    }

    function parseClassBody() {
        var classElement, classElements = [], existingProps = {};

        existingProps[ClassPropertyType.static] = {};
        existingProps[ClassPropertyType.prototype] = {};

        expect('{');

        while (index < length) {
            if (match('}')) {
                break;
            }
            classElement = parseClassElement(existingProps);

            if (typeof classElement !== 'undefined') {
                classElements.push(classElement);
            }
        }

        expect('}');

        return delegate.createClassBody(classElements);
    }

    function parseClassExpression() {
        var id, previousYieldAllowed, superClass = null;

        expectKeyword('class');

        if (!matchKeyword('extends') && !match('{')) {
            id = parseVariableIdentifier();
        }

        if (matchKeyword('extends')) {
            expectKeyword('extends');
            previousYieldAllowed = state.yieldAllowed;
            state.yieldAllowed = false;
            superClass = parseAssignmentExpression();
            state.yieldAllowed = previousYieldAllowed;
        }

        return delegate.createClassExpression(id, superClass, parseClassBody());
    }

    function parseClassDeclaration() {
        var id, previousYieldAllowed, superClass = null;

        expectKeyword('class');

        id = parseVariableIdentifier();

        if (matchKeyword('extends')) {
            expectKeyword('extends');
            previousYieldAllowed = state.yieldAllowed;
            state.yieldAllowed = false;
            superClass = parseAssignmentExpression();
            state.yieldAllowed = previousYieldAllowed;
        }

        return delegate.createClassDeclaration(id, superClass, parseClassBody());
    }

    // 15 Program

    function matchModuleDeclaration() {
        var id;
        if (matchContextualKeyword('module')) {
            id = lookahead2();
            return id.type === Token.StringLiteral || id.type === Token.Identifier;
        }
        return false;
    }

    function parseSourceElement() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'const':
            case 'let':
                return parseConstLetDeclaration(lookahead.value);
            case 'function':
                return parseFunctionDeclaration();
            case 'export':
                return parseExportDeclaration();
            case 'import':
                return parseImportDeclaration();
            default:
                return parseStatement();
            }
        }

        if (matchModuleDeclaration()) {
            throwError({}, Messages.NestedModule);
        }

        if (lookahead.type !== Token.EOF) {
            return parseStatement();
        }
    }

    function parseProgramElement() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'export':
                return parseExportDeclaration();
            case 'import':
                return parseImportDeclaration();
            }
        }

        if (matchModuleDeclaration()) {
            return parseModuleDeclaration();
        }

        return parseSourceElement();
    }

    function parseProgramElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;

        while (index < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseProgramElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.range[0] + 1, token.range[1] - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (index < length) {
            sourceElement = parseProgramElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }
        return sourceElements;
    }

    function parseModuleElement() {
        return parseSourceElement();
    }

    function parseModuleElements() {
        var list = [],
            statement;

        while (index < length) {
            if (match('}')) {
                break;
            }
            statement = parseModuleElement();
            if (typeof statement === 'undefined') {
                break;
            }
            list.push(statement);
        }

        return list;
    }

    function parseModuleBlock() {
        var block;

        expect('{');

        block = parseModuleElements();

        expect('}');

        return delegate.createBlockStatement(block);
    }

    function parseProgram() {
        var body;
        strict = false;
        peek();
        body = parseProgramElements();
        return delegate.createProgram(body);
    }

    // The following functions are needed only when the option to preserve
    // the comments is active.

    function addComment(type, value, start, end, loc) {
        assert(typeof start === 'number', 'Comment must have valid position');

        // Because the way the actual token is scanned, often the comments
        // (if any) are skipped twice during the lexical analysis.
        // Thus, we need to skip adding a comment if the comment array already
        // handled it.
        if (extra.comments.length > 0) {
            if (extra.comments[extra.comments.length - 1].range[1] > start) {
                return;
            }
        }

        extra.comments.push({
            type: type,
            value: value,
            range: [start, end],
            loc: loc
        });
    }

    function scanComment() {
        var comment, ch, loc, start, blockComment, lineComment;

        comment = '';
        blockComment = false;
        lineComment = false;

        while (index < length) {
            ch = source[index];

            if (lineComment) {
                ch = source[index++];
                if (isLineTerminator(ch.charCodeAt(0))) {
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    lineComment = false;
                    addComment('Line', comment, start, index - 1, loc);
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                    comment = '';
                } else if (index >= length) {
                    lineComment = false;
                    comment += ch;
                    loc.end = {
                        line: lineNumber,
                        column: length - lineStart
                    };
                    addComment('Line', comment, start, length, loc);
                } else {
                    comment += ch;
                }
            } else if (blockComment) {
                if (isLineTerminator(ch.charCodeAt(0))) {
                    if (ch === '\r' && source[index + 1] === '\n') {
                        ++index;
                        comment += '\r\n';
                    } else {
                        comment += ch;
                    }
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    ch = source[index++];
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    comment += ch;
                    if (ch === '*') {
                        ch = source[index];
                        if (ch === '/') {
                            comment = comment.substr(0, comment.length - 1);
                            blockComment = false;
                            ++index;
                            loc.end = {
                                line: lineNumber,
                                column: index - lineStart
                            };
                            addComment('Block', comment, start, index, loc);
                            comment = '';
                        }
                    }
                }
            } else if (ch === '/') {
                ch = source[index + 1];
                if (ch === '/') {
                    loc = {
                        start: {
                            line: lineNumber,
                            column: index - lineStart
                        }
                    };
                    start = index;
                    index += 2;
                    lineComment = true;
                    if (index >= length) {
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        lineComment = false;
                        addComment('Line', comment, start, index, loc);
                    }
                } else if (ch === '*') {
                    start = index;
                    index += 2;
                    blockComment = true;
                    loc = {
                        start: {
                            line: lineNumber,
                            column: index - lineStart - 2
                        }
                    };
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    break;
                }
            } else if (isWhiteSpace(ch.charCodeAt(0))) {
                ++index;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                ++index;
                if (ch ===  '\r' && source[index] === '\n') {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
            } else {
                break;
            }
        }
    }

    function filterCommentLocation() {
        var i, entry, comment, comments = [];

        for (i = 0; i < extra.comments.length; ++i) {
            entry = extra.comments[i];
            comment = {
                type: entry.type,
                value: entry.value
            };
            if (extra.range) {
                comment.range = entry.range;
            }
            if (extra.loc) {
                comment.loc = entry.loc;
            }
            comments.push(comment);
        }

        extra.comments = comments;
    }

    function collectToken() {
        var start, loc, token, range, value;

        skipComment();
        start = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = extra.advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            range = [token.range[0], token.range[1]];
            value = source.slice(token.range[0], token.range[1]);
            extra.tokens.push({
                type: TokenName[token.type],
                value: value,
                range: range,
                loc: loc
            });
        }

        return token;
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = extra.scanRegExp();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function LocationMarker() {
        this.range = [index, index];
        this.loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            },
            end: {
                line: lineNumber,
                column: index - lineStart
            }
        };
    }

    LocationMarker.prototype = {
        constructor: LocationMarker,

        end: function () {
            this.range[1] = index;
            this.loc.end.line = lineNumber;
            this.loc.end.column = index - lineStart;
        },

        applyGroup: function (node) {
            if (extra.range) {
                node.groupRange = [this.range[0], this.range[1]];
            }
            if (extra.loc) {
                node.groupLoc = {
                    start: {
                        line: this.loc.start.line,
                        column: this.loc.start.column
                    },
                    end: {
                        line: this.loc.end.line,
                        column: this.loc.end.column
                    }
                };
                node = delegate.postProcess(node);
            }
        },

        apply: function (node) {
            var nodeType = typeof node;
            assert(nodeType === 'object',
                'Applying location marker to an unexpected node type: ' +
                    nodeType);

            if (extra.range) {
                node.range = [this.range[0], this.range[1]];
            }
            if (extra.loc) {
                node.loc = {
                    start: {
                        line: this.loc.start.line,
                        column: this.loc.start.column
                    },
                    end: {
                        line: this.loc.end.line,
                        column: this.loc.end.column
                    }
                };
                node = delegate.postProcess(node);
            }
        }
    };

    function createLocationMarker() {
        return new LocationMarker();
    }

    function trackGroupExpression() {
        var marker, expr;

        skipComment();
        marker = createLocationMarker();
        expect('(');

        ++state.parenthesizedCount;
        expr = parseExpression();

        expect(')');
        marker.end();
        marker.applyGroup(expr);

        return expr;
    }

    function trackLeftHandSideExpression() {
        var marker, expr;

        skipComment();
        marker = createLocationMarker();

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[') || lookahead.type === Token.Template) {
            if (match('[')) {
                expr = delegate.createMemberExpression('[', expr, parseComputedMember());
                marker.end();
                marker.apply(expr);
            } else if (match('.')) {
                expr = delegate.createMemberExpression('.', expr, parseNonComputedMember());
                marker.end();
                marker.apply(expr);
            } else {
                expr = delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral());
                marker.end();
                marker.apply(expr);
            }
        }

        return expr;
    }

    function trackLeftHandSideExpressionAllowCall() {
        var marker, expr, args;

        skipComment();
        marker = createLocationMarker();

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        while (match('.') || match('[') || match('(') || lookahead.type === Token.Template) {
            if (match('(')) {
                args = parseArguments();
                expr = delegate.createCallExpression(expr, args);
                marker.end();
                marker.apply(expr);
            } else if (match('[')) {
                expr = delegate.createMemberExpression('[', expr, parseComputedMember());
                marker.end();
                marker.apply(expr);
            } else if (match('.')) {
                expr = delegate.createMemberExpression('.', expr, parseNonComputedMember());
                marker.end();
                marker.apply(expr);
            } else {
                expr = delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral());
                marker.end();
                marker.apply(expr);
            }
        }

        return expr;
    }

    function filterGroup(node) {
        var n, i, entry;

        n = (Object.prototype.toString.apply(node) === '[object Array]') ? [] : {};
        for (i in node) {
            if (node.hasOwnProperty(i) && i !== 'groupRange' && i !== 'groupLoc') {
                entry = node[i];
                if (entry === null || typeof entry !== 'object' || entry instanceof RegExp) {
                    n[i] = entry;
                } else {
                    n[i] = filterGroup(entry);
                }
            }
        }
        return n;
    }

    function wrapTrackingFunction(range, loc) {

        return function (parseFunction) {

            function isBinary(node) {
                return node.type === Syntax.LogicalExpression ||
                    node.type === Syntax.BinaryExpression;
            }

            function visit(node) {
                var start, end;

                if (isBinary(node.left)) {
                    visit(node.left);
                }
                if (isBinary(node.right)) {
                    visit(node.right);
                }

                if (range) {
                    if (node.left.groupRange || node.right.groupRange) {
                        start = node.left.groupRange ? node.left.groupRange[0] : node.left.range[0];
                        end = node.right.groupRange ? node.right.groupRange[1] : node.right.range[1];
                        node.range = [start, end];
                    } else if (typeof node.range === 'undefined') {
                        start = node.left.range[0];
                        end = node.right.range[1];
                        node.range = [start, end];
                    }
                }
                if (loc) {
                    if (node.left.groupLoc || node.right.groupLoc) {
                        start = node.left.groupLoc ? node.left.groupLoc.start : node.left.loc.start;
                        end = node.right.groupLoc ? node.right.groupLoc.end : node.right.loc.end;
                        node.loc = {
                            start: start,
                            end: end
                        };
                        node = delegate.postProcess(node);
                    } else if (typeof node.loc === 'undefined') {
                        node.loc = {
                            start: node.left.loc.start,
                            end: node.right.loc.end
                        };
                        node = delegate.postProcess(node);
                    }
                }
            }

            return function () {
                var marker, node;

                skipComment();

                marker = createLocationMarker();
                node = parseFunction.apply(null, arguments);
                marker.end();

                if (range && typeof node.range === 'undefined') {
                    marker.apply(node);
                }

                if (loc && typeof node.loc === 'undefined') {
                    marker.apply(node);
                }

                if (isBinary(node)) {
                    visit(node);
                }

                return node;
            };
        };
    }

    function patch() {

        var wrapTracking;

        if (extra.comments) {
            extra.skipComment = skipComment;
            skipComment = scanComment;
        }

        if (extra.range || extra.loc) {

            extra.parseGroupExpression = parseGroupExpression;
            extra.parseLeftHandSideExpression = parseLeftHandSideExpression;
            extra.parseLeftHandSideExpressionAllowCall = parseLeftHandSideExpressionAllowCall;
            parseGroupExpression = trackGroupExpression;
            parseLeftHandSideExpression = trackLeftHandSideExpression;
            parseLeftHandSideExpressionAllowCall = trackLeftHandSideExpressionAllowCall;

            wrapTracking = wrapTrackingFunction(extra.range, extra.loc);

            extra.parseArrayInitialiser = parseArrayInitialiser;
            extra.parseAssignmentExpression = parseAssignmentExpression;
            extra.parseBinaryExpression = parseBinaryExpression;
            extra.parseBlock = parseBlock;
            extra.parseFunctionSourceElements = parseFunctionSourceElements;
            extra.parseCatchClause = parseCatchClause;
            extra.parseComputedMember = parseComputedMember;
            extra.parseConditionalExpression = parseConditionalExpression;
            extra.parseConstLetDeclaration = parseConstLetDeclaration;
            extra.parseExportBatchSpecifier = parseExportBatchSpecifier;
            extra.parseExportDeclaration = parseExportDeclaration;
            extra.parseExportSpecifier = parseExportSpecifier;
            extra.parseExpression = parseExpression;
            extra.parseForVariableDeclaration = parseForVariableDeclaration;
            extra.parseFunctionDeclaration = parseFunctionDeclaration;
            extra.parseFunctionExpression = parseFunctionExpression;
            extra.parseParams = parseParams;
            extra.parseImportDeclaration = parseImportDeclaration;
            extra.parseImportSpecifier = parseImportSpecifier;
            extra.parseModuleDeclaration = parseModuleDeclaration;
            extra.parseModuleBlock = parseModuleBlock;
            extra.parseNewExpression = parseNewExpression;
            extra.parseNonComputedProperty = parseNonComputedProperty;
            extra.parseObjectInitialiser = parseObjectInitialiser;
            extra.parseObjectProperty = parseObjectProperty;
            extra.parseObjectPropertyKey = parseObjectPropertyKey;
            extra.parsePostfixExpression = parsePostfixExpression;
            extra.parsePrimaryExpression = parsePrimaryExpression;
            extra.parseProgram = parseProgram;
            extra.parsePropertyFunction = parsePropertyFunction;
            extra.parseSpreadOrAssignmentExpression = parseSpreadOrAssignmentExpression;
            extra.parseTemplateElement = parseTemplateElement;
            extra.parseTemplateLiteral = parseTemplateLiteral;
            extra.parseStatement = parseStatement;
            extra.parseSwitchCase = parseSwitchCase;
            extra.parseUnaryExpression = parseUnaryExpression;
            extra.parseVariableDeclaration = parseVariableDeclaration;
            extra.parseVariableIdentifier = parseVariableIdentifier;
            extra.parseMethodDefinition = parseMethodDefinition;
            extra.parseClassDeclaration = parseClassDeclaration;
            extra.parseClassExpression = parseClassExpression;
            extra.parseClassBody = parseClassBody;

            parseArrayInitialiser = wrapTracking(extra.parseArrayInitialiser);
            parseAssignmentExpression = wrapTracking(extra.parseAssignmentExpression);
            parseBinaryExpression = wrapTracking(extra.parseBinaryExpression);
            parseBlock = wrapTracking(extra.parseBlock);
            parseFunctionSourceElements = wrapTracking(extra.parseFunctionSourceElements);
            parseCatchClause = wrapTracking(extra.parseCatchClause);
            parseComputedMember = wrapTracking(extra.parseComputedMember);
            parseConditionalExpression = wrapTracking(extra.parseConditionalExpression);
            parseConstLetDeclaration = wrapTracking(extra.parseConstLetDeclaration);
            parseExportBatchSpecifier = wrapTracking(parseExportBatchSpecifier);
            parseExportDeclaration = wrapTracking(parseExportDeclaration);
            parseExportSpecifier = wrapTracking(parseExportSpecifier);
            parseExpression = wrapTracking(extra.parseExpression);
            parseForVariableDeclaration = wrapTracking(extra.parseForVariableDeclaration);
            parseFunctionDeclaration = wrapTracking(extra.parseFunctionDeclaration);
            parseFunctionExpression = wrapTracking(extra.parseFunctionExpression);
            parseParams = wrapTracking(extra.parseParams);
            parseImportDeclaration = wrapTracking(extra.parseImportDeclaration);
            parseImportSpecifier = wrapTracking(extra.parseImportSpecifier);
            parseModuleDeclaration = wrapTracking(extra.parseModuleDeclaration);
            parseModuleBlock = wrapTracking(extra.parseModuleBlock);
            parseLeftHandSideExpression = wrapTracking(parseLeftHandSideExpression);
            parseNewExpression = wrapTracking(extra.parseNewExpression);
            parseNonComputedProperty = wrapTracking(extra.parseNonComputedProperty);
            parseObjectInitialiser = wrapTracking(extra.parseObjectInitialiser);
            parseObjectProperty = wrapTracking(extra.parseObjectProperty);
            parseObjectPropertyKey = wrapTracking(extra.parseObjectPropertyKey);
            parsePostfixExpression = wrapTracking(extra.parsePostfixExpression);
            parsePrimaryExpression = wrapTracking(extra.parsePrimaryExpression);
            parseProgram = wrapTracking(extra.parseProgram);
            parsePropertyFunction = wrapTracking(extra.parsePropertyFunction);
            parseTemplateElement = wrapTracking(extra.parseTemplateElement);
            parseTemplateLiteral = wrapTracking(extra.parseTemplateLiteral);
            parseSpreadOrAssignmentExpression = wrapTracking(extra.parseSpreadOrAssignmentExpression);
            parseStatement = wrapTracking(extra.parseStatement);
            parseSwitchCase = wrapTracking(extra.parseSwitchCase);
            parseUnaryExpression = wrapTracking(extra.parseUnaryExpression);
            parseVariableDeclaration = wrapTracking(extra.parseVariableDeclaration);
            parseVariableIdentifier = wrapTracking(extra.parseVariableIdentifier);
            parseMethodDefinition = wrapTracking(extra.parseMethodDefinition);
            parseClassDeclaration = wrapTracking(extra.parseClassDeclaration);
            parseClassExpression = wrapTracking(extra.parseClassExpression);
            parseClassBody = wrapTracking(extra.parseClassBody);
        }

        if (typeof extra.tokens !== 'undefined') {
            extra.advance = advance;
            extra.scanRegExp = scanRegExp;

            advance = collectToken;
            scanRegExp = collectRegex;
        }
    }

    function unpatch() {
        if (typeof extra.skipComment === 'function') {
            skipComment = extra.skipComment;
        }

        if (extra.range || extra.loc) {
            parseArrayInitialiser = extra.parseArrayInitialiser;
            parseAssignmentExpression = extra.parseAssignmentExpression;
            parseBinaryExpression = extra.parseBinaryExpression;
            parseBlock = extra.parseBlock;
            parseFunctionSourceElements = extra.parseFunctionSourceElements;
            parseCatchClause = extra.parseCatchClause;
            parseComputedMember = extra.parseComputedMember;
            parseConditionalExpression = extra.parseConditionalExpression;
            parseConstLetDeclaration = extra.parseConstLetDeclaration;
            parseExportBatchSpecifier = extra.parseExportBatchSpecifier;
            parseExportDeclaration = extra.parseExportDeclaration;
            parseExportSpecifier = extra.parseExportSpecifier;
            parseExpression = extra.parseExpression;
            parseForVariableDeclaration = extra.parseForVariableDeclaration;
            parseFunctionDeclaration = extra.parseFunctionDeclaration;
            parseFunctionExpression = extra.parseFunctionExpression;
            parseImportDeclaration = extra.parseImportDeclaration;
            parseImportSpecifier = extra.parseImportSpecifier;
            parseGroupExpression = extra.parseGroupExpression;
            parseLeftHandSideExpression = extra.parseLeftHandSideExpression;
            parseLeftHandSideExpressionAllowCall = extra.parseLeftHandSideExpressionAllowCall;
            parseModuleDeclaration = extra.parseModuleDeclaration;
            parseModuleBlock = extra.parseModuleBlock;
            parseNewExpression = extra.parseNewExpression;
            parseNonComputedProperty = extra.parseNonComputedProperty;
            parseObjectInitialiser = extra.parseObjectInitialiser;
            parseObjectProperty = extra.parseObjectProperty;
            parseObjectPropertyKey = extra.parseObjectPropertyKey;
            parsePostfixExpression = extra.parsePostfixExpression;
            parsePrimaryExpression = extra.parsePrimaryExpression;
            parseProgram = extra.parseProgram;
            parsePropertyFunction = extra.parsePropertyFunction;
            parseTemplateElement = extra.parseTemplateElement;
            parseTemplateLiteral = extra.parseTemplateLiteral;
            parseSpreadOrAssignmentExpression = extra.parseSpreadOrAssignmentExpression;
            parseStatement = extra.parseStatement;
            parseSwitchCase = extra.parseSwitchCase;
            parseUnaryExpression = extra.parseUnaryExpression;
            parseVariableDeclaration = extra.parseVariableDeclaration;
            parseVariableIdentifier = extra.parseVariableIdentifier;
            parseMethodDefinition = extra.parseMethodDefinition;
            parseClassDeclaration = extra.parseClassDeclaration;
            parseClassExpression = extra.parseClassExpression;
            parseClassBody = extra.parseClassBody;
        }

        if (typeof extra.scanRegExp === 'function') {
            advance = extra.advance;
            scanRegExp = extra.scanRegExp;
        }
    }

    // This is used to modify the delegate.

    function extend(object, properties) {
        var entry, result = {};

        for (entry in object) {
            if (object.hasOwnProperty(entry)) {
                result[entry] = object[entry];
            }
        }

        for (entry in properties) {
            if (properties.hasOwnProperty(entry)) {
                result[entry] = properties[entry];
            }
        }

        return result;
    }

    function tokenize(code, options) {
        var toString,
            token,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowKeyword: true,
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        if (length > 0) {
            if (typeof source[0] === 'undefined') {
                // Try first to convert to a string. This is good as fast path
                // for old IE which understands string indexing for string
                // literals only and not for string object.
                if (code instanceof String) {
                    source = code.valueOf();
                }
            }
        }

        patch();

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            token = lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    token = lex();
                } catch (lexError) {
                    token = lookahead;
                    if (extra.errors) {
                        extra.errors.push(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            filterTokenLocation();
            tokens = extra.tokens;
            if (typeof extra.comments !== 'undefined') {
                filterCommentLocation();
                tokens.comments = extra.comments;
            }
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            unpatch();
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        delegate = SyntaxTreeDelegate;
        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowKeyword: false,
            allowIn: true,
            labelSet: {},
            parenthesizedCount: 0,
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            yieldAllowed: false,
            yieldFound: false
        };

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                delegate = extend(delegate, {
                    'postProcess': function (node) {
                        node.loc.source = toString(options.source);
                        return node;
                    }
                });
            }

            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
        }

        if (length > 0) {
            if (typeof source[0] === 'undefined') {
                // Try first to convert to a string. This is good as fast path
                // for old IE which understands string indexing for string
                // literals only and not for string object.
                if (code instanceof String) {
                    source = code.valueOf();
                }
            }
        }

        patch();
        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                filterCommentLocation();
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
            if (extra.range || extra.loc) {
                program.body = filterGroup(program.body);
            }
        } catch (e) {
            throw e;
        } finally {
            unpatch();
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '1.1.0-dev-harmony';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],55:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true, define:true*/
(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // and plain browser loading,
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.estraverse = {}));
    }
}(this, function (exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        BREAK,
        SKIP;

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'defaults', 'rest', 'body'],
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'body', 'superClass'],
        ClassExpression: ['id', 'body', 'superClass'],
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'defaults', 'rest', 'body'],
        FunctionExpression: ['id', 'params', 'defaults', 'rest', 'body'],
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MethodDefinition: ['key', 'value'],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handlers', 'handler', 'guardedHandlers', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
    };

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = element.wrap || node.type;
                candidates = VisitorKeys[nodeType];

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (!isArray(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                        continue;
                    }

                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if ((nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === candidates[current]) {
                            element = new Element(candidate[current2], [key, current2], 'Property', null);
                        } else {
                            element = new Element(candidate[current2], [key, current2], null, null);
                        }
                        worklist.push(element);
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = element.wrap || node.type;
            candidates = VisitorKeys[nodeType];

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (!isArray(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                    continue;
                }

                current2 = candidate.length;
                while ((current2 -= 1) >= 0) {
                    if (!candidate[current2]) {
                        continue;
                    }
                    if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                        element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                    } else {
                        element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                    }
                    worklist.push(element);
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = '1.3.3-dev';
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],56:[function(require,module,exports){

},{}],57:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":59}],58:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],59:[function(require,module,exports){
(function (process,global){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
}).call(this,require("/Users/honambang/git/aether/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":58,"/Users/honambang/git/aether/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":62,"inherits":61}],60:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        throw TypeError('Uncaught, unspecified "error" event.');
      }
      return false;
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      console.trace();
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],61:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],62:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],63:[function(require,module,exports){
(function (process){// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;
}).call(this,require("/Users/honambang/git/aether/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/Users/honambang/git/aether/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":62}],64:[function(require,module,exports){
module.exports=require(58)
},{}],65:[function(require,module,exports){
module.exports=require(59)
},{"./support/isBuffer":64,"/Users/honambang/git/aether/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":62,"inherits":61}],66:[function(require,module,exports){
var identifierStartTable = [];

for (var i = 0; i < 128; i++) {
	identifierStartTable[i] =
		i === 36 ||           // $
		i >= 65 && i <= 90 || // A-Z
		i === 95 ||           // _
		i >= 97 && i <= 122;  // a-z
}

var identifierPartTable = [];

for (var i = 0; i < 128; i++) {
	identifierPartTable[i] =
		identifierStartTable[i] || // $, _, A-Z, a-z
		i >= 48 && i <= 57;        // 0-9
}

module.exports = {
	asciiIdentifierStartTable: identifierStartTable,
	asciiIdentifierPartTable: identifierPartTable
};

},{}],67:[function(require,module,exports){
module.exports = [
	768,
	769,
	770,
	771,
	772,
	773,
	774,
	775,
	776,
	777,
	778,
	779,
	780,
	781,
	782,
	783,
	784,
	785,
	786,
	787,
	788,
	789,
	790,
	791,
	792,
	793,
	794,
	795,
	796,
	797,
	798,
	799,
	800,
	801,
	802,
	803,
	804,
	805,
	806,
	807,
	808,
	809,
	810,
	811,
	812,
	813,
	814,
	815,
	816,
	817,
	818,
	819,
	820,
	821,
	822,
	823,
	824,
	825,
	826,
	827,
	828,
	829,
	830,
	831,
	832,
	833,
	834,
	835,
	836,
	837,
	838,
	839,
	840,
	841,
	842,
	843,
	844,
	845,
	846,
	847,
	848,
	849,
	850,
	851,
	852,
	853,
	854,
	855,
	856,
	857,
	858,
	859,
	860,
	861,
	862,
	863,
	864,
	865,
	866,
	867,
	868,
	869,
	870,
	871,
	872,
	873,
	874,
	875,
	876,
	877,
	878,
	879,
	1155,
	1156,
	1157,
	1158,
	1159,
	1425,
	1426,
	1427,
	1428,
	1429,
	1430,
	1431,
	1432,
	1433,
	1434,
	1435,
	1436,
	1437,
	1438,
	1439,
	1440,
	1441,
	1442,
	1443,
	1444,
	1445,
	1446,
	1447,
	1448,
	1449,
	1450,
	1451,
	1452,
	1453,
	1454,
	1455,
	1456,
	1457,
	1458,
	1459,
	1460,
	1461,
	1462,
	1463,
	1464,
	1465,
	1466,
	1467,
	1468,
	1469,
	1471,
	1473,
	1474,
	1476,
	1477,
	1479,
	1552,
	1553,
	1554,
	1555,
	1556,
	1557,
	1558,
	1559,
	1560,
	1561,
	1562,
	1611,
	1612,
	1613,
	1614,
	1615,
	1616,
	1617,
	1618,
	1619,
	1620,
	1621,
	1622,
	1623,
	1624,
	1625,
	1626,
	1627,
	1628,
	1629,
	1630,
	1631,
	1632,
	1633,
	1634,
	1635,
	1636,
	1637,
	1638,
	1639,
	1640,
	1641,
	1648,
	1750,
	1751,
	1752,
	1753,
	1754,
	1755,
	1756,
	1759,
	1760,
	1761,
	1762,
	1763,
	1764,
	1767,
	1768,
	1770,
	1771,
	1772,
	1773,
	1776,
	1777,
	1778,
	1779,
	1780,
	1781,
	1782,
	1783,
	1784,
	1785,
	1809,
	1840,
	1841,
	1842,
	1843,
	1844,
	1845,
	1846,
	1847,
	1848,
	1849,
	1850,
	1851,
	1852,
	1853,
	1854,
	1855,
	1856,
	1857,
	1858,
	1859,
	1860,
	1861,
	1862,
	1863,
	1864,
	1865,
	1866,
	1958,
	1959,
	1960,
	1961,
	1962,
	1963,
	1964,
	1965,
	1966,
	1967,
	1968,
	1984,
	1985,
	1986,
	1987,
	1988,
	1989,
	1990,
	1991,
	1992,
	1993,
	2027,
	2028,
	2029,
	2030,
	2031,
	2032,
	2033,
	2034,
	2035,
	2070,
	2071,
	2072,
	2073,
	2075,
	2076,
	2077,
	2078,
	2079,
	2080,
	2081,
	2082,
	2083,
	2085,
	2086,
	2087,
	2089,
	2090,
	2091,
	2092,
	2093,
	2137,
	2138,
	2139,
	2276,
	2277,
	2278,
	2279,
	2280,
	2281,
	2282,
	2283,
	2284,
	2285,
	2286,
	2287,
	2288,
	2289,
	2290,
	2291,
	2292,
	2293,
	2294,
	2295,
	2296,
	2297,
	2298,
	2299,
	2300,
	2301,
	2302,
	2304,
	2305,
	2306,
	2307,
	2362,
	2363,
	2364,
	2366,
	2367,
	2368,
	2369,
	2370,
	2371,
	2372,
	2373,
	2374,
	2375,
	2376,
	2377,
	2378,
	2379,
	2380,
	2381,
	2382,
	2383,
	2385,
	2386,
	2387,
	2388,
	2389,
	2390,
	2391,
	2402,
	2403,
	2406,
	2407,
	2408,
	2409,
	2410,
	2411,
	2412,
	2413,
	2414,
	2415,
	2433,
	2434,
	2435,
	2492,
	2494,
	2495,
	2496,
	2497,
	2498,
	2499,
	2500,
	2503,
	2504,
	2507,
	2508,
	2509,
	2519,
	2530,
	2531,
	2534,
	2535,
	2536,
	2537,
	2538,
	2539,
	2540,
	2541,
	2542,
	2543,
	2561,
	2562,
	2563,
	2620,
	2622,
	2623,
	2624,
	2625,
	2626,
	2631,
	2632,
	2635,
	2636,
	2637,
	2641,
	2662,
	2663,
	2664,
	2665,
	2666,
	2667,
	2668,
	2669,
	2670,
	2671,
	2672,
	2673,
	2677,
	2689,
	2690,
	2691,
	2748,
	2750,
	2751,
	2752,
	2753,
	2754,
	2755,
	2756,
	2757,
	2759,
	2760,
	2761,
	2763,
	2764,
	2765,
	2786,
	2787,
	2790,
	2791,
	2792,
	2793,
	2794,
	2795,
	2796,
	2797,
	2798,
	2799,
	2817,
	2818,
	2819,
	2876,
	2878,
	2879,
	2880,
	2881,
	2882,
	2883,
	2884,
	2887,
	2888,
	2891,
	2892,
	2893,
	2902,
	2903,
	2914,
	2915,
	2918,
	2919,
	2920,
	2921,
	2922,
	2923,
	2924,
	2925,
	2926,
	2927,
	2946,
	3006,
	3007,
	3008,
	3009,
	3010,
	3014,
	3015,
	3016,
	3018,
	3019,
	3020,
	3021,
	3031,
	3046,
	3047,
	3048,
	3049,
	3050,
	3051,
	3052,
	3053,
	3054,
	3055,
	3073,
	3074,
	3075,
	3134,
	3135,
	3136,
	3137,
	3138,
	3139,
	3140,
	3142,
	3143,
	3144,
	3146,
	3147,
	3148,
	3149,
	3157,
	3158,
	3170,
	3171,
	3174,
	3175,
	3176,
	3177,
	3178,
	3179,
	3180,
	3181,
	3182,
	3183,
	3202,
	3203,
	3260,
	3262,
	3263,
	3264,
	3265,
	3266,
	3267,
	3268,
	3270,
	3271,
	3272,
	3274,
	3275,
	3276,
	3277,
	3285,
	3286,
	3298,
	3299,
	3302,
	3303,
	3304,
	3305,
	3306,
	3307,
	3308,
	3309,
	3310,
	3311,
	3330,
	3331,
	3390,
	3391,
	3392,
	3393,
	3394,
	3395,
	3396,
	3398,
	3399,
	3400,
	3402,
	3403,
	3404,
	3405,
	3415,
	3426,
	3427,
	3430,
	3431,
	3432,
	3433,
	3434,
	3435,
	3436,
	3437,
	3438,
	3439,
	3458,
	3459,
	3530,
	3535,
	3536,
	3537,
	3538,
	3539,
	3540,
	3542,
	3544,
	3545,
	3546,
	3547,
	3548,
	3549,
	3550,
	3551,
	3570,
	3571,
	3633,
	3636,
	3637,
	3638,
	3639,
	3640,
	3641,
	3642,
	3655,
	3656,
	3657,
	3658,
	3659,
	3660,
	3661,
	3662,
	3664,
	3665,
	3666,
	3667,
	3668,
	3669,
	3670,
	3671,
	3672,
	3673,
	3761,
	3764,
	3765,
	3766,
	3767,
	3768,
	3769,
	3771,
	3772,
	3784,
	3785,
	3786,
	3787,
	3788,
	3789,
	3792,
	3793,
	3794,
	3795,
	3796,
	3797,
	3798,
	3799,
	3800,
	3801,
	3864,
	3865,
	3872,
	3873,
	3874,
	3875,
	3876,
	3877,
	3878,
	3879,
	3880,
	3881,
	3893,
	3895,
	3897,
	3902,
	3903,
	3953,
	3954,
	3955,
	3956,
	3957,
	3958,
	3959,
	3960,
	3961,
	3962,
	3963,
	3964,
	3965,
	3966,
	3967,
	3968,
	3969,
	3970,
	3971,
	3972,
	3974,
	3975,
	3981,
	3982,
	3983,
	3984,
	3985,
	3986,
	3987,
	3988,
	3989,
	3990,
	3991,
	3993,
	3994,
	3995,
	3996,
	3997,
	3998,
	3999,
	4000,
	4001,
	4002,
	4003,
	4004,
	4005,
	4006,
	4007,
	4008,
	4009,
	4010,
	4011,
	4012,
	4013,
	4014,
	4015,
	4016,
	4017,
	4018,
	4019,
	4020,
	4021,
	4022,
	4023,
	4024,
	4025,
	4026,
	4027,
	4028,
	4038,
	4139,
	4140,
	4141,
	4142,
	4143,
	4144,
	4145,
	4146,
	4147,
	4148,
	4149,
	4150,
	4151,
	4152,
	4153,
	4154,
	4155,
	4156,
	4157,
	4158,
	4160,
	4161,
	4162,
	4163,
	4164,
	4165,
	4166,
	4167,
	4168,
	4169,
	4182,
	4183,
	4184,
	4185,
	4190,
	4191,
	4192,
	4194,
	4195,
	4196,
	4199,
	4200,
	4201,
	4202,
	4203,
	4204,
	4205,
	4209,
	4210,
	4211,
	4212,
	4226,
	4227,
	4228,
	4229,
	4230,
	4231,
	4232,
	4233,
	4234,
	4235,
	4236,
	4237,
	4239,
	4240,
	4241,
	4242,
	4243,
	4244,
	4245,
	4246,
	4247,
	4248,
	4249,
	4250,
	4251,
	4252,
	4253,
	4957,
	4958,
	4959,
	5906,
	5907,
	5908,
	5938,
	5939,
	5940,
	5970,
	5971,
	6002,
	6003,
	6068,
	6069,
	6070,
	6071,
	6072,
	6073,
	6074,
	6075,
	6076,
	6077,
	6078,
	6079,
	6080,
	6081,
	6082,
	6083,
	6084,
	6085,
	6086,
	6087,
	6088,
	6089,
	6090,
	6091,
	6092,
	6093,
	6094,
	6095,
	6096,
	6097,
	6098,
	6099,
	6109,
	6112,
	6113,
	6114,
	6115,
	6116,
	6117,
	6118,
	6119,
	6120,
	6121,
	6155,
	6156,
	6157,
	6160,
	6161,
	6162,
	6163,
	6164,
	6165,
	6166,
	6167,
	6168,
	6169,
	6313,
	6432,
	6433,
	6434,
	6435,
	6436,
	6437,
	6438,
	6439,
	6440,
	6441,
	6442,
	6443,
	6448,
	6449,
	6450,
	6451,
	6452,
	6453,
	6454,
	6455,
	6456,
	6457,
	6458,
	6459,
	6470,
	6471,
	6472,
	6473,
	6474,
	6475,
	6476,
	6477,
	6478,
	6479,
	6576,
	6577,
	6578,
	6579,
	6580,
	6581,
	6582,
	6583,
	6584,
	6585,
	6586,
	6587,
	6588,
	6589,
	6590,
	6591,
	6592,
	6600,
	6601,
	6608,
	6609,
	6610,
	6611,
	6612,
	6613,
	6614,
	6615,
	6616,
	6617,
	6679,
	6680,
	6681,
	6682,
	6683,
	6741,
	6742,
	6743,
	6744,
	6745,
	6746,
	6747,
	6748,
	6749,
	6750,
	6752,
	6753,
	6754,
	6755,
	6756,
	6757,
	6758,
	6759,
	6760,
	6761,
	6762,
	6763,
	6764,
	6765,
	6766,
	6767,
	6768,
	6769,
	6770,
	6771,
	6772,
	6773,
	6774,
	6775,
	6776,
	6777,
	6778,
	6779,
	6780,
	6783,
	6784,
	6785,
	6786,
	6787,
	6788,
	6789,
	6790,
	6791,
	6792,
	6793,
	6800,
	6801,
	6802,
	6803,
	6804,
	6805,
	6806,
	6807,
	6808,
	6809,
	6912,
	6913,
	6914,
	6915,
	6916,
	6964,
	6965,
	6966,
	6967,
	6968,
	6969,
	6970,
	6971,
	6972,
	6973,
	6974,
	6975,
	6976,
	6977,
	6978,
	6979,
	6980,
	6992,
	6993,
	6994,
	6995,
	6996,
	6997,
	6998,
	6999,
	7000,
	7001,
	7019,
	7020,
	7021,
	7022,
	7023,
	7024,
	7025,
	7026,
	7027,
	7040,
	7041,
	7042,
	7073,
	7074,
	7075,
	7076,
	7077,
	7078,
	7079,
	7080,
	7081,
	7082,
	7083,
	7084,
	7085,
	7088,
	7089,
	7090,
	7091,
	7092,
	7093,
	7094,
	7095,
	7096,
	7097,
	7142,
	7143,
	7144,
	7145,
	7146,
	7147,
	7148,
	7149,
	7150,
	7151,
	7152,
	7153,
	7154,
	7155,
	7204,
	7205,
	7206,
	7207,
	7208,
	7209,
	7210,
	7211,
	7212,
	7213,
	7214,
	7215,
	7216,
	7217,
	7218,
	7219,
	7220,
	7221,
	7222,
	7223,
	7232,
	7233,
	7234,
	7235,
	7236,
	7237,
	7238,
	7239,
	7240,
	7241,
	7248,
	7249,
	7250,
	7251,
	7252,
	7253,
	7254,
	7255,
	7256,
	7257,
	7376,
	7377,
	7378,
	7380,
	7381,
	7382,
	7383,
	7384,
	7385,
	7386,
	7387,
	7388,
	7389,
	7390,
	7391,
	7392,
	7393,
	7394,
	7395,
	7396,
	7397,
	7398,
	7399,
	7400,
	7405,
	7410,
	7411,
	7412,
	7616,
	7617,
	7618,
	7619,
	7620,
	7621,
	7622,
	7623,
	7624,
	7625,
	7626,
	7627,
	7628,
	7629,
	7630,
	7631,
	7632,
	7633,
	7634,
	7635,
	7636,
	7637,
	7638,
	7639,
	7640,
	7641,
	7642,
	7643,
	7644,
	7645,
	7646,
	7647,
	7648,
	7649,
	7650,
	7651,
	7652,
	7653,
	7654,
	7676,
	7677,
	7678,
	7679,
	8204,
	8205,
	8255,
	8256,
	8276,
	8400,
	8401,
	8402,
	8403,
	8404,
	8405,
	8406,
	8407,
	8408,
	8409,
	8410,
	8411,
	8412,
	8417,
	8421,
	8422,
	8423,
	8424,
	8425,
	8426,
	8427,
	8428,
	8429,
	8430,
	8431,
	8432,
	11503,
	11504,
	11505,
	11647,
	11744,
	11745,
	11746,
	11747,
	11748,
	11749,
	11750,
	11751,
	11752,
	11753,
	11754,
	11755,
	11756,
	11757,
	11758,
	11759,
	11760,
	11761,
	11762,
	11763,
	11764,
	11765,
	11766,
	11767,
	11768,
	11769,
	11770,
	11771,
	11772,
	11773,
	11774,
	11775,
	12330,
	12331,
	12332,
	12333,
	12334,
	12335,
	12441,
	12442,
	42528,
	42529,
	42530,
	42531,
	42532,
	42533,
	42534,
	42535,
	42536,
	42537,
	42607,
	42612,
	42613,
	42614,
	42615,
	42616,
	42617,
	42618,
	42619,
	42620,
	42621,
	42655,
	42736,
	42737,
	43010,
	43014,
	43019,
	43043,
	43044,
	43045,
	43046,
	43047,
	43136,
	43137,
	43188,
	43189,
	43190,
	43191,
	43192,
	43193,
	43194,
	43195,
	43196,
	43197,
	43198,
	43199,
	43200,
	43201,
	43202,
	43203,
	43204,
	43216,
	43217,
	43218,
	43219,
	43220,
	43221,
	43222,
	43223,
	43224,
	43225,
	43232,
	43233,
	43234,
	43235,
	43236,
	43237,
	43238,
	43239,
	43240,
	43241,
	43242,
	43243,
	43244,
	43245,
	43246,
	43247,
	43248,
	43249,
	43264,
	43265,
	43266,
	43267,
	43268,
	43269,
	43270,
	43271,
	43272,
	43273,
	43302,
	43303,
	43304,
	43305,
	43306,
	43307,
	43308,
	43309,
	43335,
	43336,
	43337,
	43338,
	43339,
	43340,
	43341,
	43342,
	43343,
	43344,
	43345,
	43346,
	43347,
	43392,
	43393,
	43394,
	43395,
	43443,
	43444,
	43445,
	43446,
	43447,
	43448,
	43449,
	43450,
	43451,
	43452,
	43453,
	43454,
	43455,
	43456,
	43472,
	43473,
	43474,
	43475,
	43476,
	43477,
	43478,
	43479,
	43480,
	43481,
	43561,
	43562,
	43563,
	43564,
	43565,
	43566,
	43567,
	43568,
	43569,
	43570,
	43571,
	43572,
	43573,
	43574,
	43587,
	43596,
	43597,
	43600,
	43601,
	43602,
	43603,
	43604,
	43605,
	43606,
	43607,
	43608,
	43609,
	43643,
	43696,
	43698,
	43699,
	43700,
	43703,
	43704,
	43710,
	43711,
	43713,
	43755,
	43756,
	43757,
	43758,
	43759,
	43765,
	43766,
	44003,
	44004,
	44005,
	44006,
	44007,
	44008,
	44009,
	44010,
	44012,
	44013,
	44016,
	44017,
	44018,
	44019,
	44020,
	44021,
	44022,
	44023,
	44024,
	44025,
	64286,
	65024,
	65025,
	65026,
	65027,
	65028,
	65029,
	65030,
	65031,
	65032,
	65033,
	65034,
	65035,
	65036,
	65037,
	65038,
	65039,
	65056,
	65057,
	65058,
	65059,
	65060,
	65061,
	65062,
	65075,
	65076,
	65101,
	65102,
	65103,
	65296,
	65297,
	65298,
	65299,
	65300,
	65301,
	65302,
	65303,
	65304,
	65305,
	65343
];

},{}],68:[function(require,module,exports){
module.exports = [
	170,
	181,
	186,
	192,
	193,
	194,
	195,
	196,
	197,
	198,
	199,
	200,
	201,
	202,
	203,
	204,
	205,
	206,
	207,
	208,
	209,
	210,
	211,
	212,
	213,
	214,
	216,
	217,
	218,
	219,
	220,
	221,
	222,
	223,
	224,
	225,
	226,
	227,
	228,
	229,
	230,
	231,
	232,
	233,
	234,
	235,
	236,
	237,
	238,
	239,
	240,
	241,
	242,
	243,
	244,
	245,
	246,
	248,
	249,
	250,
	251,
	252,
	253,
	254,
	255,
	256,
	257,
	258,
	259,
	260,
	261,
	262,
	263,
	264,
	265,
	266,
	267,
	268,
	269,
	270,
	271,
	272,
	273,
	274,
	275,
	276,
	277,
	278,
	279,
	280,
	281,
	282,
	283,
	284,
	285,
	286,
	287,
	288,
	289,
	290,
	291,
	292,
	293,
	294,
	295,
	296,
	297,
	298,
	299,
	300,
	301,
	302,
	303,
	304,
	305,
	306,
	307,
	308,
	309,
	310,
	311,
	312,
	313,
	314,
	315,
	316,
	317,
	318,
	319,
	320,
	321,
	322,
	323,
	324,
	325,
	326,
	327,
	328,
	329,
	330,
	331,
	332,
	333,
	334,
	335,
	336,
	337,
	338,
	339,
	340,
	341,
	342,
	343,
	344,
	345,
	346,
	347,
	348,
	349,
	350,
	351,
	352,
	353,
	354,
	355,
	356,
	357,
	358,
	359,
	360,
	361,
	362,
	363,
	364,
	365,
	366,
	367,
	368,
	369,
	370,
	371,
	372,
	373,
	374,
	375,
	376,
	377,
	378,
	379,
	380,
	381,
	382,
	383,
	384,
	385,
	386,
	387,
	388,
	389,
	390,
	391,
	392,
	393,
	394,
	395,
	396,
	397,
	398,
	399,
	400,
	401,
	402,
	403,
	404,
	405,
	406,
	407,
	408,
	409,
	410,
	411,
	412,
	413,
	414,
	415,
	416,
	417,
	418,
	419,
	420,
	421,
	422,
	423,
	424,
	425,
	426,
	427,
	428,
	429,
	430,
	431,
	432,
	433,
	434,
	435,
	436,
	437,
	438,
	439,
	440,
	441,
	442,
	443,
	444,
	445,
	446,
	447,
	448,
	449,
	450,
	451,
	452,
	453,
	454,
	455,
	456,
	457,
	458,
	459,
	460,
	461,
	462,
	463,
	464,
	465,
	466,
	467,
	468,
	469,
	470,
	471,
	472,
	473,
	474,
	475,
	476,
	477,
	478,
	479,
	480,
	481,
	482,
	483,
	484,
	485,
	486,
	487,
	488,
	489,
	490,
	491,
	492,
	493,
	494,
	495,
	496,
	497,
	498,
	499,
	500,
	501,
	502,
	503,
	504,
	505,
	506,
	507,
	508,
	509,
	510,
	511,
	512,
	513,
	514,
	515,
	516,
	517,
	518,
	519,
	520,
	521,
	522,
	523,
	524,
	525,
	526,
	527,
	528,
	529,
	530,
	531,
	532,
	533,
	534,
	535,
	536,
	537,
	538,
	539,
	540,
	541,
	542,
	543,
	544,
	545,
	546,
	547,
	548,
	549,
	550,
	551,
	552,
	553,
	554,
	555,
	556,
	557,
	558,
	559,
	560,
	561,
	562,
	563,
	564,
	565,
	566,
	567,
	568,
	569,
	570,
	571,
	572,
	573,
	574,
	575,
	576,
	577,
	578,
	579,
	580,
	581,
	582,
	583,
	584,
	585,
	586,
	587,
	588,
	589,
	590,
	591,
	592,
	593,
	594,
	595,
	596,
	597,
	598,
	599,
	600,
	601,
	602,
	603,
	604,
	605,
	606,
	607,
	608,
	609,
	610,
	611,
	612,
	613,
	614,
	615,
	616,
	617,
	618,
	619,
	620,
	621,
	622,
	623,
	624,
	625,
	626,
	627,
	628,
	629,
	630,
	631,
	632,
	633,
	634,
	635,
	636,
	637,
	638,
	639,
	640,
	641,
	642,
	643,
	644,
	645,
	646,
	647,
	648,
	649,
	650,
	651,
	652,
	653,
	654,
	655,
	656,
	657,
	658,
	659,
	660,
	661,
	662,
	663,
	664,
	665,
	666,
	667,
	668,
	669,
	670,
	671,
	672,
	673,
	674,
	675,
	676,
	677,
	678,
	679,
	680,
	681,
	682,
	683,
	684,
	685,
	686,
	687,
	688,
	689,
	690,
	691,
	692,
	693,
	694,
	695,
	696,
	697,
	698,
	699,
	700,
	701,
	702,
	703,
	704,
	705,
	710,
	711,
	712,
	713,
	714,
	715,
	716,
	717,
	718,
	719,
	720,
	721,
	736,
	737,
	738,
	739,
	740,
	748,
	750,
	880,
	881,
	882,
	883,
	884,
	886,
	887,
	890,
	891,
	892,
	893,
	902,
	904,
	905,
	906,
	908,
	910,
	911,
	912,
	913,
	914,
	915,
	916,
	917,
	918,
	919,
	920,
	921,
	922,
	923,
	924,
	925,
	926,
	927,
	928,
	929,
	931,
	932,
	933,
	934,
	935,
	936,
	937,
	938,
	939,
	940,
	941,
	942,
	943,
	944,
	945,
	946,
	947,
	948,
	949,
	950,
	951,
	952,
	953,
	954,
	955,
	956,
	957,
	958,
	959,
	960,
	961,
	962,
	963,
	964,
	965,
	966,
	967,
	968,
	969,
	970,
	971,
	972,
	973,
	974,
	975,
	976,
	977,
	978,
	979,
	980,
	981,
	982,
	983,
	984,
	985,
	986,
	987,
	988,
	989,
	990,
	991,
	992,
	993,
	994,
	995,
	996,
	997,
	998,
	999,
	1000,
	1001,
	1002,
	1003,
	1004,
	1005,
	1006,
	1007,
	1008,
	1009,
	1010,
	1011,
	1012,
	1013,
	1015,
	1016,
	1017,
	1018,
	1019,
	1020,
	1021,
	1022,
	1023,
	1024,
	1025,
	1026,
	1027,
	1028,
	1029,
	1030,
	1031,
	1032,
	1033,
	1034,
	1035,
	1036,
	1037,
	1038,
	1039,
	1040,
	1041,
	1042,
	1043,
	1044,
	1045,
	1046,
	1047,
	1048,
	1049,
	1050,
	1051,
	1052,
	1053,
	1054,
	1055,
	1056,
	1057,
	1058,
	1059,
	1060,
	1061,
	1062,
	1063,
	1064,
	1065,
	1066,
	1067,
	1068,
	1069,
	1070,
	1071,
	1072,
	1073,
	1074,
	1075,
	1076,
	1077,
	1078,
	1079,
	1080,
	1081,
	1082,
	1083,
	1084,
	1085,
	1086,
	1087,
	1088,
	1089,
	1090,
	1091,
	1092,
	1093,
	1094,
	1095,
	1096,
	1097,
	1098,
	1099,
	1100,
	1101,
	1102,
	1103,
	1104,
	1105,
	1106,
	1107,
	1108,
	1109,
	1110,
	1111,
	1112,
	1113,
	1114,
	1115,
	1116,
	1117,
	1118,
	1119,
	1120,
	1121,
	1122,
	1123,
	1124,
	1125,
	1126,
	1127,
	1128,
	1129,
	1130,
	1131,
	1132,
	1133,
	1134,
	1135,
	1136,
	1137,
	1138,
	1139,
	1140,
	1141,
	1142,
	1143,
	1144,
	1145,
	1146,
	1147,
	1148,
	1149,
	1150,
	1151,
	1152,
	1153,
	1162,
	1163,
	1164,
	1165,
	1166,
	1167,
	1168,
	1169,
	1170,
	1171,
	1172,
	1173,
	1174,
	1175,
	1176,
	1177,
	1178,
	1179,
	1180,
	1181,
	1182,
	1183,
	1184,
	1185,
	1186,
	1187,
	1188,
	1189,
	1190,
	1191,
	1192,
	1193,
	1194,
	1195,
	1196,
	1197,
	1198,
	1199,
	1200,
	1201,
	1202,
	1203,
	1204,
	1205,
	1206,
	1207,
	1208,
	1209,
	1210,
	1211,
	1212,
	1213,
	1214,
	1215,
	1216,
	1217,
	1218,
	1219,
	1220,
	1221,
	1222,
	1223,
	1224,
	1225,
	1226,
	1227,
	1228,
	1229,
	1230,
	1231,
	1232,
	1233,
	1234,
	1235,
	1236,
	1237,
	1238,
	1239,
	1240,
	1241,
	1242,
	1243,
	1244,
	1245,
	1246,
	1247,
	1248,
	1249,
	1250,
	1251,
	1252,
	1253,
	1254,
	1255,
	1256,
	1257,
	1258,
	1259,
	1260,
	1261,
	1262,
	1263,
	1264,
	1265,
	1266,
	1267,
	1268,
	1269,
	1270,
	1271,
	1272,
	1273,
	1274,
	1275,
	1276,
	1277,
	1278,
	1279,
	1280,
	1281,
	1282,
	1283,
	1284,
	1285,
	1286,
	1287,
	1288,
	1289,
	1290,
	1291,
	1292,
	1293,
	1294,
	1295,
	1296,
	1297,
	1298,
	1299,
	1300,
	1301,
	1302,
	1303,
	1304,
	1305,
	1306,
	1307,
	1308,
	1309,
	1310,
	1311,
	1312,
	1313,
	1314,
	1315,
	1316,
	1317,
	1318,
	1319,
	1329,
	1330,
	1331,
	1332,
	1333,
	1334,
	1335,
	1336,
	1337,
	1338,
	1339,
	1340,
	1341,
	1342,
	1343,
	1344,
	1345,
	1346,
	1347,
	1348,
	1349,
	1350,
	1351,
	1352,
	1353,
	1354,
	1355,
	1356,
	1357,
	1358,
	1359,
	1360,
	1361,
	1362,
	1363,
	1364,
	1365,
	1366,
	1369,
	1377,
	1378,
	1379,
	1380,
	1381,
	1382,
	1383,
	1384,
	1385,
	1386,
	1387,
	1388,
	1389,
	1390,
	1391,
	1392,
	1393,
	1394,
	1395,
	1396,
	1397,
	1398,
	1399,
	1400,
	1401,
	1402,
	1403,
	1404,
	1405,
	1406,
	1407,
	1408,
	1409,
	1410,
	1411,
	1412,
	1413,
	1414,
	1415,
	1488,
	1489,
	1490,
	1491,
	1492,
	1493,
	1494,
	1495,
	1496,
	1497,
	1498,
	1499,
	1500,
	1501,
	1502,
	1503,
	1504,
	1505,
	1506,
	1507,
	1508,
	1509,
	1510,
	1511,
	1512,
	1513,
	1514,
	1520,
	1521,
	1522,
	1568,
	1569,
	1570,
	1571,
	1572,
	1573,
	1574,
	1575,
	1576,
	1577,
	1578,
	1579,
	1580,
	1581,
	1582,
	1583,
	1584,
	1585,
	1586,
	1587,
	1588,
	1589,
	1590,
	1591,
	1592,
	1593,
	1594,
	1595,
	1596,
	1597,
	1598,
	1599,
	1600,
	1601,
	1602,
	1603,
	1604,
	1605,
	1606,
	1607,
	1608,
	1609,
	1610,
	1646,
	1647,
	1649,
	1650,
	1651,
	1652,
	1653,
	1654,
	1655,
	1656,
	1657,
	1658,
	1659,
	1660,
	1661,
	1662,
	1663,
	1664,
	1665,
	1666,
	1667,
	1668,
	1669,
	1670,
	1671,
	1672,
	1673,
	1674,
	1675,
	1676,
	1677,
	1678,
	1679,
	1680,
	1681,
	1682,
	1683,
	1684,
	1685,
	1686,
	1687,
	1688,
	1689,
	1690,
	1691,
	1692,
	1693,
	1694,
	1695,
	1696,
	1697,
	1698,
	1699,
	1700,
	1701,
	1702,
	1703,
	1704,
	1705,
	1706,
	1707,
	1708,
	1709,
	1710,
	1711,
	1712,
	1713,
	1714,
	1715,
	1716,
	1717,
	1718,
	1719,
	1720,
	1721,
	1722,
	1723,
	1724,
	1725,
	1726,
	1727,
	1728,
	1729,
	1730,
	1731,
	1732,
	1733,
	1734,
	1735,
	1736,
	1737,
	1738,
	1739,
	1740,
	1741,
	1742,
	1743,
	1744,
	1745,
	1746,
	1747,
	1749,
	1765,
	1766,
	1774,
	1775,
	1786,
	1787,
	1788,
	1791,
	1808,
	1810,
	1811,
	1812,
	1813,
	1814,
	1815,
	1816,
	1817,
	1818,
	1819,
	1820,
	1821,
	1822,
	1823,
	1824,
	1825,
	1826,
	1827,
	1828,
	1829,
	1830,
	1831,
	1832,
	1833,
	1834,
	1835,
	1836,
	1837,
	1838,
	1839,
	1869,
	1870,
	1871,
	1872,
	1873,
	1874,
	1875,
	1876,
	1877,
	1878,
	1879,
	1880,
	1881,
	1882,
	1883,
	1884,
	1885,
	1886,
	1887,
	1888,
	1889,
	1890,
	1891,
	1892,
	1893,
	1894,
	1895,
	1896,
	1897,
	1898,
	1899,
	1900,
	1901,
	1902,
	1903,
	1904,
	1905,
	1906,
	1907,
	1908,
	1909,
	1910,
	1911,
	1912,
	1913,
	1914,
	1915,
	1916,
	1917,
	1918,
	1919,
	1920,
	1921,
	1922,
	1923,
	1924,
	1925,
	1926,
	1927,
	1928,
	1929,
	1930,
	1931,
	1932,
	1933,
	1934,
	1935,
	1936,
	1937,
	1938,
	1939,
	1940,
	1941,
	1942,
	1943,
	1944,
	1945,
	1946,
	1947,
	1948,
	1949,
	1950,
	1951,
	1952,
	1953,
	1954,
	1955,
	1956,
	1957,
	1969,
	1994,
	1995,
	1996,
	1997,
	1998,
	1999,
	2000,
	2001,
	2002,
	2003,
	2004,
	2005,
	2006,
	2007,
	2008,
	2009,
	2010,
	2011,
	2012,
	2013,
	2014,
	2015,
	2016,
	2017,
	2018,
	2019,
	2020,
	2021,
	2022,
	2023,
	2024,
	2025,
	2026,
	2036,
	2037,
	2042,
	2048,
	2049,
	2050,
	2051,
	2052,
	2053,
	2054,
	2055,
	2056,
	2057,
	2058,
	2059,
	2060,
	2061,
	2062,
	2063,
	2064,
	2065,
	2066,
	2067,
	2068,
	2069,
	2074,
	2084,
	2088,
	2112,
	2113,
	2114,
	2115,
	2116,
	2117,
	2118,
	2119,
	2120,
	2121,
	2122,
	2123,
	2124,
	2125,
	2126,
	2127,
	2128,
	2129,
	2130,
	2131,
	2132,
	2133,
	2134,
	2135,
	2136,
	2208,
	2210,
	2211,
	2212,
	2213,
	2214,
	2215,
	2216,
	2217,
	2218,
	2219,
	2220,
	2308,
	2309,
	2310,
	2311,
	2312,
	2313,
	2314,
	2315,
	2316,
	2317,
	2318,
	2319,
	2320,
	2321,
	2322,
	2323,
	2324,
	2325,
	2326,
	2327,
	2328,
	2329,
	2330,
	2331,
	2332,
	2333,
	2334,
	2335,
	2336,
	2337,
	2338,
	2339,
	2340,
	2341,
	2342,
	2343,
	2344,
	2345,
	2346,
	2347,
	2348,
	2349,
	2350,
	2351,
	2352,
	2353,
	2354,
	2355,
	2356,
	2357,
	2358,
	2359,
	2360,
	2361,
	2365,
	2384,
	2392,
	2393,
	2394,
	2395,
	2396,
	2397,
	2398,
	2399,
	2400,
	2401,
	2417,
	2418,
	2419,
	2420,
	2421,
	2422,
	2423,
	2425,
	2426,
	2427,
	2428,
	2429,
	2430,
	2431,
	2437,
	2438,
	2439,
	2440,
	2441,
	2442,
	2443,
	2444,
	2447,
	2448,
	2451,
	2452,
	2453,
	2454,
	2455,
	2456,
	2457,
	2458,
	2459,
	2460,
	2461,
	2462,
	2463,
	2464,
	2465,
	2466,
	2467,
	2468,
	2469,
	2470,
	2471,
	2472,
	2474,
	2475,
	2476,
	2477,
	2478,
	2479,
	2480,
	2482,
	2486,
	2487,
	2488,
	2489,
	2493,
	2510,
	2524,
	2525,
	2527,
	2528,
	2529,
	2544,
	2545,
	2565,
	2566,
	2567,
	2568,
	2569,
	2570,
	2575,
	2576,
	2579,
	2580,
	2581,
	2582,
	2583,
	2584,
	2585,
	2586,
	2587,
	2588,
	2589,
	2590,
	2591,
	2592,
	2593,
	2594,
	2595,
	2596,
	2597,
	2598,
	2599,
	2600,
	2602,
	2603,
	2604,
	2605,
	2606,
	2607,
	2608,
	2610,
	2611,
	2613,
	2614,
	2616,
	2617,
	2649,
	2650,
	2651,
	2652,
	2654,
	2674,
	2675,
	2676,
	2693,
	2694,
	2695,
	2696,
	2697,
	2698,
	2699,
	2700,
	2701,
	2703,
	2704,
	2705,
	2707,
	2708,
	2709,
	2710,
	2711,
	2712,
	2713,
	2714,
	2715,
	2716,
	2717,
	2718,
	2719,
	2720,
	2721,
	2722,
	2723,
	2724,
	2725,
	2726,
	2727,
	2728,
	2730,
	2731,
	2732,
	2733,
	2734,
	2735,
	2736,
	2738,
	2739,
	2741,
	2742,
	2743,
	2744,
	2745,
	2749,
	2768,
	2784,
	2785,
	2821,
	2822,
	2823,
	2824,
	2825,
	2826,
	2827,
	2828,
	2831,
	2832,
	2835,
	2836,
	2837,
	2838,
	2839,
	2840,
	2841,
	2842,
	2843,
	2844,
	2845,
	2846,
	2847,
	2848,
	2849,
	2850,
	2851,
	2852,
	2853,
	2854,
	2855,
	2856,
	2858,
	2859,
	2860,
	2861,
	2862,
	2863,
	2864,
	2866,
	2867,
	2869,
	2870,
	2871,
	2872,
	2873,
	2877,
	2908,
	2909,
	2911,
	2912,
	2913,
	2929,
	2947,
	2949,
	2950,
	2951,
	2952,
	2953,
	2954,
	2958,
	2959,
	2960,
	2962,
	2963,
	2964,
	2965,
	2969,
	2970,
	2972,
	2974,
	2975,
	2979,
	2980,
	2984,
	2985,
	2986,
	2990,
	2991,
	2992,
	2993,
	2994,
	2995,
	2996,
	2997,
	2998,
	2999,
	3000,
	3001,
	3024,
	3077,
	3078,
	3079,
	3080,
	3081,
	3082,
	3083,
	3084,
	3086,
	3087,
	3088,
	3090,
	3091,
	3092,
	3093,
	3094,
	3095,
	3096,
	3097,
	3098,
	3099,
	3100,
	3101,
	3102,
	3103,
	3104,
	3105,
	3106,
	3107,
	3108,
	3109,
	3110,
	3111,
	3112,
	3114,
	3115,
	3116,
	3117,
	3118,
	3119,
	3120,
	3121,
	3122,
	3123,
	3125,
	3126,
	3127,
	3128,
	3129,
	3133,
	3160,
	3161,
	3168,
	3169,
	3205,
	3206,
	3207,
	3208,
	3209,
	3210,
	3211,
	3212,
	3214,
	3215,
	3216,
	3218,
	3219,
	3220,
	3221,
	3222,
	3223,
	3224,
	3225,
	3226,
	3227,
	3228,
	3229,
	3230,
	3231,
	3232,
	3233,
	3234,
	3235,
	3236,
	3237,
	3238,
	3239,
	3240,
	3242,
	3243,
	3244,
	3245,
	3246,
	3247,
	3248,
	3249,
	3250,
	3251,
	3253,
	3254,
	3255,
	3256,
	3257,
	3261,
	3294,
	3296,
	3297,
	3313,
	3314,
	3333,
	3334,
	3335,
	3336,
	3337,
	3338,
	3339,
	3340,
	3342,
	3343,
	3344,
	3346,
	3347,
	3348,
	3349,
	3350,
	3351,
	3352,
	3353,
	3354,
	3355,
	3356,
	3357,
	3358,
	3359,
	3360,
	3361,
	3362,
	3363,
	3364,
	3365,
	3366,
	3367,
	3368,
	3369,
	3370,
	3371,
	3372,
	3373,
	3374,
	3375,
	3376,
	3377,
	3378,
	3379,
	3380,
	3381,
	3382,
	3383,
	3384,
	3385,
	3386,
	3389,
	3406,
	3424,
	3425,
	3450,
	3451,
	3452,
	3453,
	3454,
	3455,
	3461,
	3462,
	3463,
	3464,
	3465,
	3466,
	3467,
	3468,
	3469,
	3470,
	3471,
	3472,
	3473,
	3474,
	3475,
	3476,
	3477,
	3478,
	3482,
	3483,
	3484,
	3485,
	3486,
	3487,
	3488,
	3489,
	3490,
	3491,
	3492,
	3493,
	3494,
	3495,
	3496,
	3497,
	3498,
	3499,
	3500,
	3501,
	3502,
	3503,
	3504,
	3505,
	3507,
	3508,
	3509,
	3510,
	3511,
	3512,
	3513,
	3514,
	3515,
	3517,
	3520,
	3521,
	3522,
	3523,
	3524,
	3525,
	3526,
	3585,
	3586,
	3587,
	3588,
	3589,
	3590,
	3591,
	3592,
	3593,
	3594,
	3595,
	3596,
	3597,
	3598,
	3599,
	3600,
	3601,
	3602,
	3603,
	3604,
	3605,
	3606,
	3607,
	3608,
	3609,
	3610,
	3611,
	3612,
	3613,
	3614,
	3615,
	3616,
	3617,
	3618,
	3619,
	3620,
	3621,
	3622,
	3623,
	3624,
	3625,
	3626,
	3627,
	3628,
	3629,
	3630,
	3631,
	3632,
	3634,
	3635,
	3648,
	3649,
	3650,
	3651,
	3652,
	3653,
	3654,
	3713,
	3714,
	3716,
	3719,
	3720,
	3722,
	3725,
	3732,
	3733,
	3734,
	3735,
	3737,
	3738,
	3739,
	3740,
	3741,
	3742,
	3743,
	3745,
	3746,
	3747,
	3749,
	3751,
	3754,
	3755,
	3757,
	3758,
	3759,
	3760,
	3762,
	3763,
	3773,
	3776,
	3777,
	3778,
	3779,
	3780,
	3782,
	3804,
	3805,
	3806,
	3807,
	3840,
	3904,
	3905,
	3906,
	3907,
	3908,
	3909,
	3910,
	3911,
	3913,
	3914,
	3915,
	3916,
	3917,
	3918,
	3919,
	3920,
	3921,
	3922,
	3923,
	3924,
	3925,
	3926,
	3927,
	3928,
	3929,
	3930,
	3931,
	3932,
	3933,
	3934,
	3935,
	3936,
	3937,
	3938,
	3939,
	3940,
	3941,
	3942,
	3943,
	3944,
	3945,
	3946,
	3947,
	3948,
	3976,
	3977,
	3978,
	3979,
	3980,
	4096,
	4097,
	4098,
	4099,
	4100,
	4101,
	4102,
	4103,
	4104,
	4105,
	4106,
	4107,
	4108,
	4109,
	4110,
	4111,
	4112,
	4113,
	4114,
	4115,
	4116,
	4117,
	4118,
	4119,
	4120,
	4121,
	4122,
	4123,
	4124,
	4125,
	4126,
	4127,
	4128,
	4129,
	4130,
	4131,
	4132,
	4133,
	4134,
	4135,
	4136,
	4137,
	4138,
	4159,
	4176,
	4177,
	4178,
	4179,
	4180,
	4181,
	4186,
	4187,
	4188,
	4189,
	4193,
	4197,
	4198,
	4206,
	4207,
	4208,
	4213,
	4214,
	4215,
	4216,
	4217,
	4218,
	4219,
	4220,
	4221,
	4222,
	4223,
	4224,
	4225,
	4238,
	4256,
	4257,
	4258,
	4259,
	4260,
	4261,
	4262,
	4263,
	4264,
	4265,
	4266,
	4267,
	4268,
	4269,
	4270,
	4271,
	4272,
	4273,
	4274,
	4275,
	4276,
	4277,
	4278,
	4279,
	4280,
	4281,
	4282,
	4283,
	4284,
	4285,
	4286,
	4287,
	4288,
	4289,
	4290,
	4291,
	4292,
	4293,
	4295,
	4301,
	4304,
	4305,
	4306,
	4307,
	4308,
	4309,
	4310,
	4311,
	4312,
	4313,
	4314,
	4315,
	4316,
	4317,
	4318,
	4319,
	4320,
	4321,
	4322,
	4323,
	4324,
	4325,
	4326,
	4327,
	4328,
	4329,
	4330,
	4331,
	4332,
	4333,
	4334,
	4335,
	4336,
	4337,
	4338,
	4339,
	4340,
	4341,
	4342,
	4343,
	4344,
	4345,
	4346,
	4348,
	4349,
	4350,
	4351,
	4352,
	4353,
	4354,
	4355,
	4356,
	4357,
	4358,
	4359,
	4360,
	4361,
	4362,
	4363,
	4364,
	4365,
	4366,
	4367,
	4368,
	4369,
	4370,
	4371,
	4372,
	4373,
	4374,
	4375,
	4376,
	4377,
	4378,
	4379,
	4380,
	4381,
	4382,
	4383,
	4384,
	4385,
	4386,
	4387,
	4388,
	4389,
	4390,
	4391,
	4392,
	4393,
	4394,
	4395,
	4396,
	4397,
	4398,
	4399,
	4400,
	4401,
	4402,
	4403,
	4404,
	4405,
	4406,
	4407,
	4408,
	4409,
	4410,
	4411,
	4412,
	4413,
	4414,
	4415,
	4416,
	4417,
	4418,
	4419,
	4420,
	4421,
	4422,
	4423,
	4424,
	4425,
	4426,
	4427,
	4428,
	4429,
	4430,
	4431,
	4432,
	4433,
	4434,
	4435,
	4436,
	4437,
	4438,
	4439,
	4440,
	4441,
	4442,
	4443,
	4444,
	4445,
	4446,
	4447,
	4448,
	4449,
	4450,
	4451,
	4452,
	4453,
	4454,
	4455,
	4456,
	4457,
	4458,
	4459,
	4460,
	4461,
	4462,
	4463,
	4464,
	4465,
	4466,
	4467,
	4468,
	4469,
	4470,
	4471,
	4472,
	4473,
	4474,
	4475,
	4476,
	4477,
	4478,
	4479,
	4480,
	4481,
	4482,
	4483,
	4484,
	4485,
	4486,
	4487,
	4488,
	4489,
	4490,
	4491,
	4492,
	4493,
	4494,
	4495,
	4496,
	4497,
	4498,
	4499,
	4500,
	4501,
	4502,
	4503,
	4504,
	4505,
	4506,
	4507,
	4508,
	4509,
	4510,
	4511,
	4512,
	4513,
	4514,
	4515,
	4516,
	4517,
	4518,
	4519,
	4520,
	4521,
	4522,
	4523,
	4524,
	4525,
	4526,
	4527,
	4528,
	4529,
	4530,
	4531,
	4532,
	4533,
	4534,
	4535,
	4536,
	4537,
	4538,
	4539,
	4540,
	4541,
	4542,
	4543,
	4544,
	4545,
	4546,
	4547,
	4548,
	4549,
	4550,
	4551,
	4552,
	4553,
	4554,
	4555,
	4556,
	4557,
	4558,
	4559,
	4560,
	4561,
	4562,
	4563,
	4564,
	4565,
	4566,
	4567,
	4568,
	4569,
	4570,
	4571,
	4572,
	4573,
	4574,
	4575,
	4576,
	4577,
	4578,
	4579,
	4580,
	4581,
	4582,
	4583,
	4584,
	4585,
	4586,
	4587,
	4588,
	4589,
	4590,
	4591,
	4592,
	4593,
	4594,
	4595,
	4596,
	4597,
	4598,
	4599,
	4600,
	4601,
	4602,
	4603,
	4604,
	4605,
	4606,
	4607,
	4608,
	4609,
	4610,
	4611,
	4612,
	4613,
	4614,
	4615,
	4616,
	4617,
	4618,
	4619,
	4620,
	4621,
	4622,
	4623,
	4624,
	4625,
	4626,
	4627,
	4628,
	4629,
	4630,
	4631,
	4632,
	4633,
	4634,
	4635,
	4636,
	4637,
	4638,
	4639,
	4640,
	4641,
	4642,
	4643,
	4644,
	4645,
	4646,
	4647,
	4648,
	4649,
	4650,
	4651,
	4652,
	4653,
	4654,
	4655,
	4656,
	4657,
	4658,
	4659,
	4660,
	4661,
	4662,
	4663,
	4664,
	4665,
	4666,
	4667,
	4668,
	4669,
	4670,
	4671,
	4672,
	4673,
	4674,
	4675,
	4676,
	4677,
	4678,
	4679,
	4680,
	4682,
	4683,
	4684,
	4685,
	4688,
	4689,
	4690,
	4691,
	4692,
	4693,
	4694,
	4696,
	4698,
	4699,
	4700,
	4701,
	4704,
	4705,
	4706,
	4707,
	4708,
	4709,
	4710,
	4711,
	4712,
	4713,
	4714,
	4715,
	4716,
	4717,
	4718,
	4719,
	4720,
	4721,
	4722,
	4723,
	4724,
	4725,
	4726,
	4727,
	4728,
	4729,
	4730,
	4731,
	4732,
	4733,
	4734,
	4735,
	4736,
	4737,
	4738,
	4739,
	4740,
	4741,
	4742,
	4743,
	4744,
	4746,
	4747,
	4748,
	4749,
	4752,
	4753,
	4754,
	4755,
	4756,
	4757,
	4758,
	4759,
	4760,
	4761,
	4762,
	4763,
	4764,
	4765,
	4766,
	4767,
	4768,
	4769,
	4770,
	4771,
	4772,
	4773,
	4774,
	4775,
	4776,
	4777,
	4778,
	4779,
	4780,
	4781,
	4782,
	4783,
	4784,
	4786,
	4787,
	4788,
	4789,
	4792,
	4793,
	4794,
	4795,
	4796,
	4797,
	4798,
	4800,
	4802,
	4803,
	4804,
	4805,
	4808,
	4809,
	4810,
	4811,
	4812,
	4813,
	4814,
	4815,
	4816,
	4817,
	4818,
	4819,
	4820,
	4821,
	4822,
	4824,
	4825,
	4826,
	4827,
	4828,
	4829,
	4830,
	4831,
	4832,
	4833,
	4834,
	4835,
	4836,
	4837,
	4838,
	4839,
	4840,
	4841,
	4842,
	4843,
	4844,
	4845,
	4846,
	4847,
	4848,
	4849,
	4850,
	4851,
	4852,
	4853,
	4854,
	4855,
	4856,
	4857,
	4858,
	4859,
	4860,
	4861,
	4862,
	4863,
	4864,
	4865,
	4866,
	4867,
	4868,
	4869,
	4870,
	4871,
	4872,
	4873,
	4874,
	4875,
	4876,
	4877,
	4878,
	4879,
	4880,
	4882,
	4883,
	4884,
	4885,
	4888,
	4889,
	4890,
	4891,
	4892,
	4893,
	4894,
	4895,
	4896,
	4897,
	4898,
	4899,
	4900,
	4901,
	4902,
	4903,
	4904,
	4905,
	4906,
	4907,
	4908,
	4909,
	4910,
	4911,
	4912,
	4913,
	4914,
	4915,
	4916,
	4917,
	4918,
	4919,
	4920,
	4921,
	4922,
	4923,
	4924,
	4925,
	4926,
	4927,
	4928,
	4929,
	4930,
	4931,
	4932,
	4933,
	4934,
	4935,
	4936,
	4937,
	4938,
	4939,
	4940,
	4941,
	4942,
	4943,
	4944,
	4945,
	4946,
	4947,
	4948,
	4949,
	4950,
	4951,
	4952,
	4953,
	4954,
	4992,
	4993,
	4994,
	4995,
	4996,
	4997,
	4998,
	4999,
	5000,
	5001,
	5002,
	5003,
	5004,
	5005,
	5006,
	5007,
	5024,
	5025,
	5026,
	5027,
	5028,
	5029,
	5030,
	5031,
	5032,
	5033,
	5034,
	5035,
	5036,
	5037,
	5038,
	5039,
	5040,
	5041,
	5042,
	5043,
	5044,
	5045,
	5046,
	5047,
	5048,
	5049,
	5050,
	5051,
	5052,
	5053,
	5054,
	5055,
	5056,
	5057,
	5058,
	5059,
	5060,
	5061,
	5062,
	5063,
	5064,
	5065,
	5066,
	5067,
	5068,
	5069,
	5070,
	5071,
	5072,
	5073,
	5074,
	5075,
	5076,
	5077,
	5078,
	5079,
	5080,
	5081,
	5082,
	5083,
	5084,
	5085,
	5086,
	5087,
	5088,
	5089,
	5090,
	5091,
	5092,
	5093,
	5094,
	5095,
	5096,
	5097,
	5098,
	5099,
	5100,
	5101,
	5102,
	5103,
	5104,
	5105,
	5106,
	5107,
	5108,
	5121,
	5122,
	5123,
	5124,
	5125,
	5126,
	5127,
	5128,
	5129,
	5130,
	5131,
	5132,
	5133,
	5134,
	5135,
	5136,
	5137,
	5138,
	5139,
	5140,
	5141,
	5142,
	5143,
	5144,
	5145,
	5146,
	5147,
	5148,
	5149,
	5150,
	5151,
	5152,
	5153,
	5154,
	5155,
	5156,
	5157,
	5158,
	5159,
	5160,
	5161,
	5162,
	5163,
	5164,
	5165,
	5166,
	5167,
	5168,
	5169,
	5170,
	5171,
	5172,
	5173,
	5174,
	5175,
	5176,
	5177,
	5178,
	5179,
	5180,
	5181,
	5182,
	5183,
	5184,
	5185,
	5186,
	5187,
	5188,
	5189,
	5190,
	5191,
	5192,
	5193,
	5194,
	5195,
	5196,
	5197,
	5198,
	5199,
	5200,
	5201,
	5202,
	5203,
	5204,
	5205,
	5206,
	5207,
	5208,
	5209,
	5210,
	5211,
	5212,
	5213,
	5214,
	5215,
	5216,
	5217,
	5218,
	5219,
	5220,
	5221,
	5222,
	5223,
	5224,
	5225,
	5226,
	5227,
	5228,
	5229,
	5230,
	5231,
	5232,
	5233,
	5234,
	5235,
	5236,
	5237,
	5238,
	5239,
	5240,
	5241,
	5242,
	5243,
	5244,
	5245,
	5246,
	5247,
	5248,
	5249,
	5250,
	5251,
	5252,
	5253,
	5254,
	5255,
	5256,
	5257,
	5258,
	5259,
	5260,
	5261,
	5262,
	5263,
	5264,
	5265,
	5266,
	5267,
	5268,
	5269,
	5270,
	5271,
	5272,
	5273,
	5274,
	5275,
	5276,
	5277,
	5278,
	5279,
	5280,
	5281,
	5282,
	5283,
	5284,
	5285,
	5286,
	5287,
	5288,
	5289,
	5290,
	5291,
	5292,
	5293,
	5294,
	5295,
	5296,
	5297,
	5298,
	5299,
	5300,
	5301,
	5302,
	5303,
	5304,
	5305,
	5306,
	5307,
	5308,
	5309,
	5310,
	5311,
	5312,
	5313,
	5314,
	5315,
	5316,
	5317,
	5318,
	5319,
	5320,
	5321,
	5322,
	5323,
	5324,
	5325,
	5326,
	5327,
	5328,
	5329,
	5330,
	5331,
	5332,
	5333,
	5334,
	5335,
	5336,
	5337,
	5338,
	5339,
	5340,
	5341,
	5342,
	5343,
	5344,
	5345,
	5346,
	5347,
	5348,
	5349,
	5350,
	5351,
	5352,
	5353,
	5354,
	5355,
	5356,
	5357,
	5358,
	5359,
	5360,
	5361,
	5362,
	5363,
	5364,
	5365,
	5366,
	5367,
	5368,
	5369,
	5370,
	5371,
	5372,
	5373,
	5374,
	5375,
	5376,
	5377,
	5378,
	5379,
	5380,
	5381,
	5382,
	5383,
	5384,
	5385,
	5386,
	5387,
	5388,
	5389,
	5390,
	5391,
	5392,
	5393,
	5394,
	5395,
	5396,
	5397,
	5398,
	5399,
	5400,
	5401,
	5402,
	5403,
	5404,
	5405,
	5406,
	5407,
	5408,
	5409,
	5410,
	5411,
	5412,
	5413,
	5414,
	5415,
	5416,
	5417,
	5418,
	5419,
	5420,
	5421,
	5422,
	5423,
	5424,
	5425,
	5426,
	5427,
	5428,
	5429,
	5430,
	5431,
	5432,
	5433,
	5434,
	5435,
	5436,
	5437,
	5438,
	5439,
	5440,
	5441,
	5442,
	5443,
	5444,
	5445,
	5446,
	5447,
	5448,
	5449,
	5450,
	5451,
	5452,
	5453,
	5454,
	5455,
	5456,
	5457,
	5458,
	5459,
	5460,
	5461,
	5462,
	5463,
	5464,
	5465,
	5466,
	5467,
	5468,
	5469,
	5470,
	5471,
	5472,
	5473,
	5474,
	5475,
	5476,
	5477,
	5478,
	5479,
	5480,
	5481,
	5482,
	5483,
	5484,
	5485,
	5486,
	5487,
	5488,
	5489,
	5490,
	5491,
	5492,
	5493,
	5494,
	5495,
	5496,
	5497,
	5498,
	5499,
	5500,
	5501,
	5502,
	5503,
	5504,
	5505,
	5506,
	5507,
	5508,
	5509,
	5510,
	5511,
	5512,
	5513,
	5514,
	5515,
	5516,
	5517,
	5518,
	5519,
	5520,
	5521,
	5522,
	5523,
	5524,
	5525,
	5526,
	5527,
	5528,
	5529,
	5530,
	5531,
	5532,
	5533,
	5534,
	5535,
	5536,
	5537,
	5538,
	5539,
	5540,
	5541,
	5542,
	5543,
	5544,
	5545,
	5546,
	5547,
	5548,
	5549,
	5550,
	5551,
	5552,
	5553,
	5554,
	5555,
	5556,
	5557,
	5558,
	5559,
	5560,
	5561,
	5562,
	5563,
	5564,
	5565,
	5566,
	5567,
	5568,
	5569,
	5570,
	5571,
	5572,
	5573,
	5574,
	5575,
	5576,
	5577,
	5578,
	5579,
	5580,
	5581,
	5582,
	5583,
	5584,
	5585,
	5586,
	5587,
	5588,
	5589,
	5590,
	5591,
	5592,
	5593,
	5594,
	5595,
	5596,
	5597,
	5598,
	5599,
	5600,
	5601,
	5602,
	5603,
	5604,
	5605,
	5606,
	5607,
	5608,
	5609,
	5610,
	5611,
	5612,
	5613,
	5614,
	5615,
	5616,
	5617,
	5618,
	5619,
	5620,
	5621,
	5622,
	5623,
	5624,
	5625,
	5626,
	5627,
	5628,
	5629,
	5630,
	5631,
	5632,
	5633,
	5634,
	5635,
	5636,
	5637,
	5638,
	5639,
	5640,
	5641,
	5642,
	5643,
	5644,
	5645,
	5646,
	5647,
	5648,
	5649,
	5650,
	5651,
	5652,
	5653,
	5654,
	5655,
	5656,
	5657,
	5658,
	5659,
	5660,
	5661,
	5662,
	5663,
	5664,
	5665,
	5666,
	5667,
	5668,
	5669,
	5670,
	5671,
	5672,
	5673,
	5674,
	5675,
	5676,
	5677,
	5678,
	5679,
	5680,
	5681,
	5682,
	5683,
	5684,
	5685,
	5686,
	5687,
	5688,
	5689,
	5690,
	5691,
	5692,
	5693,
	5694,
	5695,
	5696,
	5697,
	5698,
	5699,
	5700,
	5701,
	5702,
	5703,
	5704,
	5705,
	5706,
	5707,
	5708,
	5709,
	5710,
	5711,
	5712,
	5713,
	5714,
	5715,
	5716,
	5717,
	5718,
	5719,
	5720,
	5721,
	5722,
	5723,
	5724,
	5725,
	5726,
	5727,
	5728,
	5729,
	5730,
	5731,
	5732,
	5733,
	5734,
	5735,
	5736,
	5737,
	5738,
	5739,
	5740,
	5743,
	5744,
	5745,
	5746,
	5747,
	5748,
	5749,
	5750,
	5751,
	5752,
	5753,
	5754,
	5755,
	5756,
	5757,
	5758,
	5759,
	5761,
	5762,
	5763,
	5764,
	5765,
	5766,
	5767,
	5768,
	5769,
	5770,
	5771,
	5772,
	5773,
	5774,
	5775,
	5776,
	5777,
	5778,
	5779,
	5780,
	5781,
	5782,
	5783,
	5784,
	5785,
	5786,
	5792,
	5793,
	5794,
	5795,
	5796,
	5797,
	5798,
	5799,
	5800,
	5801,
	5802,
	5803,
	5804,
	5805,
	5806,
	5807,
	5808,
	5809,
	5810,
	5811,
	5812,
	5813,
	5814,
	5815,
	5816,
	5817,
	5818,
	5819,
	5820,
	5821,
	5822,
	5823,
	5824,
	5825,
	5826,
	5827,
	5828,
	5829,
	5830,
	5831,
	5832,
	5833,
	5834,
	5835,
	5836,
	5837,
	5838,
	5839,
	5840,
	5841,
	5842,
	5843,
	5844,
	5845,
	5846,
	5847,
	5848,
	5849,
	5850,
	5851,
	5852,
	5853,
	5854,
	5855,
	5856,
	5857,
	5858,
	5859,
	5860,
	5861,
	5862,
	5863,
	5864,
	5865,
	5866,
	5870,
	5871,
	5872,
	5888,
	5889,
	5890,
	5891,
	5892,
	5893,
	5894,
	5895,
	5896,
	5897,
	5898,
	5899,
	5900,
	5902,
	5903,
	5904,
	5905,
	5920,
	5921,
	5922,
	5923,
	5924,
	5925,
	5926,
	5927,
	5928,
	5929,
	5930,
	5931,
	5932,
	5933,
	5934,
	5935,
	5936,
	5937,
	5952,
	5953,
	5954,
	5955,
	5956,
	5957,
	5958,
	5959,
	5960,
	5961,
	5962,
	5963,
	5964,
	5965,
	5966,
	5967,
	5968,
	5969,
	5984,
	5985,
	5986,
	5987,
	5988,
	5989,
	5990,
	5991,
	5992,
	5993,
	5994,
	5995,
	5996,
	5998,
	5999,
	6000,
	6016,
	6017,
	6018,
	6019,
	6020,
	6021,
	6022,
	6023,
	6024,
	6025,
	6026,
	6027,
	6028,
	6029,
	6030,
	6031,
	6032,
	6033,
	6034,
	6035,
	6036,
	6037,
	6038,
	6039,
	6040,
	6041,
	6042,
	6043,
	6044,
	6045,
	6046,
	6047,
	6048,
	6049,
	6050,
	6051,
	6052,
	6053,
	6054,
	6055,
	6056,
	6057,
	6058,
	6059,
	6060,
	6061,
	6062,
	6063,
	6064,
	6065,
	6066,
	6067,
	6103,
	6108,
	6176,
	6177,
	6178,
	6179,
	6180,
	6181,
	6182,
	6183,
	6184,
	6185,
	6186,
	6187,
	6188,
	6189,
	6190,
	6191,
	6192,
	6193,
	6194,
	6195,
	6196,
	6197,
	6198,
	6199,
	6200,
	6201,
	6202,
	6203,
	6204,
	6205,
	6206,
	6207,
	6208,
	6209,
	6210,
	6211,
	6212,
	6213,
	6214,
	6215,
	6216,
	6217,
	6218,
	6219,
	6220,
	6221,
	6222,
	6223,
	6224,
	6225,
	6226,
	6227,
	6228,
	6229,
	6230,
	6231,
	6232,
	6233,
	6234,
	6235,
	6236,
	6237,
	6238,
	6239,
	6240,
	6241,
	6242,
	6243,
	6244,
	6245,
	6246,
	6247,
	6248,
	6249,
	6250,
	6251,
	6252,
	6253,
	6254,
	6255,
	6256,
	6257,
	6258,
	6259,
	6260,
	6261,
	6262,
	6263,
	6272,
	6273,
	6274,
	6275,
	6276,
	6277,
	6278,
	6279,
	6280,
	6281,
	6282,
	6283,
	6284,
	6285,
	6286,
	6287,
	6288,
	6289,
	6290,
	6291,
	6292,
	6293,
	6294,
	6295,
	6296,
	6297,
	6298,
	6299,
	6300,
	6301,
	6302,
	6303,
	6304,
	6305,
	6306,
	6307,
	6308,
	6309,
	6310,
	6311,
	6312,
	6314,
	6320,
	6321,
	6322,
	6323,
	6324,
	6325,
	6326,
	6327,
	6328,
	6329,
	6330,
	6331,
	6332,
	6333,
	6334,
	6335,
	6336,
	6337,
	6338,
	6339,
	6340,
	6341,
	6342,
	6343,
	6344,
	6345,
	6346,
	6347,
	6348,
	6349,
	6350,
	6351,
	6352,
	6353,
	6354,
	6355,
	6356,
	6357,
	6358,
	6359,
	6360,
	6361,
	6362,
	6363,
	6364,
	6365,
	6366,
	6367,
	6368,
	6369,
	6370,
	6371,
	6372,
	6373,
	6374,
	6375,
	6376,
	6377,
	6378,
	6379,
	6380,
	6381,
	6382,
	6383,
	6384,
	6385,
	6386,
	6387,
	6388,
	6389,
	6400,
	6401,
	6402,
	6403,
	6404,
	6405,
	6406,
	6407,
	6408,
	6409,
	6410,
	6411,
	6412,
	6413,
	6414,
	6415,
	6416,
	6417,
	6418,
	6419,
	6420,
	6421,
	6422,
	6423,
	6424,
	6425,
	6426,
	6427,
	6428,
	6480,
	6481,
	6482,
	6483,
	6484,
	6485,
	6486,
	6487,
	6488,
	6489,
	6490,
	6491,
	6492,
	6493,
	6494,
	6495,
	6496,
	6497,
	6498,
	6499,
	6500,
	6501,
	6502,
	6503,
	6504,
	6505,
	6506,
	6507,
	6508,
	6509,
	6512,
	6513,
	6514,
	6515,
	6516,
	6528,
	6529,
	6530,
	6531,
	6532,
	6533,
	6534,
	6535,
	6536,
	6537,
	6538,
	6539,
	6540,
	6541,
	6542,
	6543,
	6544,
	6545,
	6546,
	6547,
	6548,
	6549,
	6550,
	6551,
	6552,
	6553,
	6554,
	6555,
	6556,
	6557,
	6558,
	6559,
	6560,
	6561,
	6562,
	6563,
	6564,
	6565,
	6566,
	6567,
	6568,
	6569,
	6570,
	6571,
	6593,
	6594,
	6595,
	6596,
	6597,
	6598,
	6599,
	6656,
	6657,
	6658,
	6659,
	6660,
	6661,
	6662,
	6663,
	6664,
	6665,
	6666,
	6667,
	6668,
	6669,
	6670,
	6671,
	6672,
	6673,
	6674,
	6675,
	6676,
	6677,
	6678,
	6688,
	6689,
	6690,
	6691,
	6692,
	6693,
	6694,
	6695,
	6696,
	6697,
	6698,
	6699,
	6700,
	6701,
	6702,
	6703,
	6704,
	6705,
	6706,
	6707,
	6708,
	6709,
	6710,
	6711,
	6712,
	6713,
	6714,
	6715,
	6716,
	6717,
	6718,
	6719,
	6720,
	6721,
	6722,
	6723,
	6724,
	6725,
	6726,
	6727,
	6728,
	6729,
	6730,
	6731,
	6732,
	6733,
	6734,
	6735,
	6736,
	6737,
	6738,
	6739,
	6740,
	6823,
	6917,
	6918,
	6919,
	6920,
	6921,
	6922,
	6923,
	6924,
	6925,
	6926,
	6927,
	6928,
	6929,
	6930,
	6931,
	6932,
	6933,
	6934,
	6935,
	6936,
	6937,
	6938,
	6939,
	6940,
	6941,
	6942,
	6943,
	6944,
	6945,
	6946,
	6947,
	6948,
	6949,
	6950,
	6951,
	6952,
	6953,
	6954,
	6955,
	6956,
	6957,
	6958,
	6959,
	6960,
	6961,
	6962,
	6963,
	6981,
	6982,
	6983,
	6984,
	6985,
	6986,
	6987,
	7043,
	7044,
	7045,
	7046,
	7047,
	7048,
	7049,
	7050,
	7051,
	7052,
	7053,
	7054,
	7055,
	7056,
	7057,
	7058,
	7059,
	7060,
	7061,
	7062,
	7063,
	7064,
	7065,
	7066,
	7067,
	7068,
	7069,
	7070,
	7071,
	7072,
	7086,
	7087,
	7098,
	7099,
	7100,
	7101,
	7102,
	7103,
	7104,
	7105,
	7106,
	7107,
	7108,
	7109,
	7110,
	7111,
	7112,
	7113,
	7114,
	7115,
	7116,
	7117,
	7118,
	7119,
	7120,
	7121,
	7122,
	7123,
	7124,
	7125,
	7126,
	7127,
	7128,
	7129,
	7130,
	7131,
	7132,
	7133,
	7134,
	7135,
	7136,
	7137,
	7138,
	7139,
	7140,
	7141,
	7168,
	7169,
	7170,
	7171,
	7172,
	7173,
	7174,
	7175,
	7176,
	7177,
	7178,
	7179,
	7180,
	7181,
	7182,
	7183,
	7184,
	7185,
	7186,
	7187,
	7188,
	7189,
	7190,
	7191,
	7192,
	7193,
	7194,
	7195,
	7196,
	7197,
	7198,
	7199,
	7200,
	7201,
	7202,
	7203,
	7245,
	7246,
	7247,
	7258,
	7259,
	7260,
	7261,
	7262,
	7263,
	7264,
	7265,
	7266,
	7267,
	7268,
	7269,
	7270,
	7271,
	7272,
	7273,
	7274,
	7275,
	7276,
	7277,
	7278,
	7279,
	7280,
	7281,
	7282,
	7283,
	7284,
	7285,
	7286,
	7287,
	7288,
	7289,
	7290,
	7291,
	7292,
	7293,
	7401,
	7402,
	7403,
	7404,
	7406,
	7407,
	7408,
	7409,
	7413,
	7414,
	7424,
	7425,
	7426,
	7427,
	7428,
	7429,
	7430,
	7431,
	7432,
	7433,
	7434,
	7435,
	7436,
	7437,
	7438,
	7439,
	7440,
	7441,
	7442,
	7443,
	7444,
	7445,
	7446,
	7447,
	7448,
	7449,
	7450,
	7451,
	7452,
	7453,
	7454,
	7455,
	7456,
	7457,
	7458,
	7459,
	7460,
	7461,
	7462,
	7463,
	7464,
	7465,
	7466,
	7467,
	7468,
	7469,
	7470,
	7471,
	7472,
	7473,
	7474,
	7475,
	7476,
	7477,
	7478,
	7479,
	7480,
	7481,
	7482,
	7483,
	7484,
	7485,
	7486,
	7487,
	7488,
	7489,
	7490,
	7491,
	7492,
	7493,
	7494,
	7495,
	7496,
	7497,
	7498,
	7499,
	7500,
	7501,
	7502,
	7503,
	7504,
	7505,
	7506,
	7507,
	7508,
	7509,
	7510,
	7511,
	7512,
	7513,
	7514,
	7515,
	7516,
	7517,
	7518,
	7519,
	7520,
	7521,
	7522,
	7523,
	7524,
	7525,
	7526,
	7527,
	7528,
	7529,
	7530,
	7531,
	7532,
	7533,
	7534,
	7535,
	7536,
	7537,
	7538,
	7539,
	7540,
	7541,
	7542,
	7543,
	7544,
	7545,
	7546,
	7547,
	7548,
	7549,
	7550,
	7551,
	7552,
	7553,
	7554,
	7555,
	7556,
	7557,
	7558,
	7559,
	7560,
	7561,
	7562,
	7563,
	7564,
	7565,
	7566,
	7567,
	7568,
	7569,
	7570,
	7571,
	7572,
	7573,
	7574,
	7575,
	7576,
	7577,
	7578,
	7579,
	7580,
	7581,
	7582,
	7583,
	7584,
	7585,
	7586,
	7587,
	7588,
	7589,
	7590,
	7591,
	7592,
	7593,
	7594,
	7595,
	7596,
	7597,
	7598,
	7599,
	7600,
	7601,
	7602,
	7603,
	7604,
	7605,
	7606,
	7607,
	7608,
	7609,
	7610,
	7611,
	7612,
	7613,
	7614,
	7615,
	7680,
	7681,
	7682,
	7683,
	7684,
	7685,
	7686,
	7687,
	7688,
	7689,
	7690,
	7691,
	7692,
	7693,
	7694,
	7695,
	7696,
	7697,
	7698,
	7699,
	7700,
	7701,
	7702,
	7703,
	7704,
	7705,
	7706,
	7707,
	7708,
	7709,
	7710,
	7711,
	7712,
	7713,
	7714,
	7715,
	7716,
	7717,
	7718,
	7719,
	7720,
	7721,
	7722,
	7723,
	7724,
	7725,
	7726,
	7727,
	7728,
	7729,
	7730,
	7731,
	7732,
	7733,
	7734,
	7735,
	7736,
	7737,
	7738,
	7739,
	7740,
	7741,
	7742,
	7743,
	7744,
	7745,
	7746,
	7747,
	7748,
	7749,
	7750,
	7751,
	7752,
	7753,
	7754,
	7755,
	7756,
	7757,
	7758,
	7759,
	7760,
	7761,
	7762,
	7763,
	7764,
	7765,
	7766,
	7767,
	7768,
	7769,
	7770,
	7771,
	7772,
	7773,
	7774,
	7775,
	7776,
	7777,
	7778,
	7779,
	7780,
	7781,
	7782,
	7783,
	7784,
	7785,
	7786,
	7787,
	7788,
	7789,
	7790,
	7791,
	7792,
	7793,
	7794,
	7795,
	7796,
	7797,
	7798,
	7799,
	7800,
	7801,
	7802,
	7803,
	7804,
	7805,
	7806,
	7807,
	7808,
	7809,
	7810,
	7811,
	7812,
	7813,
	7814,
	7815,
	7816,
	7817,
	7818,
	7819,
	7820,
	7821,
	7822,
	7823,
	7824,
	7825,
	7826,
	7827,
	7828,
	7829,
	7830,
	7831,
	7832,
	7833,
	7834,
	7835,
	7836,
	7837,
	7838,
	7839,
	7840,
	7841,
	7842,
	7843,
	7844,
	7845,
	7846,
	7847,
	7848,
	7849,
	7850,
	7851,
	7852,
	7853,
	7854,
	7855,
	7856,
	7857,
	7858,
	7859,
	7860,
	7861,
	7862,
	7863,
	7864,
	7865,
	7866,
	7867,
	7868,
	7869,
	7870,
	7871,
	7872,
	7873,
	7874,
	7875,
	7876,
	7877,
	7878,
	7879,
	7880,
	7881,
	7882,
	7883,
	7884,
	7885,
	7886,
	7887,
	7888,
	7889,
	7890,
	7891,
	7892,
	7893,
	7894,
	7895,
	7896,
	7897,
	7898,
	7899,
	7900,
	7901,
	7902,
	7903,
	7904,
	7905,
	7906,
	7907,
	7908,
	7909,
	7910,
	7911,
	7912,
	7913,
	7914,
	7915,
	7916,
	7917,
	7918,
	7919,
	7920,
	7921,
	7922,
	7923,
	7924,
	7925,
	7926,
	7927,
	7928,
	7929,
	7930,
	7931,
	7932,
	7933,
	7934,
	7935,
	7936,
	7937,
	7938,
	7939,
	7940,
	7941,
	7942,
	7943,
	7944,
	7945,
	7946,
	7947,
	7948,
	7949,
	7950,
	7951,
	7952,
	7953,
	7954,
	7955,
	7956,
	7957,
	7960,
	7961,
	7962,
	7963,
	7964,
	7965,
	7968,
	7969,
	7970,
	7971,
	7972,
	7973,
	7974,
	7975,
	7976,
	7977,
	7978,
	7979,
	7980,
	7981,
	7982,
	7983,
	7984,
	7985,
	7986,
	7987,
	7988,
	7989,
	7990,
	7991,
	7992,
	7993,
	7994,
	7995,
	7996,
	7997,
	7998,
	7999,
	8000,
	8001,
	8002,
	8003,
	8004,
	8005,
	8008,
	8009,
	8010,
	8011,
	8012,
	8013,
	8016,
	8017,
	8018,
	8019,
	8020,
	8021,
	8022,
	8023,
	8025,
	8027,
	8029,
	8031,
	8032,
	8033,
	8034,
	8035,
	8036,
	8037,
	8038,
	8039,
	8040,
	8041,
	8042,
	8043,
	8044,
	8045,
	8046,
	8047,
	8048,
	8049,
	8050,
	8051,
	8052,
	8053,
	8054,
	8055,
	8056,
	8057,
	8058,
	8059,
	8060,
	8061,
	8064,
	8065,
	8066,
	8067,
	8068,
	8069,
	8070,
	8071,
	8072,
	8073,
	8074,
	8075,
	8076,
	8077,
	8078,
	8079,
	8080,
	8081,
	8082,
	8083,
	8084,
	8085,
	8086,
	8087,
	8088,
	8089,
	8090,
	8091,
	8092,
	8093,
	8094,
	8095,
	8096,
	8097,
	8098,
	8099,
	8100,
	8101,
	8102,
	8103,
	8104,
	8105,
	8106,
	8107,
	8108,
	8109,
	8110,
	8111,
	8112,
	8113,
	8114,
	8115,
	8116,
	8118,
	8119,
	8120,
	8121,
	8122,
	8123,
	8124,
	8126,
	8130,
	8131,
	8132,
	8134,
	8135,
	8136,
	8137,
	8138,
	8139,
	8140,
	8144,
	8145,
	8146,
	8147,
	8150,
	8151,
	8152,
	8153,
	8154,
	8155,
	8160,
	8161,
	8162,
	8163,
	8164,
	8165,
	8166,
	8167,
	8168,
	8169,
	8170,
	8171,
	8172,
	8178,
	8179,
	8180,
	8182,
	8183,
	8184,
	8185,
	8186,
	8187,
	8188,
	8305,
	8319,
	8336,
	8337,
	8338,
	8339,
	8340,
	8341,
	8342,
	8343,
	8344,
	8345,
	8346,
	8347,
	8348,
	8450,
	8455,
	8458,
	8459,
	8460,
	8461,
	8462,
	8463,
	8464,
	8465,
	8466,
	8467,
	8469,
	8473,
	8474,
	8475,
	8476,
	8477,
	8484,
	8486,
	8488,
	8490,
	8491,
	8492,
	8493,
	8495,
	8496,
	8497,
	8498,
	8499,
	8500,
	8501,
	8502,
	8503,
	8504,
	8505,
	8508,
	8509,
	8510,
	8511,
	8517,
	8518,
	8519,
	8520,
	8521,
	8526,
	8544,
	8545,
	8546,
	8547,
	8548,
	8549,
	8550,
	8551,
	8552,
	8553,
	8554,
	8555,
	8556,
	8557,
	8558,
	8559,
	8560,
	8561,
	8562,
	8563,
	8564,
	8565,
	8566,
	8567,
	8568,
	8569,
	8570,
	8571,
	8572,
	8573,
	8574,
	8575,
	8576,
	8577,
	8578,
	8579,
	8580,
	8581,
	8582,
	8583,
	8584,
	11264,
	11265,
	11266,
	11267,
	11268,
	11269,
	11270,
	11271,
	11272,
	11273,
	11274,
	11275,
	11276,
	11277,
	11278,
	11279,
	11280,
	11281,
	11282,
	11283,
	11284,
	11285,
	11286,
	11287,
	11288,
	11289,
	11290,
	11291,
	11292,
	11293,
	11294,
	11295,
	11296,
	11297,
	11298,
	11299,
	11300,
	11301,
	11302,
	11303,
	11304,
	11305,
	11306,
	11307,
	11308,
	11309,
	11310,
	11312,
	11313,
	11314,
	11315,
	11316,
	11317,
	11318,
	11319,
	11320,
	11321,
	11322,
	11323,
	11324,
	11325,
	11326,
	11327,
	11328,
	11329,
	11330,
	11331,
	11332,
	11333,
	11334,
	11335,
	11336,
	11337,
	11338,
	11339,
	11340,
	11341,
	11342,
	11343,
	11344,
	11345,
	11346,
	11347,
	11348,
	11349,
	11350,
	11351,
	11352,
	11353,
	11354,
	11355,
	11356,
	11357,
	11358,
	11360,
	11361,
	11362,
	11363,
	11364,
	11365,
	11366,
	11367,
	11368,
	11369,
	11370,
	11371,
	11372,
	11373,
	11374,
	11375,
	11376,
	11377,
	11378,
	11379,
	11380,
	11381,
	11382,
	11383,
	11384,
	11385,
	11386,
	11387,
	11388,
	11389,
	11390,
	11391,
	11392,
	11393,
	11394,
	11395,
	11396,
	11397,
	11398,
	11399,
	11400,
	11401,
	11402,
	11403,
	11404,
	11405,
	11406,
	11407,
	11408,
	11409,
	11410,
	11411,
	11412,
	11413,
	11414,
	11415,
	11416,
	11417,
	11418,
	11419,
	11420,
	11421,
	11422,
	11423,
	11424,
	11425,
	11426,
	11427,
	11428,
	11429,
	11430,
	11431,
	11432,
	11433,
	11434,
	11435,
	11436,
	11437,
	11438,
	11439,
	11440,
	11441,
	11442,
	11443,
	11444,
	11445,
	11446,
	11447,
	11448,
	11449,
	11450,
	11451,
	11452,
	11453,
	11454,
	11455,
	11456,
	11457,
	11458,
	11459,
	11460,
	11461,
	11462,
	11463,
	11464,
	11465,
	11466,
	11467,
	11468,
	11469,
	11470,
	11471,
	11472,
	11473,
	11474,
	11475,
	11476,
	11477,
	11478,
	11479,
	11480,
	11481,
	11482,
	11483,
	11484,
	11485,
	11486,
	11487,
	11488,
	11489,
	11490,
	11491,
	11492,
	11499,
	11500,
	11501,
	11502,
	11506,
	11507,
	11520,
	11521,
	11522,
	11523,
	11524,
	11525,
	11526,
	11527,
	11528,
	11529,
	11530,
	11531,
	11532,
	11533,
	11534,
	11535,
	11536,
	11537,
	11538,
	11539,
	11540,
	11541,
	11542,
	11543,
	11544,
	11545,
	11546,
	11547,
	11548,
	11549,
	11550,
	11551,
	11552,
	11553,
	11554,
	11555,
	11556,
	11557,
	11559,
	11565,
	11568,
	11569,
	11570,
	11571,
	11572,
	11573,
	11574,
	11575,
	11576,
	11577,
	11578,
	11579,
	11580,
	11581,
	11582,
	11583,
	11584,
	11585,
	11586,
	11587,
	11588,
	11589,
	11590,
	11591,
	11592,
	11593,
	11594,
	11595,
	11596,
	11597,
	11598,
	11599,
	11600,
	11601,
	11602,
	11603,
	11604,
	11605,
	11606,
	11607,
	11608,
	11609,
	11610,
	11611,
	11612,
	11613,
	11614,
	11615,
	11616,
	11617,
	11618,
	11619,
	11620,
	11621,
	11622,
	11623,
	11631,
	11648,
	11649,
	11650,
	11651,
	11652,
	11653,
	11654,
	11655,
	11656,
	11657,
	11658,
	11659,
	11660,
	11661,
	11662,
	11663,
	11664,
	11665,
	11666,
	11667,
	11668,
	11669,
	11670,
	11680,
	11681,
	11682,
	11683,
	11684,
	11685,
	11686,
	11688,
	11689,
	11690,
	11691,
	11692,
	11693,
	11694,
	11696,
	11697,
	11698,
	11699,
	11700,
	11701,
	11702,
	11704,
	11705,
	11706,
	11707,
	11708,
	11709,
	11710,
	11712,
	11713,
	11714,
	11715,
	11716,
	11717,
	11718,
	11720,
	11721,
	11722,
	11723,
	11724,
	11725,
	11726,
	11728,
	11729,
	11730,
	11731,
	11732,
	11733,
	11734,
	11736,
	11737,
	11738,
	11739,
	11740,
	11741,
	11742,
	11823,
	12293,
	12294,
	12295,
	12321,
	12322,
	12323,
	12324,
	12325,
	12326,
	12327,
	12328,
	12329,
	12337,
	12338,
	12339,
	12340,
	12341,
	12344,
	12345,
	12346,
	12347,
	12348,
	12353,
	12354,
	12355,
	12356,
	12357,
	12358,
	12359,
	12360,
	12361,
	12362,
	12363,
	12364,
	12365,
	12366,
	12367,
	12368,
	12369,
	12370,
	12371,
	12372,
	12373,
	12374,
	12375,
	12376,
	12377,
	12378,
	12379,
	12380,
	12381,
	12382,
	12383,
	12384,
	12385,
	12386,
	12387,
	12388,
	12389,
	12390,
	12391,
	12392,
	12393,
	12394,
	12395,
	12396,
	12397,
	12398,
	12399,
	12400,
	12401,
	12402,
	12403,
	12404,
	12405,
	12406,
	12407,
	12408,
	12409,
	12410,
	12411,
	12412,
	12413,
	12414,
	12415,
	12416,
	12417,
	12418,
	12419,
	12420,
	12421,
	12422,
	12423,
	12424,
	12425,
	12426,
	12427,
	12428,
	12429,
	12430,
	12431,
	12432,
	12433,
	12434,
	12435,
	12436,
	12437,
	12438,
	12445,
	12446,
	12447,
	12449,
	12450,
	12451,
	12452,
	12453,
	12454,
	12455,
	12456,
	12457,
	12458,
	12459,
	12460,
	12461,
	12462,
	12463,
	12464,
	12465,
	12466,
	12467,
	12468,
	12469,
	12470,
	12471,
	12472,
	12473,
	12474,
	12475,
	12476,
	12477,
	12478,
	12479,
	12480,
	12481,
	12482,
	12483,
	12484,
	12485,
	12486,
	12487,
	12488,
	12489,
	12490,
	12491,
	12492,
	12493,
	12494,
	12495,
	12496,
	12497,
	12498,
	12499,
	12500,
	12501,
	12502,
	12503,
	12504,
	12505,
	12506,
	12507,
	12508,
	12509,
	12510,
	12511,
	12512,
	12513,
	12514,
	12515,
	12516,
	12517,
	12518,
	12519,
	12520,
	12521,
	12522,
	12523,
	12524,
	12525,
	12526,
	12527,
	12528,
	12529,
	12530,
	12531,
	12532,
	12533,
	12534,
	12535,
	12536,
	12537,
	12538,
	12540,
	12541,
	12542,
	12543,
	12549,
	12550,
	12551,
	12552,
	12553,
	12554,
	12555,
	12556,
	12557,
	12558,
	12559,
	12560,
	12561,
	12562,
	12563,
	12564,
	12565,
	12566,
	12567,
	12568,
	12569,
	12570,
	12571,
	12572,
	12573,
	12574,
	12575,
	12576,
	12577,
	12578,
	12579,
	12580,
	12581,
	12582,
	12583,
	12584,
	12585,
	12586,
	12587,
	12588,
	12589,
	12593,
	12594,
	12595,
	12596,
	12597,
	12598,
	12599,
	12600,
	12601,
	12602,
	12603,
	12604,
	12605,
	12606,
	12607,
	12608,
	12609,
	12610,
	12611,
	12612,
	12613,
	12614,
	12615,
	12616,
	12617,
	12618,
	12619,
	12620,
	12621,
	12622,
	12623,
	12624,
	12625,
	12626,
	12627,
	12628,
	12629,
	12630,
	12631,
	12632,
	12633,
	12634,
	12635,
	12636,
	12637,
	12638,
	12639,
	12640,
	12641,
	12642,
	12643,
	12644,
	12645,
	12646,
	12647,
	12648,
	12649,
	12650,
	12651,
	12652,
	12653,
	12654,
	12655,
	12656,
	12657,
	12658,
	12659,
	12660,
	12661,
	12662,
	12663,
	12664,
	12665,
	12666,
	12667,
	12668,
	12669,
	12670,
	12671,
	12672,
	12673,
	12674,
	12675,
	12676,
	12677,
	12678,
	12679,
	12680,
	12681,
	12682,
	12683,
	12684,
	12685,
	12686,
	12704,
	12705,
	12706,
	12707,
	12708,
	12709,
	12710,
	12711,
	12712,
	12713,
	12714,
	12715,
	12716,
	12717,
	12718,
	12719,
	12720,
	12721,
	12722,
	12723,
	12724,
	12725,
	12726,
	12727,
	12728,
	12729,
	12730,
	12784,
	12785,
	12786,
	12787,
	12788,
	12789,
	12790,
	12791,
	12792,
	12793,
	12794,
	12795,
	12796,
	12797,
	12798,
	12799,
	13312,
	13313,
	13314,
	13315,
	13316,
	13317,
	13318,
	13319,
	13320,
	13321,
	13322,
	13323,
	13324,
	13325,
	13326,
	13327,
	13328,
	13329,
	13330,
	13331,
	13332,
	13333,
	13334,
	13335,
	13336,
	13337,
	13338,
	13339,
	13340,
	13341,
	13342,
	13343,
	13344,
	13345,
	13346,
	13347,
	13348,
	13349,
	13350,
	13351,
	13352,
	13353,
	13354,
	13355,
	13356,
	13357,
	13358,
	13359,
	13360,
	13361,
	13362,
	13363,
	13364,
	13365,
	13366,
	13367,
	13368,
	13369,
	13370,
	13371,
	13372,
	13373,
	13374,
	13375,
	13376,
	13377,
	13378,
	13379,
	13380,
	13381,
	13382,
	13383,
	13384,
	13385,
	13386,
	13387,
	13388,
	13389,
	13390,
	13391,
	13392,
	13393,
	13394,
	13395,
	13396,
	13397,
	13398,
	13399,
	13400,
	13401,
	13402,
	13403,
	13404,
	13405,
	13406,
	13407,
	13408,
	13409,
	13410,
	13411,
	13412,
	13413,
	13414,
	13415,
	13416,
	13417,
	13418,
	13419,
	13420,
	13421,
	13422,
	13423,
	13424,
	13425,
	13426,
	13427,
	13428,
	13429,
	13430,
	13431,
	13432,
	13433,
	13434,
	13435,
	13436,
	13437,
	13438,
	13439,
	13440,
	13441,
	13442,
	13443,
	13444,
	13445,
	13446,
	13447,
	13448,
	13449,
	13450,
	13451,
	13452,
	13453,
	13454,
	13455,
	13456,
	13457,
	13458,
	13459,
	13460,
	13461,
	13462,
	13463,
	13464,
	13465,
	13466,
	13467,
	13468,
	13469,
	13470,
	13471,
	13472,
	13473,
	13474,
	13475,
	13476,
	13477,
	13478,
	13479,
	13480,
	13481,
	13482,
	13483,
	13484,
	13485,
	13486,
	13487,
	13488,
	13489,
	13490,
	13491,
	13492,
	13493,
	13494,
	13495,
	13496,
	13497,
	13498,
	13499,
	13500,
	13501,
	13502,
	13503,
	13504,
	13505,
	13506,
	13507,
	13508,
	13509,
	13510,
	13511,
	13512,
	13513,
	13514,
	13515,
	13516,
	13517,
	13518,
	13519,
	13520,
	13521,
	13522,
	13523,
	13524,
	13525,
	13526,
	13527,
	13528,
	13529,
	13530,
	13531,
	13532,
	13533,
	13534,
	13535,
	13536,
	13537,
	13538,
	13539,
	13540,
	13541,
	13542,
	13543,
	13544,
	13545,
	13546,
	13547,
	13548,
	13549,
	13550,
	13551,
	13552,
	13553,
	13554,
	13555,
	13556,
	13557,
	13558,
	13559,
	13560,
	13561,
	13562,
	13563,
	13564,
	13565,
	13566,
	13567,
	13568,
	13569,
	13570,
	13571,
	13572,
	13573,
	13574,
	13575,
	13576,
	13577,
	13578,
	13579,
	13580,
	13581,
	13582,
	13583,
	13584,
	13585,
	13586,
	13587,
	13588,
	13589,
	13590,
	13591,
	13592,
	13593,
	13594,
	13595,
	13596,
	13597,
	13598,
	13599,
	13600,
	13601,
	13602,
	13603,
	13604,
	13605,
	13606,
	13607,
	13608,
	13609,
	13610,
	13611,
	13612,
	13613,
	13614,
	13615,
	13616,
	13617,
	13618,
	13619,
	13620,
	13621,
	13622,
	13623,
	13624,
	13625,
	13626,
	13627,
	13628,
	13629,
	13630,
	13631,
	13632,
	13633,
	13634,
	13635,
	13636,
	13637,
	13638,
	13639,
	13640,
	13641,
	13642,
	13643,
	13644,
	13645,
	13646,
	13647,
	13648,
	13649,
	13650,
	13651,
	13652,
	13653,
	13654,
	13655,
	13656,
	13657,
	13658,
	13659,
	13660,
	13661,
	13662,
	13663,
	13664,
	13665,
	13666,
	13667,
	13668,
	13669,
	13670,
	13671,
	13672,
	13673,
	13674,
	13675,
	13676,
	13677,
	13678,
	13679,
	13680,
	13681,
	13682,
	13683,
	13684,
	13685,
	13686,
	13687,
	13688,
	13689,
	13690,
	13691,
	13692,
	13693,
	13694,
	13695,
	13696,
	13697,
	13698,
	13699,
	13700,
	13701,
	13702,
	13703,
	13704,
	13705,
	13706,
	13707,
	13708,
	13709,
	13710,
	13711,
	13712,
	13713,
	13714,
	13715,
	13716,
	13717,
	13718,
	13719,
	13720,
	13721,
	13722,
	13723,
	13724,
	13725,
	13726,
	13727,
	13728,
	13729,
	13730,
	13731,
	13732,
	13733,
	13734,
	13735,
	13736,
	13737,
	13738,
	13739,
	13740,
	13741,
	13742,
	13743,
	13744,
	13745,
	13746,
	13747,
	13748,
	13749,
	13750,
	13751,
	13752,
	13753,
	13754,
	13755,
	13756,
	13757,
	13758,
	13759,
	13760,
	13761,
	13762,
	13763,
	13764,
	13765,
	13766,
	13767,
	13768,
	13769,
	13770,
	13771,
	13772,
	13773,
	13774,
	13775,
	13776,
	13777,
	13778,
	13779,
	13780,
	13781,
	13782,
	13783,
	13784,
	13785,
	13786,
	13787,
	13788,
	13789,
	13790,
	13791,
	13792,
	13793,
	13794,
	13795,
	13796,
	13797,
	13798,
	13799,
	13800,
	13801,
	13802,
	13803,
	13804,
	13805,
	13806,
	13807,
	13808,
	13809,
	13810,
	13811,
	13812,
	13813,
	13814,
	13815,
	13816,
	13817,
	13818,
	13819,
	13820,
	13821,
	13822,
	13823,
	13824,
	13825,
	13826,
	13827,
	13828,
	13829,
	13830,
	13831,
	13832,
	13833,
	13834,
	13835,
	13836,
	13837,
	13838,
	13839,
	13840,
	13841,
	13842,
	13843,
	13844,
	13845,
	13846,
	13847,
	13848,
	13849,
	13850,
	13851,
	13852,
	13853,
	13854,
	13855,
	13856,
	13857,
	13858,
	13859,
	13860,
	13861,
	13862,
	13863,
	13864,
	13865,
	13866,
	13867,
	13868,
	13869,
	13870,
	13871,
	13872,
	13873,
	13874,
	13875,
	13876,
	13877,
	13878,
	13879,
	13880,
	13881,
	13882,
	13883,
	13884,
	13885,
	13886,
	13887,
	13888,
	13889,
	13890,
	13891,
	13892,
	13893,
	13894,
	13895,
	13896,
	13897,
	13898,
	13899,
	13900,
	13901,
	13902,
	13903,
	13904,
	13905,
	13906,
	13907,
	13908,
	13909,
	13910,
	13911,
	13912,
	13913,
	13914,
	13915,
	13916,
	13917,
	13918,
	13919,
	13920,
	13921,
	13922,
	13923,
	13924,
	13925,
	13926,
	13927,
	13928,
	13929,
	13930,
	13931,
	13932,
	13933,
	13934,
	13935,
	13936,
	13937,
	13938,
	13939,
	13940,
	13941,
	13942,
	13943,
	13944,
	13945,
	13946,
	13947,
	13948,
	13949,
	13950,
	13951,
	13952,
	13953,
	13954,
	13955,
	13956,
	13957,
	13958,
	13959,
	13960,
	13961,
	13962,
	13963,
	13964,
	13965,
	13966,
	13967,
	13968,
	13969,
	13970,
	13971,
	13972,
	13973,
	13974,
	13975,
	13976,
	13977,
	13978,
	13979,
	13980,
	13981,
	13982,
	13983,
	13984,
	13985,
	13986,
	13987,
	13988,
	13989,
	13990,
	13991,
	13992,
	13993,
	13994,
	13995,
	13996,
	13997,
	13998,
	13999,
	14000,
	14001,
	14002,
	14003,
	14004,
	14005,
	14006,
	14007,
	14008,
	14009,
	14010,
	14011,
	14012,
	14013,
	14014,
	14015,
	14016,
	14017,
	14018,
	14019,
	14020,
	14021,
	14022,
	14023,
	14024,
	14025,
	14026,
	14027,
	14028,
	14029,
	14030,
	14031,
	14032,
	14033,
	14034,
	14035,
	14036,
	14037,
	14038,
	14039,
	14040,
	14041,
	14042,
	14043,
	14044,
	14045,
	14046,
	14047,
	14048,
	14049,
	14050,
	14051,
	14052,
	14053,
	14054,
	14055,
	14056,
	14057,
	14058,
	14059,
	14060,
	14061,
	14062,
	14063,
	14064,
	14065,
	14066,
	14067,
	14068,
	14069,
	14070,
	14071,
	14072,
	14073,
	14074,
	14075,
	14076,
	14077,
	14078,
	14079,
	14080,
	14081,
	14082,
	14083,
	14084,
	14085,
	14086,
	14087,
	14088,
	14089,
	14090,
	14091,
	14092,
	14093,
	14094,
	14095,
	14096,
	14097,
	14098,
	14099,
	14100,
	14101,
	14102,
	14103,
	14104,
	14105,
	14106,
	14107,
	14108,
	14109,
	14110,
	14111,
	14112,
	14113,
	14114,
	14115,
	14116,
	14117,
	14118,
	14119,
	14120,
	14121,
	14122,
	14123,
	14124,
	14125,
	14126,
	14127,
	14128,
	14129,
	14130,
	14131,
	14132,
	14133,
	14134,
	14135,
	14136,
	14137,
	14138,
	14139,
	14140,
	14141,
	14142,
	14143,
	14144,
	14145,
	14146,
	14147,
	14148,
	14149,
	14150,
	14151,
	14152,
	14153,
	14154,
	14155,
	14156,
	14157,
	14158,
	14159,
	14160,
	14161,
	14162,
	14163,
	14164,
	14165,
	14166,
	14167,
	14168,
	14169,
	14170,
	14171,
	14172,
	14173,
	14174,
	14175,
	14176,
	14177,
	14178,
	14179,
	14180,
	14181,
	14182,
	14183,
	14184,
	14185,
	14186,
	14187,
	14188,
	14189,
	14190,
	14191,
	14192,
	14193,
	14194,
	14195,
	14196,
	14197,
	14198,
	14199,
	14200,
	14201,
	14202,
	14203,
	14204,
	14205,
	14206,
	14207,
	14208,
	14209,
	14210,
	14211,
	14212,
	14213,
	14214,
	14215,
	14216,
	14217,
	14218,
	14219,
	14220,
	14221,
	14222,
	14223,
	14224,
	14225,
	14226,
	14227,
	14228,
	14229,
	14230,
	14231,
	14232,
	14233,
	14234,
	14235,
	14236,
	14237,
	14238,
	14239,
	14240,
	14241,
	14242,
	14243,
	14244,
	14245,
	14246,
	14247,
	14248,
	14249,
	14250,
	14251,
	14252,
	14253,
	14254,
	14255,
	14256,
	14257,
	14258,
	14259,
	14260,
	14261,
	14262,
	14263,
	14264,
	14265,
	14266,
	14267,
	14268,
	14269,
	14270,
	14271,
	14272,
	14273,
	14274,
	14275,
	14276,
	14277,
	14278,
	14279,
	14280,
	14281,
	14282,
	14283,
	14284,
	14285,
	14286,
	14287,
	14288,
	14289,
	14290,
	14291,
	14292,
	14293,
	14294,
	14295,
	14296,
	14297,
	14298,
	14299,
	14300,
	14301,
	14302,
	14303,
	14304,
	14305,
	14306,
	14307,
	14308,
	14309,
	14310,
	14311,
	14312,
	14313,
	14314,
	14315,
	14316,
	14317,
	14318,
	14319,
	14320,
	14321,
	14322,
	14323,
	14324,
	14325,
	14326,
	14327,
	14328,
	14329,
	14330,
	14331,
	14332,
	14333,
	14334,
	14335,
	14336,
	14337,
	14338,
	14339,
	14340,
	14341,
	14342,
	14343,
	14344,
	14345,
	14346,
	14347,
	14348,
	14349,
	14350,
	14351,
	14352,
	14353,
	14354,
	14355,
	14356,
	14357,
	14358,
	14359,
	14360,
	14361,
	14362,
	14363,
	14364,
	14365,
	14366,
	14367,
	14368,
	14369,
	14370,
	14371,
	14372,
	14373,
	14374,
	14375,
	14376,
	14377,
	14378,
	14379,
	14380,
	14381,
	14382,
	14383,
	14384,
	14385,
	14386,
	14387,
	14388,
	14389,
	14390,
	14391,
	14392,
	14393,
	14394,
	14395,
	14396,
	14397,
	14398,
	14399,
	14400,
	14401,
	14402,
	14403,
	14404,
	14405,
	14406,
	14407,
	14408,
	14409,
	14410,
	14411,
	14412,
	14413,
	14414,
	14415,
	14416,
	14417,
	14418,
	14419,
	14420,
	14421,
	14422,
	14423,
	14424,
	14425,
	14426,
	14427,
	14428,
	14429,
	14430,
	14431,
	14432,
	14433,
	14434,
	14435,
	14436,
	14437,
	14438,
	14439,
	14440,
	14441,
	14442,
	14443,
	14444,
	14445,
	14446,
	14447,
	14448,
	14449,
	14450,
	14451,
	14452,
	14453,
	14454,
	14455,
	14456,
	14457,
	14458,
	14459,
	14460,
	14461,
	14462,
	14463,
	14464,
	14465,
	14466,
	14467,
	14468,
	14469,
	14470,
	14471,
	14472,
	14473,
	14474,
	14475,
	14476,
	14477,
	14478,
	14479,
	14480,
	14481,
	14482,
	14483,
	14484,
	14485,
	14486,
	14487,
	14488,
	14489,
	14490,
	14491,
	14492,
	14493,
	14494,
	14495,
	14496,
	14497,
	14498,
	14499,
	14500,
	14501,
	14502,
	14503,
	14504,
	14505,
	14506,
	14507,
	14508,
	14509,
	14510,
	14511,
	14512,
	14513,
	14514,
	14515,
	14516,
	14517,
	14518,
	14519,
	14520,
	14521,
	14522,
	14523,
	14524,
	14525,
	14526,
	14527,
	14528,
	14529,
	14530,
	14531,
	14532,
	14533,
	14534,
	14535,
	14536,
	14537,
	14538,
	14539,
	14540,
	14541,
	14542,
	14543,
	14544,
	14545,
	14546,
	14547,
	14548,
	14549,
	14550,
	14551,
	14552,
	14553,
	14554,
	14555,
	14556,
	14557,
	14558,
	14559,
	14560,
	14561,
	14562,
	14563,
	14564,
	14565,
	14566,
	14567,
	14568,
	14569,
	14570,
	14571,
	14572,
	14573,
	14574,
	14575,
	14576,
	14577,
	14578,
	14579,
	14580,
	14581,
	14582,
	14583,
	14584,
	14585,
	14586,
	14587,
	14588,
	14589,
	14590,
	14591,
	14592,
	14593,
	14594,
	14595,
	14596,
	14597,
	14598,
	14599,
	14600,
	14601,
	14602,
	14603,
	14604,
	14605,
	14606,
	14607,
	14608,
	14609,
	14610,
	14611,
	14612,
	14613,
	14614,
	14615,
	14616,
	14617,
	14618,
	14619,
	14620,
	14621,
	14622,
	14623,
	14624,
	14625,
	14626,
	14627,
	14628,
	14629,
	14630,
	14631,
	14632,
	14633,
	14634,
	14635,
	14636,
	14637,
	14638,
	14639,
	14640,
	14641,
	14642,
	14643,
	14644,
	14645,
	14646,
	14647,
	14648,
	14649,
	14650,
	14651,
	14652,
	14653,
	14654,
	14655,
	14656,
	14657,
	14658,
	14659,
	14660,
	14661,
	14662,
	14663,
	14664,
	14665,
	14666,
	14667,
	14668,
	14669,
	14670,
	14671,
	14672,
	14673,
	14674,
	14675,
	14676,
	14677,
	14678,
	14679,
	14680,
	14681,
	14682,
	14683,
	14684,
	14685,
	14686,
	14687,
	14688,
	14689,
	14690,
	14691,
	14692,
	14693,
	14694,
	14695,
	14696,
	14697,
	14698,
	14699,
	14700,
	14701,
	14702,
	14703,
	14704,
	14705,
	14706,
	14707,
	14708,
	14709,
	14710,
	14711,
	14712,
	14713,
	14714,
	14715,
	14716,
	14717,
	14718,
	14719,
	14720,
	14721,
	14722,
	14723,
	14724,
	14725,
	14726,
	14727,
	14728,
	14729,
	14730,
	14731,
	14732,
	14733,
	14734,
	14735,
	14736,
	14737,
	14738,
	14739,
	14740,
	14741,
	14742,
	14743,
	14744,
	14745,
	14746,
	14747,
	14748,
	14749,
	14750,
	14751,
	14752,
	14753,
	14754,
	14755,
	14756,
	14757,
	14758,
	14759,
	14760,
	14761,
	14762,
	14763,
	14764,
	14765,
	14766,
	14767,
	14768,
	14769,
	14770,
	14771,
	14772,
	14773,
	14774,
	14775,
	14776,
	14777,
	14778,
	14779,
	14780,
	14781,
	14782,
	14783,
	14784,
	14785,
	14786,
	14787,
	14788,
	14789,
	14790,
	14791,
	14792,
	14793,
	14794,
	14795,
	14796,
	14797,
	14798,
	14799,
	14800,
	14801,
	14802,
	14803,
	14804,
	14805,
	14806,
	14807,
	14808,
	14809,
	14810,
	14811,
	14812,
	14813,
	14814,
	14815,
	14816,
	14817,
	14818,
	14819,
	14820,
	14821,
	14822,
	14823,
	14824,
	14825,
	14826,
	14827,
	14828,
	14829,
	14830,
	14831,
	14832,
	14833,
	14834,
	14835,
	14836,
	14837,
	14838,
	14839,
	14840,
	14841,
	14842,
	14843,
	14844,
	14845,
	14846,
	14847,
	14848,
	14849,
	14850,
	14851,
	14852,
	14853,
	14854,
	14855,
	14856,
	14857,
	14858,
	14859,
	14860,
	14861,
	14862,
	14863,
	14864,
	14865,
	14866,
	14867,
	14868,
	14869,
	14870,
	14871,
	14872,
	14873,
	14874,
	14875,
	14876,
	14877,
	14878,
	14879,
	14880,
	14881,
	14882,
	14883,
	14884,
	14885,
	14886,
	14887,
	14888,
	14889,
	14890,
	14891,
	14892,
	14893,
	14894,
	14895,
	14896,
	14897,
	14898,
	14899,
	14900,
	14901,
	14902,
	14903,
	14904,
	14905,
	14906,
	14907,
	14908,
	14909,
	14910,
	14911,
	14912,
	14913,
	14914,
	14915,
	14916,
	14917,
	14918,
	14919,
	14920,
	14921,
	14922,
	14923,
	14924,
	14925,
	14926,
	14927,
	14928,
	14929,
	14930,
	14931,
	14932,
	14933,
	14934,
	14935,
	14936,
	14937,
	14938,
	14939,
	14940,
	14941,
	14942,
	14943,
	14944,
	14945,
	14946,
	14947,
	14948,
	14949,
	14950,
	14951,
	14952,
	14953,
	14954,
	14955,
	14956,
	14957,
	14958,
	14959,
	14960,
	14961,
	14962,
	14963,
	14964,
	14965,
	14966,
	14967,
	14968,
	14969,
	14970,
	14971,
	14972,
	14973,
	14974,
	14975,
	14976,
	14977,
	14978,
	14979,
	14980,
	14981,
	14982,
	14983,
	14984,
	14985,
	14986,
	14987,
	14988,
	14989,
	14990,
	14991,
	14992,
	14993,
	14994,
	14995,
	14996,
	14997,
	14998,
	14999,
	15000,
	15001,
	15002,
	15003,
	15004,
	15005,
	15006,
	15007,
	15008,
	15009,
	15010,
	15011,
	15012,
	15013,
	15014,
	15015,
	15016,
	15017,
	15018,
	15019,
	15020,
	15021,
	15022,
	15023,
	15024,
	15025,
	15026,
	15027,
	15028,
	15029,
	15030,
	15031,
	15032,
	15033,
	15034,
	15035,
	15036,
	15037,
	15038,
	15039,
	15040,
	15041,
	15042,
	15043,
	15044,
	15045,
	15046,
	15047,
	15048,
	15049,
	15050,
	15051,
	15052,
	15053,
	15054,
	15055,
	15056,
	15057,
	15058,
	15059,
	15060,
	15061,
	15062,
	15063,
	15064,
	15065,
	15066,
	15067,
	15068,
	15069,
	15070,
	15071,
	15072,
	15073,
	15074,
	15075,
	15076,
	15077,
	15078,
	15079,
	15080,
	15081,
	15082,
	15083,
	15084,
	15085,
	15086,
	15087,
	15088,
	15089,
	15090,
	15091,
	15092,
	15093,
	15094,
	15095,
	15096,
	15097,
	15098,
	15099,
	15100,
	15101,
	15102,
	15103,
	15104,
	15105,
	15106,
	15107,
	15108,
	15109,
	15110,
	15111,
	15112,
	15113,
	15114,
	15115,
	15116,
	15117,
	15118,
	15119,
	15120,
	15121,
	15122,
	15123,
	15124,
	15125,
	15126,
	15127,
	15128,
	15129,
	15130,
	15131,
	15132,
	15133,
	15134,
	15135,
	15136,
	15137,
	15138,
	15139,
	15140,
	15141,
	15142,
	15143,
	15144,
	15145,
	15146,
	15147,
	15148,
	15149,
	15150,
	15151,
	15152,
	15153,
	15154,
	15155,
	15156,
	15157,
	15158,
	15159,
	15160,
	15161,
	15162,
	15163,
	15164,
	15165,
	15166,
	15167,
	15168,
	15169,
	15170,
	15171,
	15172,
	15173,
	15174,
	15175,
	15176,
	15177,
	15178,
	15179,
	15180,
	15181,
	15182,
	15183,
	15184,
	15185,
	15186,
	15187,
	15188,
	15189,
	15190,
	15191,
	15192,
	15193,
	15194,
	15195,
	15196,
	15197,
	15198,
	15199,
	15200,
	15201,
	15202,
	15203,
	15204,
	15205,
	15206,
	15207,
	15208,
	15209,
	15210,
	15211,
	15212,
	15213,
	15214,
	15215,
	15216,
	15217,
	15218,
	15219,
	15220,
	15221,
	15222,
	15223,
	15224,
	15225,
	15226,
	15227,
	15228,
	15229,
	15230,
	15231,
	15232,
	15233,
	15234,
	15235,
	15236,
	15237,
	15238,
	15239,
	15240,
	15241,
	15242,
	15243,
	15244,
	15245,
	15246,
	15247,
	15248,
	15249,
	15250,
	15251,
	15252,
	15253,
	15254,
	15255,
	15256,
	15257,
	15258,
	15259,
	15260,
	15261,
	15262,
	15263,
	15264,
	15265,
	15266,
	15267,
	15268,
	15269,
	15270,
	15271,
	15272,
	15273,
	15274,
	15275,
	15276,
	15277,
	15278,
	15279,
	15280,
	15281,
	15282,
	15283,
	15284,
	15285,
	15286,
	15287,
	15288,
	15289,
	15290,
	15291,
	15292,
	15293,
	15294,
	15295,
	15296,
	15297,
	15298,
	15299,
	15300,
	15301,
	15302,
	15303,
	15304,
	15305,
	15306,
	15307,
	15308,
	15309,
	15310,
	15311,
	15312,
	15313,
	15314,
	15315,
	15316,
	15317,
	15318,
	15319,
	15320,
	15321,
	15322,
	15323,
	15324,
	15325,
	15326,
	15327,
	15328,
	15329,
	15330,
	15331,
	15332,
	15333,
	15334,
	15335,
	15336,
	15337,
	15338,
	15339,
	15340,
	15341,
	15342,
	15343,
	15344,
	15345,
	15346,
	15347,
	15348,
	15349,
	15350,
	15351,
	15352,
	15353,
	15354,
	15355,
	15356,
	15357,
	15358,
	15359,
	15360,
	15361,
	15362,
	15363,
	15364,
	15365,
	15366,
	15367,
	15368,
	15369,
	15370,
	15371,
	15372,
	15373,
	15374,
	15375,
	15376,
	15377,
	15378,
	15379,
	15380,
	15381,
	15382,
	15383,
	15384,
	15385,
	15386,
	15387,
	15388,
	15389,
	15390,
	15391,
	15392,
	15393,
	15394,
	15395,
	15396,
	15397,
	15398,
	15399,
	15400,
	15401,
	15402,
	15403,
	15404,
	15405,
	15406,
	15407,
	15408,
	15409,
	15410,
	15411,
	15412,
	15413,
	15414,
	15415,
	15416,
	15417,
	15418,
	15419,
	15420,
	15421,
	15422,
	15423,
	15424,
	15425,
	15426,
	15427,
	15428,
	15429,
	15430,
	15431,
	15432,
	15433,
	15434,
	15435,
	15436,
	15437,
	15438,
	15439,
	15440,
	15441,
	15442,
	15443,
	15444,
	15445,
	15446,
	15447,
	15448,
	15449,
	15450,
	15451,
	15452,
	15453,
	15454,
	15455,
	15456,
	15457,
	15458,
	15459,
	15460,
	15461,
	15462,
	15463,
	15464,
	15465,
	15466,
	15467,
	15468,
	15469,
	15470,
	15471,
	15472,
	15473,
	15474,
	15475,
	15476,
	15477,
	15478,
	15479,
	15480,
	15481,
	15482,
	15483,
	15484,
	15485,
	15486,
	15487,
	15488,
	15489,
	15490,
	15491,
	15492,
	15493,
	15494,
	15495,
	15496,
	15497,
	15498,
	15499,
	15500,
	15501,
	15502,
	15503,
	15504,
	15505,
	15506,
	15507,
	15508,
	15509,
	15510,
	15511,
	15512,
	15513,
	15514,
	15515,
	15516,
	15517,
	15518,
	15519,
	15520,
	15521,
	15522,
	15523,
	15524,
	15525,
	15526,
	15527,
	15528,
	15529,
	15530,
	15531,
	15532,
	15533,
	15534,
	15535,
	15536,
	15537,
	15538,
	15539,
	15540,
	15541,
	15542,
	15543,
	15544,
	15545,
	15546,
	15547,
	15548,
	15549,
	15550,
	15551,
	15552,
	15553,
	15554,
	15555,
	15556,
	15557,
	15558,
	15559,
	15560,
	15561,
	15562,
	15563,
	15564,
	15565,
	15566,
	15567,
	15568,
	15569,
	15570,
	15571,
	15572,
	15573,
	15574,
	15575,
	15576,
	15577,
	15578,
	15579,
	15580,
	15581,
	15582,
	15583,
	15584,
	15585,
	15586,
	15587,
	15588,
	15589,
	15590,
	15591,
	15592,
	15593,
	15594,
	15595,
	15596,
	15597,
	15598,
	15599,
	15600,
	15601,
	15602,
	15603,
	15604,
	15605,
	15606,
	15607,
	15608,
	15609,
	15610,
	15611,
	15612,
	15613,
	15614,
	15615,
	15616,
	15617,
	15618,
	15619,
	15620,
	15621,
	15622,
	15623,
	15624,
	15625,
	15626,
	15627,
	15628,
	15629,
	15630,
	15631,
	15632,
	15633,
	15634,
	15635,
	15636,
	15637,
	15638,
	15639,
	15640,
	15641,
	15642,
	15643,
	15644,
	15645,
	15646,
	15647,
	15648,
	15649,
	15650,
	15651,
	15652,
	15653,
	15654,
	15655,
	15656,
	15657,
	15658,
	15659,
	15660,
	15661,
	15662,
	15663,
	15664,
	15665,
	15666,
	15667,
	15668,
	15669,
	15670,
	15671,
	15672,
	15673,
	15674,
	15675,
	15676,
	15677,
	15678,
	15679,
	15680,
	15681,
	15682,
	15683,
	15684,
	15685,
	15686,
	15687,
	15688,
	15689,
	15690,
	15691,
	15692,
	15693,
	15694,
	15695,
	15696,
	15697,
	15698,
	15699,
	15700,
	15701,
	15702,
	15703,
	15704,
	15705,
	15706,
	15707,
	15708,
	15709,
	15710,
	15711,
	15712,
	15713,
	15714,
	15715,
	15716,
	15717,
	15718,
	15719,
	15720,
	15721,
	15722,
	15723,
	15724,
	15725,
	15726,
	15727,
	15728,
	15729,
	15730,
	15731,
	15732,
	15733,
	15734,
	15735,
	15736,
	15737,
	15738,
	15739,
	15740,
	15741,
	15742,
	15743,
	15744,
	15745,
	15746,
	15747,
	15748,
	15749,
	15750,
	15751,
	15752,
	15753,
	15754,
	15755,
	15756,
	15757,
	15758,
	15759,
	15760,
	15761,
	15762,
	15763,
	15764,
	15765,
	15766,
	15767,
	15768,
	15769,
	15770,
	15771,
	15772,
	15773,
	15774,
	15775,
	15776,
	15777,
	15778,
	15779,
	15780,
	15781,
	15782,
	15783,
	15784,
	15785,
	15786,
	15787,
	15788,
	15789,
	15790,
	15791,
	15792,
	15793,
	15794,
	15795,
	15796,
	15797,
	15798,
	15799,
	15800,
	15801,
	15802,
	15803,
	15804,
	15805,
	15806,
	15807,
	15808,
	15809,
	15810,
	15811,
	15812,
	15813,
	15814,
	15815,
	15816,
	15817,
	15818,
	15819,
	15820,
	15821,
	15822,
	15823,
	15824,
	15825,
	15826,
	15827,
	15828,
	15829,
	15830,
	15831,
	15832,
	15833,
	15834,
	15835,
	15836,
	15837,
	15838,
	15839,
	15840,
	15841,
	15842,
	15843,
	15844,
	15845,
	15846,
	15847,
	15848,
	15849,
	15850,
	15851,
	15852,
	15853,
	15854,
	15855,
	15856,
	15857,
	15858,
	15859,
	15860,
	15861,
	15862,
	15863,
	15864,
	15865,
	15866,
	15867,
	15868,
	15869,
	15870,
	15871,
	15872,
	15873,
	15874,
	15875,
	15876,
	15877,
	15878,
	15879,
	15880,
	15881,
	15882,
	15883,
	15884,
	15885,
	15886,
	15887,
	15888,
	15889,
	15890,
	15891,
	15892,
	15893,
	15894,
	15895,
	15896,
	15897,
	15898,
	15899,
	15900,
	15901,
	15902,
	15903,
	15904,
	15905,
	15906,
	15907,
	15908,
	15909,
	15910,
	15911,
	15912,
	15913,
	15914,
	15915,
	15916,
	15917,
	15918,
	15919,
	15920,
	15921,
	15922,
	15923,
	15924,
	15925,
	15926,
	15927,
	15928,
	15929,
	15930,
	15931,
	15932,
	15933,
	15934,
	15935,
	15936,
	15937,
	15938,
	15939,
	15940,
	15941,
	15942,
	15943,
	15944,
	15945,
	15946,
	15947,
	15948,
	15949,
	15950,
	15951,
	15952,
	15953,
	15954,
	15955,
	15956,
	15957,
	15958,
	15959,
	15960,
	15961,
	15962,
	15963,
	15964,
	15965,
	15966,
	15967,
	15968,
	15969,
	15970,
	15971,
	15972,
	15973,
	15974,
	15975,
	15976,
	15977,
	15978,
	15979,
	15980,
	15981,
	15982,
	15983,
	15984,
	15985,
	15986,
	15987,
	15988,
	15989,
	15990,
	15991,
	15992,
	15993,
	15994,
	15995,
	15996,
	15997,
	15998,
	15999,
	16000,
	16001,
	16002,
	16003,
	16004,
	16005,
	16006,
	16007,
	16008,
	16009,
	16010,
	16011,
	16012,
	16013,
	16014,
	16015,
	16016,
	16017,
	16018,
	16019,
	16020,
	16021,
	16022,
	16023,
	16024,
	16025,
	16026,
	16027,
	16028,
	16029,
	16030,
	16031,
	16032,
	16033,
	16034,
	16035,
	16036,
	16037,
	16038,
	16039,
	16040,
	16041,
	16042,
	16043,
	16044,
	16045,
	16046,
	16047,
	16048,
	16049,
	16050,
	16051,
	16052,
	16053,
	16054,
	16055,
	16056,
	16057,
	16058,
	16059,
	16060,
	16061,
	16062,
	16063,
	16064,
	16065,
	16066,
	16067,
	16068,
	16069,
	16070,
	16071,
	16072,
	16073,
	16074,
	16075,
	16076,
	16077,
	16078,
	16079,
	16080,
	16081,
	16082,
	16083,
	16084,
	16085,
	16086,
	16087,
	16088,
	16089,
	16090,
	16091,
	16092,
	16093,
	16094,
	16095,
	16096,
	16097,
	16098,
	16099,
	16100,
	16101,
	16102,
	16103,
	16104,
	16105,
	16106,
	16107,
	16108,
	16109,
	16110,
	16111,
	16112,
	16113,
	16114,
	16115,
	16116,
	16117,
	16118,
	16119,
	16120,
	16121,
	16122,
	16123,
	16124,
	16125,
	16126,
	16127,
	16128,
	16129,
	16130,
	16131,
	16132,
	16133,
	16134,
	16135,
	16136,
	16137,
	16138,
	16139,
	16140,
	16141,
	16142,
	16143,
	16144,
	16145,
	16146,
	16147,
	16148,
	16149,
	16150,
	16151,
	16152,
	16153,
	16154,
	16155,
	16156,
	16157,
	16158,
	16159,
	16160,
	16161,
	16162,
	16163,
	16164,
	16165,
	16166,
	16167,
	16168,
	16169,
	16170,
	16171,
	16172,
	16173,
	16174,
	16175,
	16176,
	16177,
	16178,
	16179,
	16180,
	16181,
	16182,
	16183,
	16184,
	16185,
	16186,
	16187,
	16188,
	16189,
	16190,
	16191,
	16192,
	16193,
	16194,
	16195,
	16196,
	16197,
	16198,
	16199,
	16200,
	16201,
	16202,
	16203,
	16204,
	16205,
	16206,
	16207,
	16208,
	16209,
	16210,
	16211,
	16212,
	16213,
	16214,
	16215,
	16216,
	16217,
	16218,
	16219,
	16220,
	16221,
	16222,
	16223,
	16224,
	16225,
	16226,
	16227,
	16228,
	16229,
	16230,
	16231,
	16232,
	16233,
	16234,
	16235,
	16236,
	16237,
	16238,
	16239,
	16240,
	16241,
	16242,
	16243,
	16244,
	16245,
	16246,
	16247,
	16248,
	16249,
	16250,
	16251,
	16252,
	16253,
	16254,
	16255,
	16256,
	16257,
	16258,
	16259,
	16260,
	16261,
	16262,
	16263,
	16264,
	16265,
	16266,
	16267,
	16268,
	16269,
	16270,
	16271,
	16272,
	16273,
	16274,
	16275,
	16276,
	16277,
	16278,
	16279,
	16280,
	16281,
	16282,
	16283,
	16284,
	16285,
	16286,
	16287,
	16288,
	16289,
	16290,
	16291,
	16292,
	16293,
	16294,
	16295,
	16296,
	16297,
	16298,
	16299,
	16300,
	16301,
	16302,
	16303,
	16304,
	16305,
	16306,
	16307,
	16308,
	16309,
	16310,
	16311,
	16312,
	16313,
	16314,
	16315,
	16316,
	16317,
	16318,
	16319,
	16320,
	16321,
	16322,
	16323,
	16324,
	16325,
	16326,
	16327,
	16328,
	16329,
	16330,
	16331,
	16332,
	16333,
	16334,
	16335,
	16336,
	16337,
	16338,
	16339,
	16340,
	16341,
	16342,
	16343,
	16344,
	16345,
	16346,
	16347,
	16348,
	16349,
	16350,
	16351,
	16352,
	16353,
	16354,
	16355,
	16356,
	16357,
	16358,
	16359,
	16360,
	16361,
	16362,
	16363,
	16364,
	16365,
	16366,
	16367,
	16368,
	16369,
	16370,
	16371,
	16372,
	16373,
	16374,
	16375,
	16376,
	16377,
	16378,
	16379,
	16380,
	16381,
	16382,
	16383,
	16384,
	16385,
	16386,
	16387,
	16388,
	16389,
	16390,
	16391,
	16392,
	16393,
	16394,
	16395,
	16396,
	16397,
	16398,
	16399,
	16400,
	16401,
	16402,
	16403,
	16404,
	16405,
	16406,
	16407,
	16408,
	16409,
	16410,
	16411,
	16412,
	16413,
	16414,
	16415,
	16416,
	16417,
	16418,
	16419,
	16420,
	16421,
	16422,
	16423,
	16424,
	16425,
	16426,
	16427,
	16428,
	16429,
	16430,
	16431,
	16432,
	16433,
	16434,
	16435,
	16436,
	16437,
	16438,
	16439,
	16440,
	16441,
	16442,
	16443,
	16444,
	16445,
	16446,
	16447,
	16448,
	16449,
	16450,
	16451,
	16452,
	16453,
	16454,
	16455,
	16456,
	16457,
	16458,
	16459,
	16460,
	16461,
	16462,
	16463,
	16464,
	16465,
	16466,
	16467,
	16468,
	16469,
	16470,
	16471,
	16472,
	16473,
	16474,
	16475,
	16476,
	16477,
	16478,
	16479,
	16480,
	16481,
	16482,
	16483,
	16484,
	16485,
	16486,
	16487,
	16488,
	16489,
	16490,
	16491,
	16492,
	16493,
	16494,
	16495,
	16496,
	16497,
	16498,
	16499,
	16500,
	16501,
	16502,
	16503,
	16504,
	16505,
	16506,
	16507,
	16508,
	16509,
	16510,
	16511,
	16512,
	16513,
	16514,
	16515,
	16516,
	16517,
	16518,
	16519,
	16520,
	16521,
	16522,
	16523,
	16524,
	16525,
	16526,
	16527,
	16528,
	16529,
	16530,
	16531,
	16532,
	16533,
	16534,
	16535,
	16536,
	16537,
	16538,
	16539,
	16540,
	16541,
	16542,
	16543,
	16544,
	16545,
	16546,
	16547,
	16548,
	16549,
	16550,
	16551,
	16552,
	16553,
	16554,
	16555,
	16556,
	16557,
	16558,
	16559,
	16560,
	16561,
	16562,
	16563,
	16564,
	16565,
	16566,
	16567,
	16568,
	16569,
	16570,
	16571,
	16572,
	16573,
	16574,
	16575,
	16576,
	16577,
	16578,
	16579,
	16580,
	16581,
	16582,
	16583,
	16584,
	16585,
	16586,
	16587,
	16588,
	16589,
	16590,
	16591,
	16592,
	16593,
	16594,
	16595,
	16596,
	16597,
	16598,
	16599,
	16600,
	16601,
	16602,
	16603,
	16604,
	16605,
	16606,
	16607,
	16608,
	16609,
	16610,
	16611,
	16612,
	16613,
	16614,
	16615,
	16616,
	16617,
	16618,
	16619,
	16620,
	16621,
	16622,
	16623,
	16624,
	16625,
	16626,
	16627,
	16628,
	16629,
	16630,
	16631,
	16632,
	16633,
	16634,
	16635,
	16636,
	16637,
	16638,
	16639,
	16640,
	16641,
	16642,
	16643,
	16644,
	16645,
	16646,
	16647,
	16648,
	16649,
	16650,
	16651,
	16652,
	16653,
	16654,
	16655,
	16656,
	16657,
	16658,
	16659,
	16660,
	16661,
	16662,
	16663,
	16664,
	16665,
	16666,
	16667,
	16668,
	16669,
	16670,
	16671,
	16672,
	16673,
	16674,
	16675,
	16676,
	16677,
	16678,
	16679,
	16680,
	16681,
	16682,
	16683,
	16684,
	16685,
	16686,
	16687,
	16688,
	16689,
	16690,
	16691,
	16692,
	16693,
	16694,
	16695,
	16696,
	16697,
	16698,
	16699,
	16700,
	16701,
	16702,
	16703,
	16704,
	16705,
	16706,
	16707,
	16708,
	16709,
	16710,
	16711,
	16712,
	16713,
	16714,
	16715,
	16716,
	16717,
	16718,
	16719,
	16720,
	16721,
	16722,
	16723,
	16724,
	16725,
	16726,
	16727,
	16728,
	16729,
	16730,
	16731,
	16732,
	16733,
	16734,
	16735,
	16736,
	16737,
	16738,
	16739,
	16740,
	16741,
	16742,
	16743,
	16744,
	16745,
	16746,
	16747,
	16748,
	16749,
	16750,
	16751,
	16752,
	16753,
	16754,
	16755,
	16756,
	16757,
	16758,
	16759,
	16760,
	16761,
	16762,
	16763,
	16764,
	16765,
	16766,
	16767,
	16768,
	16769,
	16770,
	16771,
	16772,
	16773,
	16774,
	16775,
	16776,
	16777,
	16778,
	16779,
	16780,
	16781,
	16782,
	16783,
	16784,
	16785,
	16786,
	16787,
	16788,
	16789,
	16790,
	16791,
	16792,
	16793,
	16794,
	16795,
	16796,
	16797,
	16798,
	16799,
	16800,
	16801,
	16802,
	16803,
	16804,
	16805,
	16806,
	16807,
	16808,
	16809,
	16810,
	16811,
	16812,
	16813,
	16814,
	16815,
	16816,
	16817,
	16818,
	16819,
	16820,
	16821,
	16822,
	16823,
	16824,
	16825,
	16826,
	16827,
	16828,
	16829,
	16830,
	16831,
	16832,
	16833,
	16834,
	16835,
	16836,
	16837,
	16838,
	16839,
	16840,
	16841,
	16842,
	16843,
	16844,
	16845,
	16846,
	16847,
	16848,
	16849,
	16850,
	16851,
	16852,
	16853,
	16854,
	16855,
	16856,
	16857,
	16858,
	16859,
	16860,
	16861,
	16862,
	16863,
	16864,
	16865,
	16866,
	16867,
	16868,
	16869,
	16870,
	16871,
	16872,
	16873,
	16874,
	16875,
	16876,
	16877,
	16878,
	16879,
	16880,
	16881,
	16882,
	16883,
	16884,
	16885,
	16886,
	16887,
	16888,
	16889,
	16890,
	16891,
	16892,
	16893,
	16894,
	16895,
	16896,
	16897,
	16898,
	16899,
	16900,
	16901,
	16902,
	16903,
	16904,
	16905,
	16906,
	16907,
	16908,
	16909,
	16910,
	16911,
	16912,
	16913,
	16914,
	16915,
	16916,
	16917,
	16918,
	16919,
	16920,
	16921,
	16922,
	16923,
	16924,
	16925,
	16926,
	16927,
	16928,
	16929,
	16930,
	16931,
	16932,
	16933,
	16934,
	16935,
	16936,
	16937,
	16938,
	16939,
	16940,
	16941,
	16942,
	16943,
	16944,
	16945,
	16946,
	16947,
	16948,
	16949,
	16950,
	16951,
	16952,
	16953,
	16954,
	16955,
	16956,
	16957,
	16958,
	16959,
	16960,
	16961,
	16962,
	16963,
	16964,
	16965,
	16966,
	16967,
	16968,
	16969,
	16970,
	16971,
	16972,
	16973,
	16974,
	16975,
	16976,
	16977,
	16978,
	16979,
	16980,
	16981,
	16982,
	16983,
	16984,
	16985,
	16986,
	16987,
	16988,
	16989,
	16990,
	16991,
	16992,
	16993,
	16994,
	16995,
	16996,
	16997,
	16998,
	16999,
	17000,
	17001,
	17002,
	17003,
	17004,
	17005,
	17006,
	17007,
	17008,
	17009,
	17010,
	17011,
	17012,
	17013,
	17014,
	17015,
	17016,
	17017,
	17018,
	17019,
	17020,
	17021,
	17022,
	17023,
	17024,
	17025,
	17026,
	17027,
	17028,
	17029,
	17030,
	17031,
	17032,
	17033,
	17034,
	17035,
	17036,
	17037,
	17038,
	17039,
	17040,
	17041,
	17042,
	17043,
	17044,
	17045,
	17046,
	17047,
	17048,
	17049,
	17050,
	17051,
	17052,
	17053,
	17054,
	17055,
	17056,
	17057,
	17058,
	17059,
	17060,
	17061,
	17062,
	17063,
	17064,
	17065,
	17066,
	17067,
	17068,
	17069,
	17070,
	17071,
	17072,
	17073,
	17074,
	17075,
	17076,
	17077,
	17078,
	17079,
	17080,
	17081,
	17082,
	17083,
	17084,
	17085,
	17086,
	17087,
	17088,
	17089,
	17090,
	17091,
	17092,
	17093,
	17094,
	17095,
	17096,
	17097,
	17098,
	17099,
	17100,
	17101,
	17102,
	17103,
	17104,
	17105,
	17106,
	17107,
	17108,
	17109,
	17110,
	17111,
	17112,
	17113,
	17114,
	17115,
	17116,
	17117,
	17118,
	17119,
	17120,
	17121,
	17122,
	17123,
	17124,
	17125,
	17126,
	17127,
	17128,
	17129,
	17130,
	17131,
	17132,
	17133,
	17134,
	17135,
	17136,
	17137,
	17138,
	17139,
	17140,
	17141,
	17142,
	17143,
	17144,
	17145,
	17146,
	17147,
	17148,
	17149,
	17150,
	17151,
	17152,
	17153,
	17154,
	17155,
	17156,
	17157,
	17158,
	17159,
	17160,
	17161,
	17162,
	17163,
	17164,
	17165,
	17166,
	17167,
	17168,
	17169,
	17170,
	17171,
	17172,
	17173,
	17174,
	17175,
	17176,
	17177,
	17178,
	17179,
	17180,
	17181,
	17182,
	17183,
	17184,
	17185,
	17186,
	17187,
	17188,
	17189,
	17190,
	17191,
	17192,
	17193,
	17194,
	17195,
	17196,
	17197,
	17198,
	17199,
	17200,
	17201,
	17202,
	17203,
	17204,
	17205,
	17206,
	17207,
	17208,
	17209,
	17210,
	17211,
	17212,
	17213,
	17214,
	17215,
	17216,
	17217,
	17218,
	17219,
	17220,
	17221,
	17222,
	17223,
	17224,
	17225,
	17226,
	17227,
	17228,
	17229,
	17230,
	17231,
	17232,
	17233,
	17234,
	17235,
	17236,
	17237,
	17238,
	17239,
	17240,
	17241,
	17242,
	17243,
	17244,
	17245,
	17246,
	17247,
	17248,
	17249,
	17250,
	17251,
	17252,
	17253,
	17254,
	17255,
	17256,
	17257,
	17258,
	17259,
	17260,
	17261,
	17262,
	17263,
	17264,
	17265,
	17266,
	17267,
	17268,
	17269,
	17270,
	17271,
	17272,
	17273,
	17274,
	17275,
	17276,
	17277,
	17278,
	17279,
	17280,
	17281,
	17282,
	17283,
	17284,
	17285,
	17286,
	17287,
	17288,
	17289,
	17290,
	17291,
	17292,
	17293,
	17294,
	17295,
	17296,
	17297,
	17298,
	17299,
	17300,
	17301,
	17302,
	17303,
	17304,
	17305,
	17306,
	17307,
	17308,
	17309,
	17310,
	17311,
	17312,
	17313,
	17314,
	17315,
	17316,
	17317,
	17318,
	17319,
	17320,
	17321,
	17322,
	17323,
	17324,
	17325,
	17326,
	17327,
	17328,
	17329,
	17330,
	17331,
	17332,
	17333,
	17334,
	17335,
	17336,
	17337,
	17338,
	17339,
	17340,
	17341,
	17342,
	17343,
	17344,
	17345,
	17346,
	17347,
	17348,
	17349,
	17350,
	17351,
	17352,
	17353,
	17354,
	17355,
	17356,
	17357,
	17358,
	17359,
	17360,
	17361,
	17362,
	17363,
	17364,
	17365,
	17366,
	17367,
	17368,
	17369,
	17370,
	17371,
	17372,
	17373,
	17374,
	17375,
	17376,
	17377,
	17378,
	17379,
	17380,
	17381,
	17382,
	17383,
	17384,
	17385,
	17386,
	17387,
	17388,
	17389,
	17390,
	17391,
	17392,
	17393,
	17394,
	17395,
	17396,
	17397,
	17398,
	17399,
	17400,
	17401,
	17402,
	17403,
	17404,
	17405,
	17406,
	17407,
	17408,
	17409,
	17410,
	17411,
	17412,
	17413,
	17414,
	17415,
	17416,
	17417,
	17418,
	17419,
	17420,
	17421,
	17422,
	17423,
	17424,
	17425,
	17426,
	17427,
	17428,
	17429,
	17430,
	17431,
	17432,
	17433,
	17434,
	17435,
	17436,
	17437,
	17438,
	17439,
	17440,
	17441,
	17442,
	17443,
	17444,
	17445,
	17446,
	17447,
	17448,
	17449,
	17450,
	17451,
	17452,
	17453,
	17454,
	17455,
	17456,
	17457,
	17458,
	17459,
	17460,
	17461,
	17462,
	17463,
	17464,
	17465,
	17466,
	17467,
	17468,
	17469,
	17470,
	17471,
	17472,
	17473,
	17474,
	17475,
	17476,
	17477,
	17478,
	17479,
	17480,
	17481,
	17482,
	17483,
	17484,
	17485,
	17486,
	17487,
	17488,
	17489,
	17490,
	17491,
	17492,
	17493,
	17494,
	17495,
	17496,
	17497,
	17498,
	17499,
	17500,
	17501,
	17502,
	17503,
	17504,
	17505,
	17506,
	17507,
	17508,
	17509,
	17510,
	17511,
	17512,
	17513,
	17514,
	17515,
	17516,
	17517,
	17518,
	17519,
	17520,
	17521,
	17522,
	17523,
	17524,
	17525,
	17526,
	17527,
	17528,
	17529,
	17530,
	17531,
	17532,
	17533,
	17534,
	17535,
	17536,
	17537,
	17538,
	17539,
	17540,
	17541,
	17542,
	17543,
	17544,
	17545,
	17546,
	17547,
	17548,
	17549,
	17550,
	17551,
	17552,
	17553,
	17554,
	17555,
	17556,
	17557,
	17558,
	17559,
	17560,
	17561,
	17562,
	17563,
	17564,
	17565,
	17566,
	17567,
	17568,
	17569,
	17570,
	17571,
	17572,
	17573,
	17574,
	17575,
	17576,
	17577,
	17578,
	17579,
	17580,
	17581,
	17582,
	17583,
	17584,
	17585,
	17586,
	17587,
	17588,
	17589,
	17590,
	17591,
	17592,
	17593,
	17594,
	17595,
	17596,
	17597,
	17598,
	17599,
	17600,
	17601,
	17602,
	17603,
	17604,
	17605,
	17606,
	17607,
	17608,
	17609,
	17610,
	17611,
	17612,
	17613,
	17614,
	17615,
	17616,
	17617,
	17618,
	17619,
	17620,
	17621,
	17622,
	17623,
	17624,
	17625,
	17626,
	17627,
	17628,
	17629,
	17630,
	17631,
	17632,
	17633,
	17634,
	17635,
	17636,
	17637,
	17638,
	17639,
	17640,
	17641,
	17642,
	17643,
	17644,
	17645,
	17646,
	17647,
	17648,
	17649,
	17650,
	17651,
	17652,
	17653,
	17654,
	17655,
	17656,
	17657,
	17658,
	17659,
	17660,
	17661,
	17662,
	17663,
	17664,
	17665,
	17666,
	17667,
	17668,
	17669,
	17670,
	17671,
	17672,
	17673,
	17674,
	17675,
	17676,
	17677,
	17678,
	17679,
	17680,
	17681,
	17682,
	17683,
	17684,
	17685,
	17686,
	17687,
	17688,
	17689,
	17690,
	17691,
	17692,
	17693,
	17694,
	17695,
	17696,
	17697,
	17698,
	17699,
	17700,
	17701,
	17702,
	17703,
	17704,
	17705,
	17706,
	17707,
	17708,
	17709,
	17710,
	17711,
	17712,
	17713,
	17714,
	17715,
	17716,
	17717,
	17718,
	17719,
	17720,
	17721,
	17722,
	17723,
	17724,
	17725,
	17726,
	17727,
	17728,
	17729,
	17730,
	17731,
	17732,
	17733,
	17734,
	17735,
	17736,
	17737,
	17738,
	17739,
	17740,
	17741,
	17742,
	17743,
	17744,
	17745,
	17746,
	17747,
	17748,
	17749,
	17750,
	17751,
	17752,
	17753,
	17754,
	17755,
	17756,
	17757,
	17758,
	17759,
	17760,
	17761,
	17762,
	17763,
	17764,
	17765,
	17766,
	17767,
	17768,
	17769,
	17770,
	17771,
	17772,
	17773,
	17774,
	17775,
	17776,
	17777,
	17778,
	17779,
	17780,
	17781,
	17782,
	17783,
	17784,
	17785,
	17786,
	17787,
	17788,
	17789,
	17790,
	17791,
	17792,
	17793,
	17794,
	17795,
	17796,
	17797,
	17798,
	17799,
	17800,
	17801,
	17802,
	17803,
	17804,
	17805,
	17806,
	17807,
	17808,
	17809,
	17810,
	17811,
	17812,
	17813,
	17814,
	17815,
	17816,
	17817,
	17818,
	17819,
	17820,
	17821,
	17822,
	17823,
	17824,
	17825,
	17826,
	17827,
	17828,
	17829,
	17830,
	17831,
	17832,
	17833,
	17834,
	17835,
	17836,
	17837,
	17838,
	17839,
	17840,
	17841,
	17842,
	17843,
	17844,
	17845,
	17846,
	17847,
	17848,
	17849,
	17850,
	17851,
	17852,
	17853,
	17854,
	17855,
	17856,
	17857,
	17858,
	17859,
	17860,
	17861,
	17862,
	17863,
	17864,
	17865,
	17866,
	17867,
	17868,
	17869,
	17870,
	17871,
	17872,
	17873,
	17874,
	17875,
	17876,
	17877,
	17878,
	17879,
	17880,
	17881,
	17882,
	17883,
	17884,
	17885,
	17886,
	17887,
	17888,
	17889,
	17890,
	17891,
	17892,
	17893,
	17894,
	17895,
	17896,
	17897,
	17898,
	17899,
	17900,
	17901,
	17902,
	17903,
	17904,
	17905,
	17906,
	17907,
	17908,
	17909,
	17910,
	17911,
	17912,
	17913,
	17914,
	17915,
	17916,
	17917,
	17918,
	17919,
	17920,
	17921,
	17922,
	17923,
	17924,
	17925,
	17926,
	17927,
	17928,
	17929,
	17930,
	17931,
	17932,
	17933,
	17934,
	17935,
	17936,
	17937,
	17938,
	17939,
	17940,
	17941,
	17942,
	17943,
	17944,
	17945,
	17946,
	17947,
	17948,
	17949,
	17950,
	17951,
	17952,
	17953,
	17954,
	17955,
	17956,
	17957,
	17958,
	17959,
	17960,
	17961,
	17962,
	17963,
	17964,
	17965,
	17966,
	17967,
	17968,
	17969,
	17970,
	17971,
	17972,
	17973,
	17974,
	17975,
	17976,
	17977,
	17978,
	17979,
	17980,
	17981,
	17982,
	17983,
	17984,
	17985,
	17986,
	17987,
	17988,
	17989,
	17990,
	17991,
	17992,
	17993,
	17994,
	17995,
	17996,
	17997,
	17998,
	17999,
	18000,
	18001,
	18002,
	18003,
	18004,
	18005,
	18006,
	18007,
	18008,
	18009,
	18010,
	18011,
	18012,
	18013,
	18014,
	18015,
	18016,
	18017,
	18018,
	18019,
	18020,
	18021,
	18022,
	18023,
	18024,
	18025,
	18026,
	18027,
	18028,
	18029,
	18030,
	18031,
	18032,
	18033,
	18034,
	18035,
	18036,
	18037,
	18038,
	18039,
	18040,
	18041,
	18042,
	18043,
	18044,
	18045,
	18046,
	18047,
	18048,
	18049,
	18050,
	18051,
	18052,
	18053,
	18054,
	18055,
	18056,
	18057,
	18058,
	18059,
	18060,
	18061,
	18062,
	18063,
	18064,
	18065,
	18066,
	18067,
	18068,
	18069,
	18070,
	18071,
	18072,
	18073,
	18074,
	18075,
	18076,
	18077,
	18078,
	18079,
	18080,
	18081,
	18082,
	18083,
	18084,
	18085,
	18086,
	18087,
	18088,
	18089,
	18090,
	18091,
	18092,
	18093,
	18094,
	18095,
	18096,
	18097,
	18098,
	18099,
	18100,
	18101,
	18102,
	18103,
	18104,
	18105,
	18106,
	18107,
	18108,
	18109,
	18110,
	18111,
	18112,
	18113,
	18114,
	18115,
	18116,
	18117,
	18118,
	18119,
	18120,
	18121,
	18122,
	18123,
	18124,
	18125,
	18126,
	18127,
	18128,
	18129,
	18130,
	18131,
	18132,
	18133,
	18134,
	18135,
	18136,
	18137,
	18138,
	18139,
	18140,
	18141,
	18142,
	18143,
	18144,
	18145,
	18146,
	18147,
	18148,
	18149,
	18150,
	18151,
	18152,
	18153,
	18154,
	18155,
	18156,
	18157,
	18158,
	18159,
	18160,
	18161,
	18162,
	18163,
	18164,
	18165,
	18166,
	18167,
	18168,
	18169,
	18170,
	18171,
	18172,
	18173,
	18174,
	18175,
	18176,
	18177,
	18178,
	18179,
	18180,
	18181,
	18182,
	18183,
	18184,
	18185,
	18186,
	18187,
	18188,
	18189,
	18190,
	18191,
	18192,
	18193,
	18194,
	18195,
	18196,
	18197,
	18198,
	18199,
	18200,
	18201,
	18202,
	18203,
	18204,
	18205,
	18206,
	18207,
	18208,
	18209,
	18210,
	18211,
	18212,
	18213,
	18214,
	18215,
	18216,
	18217,
	18218,
	18219,
	18220,
	18221,
	18222,
	18223,
	18224,
	18225,
	18226,
	18227,
	18228,
	18229,
	18230,
	18231,
	18232,
	18233,
	18234,
	18235,
	18236,
	18237,
	18238,
	18239,
	18240,
	18241,
	18242,
	18243,
	18244,
	18245,
	18246,
	18247,
	18248,
	18249,
	18250,
	18251,
	18252,
	18253,
	18254,
	18255,
	18256,
	18257,
	18258,
	18259,
	18260,
	18261,
	18262,
	18263,
	18264,
	18265,
	18266,
	18267,
	18268,
	18269,
	18270,
	18271,
	18272,
	18273,
	18274,
	18275,
	18276,
	18277,
	18278,
	18279,
	18280,
	18281,
	18282,
	18283,
	18284,
	18285,
	18286,
	18287,
	18288,
	18289,
	18290,
	18291,
	18292,
	18293,
	18294,
	18295,
	18296,
	18297,
	18298,
	18299,
	18300,
	18301,
	18302,
	18303,
	18304,
	18305,
	18306,
	18307,
	18308,
	18309,
	18310,
	18311,
	18312,
	18313,
	18314,
	18315,
	18316,
	18317,
	18318,
	18319,
	18320,
	18321,
	18322,
	18323,
	18324,
	18325,
	18326,
	18327,
	18328,
	18329,
	18330,
	18331,
	18332,
	18333,
	18334,
	18335,
	18336,
	18337,
	18338,
	18339,
	18340,
	18341,
	18342,
	18343,
	18344,
	18345,
	18346,
	18347,
	18348,
	18349,
	18350,
	18351,
	18352,
	18353,
	18354,
	18355,
	18356,
	18357,
	18358,
	18359,
	18360,
	18361,
	18362,
	18363,
	18364,
	18365,
	18366,
	18367,
	18368,
	18369,
	18370,
	18371,
	18372,
	18373,
	18374,
	18375,
	18376,
	18377,
	18378,
	18379,
	18380,
	18381,
	18382,
	18383,
	18384,
	18385,
	18386,
	18387,
	18388,
	18389,
	18390,
	18391,
	18392,
	18393,
	18394,
	18395,
	18396,
	18397,
	18398,
	18399,
	18400,
	18401,
	18402,
	18403,
	18404,
	18405,
	18406,
	18407,
	18408,
	18409,
	18410,
	18411,
	18412,
	18413,
	18414,
	18415,
	18416,
	18417,
	18418,
	18419,
	18420,
	18421,
	18422,
	18423,
	18424,
	18425,
	18426,
	18427,
	18428,
	18429,
	18430,
	18431,
	18432,
	18433,
	18434,
	18435,
	18436,
	18437,
	18438,
	18439,
	18440,
	18441,
	18442,
	18443,
	18444,
	18445,
	18446,
	18447,
	18448,
	18449,
	18450,
	18451,
	18452,
	18453,
	18454,
	18455,
	18456,
	18457,
	18458,
	18459,
	18460,
	18461,
	18462,
	18463,
	18464,
	18465,
	18466,
	18467,
	18468,
	18469,
	18470,
	18471,
	18472,
	18473,
	18474,
	18475,
	18476,
	18477,
	18478,
	18479,
	18480,
	18481,
	18482,
	18483,
	18484,
	18485,
	18486,
	18487,
	18488,
	18489,
	18490,
	18491,
	18492,
	18493,
	18494,
	18495,
	18496,
	18497,
	18498,
	18499,
	18500,
	18501,
	18502,
	18503,
	18504,
	18505,
	18506,
	18507,
	18508,
	18509,
	18510,
	18511,
	18512,
	18513,
	18514,
	18515,
	18516,
	18517,
	18518,
	18519,
	18520,
	18521,
	18522,
	18523,
	18524,
	18525,
	18526,
	18527,
	18528,
	18529,
	18530,
	18531,
	18532,
	18533,
	18534,
	18535,
	18536,
	18537,
	18538,
	18539,
	18540,
	18541,
	18542,
	18543,
	18544,
	18545,
	18546,
	18547,
	18548,
	18549,
	18550,
	18551,
	18552,
	18553,
	18554,
	18555,
	18556,
	18557,
	18558,
	18559,
	18560,
	18561,
	18562,
	18563,
	18564,
	18565,
	18566,
	18567,
	18568,
	18569,
	18570,
	18571,
	18572,
	18573,
	18574,
	18575,
	18576,
	18577,
	18578,
	18579,
	18580,
	18581,
	18582,
	18583,
	18584,
	18585,
	18586,
	18587,
	18588,
	18589,
	18590,
	18591,
	18592,
	18593,
	18594,
	18595,
	18596,
	18597,
	18598,
	18599,
	18600,
	18601,
	18602,
	18603,
	18604,
	18605,
	18606,
	18607,
	18608,
	18609,
	18610,
	18611,
	18612,
	18613,
	18614,
	18615,
	18616,
	18617,
	18618,
	18619,
	18620,
	18621,
	18622,
	18623,
	18624,
	18625,
	18626,
	18627,
	18628,
	18629,
	18630,
	18631,
	18632,
	18633,
	18634,
	18635,
	18636,
	18637,
	18638,
	18639,
	18640,
	18641,
	18642,
	18643,
	18644,
	18645,
	18646,
	18647,
	18648,
	18649,
	18650,
	18651,
	18652,
	18653,
	18654,
	18655,
	18656,
	18657,
	18658,
	18659,
	18660,
	18661,
	18662,
	18663,
	18664,
	18665,
	18666,
	18667,
	18668,
	18669,
	18670,
	18671,
	18672,
	18673,
	18674,
	18675,
	18676,
	18677,
	18678,
	18679,
	18680,
	18681,
	18682,
	18683,
	18684,
	18685,
	18686,
	18687,
	18688,
	18689,
	18690,
	18691,
	18692,
	18693,
	18694,
	18695,
	18696,
	18697,
	18698,
	18699,
	18700,
	18701,
	18702,
	18703,
	18704,
	18705,
	18706,
	18707,
	18708,
	18709,
	18710,
	18711,
	18712,
	18713,
	18714,
	18715,
	18716,
	18717,
	18718,
	18719,
	18720,
	18721,
	18722,
	18723,
	18724,
	18725,
	18726,
	18727,
	18728,
	18729,
	18730,
	18731,
	18732,
	18733,
	18734,
	18735,
	18736,
	18737,
	18738,
	18739,
	18740,
	18741,
	18742,
	18743,
	18744,
	18745,
	18746,
	18747,
	18748,
	18749,
	18750,
	18751,
	18752,
	18753,
	18754,
	18755,
	18756,
	18757,
	18758,
	18759,
	18760,
	18761,
	18762,
	18763,
	18764,
	18765,
	18766,
	18767,
	18768,
	18769,
	18770,
	18771,
	18772,
	18773,
	18774,
	18775,
	18776,
	18777,
	18778,
	18779,
	18780,
	18781,
	18782,
	18783,
	18784,
	18785,
	18786,
	18787,
	18788,
	18789,
	18790,
	18791,
	18792,
	18793,
	18794,
	18795,
	18796,
	18797,
	18798,
	18799,
	18800,
	18801,
	18802,
	18803,
	18804,
	18805,
	18806,
	18807,
	18808,
	18809,
	18810,
	18811,
	18812,
	18813,
	18814,
	18815,
	18816,
	18817,
	18818,
	18819,
	18820,
	18821,
	18822,
	18823,
	18824,
	18825,
	18826,
	18827,
	18828,
	18829,
	18830,
	18831,
	18832,
	18833,
	18834,
	18835,
	18836,
	18837,
	18838,
	18839,
	18840,
	18841,
	18842,
	18843,
	18844,
	18845,
	18846,
	18847,
	18848,
	18849,
	18850,
	18851,
	18852,
	18853,
	18854,
	18855,
	18856,
	18857,
	18858,
	18859,
	18860,
	18861,
	18862,
	18863,
	18864,
	18865,
	18866,
	18867,
	18868,
	18869,
	18870,
	18871,
	18872,
	18873,
	18874,
	18875,
	18876,
	18877,
	18878,
	18879,
	18880,
	18881,
	18882,
	18883,
	18884,
	18885,
	18886,
	18887,
	18888,
	18889,
	18890,
	18891,
	18892,
	18893,
	18894,
	18895,
	18896,
	18897,
	18898,
	18899,
	18900,
	18901,
	18902,
	18903,
	18904,
	18905,
	18906,
	18907,
	18908,
	18909,
	18910,
	18911,
	18912,
	18913,
	18914,
	18915,
	18916,
	18917,
	18918,
	18919,
	18920,
	18921,
	18922,
	18923,
	18924,
	18925,
	18926,
	18927,
	18928,
	18929,
	18930,
	18931,
	18932,
	18933,
	18934,
	18935,
	18936,
	18937,
	18938,
	18939,
	18940,
	18941,
	18942,
	18943,
	18944,
	18945,
	18946,
	18947,
	18948,
	18949,
	18950,
	18951,
	18952,
	18953,
	18954,
	18955,
	18956,
	18957,
	18958,
	18959,
	18960,
	18961,
	18962,
	18963,
	18964,
	18965,
	18966,
	18967,
	18968,
	18969,
	18970,
	18971,
	18972,
	18973,
	18974,
	18975,
	18976,
	18977,
	18978,
	18979,
	18980,
	18981,
	18982,
	18983,
	18984,
	18985,
	18986,
	18987,
	18988,
	18989,
	18990,
	18991,
	18992,
	18993,
	18994,
	18995,
	18996,
	18997,
	18998,
	18999,
	19000,
	19001,
	19002,
	19003,
	19004,
	19005,
	19006,
	19007,
	19008,
	19009,
	19010,
	19011,
	19012,
	19013,
	19014,
	19015,
	19016,
	19017,
	19018,
	19019,
	19020,
	19021,
	19022,
	19023,
	19024,
	19025,
	19026,
	19027,
	19028,
	19029,
	19030,
	19031,
	19032,
	19033,
	19034,
	19035,
	19036,
	19037,
	19038,
	19039,
	19040,
	19041,
	19042,
	19043,
	19044,
	19045,
	19046,
	19047,
	19048,
	19049,
	19050,
	19051,
	19052,
	19053,
	19054,
	19055,
	19056,
	19057,
	19058,
	19059,
	19060,
	19061,
	19062,
	19063,
	19064,
	19065,
	19066,
	19067,
	19068,
	19069,
	19070,
	19071,
	19072,
	19073,
	19074,
	19075,
	19076,
	19077,
	19078,
	19079,
	19080,
	19081,
	19082,
	19083,
	19084,
	19085,
	19086,
	19087,
	19088,
	19089,
	19090,
	19091,
	19092,
	19093,
	19094,
	19095,
	19096,
	19097,
	19098,
	19099,
	19100,
	19101,
	19102,
	19103,
	19104,
	19105,
	19106,
	19107,
	19108,
	19109,
	19110,
	19111,
	19112,
	19113,
	19114,
	19115,
	19116,
	19117,
	19118,
	19119,
	19120,
	19121,
	19122,
	19123,
	19124,
	19125,
	19126,
	19127,
	19128,
	19129,
	19130,
	19131,
	19132,
	19133,
	19134,
	19135,
	19136,
	19137,
	19138,
	19139,
	19140,
	19141,
	19142,
	19143,
	19144,
	19145,
	19146,
	19147,
	19148,
	19149,
	19150,
	19151,
	19152,
	19153,
	19154,
	19155,
	19156,
	19157,
	19158,
	19159,
	19160,
	19161,
	19162,
	19163,
	19164,
	19165,
	19166,
	19167,
	19168,
	19169,
	19170,
	19171,
	19172,
	19173,
	19174,
	19175,
	19176,
	19177,
	19178,
	19179,
	19180,
	19181,
	19182,
	19183,
	19184,
	19185,
	19186,
	19187,
	19188,
	19189,
	19190,
	19191,
	19192,
	19193,
	19194,
	19195,
	19196,
	19197,
	19198,
	19199,
	19200,
	19201,
	19202,
	19203,
	19204,
	19205,
	19206,
	19207,
	19208,
	19209,
	19210,
	19211,
	19212,
	19213,
	19214,
	19215,
	19216,
	19217,
	19218,
	19219,
	19220,
	19221,
	19222,
	19223,
	19224,
	19225,
	19226,
	19227,
	19228,
	19229,
	19230,
	19231,
	19232,
	19233,
	19234,
	19235,
	19236,
	19237,
	19238,
	19239,
	19240,
	19241,
	19242,
	19243,
	19244,
	19245,
	19246,
	19247,
	19248,
	19249,
	19250,
	19251,
	19252,
	19253,
	19254,
	19255,
	19256,
	19257,
	19258,
	19259,
	19260,
	19261,
	19262,
	19263,
	19264,
	19265,
	19266,
	19267,
	19268,
	19269,
	19270,
	19271,
	19272,
	19273,
	19274,
	19275,
	19276,
	19277,
	19278,
	19279,
	19280,
	19281,
	19282,
	19283,
	19284,
	19285,
	19286,
	19287,
	19288,
	19289,
	19290,
	19291,
	19292,
	19293,
	19294,
	19295,
	19296,
	19297,
	19298,
	19299,
	19300,
	19301,
	19302,
	19303,
	19304,
	19305,
	19306,
	19307,
	19308,
	19309,
	19310,
	19311,
	19312,
	19313,
	19314,
	19315,
	19316,
	19317,
	19318,
	19319,
	19320,
	19321,
	19322,
	19323,
	19324,
	19325,
	19326,
	19327,
	19328,
	19329,
	19330,
	19331,
	19332,
	19333,
	19334,
	19335,
	19336,
	19337,
	19338,
	19339,
	19340,
	19341,
	19342,
	19343,
	19344,
	19345,
	19346,
	19347,
	19348,
	19349,
	19350,
	19351,
	19352,
	19353,
	19354,
	19355,
	19356,
	19357,
	19358,
	19359,
	19360,
	19361,
	19362,
	19363,
	19364,
	19365,
	19366,
	19367,
	19368,
	19369,
	19370,
	19371,
	19372,
	19373,
	19374,
	19375,
	19376,
	19377,
	19378,
	19379,
	19380,
	19381,
	19382,
	19383,
	19384,
	19385,
	19386,
	19387,
	19388,
	19389,
	19390,
	19391,
	19392,
	19393,
	19394,
	19395,
	19396,
	19397,
	19398,
	19399,
	19400,
	19401,
	19402,
	19403,
	19404,
	19405,
	19406,
	19407,
	19408,
	19409,
	19410,
	19411,
	19412,
	19413,
	19414,
	19415,
	19416,
	19417,
	19418,
	19419,
	19420,
	19421,
	19422,
	19423,
	19424,
	19425,
	19426,
	19427,
	19428,
	19429,
	19430,
	19431,
	19432,
	19433,
	19434,
	19435,
	19436,
	19437,
	19438,
	19439,
	19440,
	19441,
	19442,
	19443,
	19444,
	19445,
	19446,
	19447,
	19448,
	19449,
	19450,
	19451,
	19452,
	19453,
	19454,
	19455,
	19456,
	19457,
	19458,
	19459,
	19460,
	19461,
	19462,
	19463,
	19464,
	19465,
	19466,
	19467,
	19468,
	19469,
	19470,
	19471,
	19472,
	19473,
	19474,
	19475,
	19476,
	19477,
	19478,
	19479,
	19480,
	19481,
	19482,
	19483,
	19484,
	19485,
	19486,
	19487,
	19488,
	19489,
	19490,
	19491,
	19492,
	19493,
	19494,
	19495,
	19496,
	19497,
	19498,
	19499,
	19500,
	19501,
	19502,
	19503,
	19504,
	19505,
	19506,
	19507,
	19508,
	19509,
	19510,
	19511,
	19512,
	19513,
	19514,
	19515,
	19516,
	19517,
	19518,
	19519,
	19520,
	19521,
	19522,
	19523,
	19524,
	19525,
	19526,
	19527,
	19528,
	19529,
	19530,
	19531,
	19532,
	19533,
	19534,
	19535,
	19536,
	19537,
	19538,
	19539,
	19540,
	19541,
	19542,
	19543,
	19544,
	19545,
	19546,
	19547,
	19548,
	19549,
	19550,
	19551,
	19552,
	19553,
	19554,
	19555,
	19556,
	19557,
	19558,
	19559,
	19560,
	19561,
	19562,
	19563,
	19564,
	19565,
	19566,
	19567,
	19568,
	19569,
	19570,
	19571,
	19572,
	19573,
	19574,
	19575,
	19576,
	19577,
	19578,
	19579,
	19580,
	19581,
	19582,
	19583,
	19584,
	19585,
	19586,
	19587,
	19588,
	19589,
	19590,
	19591,
	19592,
	19593,
	19594,
	19595,
	19596,
	19597,
	19598,
	19599,
	19600,
	19601,
	19602,
	19603,
	19604,
	19605,
	19606,
	19607,
	19608,
	19609,
	19610,
	19611,
	19612,
	19613,
	19614,
	19615,
	19616,
	19617,
	19618,
	19619,
	19620,
	19621,
	19622,
	19623,
	19624,
	19625,
	19626,
	19627,
	19628,
	19629,
	19630,
	19631,
	19632,
	19633,
	19634,
	19635,
	19636,
	19637,
	19638,
	19639,
	19640,
	19641,
	19642,
	19643,
	19644,
	19645,
	19646,
	19647,
	19648,
	19649,
	19650,
	19651,
	19652,
	19653,
	19654,
	19655,
	19656,
	19657,
	19658,
	19659,
	19660,
	19661,
	19662,
	19663,
	19664,
	19665,
	19666,
	19667,
	19668,
	19669,
	19670,
	19671,
	19672,
	19673,
	19674,
	19675,
	19676,
	19677,
	19678,
	19679,
	19680,
	19681,
	19682,
	19683,
	19684,
	19685,
	19686,
	19687,
	19688,
	19689,
	19690,
	19691,
	19692,
	19693,
	19694,
	19695,
	19696,
	19697,
	19698,
	19699,
	19700,
	19701,
	19702,
	19703,
	19704,
	19705,
	19706,
	19707,
	19708,
	19709,
	19710,
	19711,
	19712,
	19713,
	19714,
	19715,
	19716,
	19717,
	19718,
	19719,
	19720,
	19721,
	19722,
	19723,
	19724,
	19725,
	19726,
	19727,
	19728,
	19729,
	19730,
	19731,
	19732,
	19733,
	19734,
	19735,
	19736,
	19737,
	19738,
	19739,
	19740,
	19741,
	19742,
	19743,
	19744,
	19745,
	19746,
	19747,
	19748,
	19749,
	19750,
	19751,
	19752,
	19753,
	19754,
	19755,
	19756,
	19757,
	19758,
	19759,
	19760,
	19761,
	19762,
	19763,
	19764,
	19765,
	19766,
	19767,
	19768,
	19769,
	19770,
	19771,
	19772,
	19773,
	19774,
	19775,
	19776,
	19777,
	19778,
	19779,
	19780,
	19781,
	19782,
	19783,
	19784,
	19785,
	19786,
	19787,
	19788,
	19789,
	19790,
	19791,
	19792,
	19793,
	19794,
	19795,
	19796,
	19797,
	19798,
	19799,
	19800,
	19801,
	19802,
	19803,
	19804,
	19805,
	19806,
	19807,
	19808,
	19809,
	19810,
	19811,
	19812,
	19813,
	19814,
	19815,
	19816,
	19817,
	19818,
	19819,
	19820,
	19821,
	19822,
	19823,
	19824,
	19825,
	19826,
	19827,
	19828,
	19829,
	19830,
	19831,
	19832,
	19833,
	19834,
	19835,
	19836,
	19837,
	19838,
	19839,
	19840,
	19841,
	19842,
	19843,
	19844,
	19845,
	19846,
	19847,
	19848,
	19849,
	19850,
	19851,
	19852,
	19853,
	19854,
	19855,
	19856,
	19857,
	19858,
	19859,
	19860,
	19861,
	19862,
	19863,
	19864,
	19865,
	19866,
	19867,
	19868,
	19869,
	19870,
	19871,
	19872,
	19873,
	19874,
	19875,
	19876,
	19877,
	19878,
	19879,
	19880,
	19881,
	19882,
	19883,
	19884,
	19885,
	19886,
	19887,
	19888,
	19889,
	19890,
	19891,
	19892,
	19893,
	19968,
	19969,
	19970,
	19971,
	19972,
	19973,
	19974,
	19975,
	19976,
	19977,
	19978,
	19979,
	19980,
	19981,
	19982,
	19983,
	19984,
	19985,
	19986,
	19987,
	19988,
	19989,
	19990,
	19991,
	19992,
	19993,
	19994,
	19995,
	19996,
	19997,
	19998,
	19999,
	20000,
	20001,
	20002,
	20003,
	20004,
	20005,
	20006,
	20007,
	20008,
	20009,
	20010,
	20011,
	20012,
	20013,
	20014,
	20015,
	20016,
	20017,
	20018,
	20019,
	20020,
	20021,
	20022,
	20023,
	20024,
	20025,
	20026,
	20027,
	20028,
	20029,
	20030,
	20031,
	20032,
	20033,
	20034,
	20035,
	20036,
	20037,
	20038,
	20039,
	20040,
	20041,
	20042,
	20043,
	20044,
	20045,
	20046,
	20047,
	20048,
	20049,
	20050,
	20051,
	20052,
	20053,
	20054,
	20055,
	20056,
	20057,
	20058,
	20059,
	20060,
	20061,
	20062,
	20063,
	20064,
	20065,
	20066,
	20067,
	20068,
	20069,
	20070,
	20071,
	20072,
	20073,
	20074,
	20075,
	20076,
	20077,
	20078,
	20079,
	20080,
	20081,
	20082,
	20083,
	20084,
	20085,
	20086,
	20087,
	20088,
	20089,
	20090,
	20091,
	20092,
	20093,
	20094,
	20095,
	20096,
	20097,
	20098,
	20099,
	20100,
	20101,
	20102,
	20103,
	20104,
	20105,
	20106,
	20107,
	20108,
	20109,
	20110,
	20111,
	20112,
	20113,
	20114,
	20115,
	20116,
	20117,
	20118,
	20119,
	20120,
	20121,
	20122,
	20123,
	20124,
	20125,
	20126,
	20127,
	20128,
	20129,
	20130,
	20131,
	20132,
	20133,
	20134,
	20135,
	20136,
	20137,
	20138,
	20139,
	20140,
	20141,
	20142,
	20143,
	20144,
	20145,
	20146,
	20147,
	20148,
	20149,
	20150,
	20151,
	20152,
	20153,
	20154,
	20155,
	20156,
	20157,
	20158,
	20159,
	20160,
	20161,
	20162,
	20163,
	20164,
	20165,
	20166,
	20167,
	20168,
	20169,
	20170,
	20171,
	20172,
	20173,
	20174,
	20175,
	20176,
	20177,
	20178,
	20179,
	20180,
	20181,
	20182,
	20183,
	20184,
	20185,
	20186,
	20187,
	20188,
	20189,
	20190,
	20191,
	20192,
	20193,
	20194,
	20195,
	20196,
	20197,
	20198,
	20199,
	20200,
	20201,
	20202,
	20203,
	20204,
	20205,
	20206,
	20207,
	20208,
	20209,
	20210,
	20211,
	20212,
	20213,
	20214,
	20215,
	20216,
	20217,
	20218,
	20219,
	20220,
	20221,
	20222,
	20223,
	20224,
	20225,
	20226,
	20227,
	20228,
	20229,
	20230,
	20231,
	20232,
	20233,
	20234,
	20235,
	20236,
	20237,
	20238,
	20239,
	20240,
	20241,
	20242,
	20243,
	20244,
	20245,
	20246,
	20247,
	20248,
	20249,
	20250,
	20251,
	20252,
	20253,
	20254,
	20255,
	20256,
	20257,
	20258,
	20259,
	20260,
	20261,
	20262,
	20263,
	20264,
	20265,
	20266,
	20267,
	20268,
	20269,
	20270,
	20271,
	20272,
	20273,
	20274,
	20275,
	20276,
	20277,
	20278,
	20279,
	20280,
	20281,
	20282,
	20283,
	20284,
	20285,
	20286,
	20287,
	20288,
	20289,
	20290,
	20291,
	20292,
	20293,
	20294,
	20295,
	20296,
	20297,
	20298,
	20299,
	20300,
	20301,
	20302,
	20303,
	20304,
	20305,
	20306,
	20307,
	20308,
	20309,
	20310,
	20311,
	20312,
	20313,
	20314,
	20315,
	20316,
	20317,
	20318,
	20319,
	20320,
	20321,
	20322,
	20323,
	20324,
	20325,
	20326,
	20327,
	20328,
	20329,
	20330,
	20331,
	20332,
	20333,
	20334,
	20335,
	20336,
	20337,
	20338,
	20339,
	20340,
	20341,
	20342,
	20343,
	20344,
	20345,
	20346,
	20347,
	20348,
	20349,
	20350,
	20351,
	20352,
	20353,
	20354,
	20355,
	20356,
	20357,
	20358,
	20359,
	20360,
	20361,
	20362,
	20363,
	20364,
	20365,
	20366,
	20367,
	20368,
	20369,
	20370,
	20371,
	20372,
	20373,
	20374,
	20375,
	20376,
	20377,
	20378,
	20379,
	20380,
	20381,
	20382,
	20383,
	20384,
	20385,
	20386,
	20387,
	20388,
	20389,
	20390,
	20391,
	20392,
	20393,
	20394,
	20395,
	20396,
	20397,
	20398,
	20399,
	20400,
	20401,
	20402,
	20403,
	20404,
	20405,
	20406,
	20407,
	20408,
	20409,
	20410,
	20411,
	20412,
	20413,
	20414,
	20415,
	20416,
	20417,
	20418,
	20419,
	20420,
	20421,
	20422,
	20423,
	20424,
	20425,
	20426,
	20427,
	20428,
	20429,
	20430,
	20431,
	20432,
	20433,
	20434,
	20435,
	20436,
	20437,
	20438,
	20439,
	20440,
	20441,
	20442,
	20443,
	20444,
	20445,
	20446,
	20447,
	20448,
	20449,
	20450,
	20451,
	20452,
	20453,
	20454,
	20455,
	20456,
	20457,
	20458,
	20459,
	20460,
	20461,
	20462,
	20463,
	20464,
	20465,
	20466,
	20467,
	20468,
	20469,
	20470,
	20471,
	20472,
	20473,
	20474,
	20475,
	20476,
	20477,
	20478,
	20479,
	20480,
	20481,
	20482,
	20483,
	20484,
	20485,
	20486,
	20487,
	20488,
	20489,
	20490,
	20491,
	20492,
	20493,
	20494,
	20495,
	20496,
	20497,
	20498,
	20499,
	20500,
	20501,
	20502,
	20503,
	20504,
	20505,
	20506,
	20507,
	20508,
	20509,
	20510,
	20511,
	20512,
	20513,
	20514,
	20515,
	20516,
	20517,
	20518,
	20519,
	20520,
	20521,
	20522,
	20523,
	20524,
	20525,
	20526,
	20527,
	20528,
	20529,
	20530,
	20531,
	20532,
	20533,
	20534,
	20535,
	20536,
	20537,
	20538,
	20539,
	20540,
	20541,
	20542,
	20543,
	20544,
	20545,
	20546,
	20547,
	20548,
	20549,
	20550,
	20551,
	20552,
	20553,
	20554,
	20555,
	20556,
	20557,
	20558,
	20559,
	20560,
	20561,
	20562,
	20563,
	20564,
	20565,
	20566,
	20567,
	20568,
	20569,
	20570,
	20571,
	20572,
	20573,
	20574,
	20575,
	20576,
	20577,
	20578,
	20579,
	20580,
	20581,
	20582,
	20583,
	20584,
	20585,
	20586,
	20587,
	20588,
	20589,
	20590,
	20591,
	20592,
	20593,
	20594,
	20595,
	20596,
	20597,
	20598,
	20599,
	20600,
	20601,
	20602,
	20603,
	20604,
	20605,
	20606,
	20607,
	20608,
	20609,
	20610,
	20611,
	20612,
	20613,
	20614,
	20615,
	20616,
	20617,
	20618,
	20619,
	20620,
	20621,
	20622,
	20623,
	20624,
	20625,
	20626,
	20627,
	20628,
	20629,
	20630,
	20631,
	20632,
	20633,
	20634,
	20635,
	20636,
	20637,
	20638,
	20639,
	20640,
	20641,
	20642,
	20643,
	20644,
	20645,
	20646,
	20647,
	20648,
	20649,
	20650,
	20651,
	20652,
	20653,
	20654,
	20655,
	20656,
	20657,
	20658,
	20659,
	20660,
	20661,
	20662,
	20663,
	20664,
	20665,
	20666,
	20667,
	20668,
	20669,
	20670,
	20671,
	20672,
	20673,
	20674,
	20675,
	20676,
	20677,
	20678,
	20679,
	20680,
	20681,
	20682,
	20683,
	20684,
	20685,
	20686,
	20687,
	20688,
	20689,
	20690,
	20691,
	20692,
	20693,
	20694,
	20695,
	20696,
	20697,
	20698,
	20699,
	20700,
	20701,
	20702,
	20703,
	20704,
	20705,
	20706,
	20707,
	20708,
	20709,
	20710,
	20711,
	20712,
	20713,
	20714,
	20715,
	20716,
	20717,
	20718,
	20719,
	20720,
	20721,
	20722,
	20723,
	20724,
	20725,
	20726,
	20727,
	20728,
	20729,
	20730,
	20731,
	20732,
	20733,
	20734,
	20735,
	20736,
	20737,
	20738,
	20739,
	20740,
	20741,
	20742,
	20743,
	20744,
	20745,
	20746,
	20747,
	20748,
	20749,
	20750,
	20751,
	20752,
	20753,
	20754,
	20755,
	20756,
	20757,
	20758,
	20759,
	20760,
	20761,
	20762,
	20763,
	20764,
	20765,
	20766,
	20767,
	20768,
	20769,
	20770,
	20771,
	20772,
	20773,
	20774,
	20775,
	20776,
	20777,
	20778,
	20779,
	20780,
	20781,
	20782,
	20783,
	20784,
	20785,
	20786,
	20787,
	20788,
	20789,
	20790,
	20791,
	20792,
	20793,
	20794,
	20795,
	20796,
	20797,
	20798,
	20799,
	20800,
	20801,
	20802,
	20803,
	20804,
	20805,
	20806,
	20807,
	20808,
	20809,
	20810,
	20811,
	20812,
	20813,
	20814,
	20815,
	20816,
	20817,
	20818,
	20819,
	20820,
	20821,
	20822,
	20823,
	20824,
	20825,
	20826,
	20827,
	20828,
	20829,
	20830,
	20831,
	20832,
	20833,
	20834,
	20835,
	20836,
	20837,
	20838,
	20839,
	20840,
	20841,
	20842,
	20843,
	20844,
	20845,
	20846,
	20847,
	20848,
	20849,
	20850,
	20851,
	20852,
	20853,
	20854,
	20855,
	20856,
	20857,
	20858,
	20859,
	20860,
	20861,
	20862,
	20863,
	20864,
	20865,
	20866,
	20867,
	20868,
	20869,
	20870,
	20871,
	20872,
	20873,
	20874,
	20875,
	20876,
	20877,
	20878,
	20879,
	20880,
	20881,
	20882,
	20883,
	20884,
	20885,
	20886,
	20887,
	20888,
	20889,
	20890,
	20891,
	20892,
	20893,
	20894,
	20895,
	20896,
	20897,
	20898,
	20899,
	20900,
	20901,
	20902,
	20903,
	20904,
	20905,
	20906,
	20907,
	20908,
	20909,
	20910,
	20911,
	20912,
	20913,
	20914,
	20915,
	20916,
	20917,
	20918,
	20919,
	20920,
	20921,
	20922,
	20923,
	20924,
	20925,
	20926,
	20927,
	20928,
	20929,
	20930,
	20931,
	20932,
	20933,
	20934,
	20935,
	20936,
	20937,
	20938,
	20939,
	20940,
	20941,
	20942,
	20943,
	20944,
	20945,
	20946,
	20947,
	20948,
	20949,
	20950,
	20951,
	20952,
	20953,
	20954,
	20955,
	20956,
	20957,
	20958,
	20959,
	20960,
	20961,
	20962,
	20963,
	20964,
	20965,
	20966,
	20967,
	20968,
	20969,
	20970,
	20971,
	20972,
	20973,
	20974,
	20975,
	20976,
	20977,
	20978,
	20979,
	20980,
	20981,
	20982,
	20983,
	20984,
	20985,
	20986,
	20987,
	20988,
	20989,
	20990,
	20991,
	20992,
	20993,
	20994,
	20995,
	20996,
	20997,
	20998,
	20999,
	21000,
	21001,
	21002,
	21003,
	21004,
	21005,
	21006,
	21007,
	21008,
	21009,
	21010,
	21011,
	21012,
	21013,
	21014,
	21015,
	21016,
	21017,
	21018,
	21019,
	21020,
	21021,
	21022,
	21023,
	21024,
	21025,
	21026,
	21027,
	21028,
	21029,
	21030,
	21031,
	21032,
	21033,
	21034,
	21035,
	21036,
	21037,
	21038,
	21039,
	21040,
	21041,
	21042,
	21043,
	21044,
	21045,
	21046,
	21047,
	21048,
	21049,
	21050,
	21051,
	21052,
	21053,
	21054,
	21055,
	21056,
	21057,
	21058,
	21059,
	21060,
	21061,
	21062,
	21063,
	21064,
	21065,
	21066,
	21067,
	21068,
	21069,
	21070,
	21071,
	21072,
	21073,
	21074,
	21075,
	21076,
	21077,
	21078,
	21079,
	21080,
	21081,
	21082,
	21083,
	21084,
	21085,
	21086,
	21087,
	21088,
	21089,
	21090,
	21091,
	21092,
	21093,
	21094,
	21095,
	21096,
	21097,
	21098,
	21099,
	21100,
	21101,
	21102,
	21103,
	21104,
	21105,
	21106,
	21107,
	21108,
	21109,
	21110,
	21111,
	21112,
	21113,
	21114,
	21115,
	21116,
	21117,
	21118,
	21119,
	21120,
	21121,
	21122,
	21123,
	21124,
	21125,
	21126,
	21127,
	21128,
	21129,
	21130,
	21131,
	21132,
	21133,
	21134,
	21135,
	21136,
	21137,
	21138,
	21139,
	21140,
	21141,
	21142,
	21143,
	21144,
	21145,
	21146,
	21147,
	21148,
	21149,
	21150,
	21151,
	21152,
	21153,
	21154,
	21155,
	21156,
	21157,
	21158,
	21159,
	21160,
	21161,
	21162,
	21163,
	21164,
	21165,
	21166,
	21167,
	21168,
	21169,
	21170,
	21171,
	21172,
	21173,
	21174,
	21175,
	21176,
	21177,
	21178,
	21179,
	21180,
	21181,
	21182,
	21183,
	21184,
	21185,
	21186,
	21187,
	21188,
	21189,
	21190,
	21191,
	21192,
	21193,
	21194,
	21195,
	21196,
	21197,
	21198,
	21199,
	21200,
	21201,
	21202,
	21203,
	21204,
	21205,
	21206,
	21207,
	21208,
	21209,
	21210,
	21211,
	21212,
	21213,
	21214,
	21215,
	21216,
	21217,
	21218,
	21219,
	21220,
	21221,
	21222,
	21223,
	21224,
	21225,
	21226,
	21227,
	21228,
	21229,
	21230,
	21231,
	21232,
	21233,
	21234,
	21235,
	21236,
	21237,
	21238,
	21239,
	21240,
	21241,
	21242,
	21243,
	21244,
	21245,
	21246,
	21247,
	21248,
	21249,
	21250,
	21251,
	21252,
	21253,
	21254,
	21255,
	21256,
	21257,
	21258,
	21259,
	21260,
	21261,
	21262,
	21263,
	21264,
	21265,
	21266,
	21267,
	21268,
	21269,
	21270,
	21271,
	21272,
	21273,
	21274,
	21275,
	21276,
	21277,
	21278,
	21279,
	21280,
	21281,
	21282,
	21283,
	21284,
	21285,
	21286,
	21287,
	21288,
	21289,
	21290,
	21291,
	21292,
	21293,
	21294,
	21295,
	21296,
	21297,
	21298,
	21299,
	21300,
	21301,
	21302,
	21303,
	21304,
	21305,
	21306,
	21307,
	21308,
	21309,
	21310,
	21311,
	21312,
	21313,
	21314,
	21315,
	21316,
	21317,
	21318,
	21319,
	21320,
	21321,
	21322,
	21323,
	21324,
	21325,
	21326,
	21327,
	21328,
	21329,
	21330,
	21331,
	21332,
	21333,
	21334,
	21335,
	21336,
	21337,
	21338,
	21339,
	21340,
	21341,
	21342,
	21343,
	21344,
	21345,
	21346,
	21347,
	21348,
	21349,
	21350,
	21351,
	21352,
	21353,
	21354,
	21355,
	21356,
	21357,
	21358,
	21359,
	21360,
	21361,
	21362,
	21363,
	21364,
	21365,
	21366,
	21367,
	21368,
	21369,
	21370,
	21371,
	21372,
	21373,
	21374,
	21375,
	21376,
	21377,
	21378,
	21379,
	21380,
	21381,
	21382,
	21383,
	21384,
	21385,
	21386,
	21387,
	21388,
	21389,
	21390,
	21391,
	21392,
	21393,
	21394,
	21395,
	21396,
	21397,
	21398,
	21399,
	21400,
	21401,
	21402,
	21403,
	21404,
	21405,
	21406,
	21407,
	21408,
	21409,
	21410,
	21411,
	21412,
	21413,
	21414,
	21415,
	21416,
	21417,
	21418,
	21419,
	21420,
	21421,
	21422,
	21423,
	21424,
	21425,
	21426,
	21427,
	21428,
	21429,
	21430,
	21431,
	21432,
	21433,
	21434,
	21435,
	21436,
	21437,
	21438,
	21439,
	21440,
	21441,
	21442,
	21443,
	21444,
	21445,
	21446,
	21447,
	21448,
	21449,
	21450,
	21451,
	21452,
	21453,
	21454,
	21455,
	21456,
	21457,
	21458,
	21459,
	21460,
	21461,
	21462,
	21463,
	21464,
	21465,
	21466,
	21467,
	21468,
	21469,
	21470,
	21471,
	21472,
	21473,
	21474,
	21475,
	21476,
	21477,
	21478,
	21479,
	21480,
	21481,
	21482,
	21483,
	21484,
	21485,
	21486,
	21487,
	21488,
	21489,
	21490,
	21491,
	21492,
	21493,
	21494,
	21495,
	21496,
	21497,
	21498,
	21499,
	21500,
	21501,
	21502,
	21503,
	21504,
	21505,
	21506,
	21507,
	21508,
	21509,
	21510,
	21511,
	21512,
	21513,
	21514,
	21515,
	21516,
	21517,
	21518,
	21519,
	21520,
	21521,
	21522,
	21523,
	21524,
	21525,
	21526,
	21527,
	21528,
	21529,
	21530,
	21531,
	21532,
	21533,
	21534,
	21535,
	21536,
	21537,
	21538,
	21539,
	21540,
	21541,
	21542,
	21543,
	21544,
	21545,
	21546,
	21547,
	21548,
	21549,
	21550,
	21551,
	21552,
	21553,
	21554,
	21555,
	21556,
	21557,
	21558,
	21559,
	21560,
	21561,
	21562,
	21563,
	21564,
	21565,
	21566,
	21567,
	21568,
	21569,
	21570,
	21571,
	21572,
	21573,
	21574,
	21575,
	21576,
	21577,
	21578,
	21579,
	21580,
	21581,
	21582,
	21583,
	21584,
	21585,
	21586,
	21587,
	21588,
	21589,
	21590,
	21591,
	21592,
	21593,
	21594,
	21595,
	21596,
	21597,
	21598,
	21599,
	21600,
	21601,
	21602,
	21603,
	21604,
	21605,
	21606,
	21607,
	21608,
	21609,
	21610,
	21611,
	21612,
	21613,
	21614,
	21615,
	21616,
	21617,
	21618,
	21619,
	21620,
	21621,
	21622,
	21623,
	21624,
	21625,
	21626,
	21627,
	21628,
	21629,
	21630,
	21631,
	21632,
	21633,
	21634,
	21635,
	21636,
	21637,
	21638,
	21639,
	21640,
	21641,
	21642,
	21643,
	21644,
	21645,
	21646,
	21647,
	21648,
	21649,
	21650,
	21651,
	21652,
	21653,
	21654,
	21655,
	21656,
	21657,
	21658,
	21659,
	21660,
	21661,
	21662,
	21663,
	21664,
	21665,
	21666,
	21667,
	21668,
	21669,
	21670,
	21671,
	21672,
	21673,
	21674,
	21675,
	21676,
	21677,
	21678,
	21679,
	21680,
	21681,
	21682,
	21683,
	21684,
	21685,
	21686,
	21687,
	21688,
	21689,
	21690,
	21691,
	21692,
	21693,
	21694,
	21695,
	21696,
	21697,
	21698,
	21699,
	21700,
	21701,
	21702,
	21703,
	21704,
	21705,
	21706,
	21707,
	21708,
	21709,
	21710,
	21711,
	21712,
	21713,
	21714,
	21715,
	21716,
	21717,
	21718,
	21719,
	21720,
	21721,
	21722,
	21723,
	21724,
	21725,
	21726,
	21727,
	21728,
	21729,
	21730,
	21731,
	21732,
	21733,
	21734,
	21735,
	21736,
	21737,
	21738,
	21739,
	21740,
	21741,
	21742,
	21743,
	21744,
	21745,
	21746,
	21747,
	21748,
	21749,
	21750,
	21751,
	21752,
	21753,
	21754,
	21755,
	21756,
	21757,
	21758,
	21759,
	21760,
	21761,
	21762,
	21763,
	21764,
	21765,
	21766,
	21767,
	21768,
	21769,
	21770,
	21771,
	21772,
	21773,
	21774,
	21775,
	21776,
	21777,
	21778,
	21779,
	21780,
	21781,
	21782,
	21783,
	21784,
	21785,
	21786,
	21787,
	21788,
	21789,
	21790,
	21791,
	21792,
	21793,
	21794,
	21795,
	21796,
	21797,
	21798,
	21799,
	21800,
	21801,
	21802,
	21803,
	21804,
	21805,
	21806,
	21807,
	21808,
	21809,
	21810,
	21811,
	21812,
	21813,
	21814,
	21815,
	21816,
	21817,
	21818,
	21819,
	21820,
	21821,
	21822,
	21823,
	21824,
	21825,
	21826,
	21827,
	21828,
	21829,
	21830,
	21831,
	21832,
	21833,
	21834,
	21835,
	21836,
	21837,
	21838,
	21839,
	21840,
	21841,
	21842,
	21843,
	21844,
	21845,
	21846,
	21847,
	21848,
	21849,
	21850,
	21851,
	21852,
	21853,
	21854,
	21855,
	21856,
	21857,
	21858,
	21859,
	21860,
	21861,
	21862,
	21863,
	21864,
	21865,
	21866,
	21867,
	21868,
	21869,
	21870,
	21871,
	21872,
	21873,
	21874,
	21875,
	21876,
	21877,
	21878,
	21879,
	21880,
	21881,
	21882,
	21883,
	21884,
	21885,
	21886,
	21887,
	21888,
	21889,
	21890,
	21891,
	21892,
	21893,
	21894,
	21895,
	21896,
	21897,
	21898,
	21899,
	21900,
	21901,
	21902,
	21903,
	21904,
	21905,
	21906,
	21907,
	21908,
	21909,
	21910,
	21911,
	21912,
	21913,
	21914,
	21915,
	21916,
	21917,
	21918,
	21919,
	21920,
	21921,
	21922,
	21923,
	21924,
	21925,
	21926,
	21927,
	21928,
	21929,
	21930,
	21931,
	21932,
	21933,
	21934,
	21935,
	21936,
	21937,
	21938,
	21939,
	21940,
	21941,
	21942,
	21943,
	21944,
	21945,
	21946,
	21947,
	21948,
	21949,
	21950,
	21951,
	21952,
	21953,
	21954,
	21955,
	21956,
	21957,
	21958,
	21959,
	21960,
	21961,
	21962,
	21963,
	21964,
	21965,
	21966,
	21967,
	21968,
	21969,
	21970,
	21971,
	21972,
	21973,
	21974,
	21975,
	21976,
	21977,
	21978,
	21979,
	21980,
	21981,
	21982,
	21983,
	21984,
	21985,
	21986,
	21987,
	21988,
	21989,
	21990,
	21991,
	21992,
	21993,
	21994,
	21995,
	21996,
	21997,
	21998,
	21999,
	22000,
	22001,
	22002,
	22003,
	22004,
	22005,
	22006,
	22007,
	22008,
	22009,
	22010,
	22011,
	22012,
	22013,
	22014,
	22015,
	22016,
	22017,
	22018,
	22019,
	22020,
	22021,
	22022,
	22023,
	22024,
	22025,
	22026,
	22027,
	22028,
	22029,
	22030,
	22031,
	22032,
	22033,
	22034,
	22035,
	22036,
	22037,
	22038,
	22039,
	22040,
	22041,
	22042,
	22043,
	22044,
	22045,
	22046,
	22047,
	22048,
	22049,
	22050,
	22051,
	22052,
	22053,
	22054,
	22055,
	22056,
	22057,
	22058,
	22059,
	22060,
	22061,
	22062,
	22063,
	22064,
	22065,
	22066,
	22067,
	22068,
	22069,
	22070,
	22071,
	22072,
	22073,
	22074,
	22075,
	22076,
	22077,
	22078,
	22079,
	22080,
	22081,
	22082,
	22083,
	22084,
	22085,
	22086,
	22087,
	22088,
	22089,
	22090,
	22091,
	22092,
	22093,
	22094,
	22095,
	22096,
	22097,
	22098,
	22099,
	22100,
	22101,
	22102,
	22103,
	22104,
	22105,
	22106,
	22107,
	22108,
	22109,
	22110,
	22111,
	22112,
	22113,
	22114,
	22115,
	22116,
	22117,
	22118,
	22119,
	22120,
	22121,
	22122,
	22123,
	22124,
	22125,
	22126,
	22127,
	22128,
	22129,
	22130,
	22131,
	22132,
	22133,
	22134,
	22135,
	22136,
	22137,
	22138,
	22139,
	22140,
	22141,
	22142,
	22143,
	22144,
	22145,
	22146,
	22147,
	22148,
	22149,
	22150,
	22151,
	22152,
	22153,
	22154,
	22155,
	22156,
	22157,
	22158,
	22159,
	22160,
	22161,
	22162,
	22163,
	22164,
	22165,
	22166,
	22167,
	22168,
	22169,
	22170,
	22171,
	22172,
	22173,
	22174,
	22175,
	22176,
	22177,
	22178,
	22179,
	22180,
	22181,
	22182,
	22183,
	22184,
	22185,
	22186,
	22187,
	22188,
	22189,
	22190,
	22191,
	22192,
	22193,
	22194,
	22195,
	22196,
	22197,
	22198,
	22199,
	22200,
	22201,
	22202,
	22203,
	22204,
	22205,
	22206,
	22207,
	22208,
	22209,
	22210,
	22211,
	22212,
	22213,
	22214,
	22215,
	22216,
	22217,
	22218,
	22219,
	22220,
	22221,
	22222,
	22223,
	22224,
	22225,
	22226,
	22227,
	22228,
	22229,
	22230,
	22231,
	22232,
	22233,
	22234,
	22235,
	22236,
	22237,
	22238,
	22239,
	22240,
	22241,
	22242,
	22243,
	22244,
	22245,
	22246,
	22247,
	22248,
	22249,
	22250,
	22251,
	22252,
	22253,
	22254,
	22255,
	22256,
	22257,
	22258,
	22259,
	22260,
	22261,
	22262,
	22263,
	22264,
	22265,
	22266,
	22267,
	22268,
	22269,
	22270,
	22271,
	22272,
	22273,
	22274,
	22275,
	22276,
	22277,
	22278,
	22279,
	22280,
	22281,
	22282,
	22283,
	22284,
	22285,
	22286,
	22287,
	22288,
	22289,
	22290,
	22291,
	22292,
	22293,
	22294,
	22295,
	22296,
	22297,
	22298,
	22299,
	22300,
	22301,
	22302,
	22303,
	22304,
	22305,
	22306,
	22307,
	22308,
	22309,
	22310,
	22311,
	22312,
	22313,
	22314,
	22315,
	22316,
	22317,
	22318,
	22319,
	22320,
	22321,
	22322,
	22323,
	22324,
	22325,
	22326,
	22327,
	22328,
	22329,
	22330,
	22331,
	22332,
	22333,
	22334,
	22335,
	22336,
	22337,
	22338,
	22339,
	22340,
	22341,
	22342,
	22343,
	22344,
	22345,
	22346,
	22347,
	22348,
	22349,
	22350,
	22351,
	22352,
	22353,
	22354,
	22355,
	22356,
	22357,
	22358,
	22359,
	22360,
	22361,
	22362,
	22363,
	22364,
	22365,
	22366,
	22367,
	22368,
	22369,
	22370,
	22371,
	22372,
	22373,
	22374,
	22375,
	22376,
	22377,
	22378,
	22379,
	22380,
	22381,
	22382,
	22383,
	22384,
	22385,
	22386,
	22387,
	22388,
	22389,
	22390,
	22391,
	22392,
	22393,
	22394,
	22395,
	22396,
	22397,
	22398,
	22399,
	22400,
	22401,
	22402,
	22403,
	22404,
	22405,
	22406,
	22407,
	22408,
	22409,
	22410,
	22411,
	22412,
	22413,
	22414,
	22415,
	22416,
	22417,
	22418,
	22419,
	22420,
	22421,
	22422,
	22423,
	22424,
	22425,
	22426,
	22427,
	22428,
	22429,
	22430,
	22431,
	22432,
	22433,
	22434,
	22435,
	22436,
	22437,
	22438,
	22439,
	22440,
	22441,
	22442,
	22443,
	22444,
	22445,
	22446,
	22447,
	22448,
	22449,
	22450,
	22451,
	22452,
	22453,
	22454,
	22455,
	22456,
	22457,
	22458,
	22459,
	22460,
	22461,
	22462,
	22463,
	22464,
	22465,
	22466,
	22467,
	22468,
	22469,
	22470,
	22471,
	22472,
	22473,
	22474,
	22475,
	22476,
	22477,
	22478,
	22479,
	22480,
	22481,
	22482,
	22483,
	22484,
	22485,
	22486,
	22487,
	22488,
	22489,
	22490,
	22491,
	22492,
	22493,
	22494,
	22495,
	22496,
	22497,
	22498,
	22499,
	22500,
	22501,
	22502,
	22503,
	22504,
	22505,
	22506,
	22507,
	22508,
	22509,
	22510,
	22511,
	22512,
	22513,
	22514,
	22515,
	22516,
	22517,
	22518,
	22519,
	22520,
	22521,
	22522,
	22523,
	22524,
	22525,
	22526,
	22527,
	22528,
	22529,
	22530,
	22531,
	22532,
	22533,
	22534,
	22535,
	22536,
	22537,
	22538,
	22539,
	22540,
	22541,
	22542,
	22543,
	22544,
	22545,
	22546,
	22547,
	22548,
	22549,
	22550,
	22551,
	22552,
	22553,
	22554,
	22555,
	22556,
	22557,
	22558,
	22559,
	22560,
	22561,
	22562,
	22563,
	22564,
	22565,
	22566,
	22567,
	22568,
	22569,
	22570,
	22571,
	22572,
	22573,
	22574,
	22575,
	22576,
	22577,
	22578,
	22579,
	22580,
	22581,
	22582,
	22583,
	22584,
	22585,
	22586,
	22587,
	22588,
	22589,
	22590,
	22591,
	22592,
	22593,
	22594,
	22595,
	22596,
	22597,
	22598,
	22599,
	22600,
	22601,
	22602,
	22603,
	22604,
	22605,
	22606,
	22607,
	22608,
	22609,
	22610,
	22611,
	22612,
	22613,
	22614,
	22615,
	22616,
	22617,
	22618,
	22619,
	22620,
	22621,
	22622,
	22623,
	22624,
	22625,
	22626,
	22627,
	22628,
	22629,
	22630,
	22631,
	22632,
	22633,
	22634,
	22635,
	22636,
	22637,
	22638,
	22639,
	22640,
	22641,
	22642,
	22643,
	22644,
	22645,
	22646,
	22647,
	22648,
	22649,
	22650,
	22651,
	22652,
	22653,
	22654,
	22655,
	22656,
	22657,
	22658,
	22659,
	22660,
	22661,
	22662,
	22663,
	22664,
	22665,
	22666,
	22667,
	22668,
	22669,
	22670,
	22671,
	22672,
	22673,
	22674,
	22675,
	22676,
	22677,
	22678,
	22679,
	22680,
	22681,
	22682,
	22683,
	22684,
	22685,
	22686,
	22687,
	22688,
	22689,
	22690,
	22691,
	22692,
	22693,
	22694,
	22695,
	22696,
	22697,
	22698,
	22699,
	22700,
	22701,
	22702,
	22703,
	22704,
	22705,
	22706,
	22707,
	22708,
	22709,
	22710,
	22711,
	22712,
	22713,
	22714,
	22715,
	22716,
	22717,
	22718,
	22719,
	22720,
	22721,
	22722,
	22723,
	22724,
	22725,
	22726,
	22727,
	22728,
	22729,
	22730,
	22731,
	22732,
	22733,
	22734,
	22735,
	22736,
	22737,
	22738,
	22739,
	22740,
	22741,
	22742,
	22743,
	22744,
	22745,
	22746,
	22747,
	22748,
	22749,
	22750,
	22751,
	22752,
	22753,
	22754,
	22755,
	22756,
	22757,
	22758,
	22759,
	22760,
	22761,
	22762,
	22763,
	22764,
	22765,
	22766,
	22767,
	22768,
	22769,
	22770,
	22771,
	22772,
	22773,
	22774,
	22775,
	22776,
	22777,
	22778,
	22779,
	22780,
	22781,
	22782,
	22783,
	22784,
	22785,
	22786,
	22787,
	22788,
	22789,
	22790,
	22791,
	22792,
	22793,
	22794,
	22795,
	22796,
	22797,
	22798,
	22799,
	22800,
	22801,
	22802,
	22803,
	22804,
	22805,
	22806,
	22807,
	22808,
	22809,
	22810,
	22811,
	22812,
	22813,
	22814,
	22815,
	22816,
	22817,
	22818,
	22819,
	22820,
	22821,
	22822,
	22823,
	22824,
	22825,
	22826,
	22827,
	22828,
	22829,
	22830,
	22831,
	22832,
	22833,
	22834,
	22835,
	22836,
	22837,
	22838,
	22839,
	22840,
	22841,
	22842,
	22843,
	22844,
	22845,
	22846,
	22847,
	22848,
	22849,
	22850,
	22851,
	22852,
	22853,
	22854,
	22855,
	22856,
	22857,
	22858,
	22859,
	22860,
	22861,
	22862,
	22863,
	22864,
	22865,
	22866,
	22867,
	22868,
	22869,
	22870,
	22871,
	22872,
	22873,
	22874,
	22875,
	22876,
	22877,
	22878,
	22879,
	22880,
	22881,
	22882,
	22883,
	22884,
	22885,
	22886,
	22887,
	22888,
	22889,
	22890,
	22891,
	22892,
	22893,
	22894,
	22895,
	22896,
	22897,
	22898,
	22899,
	22900,
	22901,
	22902,
	22903,
	22904,
	22905,
	22906,
	22907,
	22908,
	22909,
	22910,
	22911,
	22912,
	22913,
	22914,
	22915,
	22916,
	22917,
	22918,
	22919,
	22920,
	22921,
	22922,
	22923,
	22924,
	22925,
	22926,
	22927,
	22928,
	22929,
	22930,
	22931,
	22932,
	22933,
	22934,
	22935,
	22936,
	22937,
	22938,
	22939,
	22940,
	22941,
	22942,
	22943,
	22944,
	22945,
	22946,
	22947,
	22948,
	22949,
	22950,
	22951,
	22952,
	22953,
	22954,
	22955,
	22956,
	22957,
	22958,
	22959,
	22960,
	22961,
	22962,
	22963,
	22964,
	22965,
	22966,
	22967,
	22968,
	22969,
	22970,
	22971,
	22972,
	22973,
	22974,
	22975,
	22976,
	22977,
	22978,
	22979,
	22980,
	22981,
	22982,
	22983,
	22984,
	22985,
	22986,
	22987,
	22988,
	22989,
	22990,
	22991,
	22992,
	22993,
	22994,
	22995,
	22996,
	22997,
	22998,
	22999,
	23000,
	23001,
	23002,
	23003,
	23004,
	23005,
	23006,
	23007,
	23008,
	23009,
	23010,
	23011,
	23012,
	23013,
	23014,
	23015,
	23016,
	23017,
	23018,
	23019,
	23020,
	23021,
	23022,
	23023,
	23024,
	23025,
	23026,
	23027,
	23028,
	23029,
	23030,
	23031,
	23032,
	23033,
	23034,
	23035,
	23036,
	23037,
	23038,
	23039,
	23040,
	23041,
	23042,
	23043,
	23044,
	23045,
	23046,
	23047,
	23048,
	23049,
	23050,
	23051,
	23052,
	23053,
	23054,
	23055,
	23056,
	23057,
	23058,
	23059,
	23060,
	23061,
	23062,
	23063,
	23064,
	23065,
	23066,
	23067,
	23068,
	23069,
	23070,
	23071,
	23072,
	23073,
	23074,
	23075,
	23076,
	23077,
	23078,
	23079,
	23080,
	23081,
	23082,
	23083,
	23084,
	23085,
	23086,
	23087,
	23088,
	23089,
	23090,
	23091,
	23092,
	23093,
	23094,
	23095,
	23096,
	23097,
	23098,
	23099,
	23100,
	23101,
	23102,
	23103,
	23104,
	23105,
	23106,
	23107,
	23108,
	23109,
	23110,
	23111,
	23112,
	23113,
	23114,
	23115,
	23116,
	23117,
	23118,
	23119,
	23120,
	23121,
	23122,
	23123,
	23124,
	23125,
	23126,
	23127,
	23128,
	23129,
	23130,
	23131,
	23132,
	23133,
	23134,
	23135,
	23136,
	23137,
	23138,
	23139,
	23140,
	23141,
	23142,
	23143,
	23144,
	23145,
	23146,
	23147,
	23148,
	23149,
	23150,
	23151,
	23152,
	23153,
	23154,
	23155,
	23156,
	23157,
	23158,
	23159,
	23160,
	23161,
	23162,
	23163,
	23164,
	23165,
	23166,
	23167,
	23168,
	23169,
	23170,
	23171,
	23172,
	23173,
	23174,
	23175,
	23176,
	23177,
	23178,
	23179,
	23180,
	23181,
	23182,
	23183,
	23184,
	23185,
	23186,
	23187,
	23188,
	23189,
	23190,
	23191,
	23192,
	23193,
	23194,
	23195,
	23196,
	23197,
	23198,
	23199,
	23200,
	23201,
	23202,
	23203,
	23204,
	23205,
	23206,
	23207,
	23208,
	23209,
	23210,
	23211,
	23212,
	23213,
	23214,
	23215,
	23216,
	23217,
	23218,
	23219,
	23220,
	23221,
	23222,
	23223,
	23224,
	23225,
	23226,
	23227,
	23228,
	23229,
	23230,
	23231,
	23232,
	23233,
	23234,
	23235,
	23236,
	23237,
	23238,
	23239,
	23240,
	23241,
	23242,
	23243,
	23244,
	23245,
	23246,
	23247,
	23248,
	23249,
	23250,
	23251,
	23252,
	23253,
	23254,
	23255,
	23256,
	23257,
	23258,
	23259,
	23260,
	23261,
	23262,
	23263,
	23264,
	23265,
	23266,
	23267,
	23268,
	23269,
	23270,
	23271,
	23272,
	23273,
	23274,
	23275,
	23276,
	23277,
	23278,
	23279,
	23280,
	23281,
	23282,
	23283,
	23284,
	23285,
	23286,
	23287,
	23288,
	23289,
	23290,
	23291,
	23292,
	23293,
	23294,
	23295,
	23296,
	23297,
	23298,
	23299,
	23300,
	23301,
	23302,
	23303,
	23304,
	23305,
	23306,
	23307,
	23308,
	23309,
	23310,
	23311,
	23312,
	23313,
	23314,
	23315,
	23316,
	23317,
	23318,
	23319,
	23320,
	23321,
	23322,
	23323,
	23324,
	23325,
	23326,
	23327,
	23328,
	23329,
	23330,
	23331,
	23332,
	23333,
	23334,
	23335,
	23336,
	23337,
	23338,
	23339,
	23340,
	23341,
	23342,
	23343,
	23344,
	23345,
	23346,
	23347,
	23348,
	23349,
	23350,
	23351,
	23352,
	23353,
	23354,
	23355,
	23356,
	23357,
	23358,
	23359,
	23360,
	23361,
	23362,
	23363,
	23364,
	23365,
	23366,
	23367,
	23368,
	23369,
	23370,
	23371,
	23372,
	23373,
	23374,
	23375,
	23376,
	23377,
	23378,
	23379,
	23380,
	23381,
	23382,
	23383,
	23384,
	23385,
	23386,
	23387,
	23388,
	23389,
	23390,
	23391,
	23392,
	23393,
	23394,
	23395,
	23396,
	23397,
	23398,
	23399,
	23400,
	23401,
	23402,
	23403,
	23404,
	23405,
	23406,
	23407,
	23408,
	23409,
	23410,
	23411,
	23412,
	23413,
	23414,
	23415,
	23416,
	23417,
	23418,
	23419,
	23420,
	23421,
	23422,
	23423,
	23424,
	23425,
	23426,
	23427,
	23428,
	23429,
	23430,
	23431,
	23432,
	23433,
	23434,
	23435,
	23436,
	23437,
	23438,
	23439,
	23440,
	23441,
	23442,
	23443,
	23444,
	23445,
	23446,
	23447,
	23448,
	23449,
	23450,
	23451,
	23452,
	23453,
	23454,
	23455,
	23456,
	23457,
	23458,
	23459,
	23460,
	23461,
	23462,
	23463,
	23464,
	23465,
	23466,
	23467,
	23468,
	23469,
	23470,
	23471,
	23472,
	23473,
	23474,
	23475,
	23476,
	23477,
	23478,
	23479,
	23480,
	23481,
	23482,
	23483,
	23484,
	23485,
	23486,
	23487,
	23488,
	23489,
	23490,
	23491,
	23492,
	23493,
	23494,
	23495,
	23496,
	23497,
	23498,
	23499,
	23500,
	23501,
	23502,
	23503,
	23504,
	23505,
	23506,
	23507,
	23508,
	23509,
	23510,
	23511,
	23512,
	23513,
	23514,
	23515,
	23516,
	23517,
	23518,
	23519,
	23520,
	23521,
	23522,
	23523,
	23524,
	23525,
	23526,
	23527,
	23528,
	23529,
	23530,
	23531,
	23532,
	23533,
	23534,
	23535,
	23536,
	23537,
	23538,
	23539,
	23540,
	23541,
	23542,
	23543,
	23544,
	23545,
	23546,
	23547,
	23548,
	23549,
	23550,
	23551,
	23552,
	23553,
	23554,
	23555,
	23556,
	23557,
	23558,
	23559,
	23560,
	23561,
	23562,
	23563,
	23564,
	23565,
	23566,
	23567,
	23568,
	23569,
	23570,
	23571,
	23572,
	23573,
	23574,
	23575,
	23576,
	23577,
	23578,
	23579,
	23580,
	23581,
	23582,
	23583,
	23584,
	23585,
	23586,
	23587,
	23588,
	23589,
	23590,
	23591,
	23592,
	23593,
	23594,
	23595,
	23596,
	23597,
	23598,
	23599,
	23600,
	23601,
	23602,
	23603,
	23604,
	23605,
	23606,
	23607,
	23608,
	23609,
	23610,
	23611,
	23612,
	23613,
	23614,
	23615,
	23616,
	23617,
	23618,
	23619,
	23620,
	23621,
	23622,
	23623,
	23624,
	23625,
	23626,
	23627,
	23628,
	23629,
	23630,
	23631,
	23632,
	23633,
	23634,
	23635,
	23636,
	23637,
	23638,
	23639,
	23640,
	23641,
	23642,
	23643,
	23644,
	23645,
	23646,
	23647,
	23648,
	23649,
	23650,
	23651,
	23652,
	23653,
	23654,
	23655,
	23656,
	23657,
	23658,
	23659,
	23660,
	23661,
	23662,
	23663,
	23664,
	23665,
	23666,
	23667,
	23668,
	23669,
	23670,
	23671,
	23672,
	23673,
	23674,
	23675,
	23676,
	23677,
	23678,
	23679,
	23680,
	23681,
	23682,
	23683,
	23684,
	23685,
	23686,
	23687,
	23688,
	23689,
	23690,
	23691,
	23692,
	23693,
	23694,
	23695,
	23696,
	23697,
	23698,
	23699,
	23700,
	23701,
	23702,
	23703,
	23704,
	23705,
	23706,
	23707,
	23708,
	23709,
	23710,
	23711,
	23712,
	23713,
	23714,
	23715,
	23716,
	23717,
	23718,
	23719,
	23720,
	23721,
	23722,
	23723,
	23724,
	23725,
	23726,
	23727,
	23728,
	23729,
	23730,
	23731,
	23732,
	23733,
	23734,
	23735,
	23736,
	23737,
	23738,
	23739,
	23740,
	23741,
	23742,
	23743,
	23744,
	23745,
	23746,
	23747,
	23748,
	23749,
	23750,
	23751,
	23752,
	23753,
	23754,
	23755,
	23756,
	23757,
	23758,
	23759,
	23760,
	23761,
	23762,
	23763,
	23764,
	23765,
	23766,
	23767,
	23768,
	23769,
	23770,
	23771,
	23772,
	23773,
	23774,
	23775,
	23776,
	23777,
	23778,
	23779,
	23780,
	23781,
	23782,
	23783,
	23784,
	23785,
	23786,
	23787,
	23788,
	23789,
	23790,
	23791,
	23792,
	23793,
	23794,
	23795,
	23796,
	23797,
	23798,
	23799,
	23800,
	23801,
	23802,
	23803,
	23804,
	23805,
	23806,
	23807,
	23808,
	23809,
	23810,
	23811,
	23812,
	23813,
	23814,
	23815,
	23816,
	23817,
	23818,
	23819,
	23820,
	23821,
	23822,
	23823,
	23824,
	23825,
	23826,
	23827,
	23828,
	23829,
	23830,
	23831,
	23832,
	23833,
	23834,
	23835,
	23836,
	23837,
	23838,
	23839,
	23840,
	23841,
	23842,
	23843,
	23844,
	23845,
	23846,
	23847,
	23848,
	23849,
	23850,
	23851,
	23852,
	23853,
	23854,
	23855,
	23856,
	23857,
	23858,
	23859,
	23860,
	23861,
	23862,
	23863,
	23864,
	23865,
	23866,
	23867,
	23868,
	23869,
	23870,
	23871,
	23872,
	23873,
	23874,
	23875,
	23876,
	23877,
	23878,
	23879,
	23880,
	23881,
	23882,
	23883,
	23884,
	23885,
	23886,
	23887,
	23888,
	23889,
	23890,
	23891,
	23892,
	23893,
	23894,
	23895,
	23896,
	23897,
	23898,
	23899,
	23900,
	23901,
	23902,
	23903,
	23904,
	23905,
	23906,
	23907,
	23908,
	23909,
	23910,
	23911,
	23912,
	23913,
	23914,
	23915,
	23916,
	23917,
	23918,
	23919,
	23920,
	23921,
	23922,
	23923,
	23924,
	23925,
	23926,
	23927,
	23928,
	23929,
	23930,
	23931,
	23932,
	23933,
	23934,
	23935,
	23936,
	23937,
	23938,
	23939,
	23940,
	23941,
	23942,
	23943,
	23944,
	23945,
	23946,
	23947,
	23948,
	23949,
	23950,
	23951,
	23952,
	23953,
	23954,
	23955,
	23956,
	23957,
	23958,
	23959,
	23960,
	23961,
	23962,
	23963,
	23964,
	23965,
	23966,
	23967,
	23968,
	23969,
	23970,
	23971,
	23972,
	23973,
	23974,
	23975,
	23976,
	23977,
	23978,
	23979,
	23980,
	23981,
	23982,
	23983,
	23984,
	23985,
	23986,
	23987,
	23988,
	23989,
	23990,
	23991,
	23992,
	23993,
	23994,
	23995,
	23996,
	23997,
	23998,
	23999,
	24000,
	24001,
	24002,
	24003,
	24004,
	24005,
	24006,
	24007,
	24008,
	24009,
	24010,
	24011,
	24012,
	24013,
	24014,
	24015,
	24016,
	24017,
	24018,
	24019,
	24020,
	24021,
	24022,
	24023,
	24024,
	24025,
	24026,
	24027,
	24028,
	24029,
	24030,
	24031,
	24032,
	24033,
	24034,
	24035,
	24036,
	24037,
	24038,
	24039,
	24040,
	24041,
	24042,
	24043,
	24044,
	24045,
	24046,
	24047,
	24048,
	24049,
	24050,
	24051,
	24052,
	24053,
	24054,
	24055,
	24056,
	24057,
	24058,
	24059,
	24060,
	24061,
	24062,
	24063,
	24064,
	24065,
	24066,
	24067,
	24068,
	24069,
	24070,
	24071,
	24072,
	24073,
	24074,
	24075,
	24076,
	24077,
	24078,
	24079,
	24080,
	24081,
	24082,
	24083,
	24084,
	24085,
	24086,
	24087,
	24088,
	24089,
	24090,
	24091,
	24092,
	24093,
	24094,
	24095,
	24096,
	24097,
	24098,
	24099,
	24100,
	24101,
	24102,
	24103,
	24104,
	24105,
	24106,
	24107,
	24108,
	24109,
	24110,
	24111,
	24112,
	24113,
	24114,
	24115,
	24116,
	24117,
	24118,
	24119,
	24120,
	24121,
	24122,
	24123,
	24124,
	24125,
	24126,
	24127,
	24128,
	24129,
	24130,
	24131,
	24132,
	24133,
	24134,
	24135,
	24136,
	24137,
	24138,
	24139,
	24140,
	24141,
	24142,
	24143,
	24144,
	24145,
	24146,
	24147,
	24148,
	24149,
	24150,
	24151,
	24152,
	24153,
	24154,
	24155,
	24156,
	24157,
	24158,
	24159,
	24160,
	24161,
	24162,
	24163,
	24164,
	24165,
	24166,
	24167,
	24168,
	24169,
	24170,
	24171,
	24172,
	24173,
	24174,
	24175,
	24176,
	24177,
	24178,
	24179,
	24180,
	24181,
	24182,
	24183,
	24184,
	24185,
	24186,
	24187,
	24188,
	24189,
	24190,
	24191,
	24192,
	24193,
	24194,
	24195,
	24196,
	24197,
	24198,
	24199,
	24200,
	24201,
	24202,
	24203,
	24204,
	24205,
	24206,
	24207,
	24208,
	24209,
	24210,
	24211,
	24212,
	24213,
	24214,
	24215,
	24216,
	24217,
	24218,
	24219,
	24220,
	24221,
	24222,
	24223,
	24224,
	24225,
	24226,
	24227,
	24228,
	24229,
	24230,
	24231,
	24232,
	24233,
	24234,
	24235,
	24236,
	24237,
	24238,
	24239,
	24240,
	24241,
	24242,
	24243,
	24244,
	24245,
	24246,
	24247,
	24248,
	24249,
	24250,
	24251,
	24252,
	24253,
	24254,
	24255,
	24256,
	24257,
	24258,
	24259,
	24260,
	24261,
	24262,
	24263,
	24264,
	24265,
	24266,
	24267,
	24268,
	24269,
	24270,
	24271,
	24272,
	24273,
	24274,
	24275,
	24276,
	24277,
	24278,
	24279,
	24280,
	24281,
	24282,
	24283,
	24284,
	24285,
	24286,
	24287,
	24288,
	24289,
	24290,
	24291,
	24292,
	24293,
	24294,
	24295,
	24296,
	24297,
	24298,
	24299,
	24300,
	24301,
	24302,
	24303,
	24304,
	24305,
	24306,
	24307,
	24308,
	24309,
	24310,
	24311,
	24312,
	24313,
	24314,
	24315,
	24316,
	24317,
	24318,
	24319,
	24320,
	24321,
	24322,
	24323,
	24324,
	24325,
	24326,
	24327,
	24328,
	24329,
	24330,
	24331,
	24332,
	24333,
	24334,
	24335,
	24336,
	24337,
	24338,
	24339,
	24340,
	24341,
	24342,
	24343,
	24344,
	24345,
	24346,
	24347,
	24348,
	24349,
	24350,
	24351,
	24352,
	24353,
	24354,
	24355,
	24356,
	24357,
	24358,
	24359,
	24360,
	24361,
	24362,
	24363,
	24364,
	24365,
	24366,
	24367,
	24368,
	24369,
	24370,
	24371,
	24372,
	24373,
	24374,
	24375,
	24376,
	24377,
	24378,
	24379,
	24380,
	24381,
	24382,
	24383,
	24384,
	24385,
	24386,
	24387,
	24388,
	24389,
	24390,
	24391,
	24392,
	24393,
	24394,
	24395,
	24396,
	24397,
	24398,
	24399,
	24400,
	24401,
	24402,
	24403,
	24404,
	24405,
	24406,
	24407,
	24408,
	24409,
	24410,
	24411,
	24412,
	24413,
	24414,
	24415,
	24416,
	24417,
	24418,
	24419,
	24420,
	24421,
	24422,
	24423,
	24424,
	24425,
	24426,
	24427,
	24428,
	24429,
	24430,
	24431,
	24432,
	24433,
	24434,
	24435,
	24436,
	24437,
	24438,
	24439,
	24440,
	24441,
	24442,
	24443,
	24444,
	24445,
	24446,
	24447,
	24448,
	24449,
	24450,
	24451,
	24452,
	24453,
	24454,
	24455,
	24456,
	24457,
	24458,
	24459,
	24460,
	24461,
	24462,
	24463,
	24464,
	24465,
	24466,
	24467,
	24468,
	24469,
	24470,
	24471,
	24472,
	24473,
	24474,
	24475,
	24476,
	24477,
	24478,
	24479,
	24480,
	24481,
	24482,
	24483,
	24484,
	24485,
	24486,
	24487,
	24488,
	24489,
	24490,
	24491,
	24492,
	24493,
	24494,
	24495,
	24496,
	24497,
	24498,
	24499,
	24500,
	24501,
	24502,
	24503,
	24504,
	24505,
	24506,
	24507,
	24508,
	24509,
	24510,
	24511,
	24512,
	24513,
	24514,
	24515,
	24516,
	24517,
	24518,
	24519,
	24520,
	24521,
	24522,
	24523,
	24524,
	24525,
	24526,
	24527,
	24528,
	24529,
	24530,
	24531,
	24532,
	24533,
	24534,
	24535,
	24536,
	24537,
	24538,
	24539,
	24540,
	24541,
	24542,
	24543,
	24544,
	24545,
	24546,
	24547,
	24548,
	24549,
	24550,
	24551,
	24552,
	24553,
	24554,
	24555,
	24556,
	24557,
	24558,
	24559,
	24560,
	24561,
	24562,
	24563,
	24564,
	24565,
	24566,
	24567,
	24568,
	24569,
	24570,
	24571,
	24572,
	24573,
	24574,
	24575,
	24576,
	24577,
	24578,
	24579,
	24580,
	24581,
	24582,
	24583,
	24584,
	24585,
	24586,
	24587,
	24588,
	24589,
	24590,
	24591,
	24592,
	24593,
	24594,
	24595,
	24596,
	24597,
	24598,
	24599,
	24600,
	24601,
	24602,
	24603,
	24604,
	24605,
	24606,
	24607,
	24608,
	24609,
	24610,
	24611,
	24612,
	24613,
	24614,
	24615,
	24616,
	24617,
	24618,
	24619,
	24620,
	24621,
	24622,
	24623,
	24624,
	24625,
	24626,
	24627,
	24628,
	24629,
	24630,
	24631,
	24632,
	24633,
	24634,
	24635,
	24636,
	24637,
	24638,
	24639,
	24640,
	24641,
	24642,
	24643,
	24644,
	24645,
	24646,
	24647,
	24648,
	24649,
	24650,
	24651,
	24652,
	24653,
	24654,
	24655,
	24656,
	24657,
	24658,
	24659,
	24660,
	24661,
	24662,
	24663,
	24664,
	24665,
	24666,
	24667,
	24668,
	24669,
	24670,
	24671,
	24672,
	24673,
	24674,
	24675,
	24676,
	24677,
	24678,
	24679,
	24680,
	24681,
	24682,
	24683,
	24684,
	24685,
	24686,
	24687,
	24688,
	24689,
	24690,
	24691,
	24692,
	24693,
	24694,
	24695,
	24696,
	24697,
	24698,
	24699,
	24700,
	24701,
	24702,
	24703,
	24704,
	24705,
	24706,
	24707,
	24708,
	24709,
	24710,
	24711,
	24712,
	24713,
	24714,
	24715,
	24716,
	24717,
	24718,
	24719,
	24720,
	24721,
	24722,
	24723,
	24724,
	24725,
	24726,
	24727,
	24728,
	24729,
	24730,
	24731,
	24732,
	24733,
	24734,
	24735,
	24736,
	24737,
	24738,
	24739,
	24740,
	24741,
	24742,
	24743,
	24744,
	24745,
	24746,
	24747,
	24748,
	24749,
	24750,
	24751,
	24752,
	24753,
	24754,
	24755,
	24756,
	24757,
	24758,
	24759,
	24760,
	24761,
	24762,
	24763,
	24764,
	24765,
	24766,
	24767,
	24768,
	24769,
	24770,
	24771,
	24772,
	24773,
	24774,
	24775,
	24776,
	24777,
	24778,
	24779,
	24780,
	24781,
	24782,
	24783,
	24784,
	24785,
	24786,
	24787,
	24788,
	24789,
	24790,
	24791,
	24792,
	24793,
	24794,
	24795,
	24796,
	24797,
	24798,
	24799,
	24800,
	24801,
	24802,
	24803,
	24804,
	24805,
	24806,
	24807,
	24808,
	24809,
	24810,
	24811,
	24812,
	24813,
	24814,
	24815,
	24816,
	24817,
	24818,
	24819,
	24820,
	24821,
	24822,
	24823,
	24824,
	24825,
	24826,
	24827,
	24828,
	24829,
	24830,
	24831,
	24832,
	24833,
	24834,
	24835,
	24836,
	24837,
	24838,
	24839,
	24840,
	24841,
	24842,
	24843,
	24844,
	24845,
	24846,
	24847,
	24848,
	24849,
	24850,
	24851,
	24852,
	24853,
	24854,
	24855,
	24856,
	24857,
	24858,
	24859,
	24860,
	24861,
	24862,
	24863,
	24864,
	24865,
	24866,
	24867,
	24868,
	24869,
	24870,
	24871,
	24872,
	24873,
	24874,
	24875,
	24876,
	24877,
	24878,
	24879,
	24880,
	24881,
	24882,
	24883,
	24884,
	24885,
	24886,
	24887,
	24888,
	24889,
	24890,
	24891,
	24892,
	24893,
	24894,
	24895,
	24896,
	24897,
	24898,
	24899,
	24900,
	24901,
	24902,
	24903,
	24904,
	24905,
	24906,
	24907,
	24908,
	24909,
	24910,
	24911,
	24912,
	24913,
	24914,
	24915,
	24916,
	24917,
	24918,
	24919,
	24920,
	24921,
	24922,
	24923,
	24924,
	24925,
	24926,
	24927,
	24928,
	24929,
	24930,
	24931,
	24932,
	24933,
	24934,
	24935,
	24936,
	24937,
	24938,
	24939,
	24940,
	24941,
	24942,
	24943,
	24944,
	24945,
	24946,
	24947,
	24948,
	24949,
	24950,
	24951,
	24952,
	24953,
	24954,
	24955,
	24956,
	24957,
	24958,
	24959,
	24960,
	24961,
	24962,
	24963,
	24964,
	24965,
	24966,
	24967,
	24968,
	24969,
	24970,
	24971,
	24972,
	24973,
	24974,
	24975,
	24976,
	24977,
	24978,
	24979,
	24980,
	24981,
	24982,
	24983,
	24984,
	24985,
	24986,
	24987,
	24988,
	24989,
	24990,
	24991,
	24992,
	24993,
	24994,
	24995,
	24996,
	24997,
	24998,
	24999,
	25000,
	25001,
	25002,
	25003,
	25004,
	25005,
	25006,
	25007,
	25008,
	25009,
	25010,
	25011,
	25012,
	25013,
	25014,
	25015,
	25016,
	25017,
	25018,
	25019,
	25020,
	25021,
	25022,
	25023,
	25024,
	25025,
	25026,
	25027,
	25028,
	25029,
	25030,
	25031,
	25032,
	25033,
	25034,
	25035,
	25036,
	25037,
	25038,
	25039,
	25040,
	25041,
	25042,
	25043,
	25044,
	25045,
	25046,
	25047,
	25048,
	25049,
	25050,
	25051,
	25052,
	25053,
	25054,
	25055,
	25056,
	25057,
	25058,
	25059,
	25060,
	25061,
	25062,
	25063,
	25064,
	25065,
	25066,
	25067,
	25068,
	25069,
	25070,
	25071,
	25072,
	25073,
	25074,
	25075,
	25076,
	25077,
	25078,
	25079,
	25080,
	25081,
	25082,
	25083,
	25084,
	25085,
	25086,
	25087,
	25088,
	25089,
	25090,
	25091,
	25092,
	25093,
	25094,
	25095,
	25096,
	25097,
	25098,
	25099,
	25100,
	25101,
	25102,
	25103,
	25104,
	25105,
	25106,
	25107,
	25108,
	25109,
	25110,
	25111,
	25112,
	25113,
	25114,
	25115,
	25116,
	25117,
	25118,
	25119,
	25120,
	25121,
	25122,
	25123,
	25124,
	25125,
	25126,
	25127,
	25128,
	25129,
	25130,
	25131,
	25132,
	25133,
	25134,
	25135,
	25136,
	25137,
	25138,
	25139,
	25140,
	25141,
	25142,
	25143,
	25144,
	25145,
	25146,
	25147,
	25148,
	25149,
	25150,
	25151,
	25152,
	25153,
	25154,
	25155,
	25156,
	25157,
	25158,
	25159,
	25160,
	25161,
	25162,
	25163,
	25164,
	25165,
	25166,
	25167,
	25168,
	25169,
	25170,
	25171,
	25172,
	25173,
	25174,
	25175,
	25176,
	25177,
	25178,
	25179,
	25180,
	25181,
	25182,
	25183,
	25184,
	25185,
	25186,
	25187,
	25188,
	25189,
	25190,
	25191,
	25192,
	25193,
	25194,
	25195,
	25196,
	25197,
	25198,
	25199,
	25200,
	25201,
	25202,
	25203,
	25204,
	25205,
	25206,
	25207,
	25208,
	25209,
	25210,
	25211,
	25212,
	25213,
	25214,
	25215,
	25216,
	25217,
	25218,
	25219,
	25220,
	25221,
	25222,
	25223,
	25224,
	25225,
	25226,
	25227,
	25228,
	25229,
	25230,
	25231,
	25232,
	25233,
	25234,
	25235,
	25236,
	25237,
	25238,
	25239,
	25240,
	25241,
	25242,
	25243,
	25244,
	25245,
	25246,
	25247,
	25248,
	25249,
	25250,
	25251,
	25252,
	25253,
	25254,
	25255,
	25256,
	25257,
	25258,
	25259,
	25260,
	25261,
	25262,
	25263,
	25264,
	25265,
	25266,
	25267,
	25268,
	25269,
	25270,
	25271,
	25272,
	25273,
	25274,
	25275,
	25276,
	25277,
	25278,
	25279,
	25280,
	25281,
	25282,
	25283,
	25284,
	25285,
	25286,
	25287,
	25288,
	25289,
	25290,
	25291,
	25292,
	25293,
	25294,
	25295,
	25296,
	25297,
	25298,
	25299,
	25300,
	25301,
	25302,
	25303,
	25304,
	25305,
	25306,
	25307,
	25308,
	25309,
	25310,
	25311,
	25312,
	25313,
	25314,
	25315,
	25316,
	25317,
	25318,
	25319,
	25320,
	25321,
	25322,
	25323,
	25324,
	25325,
	25326,
	25327,
	25328,
	25329,
	25330,
	25331,
	25332,
	25333,
	25334,
	25335,
	25336,
	25337,
	25338,
	25339,
	25340,
	25341,
	25342,
	25343,
	25344,
	25345,
	25346,
	25347,
	25348,
	25349,
	25350,
	25351,
	25352,
	25353,
	25354,
	25355,
	25356,
	25357,
	25358,
	25359,
	25360,
	25361,
	25362,
	25363,
	25364,
	25365,
	25366,
	25367,
	25368,
	25369,
	25370,
	25371,
	25372,
	25373,
	25374,
	25375,
	25376,
	25377,
	25378,
	25379,
	25380,
	25381,
	25382,
	25383,
	25384,
	25385,
	25386,
	25387,
	25388,
	25389,
	25390,
	25391,
	25392,
	25393,
	25394,
	25395,
	25396,
	25397,
	25398,
	25399,
	25400,
	25401,
	25402,
	25403,
	25404,
	25405,
	25406,
	25407,
	25408,
	25409,
	25410,
	25411,
	25412,
	25413,
	25414,
	25415,
	25416,
	25417,
	25418,
	25419,
	25420,
	25421,
	25422,
	25423,
	25424,
	25425,
	25426,
	25427,
	25428,
	25429,
	25430,
	25431,
	25432,
	25433,
	25434,
	25435,
	25436,
	25437,
	25438,
	25439,
	25440,
	25441,
	25442,
	25443,
	25444,
	25445,
	25446,
	25447,
	25448,
	25449,
	25450,
	25451,
	25452,
	25453,
	25454,
	25455,
	25456,
	25457,
	25458,
	25459,
	25460,
	25461,
	25462,
	25463,
	25464,
	25465,
	25466,
	25467,
	25468,
	25469,
	25470,
	25471,
	25472,
	25473,
	25474,
	25475,
	25476,
	25477,
	25478,
	25479,
	25480,
	25481,
	25482,
	25483,
	25484,
	25485,
	25486,
	25487,
	25488,
	25489,
	25490,
	25491,
	25492,
	25493,
	25494,
	25495,
	25496,
	25497,
	25498,
	25499,
	25500,
	25501,
	25502,
	25503,
	25504,
	25505,
	25506,
	25507,
	25508,
	25509,
	25510,
	25511,
	25512,
	25513,
	25514,
	25515,
	25516,
	25517,
	25518,
	25519,
	25520,
	25521,
	25522,
	25523,
	25524,
	25525,
	25526,
	25527,
	25528,
	25529,
	25530,
	25531,
	25532,
	25533,
	25534,
	25535,
	25536,
	25537,
	25538,
	25539,
	25540,
	25541,
	25542,
	25543,
	25544,
	25545,
	25546,
	25547,
	25548,
	25549,
	25550,
	25551,
	25552,
	25553,
	25554,
	25555,
	25556,
	25557,
	25558,
	25559,
	25560,
	25561,
	25562,
	25563,
	25564,
	25565,
	25566,
	25567,
	25568,
	25569,
	25570,
	25571,
	25572,
	25573,
	25574,
	25575,
	25576,
	25577,
	25578,
	25579,
	25580,
	25581,
	25582,
	25583,
	25584,
	25585,
	25586,
	25587,
	25588,
	25589,
	25590,
	25591,
	25592,
	25593,
	25594,
	25595,
	25596,
	25597,
	25598,
	25599,
	25600,
	25601,
	25602,
	25603,
	25604,
	25605,
	25606,
	25607,
	25608,
	25609,
	25610,
	25611,
	25612,
	25613,
	25614,
	25615,
	25616,
	25617,
	25618,
	25619,
	25620,
	25621,
	25622,
	25623,
	25624,
	25625,
	25626,
	25627,
	25628,
	25629,
	25630,
	25631,
	25632,
	25633,
	25634,
	25635,
	25636,
	25637,
	25638,
	25639,
	25640,
	25641,
	25642,
	25643,
	25644,
	25645,
	25646,
	25647,
	25648,
	25649,
	25650,
	25651,
	25652,
	25653,
	25654,
	25655,
	25656,
	25657,
	25658,
	25659,
	25660,
	25661,
	25662,
	25663,
	25664,
	25665,
	25666,
	25667,
	25668,
	25669,
	25670,
	25671,
	25672,
	25673,
	25674,
	25675,
	25676,
	25677,
	25678,
	25679,
	25680,
	25681,
	25682,
	25683,
	25684,
	25685,
	25686,
	25687,
	25688,
	25689,
	25690,
	25691,
	25692,
	25693,
	25694,
	25695,
	25696,
	25697,
	25698,
	25699,
	25700,
	25701,
	25702,
	25703,
	25704,
	25705,
	25706,
	25707,
	25708,
	25709,
	25710,
	25711,
	25712,
	25713,
	25714,
	25715,
	25716,
	25717,
	25718,
	25719,
	25720,
	25721,
	25722,
	25723,
	25724,
	25725,
	25726,
	25727,
	25728,
	25729,
	25730,
	25731,
	25732,
	25733,
	25734,
	25735,
	25736,
	25737,
	25738,
	25739,
	25740,
	25741,
	25742,
	25743,
	25744,
	25745,
	25746,
	25747,
	25748,
	25749,
	25750,
	25751,
	25752,
	25753,
	25754,
	25755,
	25756,
	25757,
	25758,
	25759,
	25760,
	25761,
	25762,
	25763,
	25764,
	25765,
	25766,
	25767,
	25768,
	25769,
	25770,
	25771,
	25772,
	25773,
	25774,
	25775,
	25776,
	25777,
	25778,
	25779,
	25780,
	25781,
	25782,
	25783,
	25784,
	25785,
	25786,
	25787,
	25788,
	25789,
	25790,
	25791,
	25792,
	25793,
	25794,
	25795,
	25796,
	25797,
	25798,
	25799,
	25800,
	25801,
	25802,
	25803,
	25804,
	25805,
	25806,
	25807,
	25808,
	25809,
	25810,
	25811,
	25812,
	25813,
	25814,
	25815,
	25816,
	25817,
	25818,
	25819,
	25820,
	25821,
	25822,
	25823,
	25824,
	25825,
	25826,
	25827,
	25828,
	25829,
	25830,
	25831,
	25832,
	25833,
	25834,
	25835,
	25836,
	25837,
	25838,
	25839,
	25840,
	25841,
	25842,
	25843,
	25844,
	25845,
	25846,
	25847,
	25848,
	25849,
	25850,
	25851,
	25852,
	25853,
	25854,
	25855,
	25856,
	25857,
	25858,
	25859,
	25860,
	25861,
	25862,
	25863,
	25864,
	25865,
	25866,
	25867,
	25868,
	25869,
	25870,
	25871,
	25872,
	25873,
	25874,
	25875,
	25876,
	25877,
	25878,
	25879,
	25880,
	25881,
	25882,
	25883,
	25884,
	25885,
	25886,
	25887,
	25888,
	25889,
	25890,
	25891,
	25892,
	25893,
	25894,
	25895,
	25896,
	25897,
	25898,
	25899,
	25900,
	25901,
	25902,
	25903,
	25904,
	25905,
	25906,
	25907,
	25908,
	25909,
	25910,
	25911,
	25912,
	25913,
	25914,
	25915,
	25916,
	25917,
	25918,
	25919,
	25920,
	25921,
	25922,
	25923,
	25924,
	25925,
	25926,
	25927,
	25928,
	25929,
	25930,
	25931,
	25932,
	25933,
	25934,
	25935,
	25936,
	25937,
	25938,
	25939,
	25940,
	25941,
	25942,
	25943,
	25944,
	25945,
	25946,
	25947,
	25948,
	25949,
	25950,
	25951,
	25952,
	25953,
	25954,
	25955,
	25956,
	25957,
	25958,
	25959,
	25960,
	25961,
	25962,
	25963,
	25964,
	25965,
	25966,
	25967,
	25968,
	25969,
	25970,
	25971,
	25972,
	25973,
	25974,
	25975,
	25976,
	25977,
	25978,
	25979,
	25980,
	25981,
	25982,
	25983,
	25984,
	25985,
	25986,
	25987,
	25988,
	25989,
	25990,
	25991,
	25992,
	25993,
	25994,
	25995,
	25996,
	25997,
	25998,
	25999,
	26000,
	26001,
	26002,
	26003,
	26004,
	26005,
	26006,
	26007,
	26008,
	26009,
	26010,
	26011,
	26012,
	26013,
	26014,
	26015,
	26016,
	26017,
	26018,
	26019,
	26020,
	26021,
	26022,
	26023,
	26024,
	26025,
	26026,
	26027,
	26028,
	26029,
	26030,
	26031,
	26032,
	26033,
	26034,
	26035,
	26036,
	26037,
	26038,
	26039,
	26040,
	26041,
	26042,
	26043,
	26044,
	26045,
	26046,
	26047,
	26048,
	26049,
	26050,
	26051,
	26052,
	26053,
	26054,
	26055,
	26056,
	26057,
	26058,
	26059,
	26060,
	26061,
	26062,
	26063,
	26064,
	26065,
	26066,
	26067,
	26068,
	26069,
	26070,
	26071,
	26072,
	26073,
	26074,
	26075,
	26076,
	26077,
	26078,
	26079,
	26080,
	26081,
	26082,
	26083,
	26084,
	26085,
	26086,
	26087,
	26088,
	26089,
	26090,
	26091,
	26092,
	26093,
	26094,
	26095,
	26096,
	26097,
	26098,
	26099,
	26100,
	26101,
	26102,
	26103,
	26104,
	26105,
	26106,
	26107,
	26108,
	26109,
	26110,
	26111,
	26112,
	26113,
	26114,
	26115,
	26116,
	26117,
	26118,
	26119,
	26120,
	26121,
	26122,
	26123,
	26124,
	26125,
	26126,
	26127,
	26128,
	26129,
	26130,
	26131,
	26132,
	26133,
	26134,
	26135,
	26136,
	26137,
	26138,
	26139,
	26140,
	26141,
	26142,
	26143,
	26144,
	26145,
	26146,
	26147,
	26148,
	26149,
	26150,
	26151,
	26152,
	26153,
	26154,
	26155,
	26156,
	26157,
	26158,
	26159,
	26160,
	26161,
	26162,
	26163,
	26164,
	26165,
	26166,
	26167,
	26168,
	26169,
	26170,
	26171,
	26172,
	26173,
	26174,
	26175,
	26176,
	26177,
	26178,
	26179,
	26180,
	26181,
	26182,
	26183,
	26184,
	26185,
	26186,
	26187,
	26188,
	26189,
	26190,
	26191,
	26192,
	26193,
	26194,
	26195,
	26196,
	26197,
	26198,
	26199,
	26200,
	26201,
	26202,
	26203,
	26204,
	26205,
	26206,
	26207,
	26208,
	26209,
	26210,
	26211,
	26212,
	26213,
	26214,
	26215,
	26216,
	26217,
	26218,
	26219,
	26220,
	26221,
	26222,
	26223,
	26224,
	26225,
	26226,
	26227,
	26228,
	26229,
	26230,
	26231,
	26232,
	26233,
	26234,
	26235,
	26236,
	26237,
	26238,
	26239,
	26240,
	26241,
	26242,
	26243,
	26244,
	26245,
	26246,
	26247,
	26248,
	26249,
	26250,
	26251,
	26252,
	26253,
	26254,
	26255,
	26256,
	26257,
	26258,
	26259,
	26260,
	26261,
	26262,
	26263,
	26264,
	26265,
	26266,
	26267,
	26268,
	26269,
	26270,
	26271,
	26272,
	26273,
	26274,
	26275,
	26276,
	26277,
	26278,
	26279,
	26280,
	26281,
	26282,
	26283,
	26284,
	26285,
	26286,
	26287,
	26288,
	26289,
	26290,
	26291,
	26292,
	26293,
	26294,
	26295,
	26296,
	26297,
	26298,
	26299,
	26300,
	26301,
	26302,
	26303,
	26304,
	26305,
	26306,
	26307,
	26308,
	26309,
	26310,
	26311,
	26312,
	26313,
	26314,
	26315,
	26316,
	26317,
	26318,
	26319,
	26320,
	26321,
	26322,
	26323,
	26324,
	26325,
	26326,
	26327,
	26328,
	26329,
	26330,
	26331,
	26332,
	26333,
	26334,
	26335,
	26336,
	26337,
	26338,
	26339,
	26340,
	26341,
	26342,
	26343,
	26344,
	26345,
	26346,
	26347,
	26348,
	26349,
	26350,
	26351,
	26352,
	26353,
	26354,
	26355,
	26356,
	26357,
	26358,
	26359,
	26360,
	26361,
	26362,
	26363,
	26364,
	26365,
	26366,
	26367,
	26368,
	26369,
	26370,
	26371,
	26372,
	26373,
	26374,
	26375,
	26376,
	26377,
	26378,
	26379,
	26380,
	26381,
	26382,
	26383,
	26384,
	26385,
	26386,
	26387,
	26388,
	26389,
	26390,
	26391,
	26392,
	26393,
	26394,
	26395,
	26396,
	26397,
	26398,
	26399,
	26400,
	26401,
	26402,
	26403,
	26404,
	26405,
	26406,
	26407,
	26408,
	26409,
	26410,
	26411,
	26412,
	26413,
	26414,
	26415,
	26416,
	26417,
	26418,
	26419,
	26420,
	26421,
	26422,
	26423,
	26424,
	26425,
	26426,
	26427,
	26428,
	26429,
	26430,
	26431,
	26432,
	26433,
	26434,
	26435,
	26436,
	26437,
	26438,
	26439,
	26440,
	26441,
	26442,
	26443,
	26444,
	26445,
	26446,
	26447,
	26448,
	26449,
	26450,
	26451,
	26452,
	26453,
	26454,
	26455,
	26456,
	26457,
	26458,
	26459,
	26460,
	26461,
	26462,
	26463,
	26464,
	26465,
	26466,
	26467,
	26468,
	26469,
	26470,
	26471,
	26472,
	26473,
	26474,
	26475,
	26476,
	26477,
	26478,
	26479,
	26480,
	26481,
	26482,
	26483,
	26484,
	26485,
	26486,
	26487,
	26488,
	26489,
	26490,
	26491,
	26492,
	26493,
	26494,
	26495,
	26496,
	26497,
	26498,
	26499,
	26500,
	26501,
	26502,
	26503,
	26504,
	26505,
	26506,
	26507,
	26508,
	26509,
	26510,
	26511,
	26512,
	26513,
	26514,
	26515,
	26516,
	26517,
	26518,
	26519,
	26520,
	26521,
	26522,
	26523,
	26524,
	26525,
	26526,
	26527,
	26528,
	26529,
	26530,
	26531,
	26532,
	26533,
	26534,
	26535,
	26536,
	26537,
	26538,
	26539,
	26540,
	26541,
	26542,
	26543,
	26544,
	26545,
	26546,
	26547,
	26548,
	26549,
	26550,
	26551,
	26552,
	26553,
	26554,
	26555,
	26556,
	26557,
	26558,
	26559,
	26560,
	26561,
	26562,
	26563,
	26564,
	26565,
	26566,
	26567,
	26568,
	26569,
	26570,
	26571,
	26572,
	26573,
	26574,
	26575,
	26576,
	26577,
	26578,
	26579,
	26580,
	26581,
	26582,
	26583,
	26584,
	26585,
	26586,
	26587,
	26588,
	26589,
	26590,
	26591,
	26592,
	26593,
	26594,
	26595,
	26596,
	26597,
	26598,
	26599,
	26600,
	26601,
	26602,
	26603,
	26604,
	26605,
	26606,
	26607,
	26608,
	26609,
	26610,
	26611,
	26612,
	26613,
	26614,
	26615,
	26616,
	26617,
	26618,
	26619,
	26620,
	26621,
	26622,
	26623,
	26624,
	26625,
	26626,
	26627,
	26628,
	26629,
	26630,
	26631,
	26632,
	26633,
	26634,
	26635,
	26636,
	26637,
	26638,
	26639,
	26640,
	26641,
	26642,
	26643,
	26644,
	26645,
	26646,
	26647,
	26648,
	26649,
	26650,
	26651,
	26652,
	26653,
	26654,
	26655,
	26656,
	26657,
	26658,
	26659,
	26660,
	26661,
	26662,
	26663,
	26664,
	26665,
	26666,
	26667,
	26668,
	26669,
	26670,
	26671,
	26672,
	26673,
	26674,
	26675,
	26676,
	26677,
	26678,
	26679,
	26680,
	26681,
	26682,
	26683,
	26684,
	26685,
	26686,
	26687,
	26688,
	26689,
	26690,
	26691,
	26692,
	26693,
	26694,
	26695,
	26696,
	26697,
	26698,
	26699,
	26700,
	26701,
	26702,
	26703,
	26704,
	26705,
	26706,
	26707,
	26708,
	26709,
	26710,
	26711,
	26712,
	26713,
	26714,
	26715,
	26716,
	26717,
	26718,
	26719,
	26720,
	26721,
	26722,
	26723,
	26724,
	26725,
	26726,
	26727,
	26728,
	26729,
	26730,
	26731,
	26732,
	26733,
	26734,
	26735,
	26736,
	26737,
	26738,
	26739,
	26740,
	26741,
	26742,
	26743,
	26744,
	26745,
	26746,
	26747,
	26748,
	26749,
	26750,
	26751,
	26752,
	26753,
	26754,
	26755,
	26756,
	26757,
	26758,
	26759,
	26760,
	26761,
	26762,
	26763,
	26764,
	26765,
	26766,
	26767,
	26768,
	26769,
	26770,
	26771,
	26772,
	26773,
	26774,
	26775,
	26776,
	26777,
	26778,
	26779,
	26780,
	26781,
	26782,
	26783,
	26784,
	26785,
	26786,
	26787,
	26788,
	26789,
	26790,
	26791,
	26792,
	26793,
	26794,
	26795,
	26796,
	26797,
	26798,
	26799,
	26800,
	26801,
	26802,
	26803,
	26804,
	26805,
	26806,
	26807,
	26808,
	26809,
	26810,
	26811,
	26812,
	26813,
	26814,
	26815,
	26816,
	26817,
	26818,
	26819,
	26820,
	26821,
	26822,
	26823,
	26824,
	26825,
	26826,
	26827,
	26828,
	26829,
	26830,
	26831,
	26832,
	26833,
	26834,
	26835,
	26836,
	26837,
	26838,
	26839,
	26840,
	26841,
	26842,
	26843,
	26844,
	26845,
	26846,
	26847,
	26848,
	26849,
	26850,
	26851,
	26852,
	26853,
	26854,
	26855,
	26856,
	26857,
	26858,
	26859,
	26860,
	26861,
	26862,
	26863,
	26864,
	26865,
	26866,
	26867,
	26868,
	26869,
	26870,
	26871,
	26872,
	26873,
	26874,
	26875,
	26876,
	26877,
	26878,
	26879,
	26880,
	26881,
	26882,
	26883,
	26884,
	26885,
	26886,
	26887,
	26888,
	26889,
	26890,
	26891,
	26892,
	26893,
	26894,
	26895,
	26896,
	26897,
	26898,
	26899,
	26900,
	26901,
	26902,
	26903,
	26904,
	26905,
	26906,
	26907,
	26908,
	26909,
	26910,
	26911,
	26912,
	26913,
	26914,
	26915,
	26916,
	26917,
	26918,
	26919,
	26920,
	26921,
	26922,
	26923,
	26924,
	26925,
	26926,
	26927,
	26928,
	26929,
	26930,
	26931,
	26932,
	26933,
	26934,
	26935,
	26936,
	26937,
	26938,
	26939,
	26940,
	26941,
	26942,
	26943,
	26944,
	26945,
	26946,
	26947,
	26948,
	26949,
	26950,
	26951,
	26952,
	26953,
	26954,
	26955,
	26956,
	26957,
	26958,
	26959,
	26960,
	26961,
	26962,
	26963,
	26964,
	26965,
	26966,
	26967,
	26968,
	26969,
	26970,
	26971,
	26972,
	26973,
	26974,
	26975,
	26976,
	26977,
	26978,
	26979,
	26980,
	26981,
	26982,
	26983,
	26984,
	26985,
	26986,
	26987,
	26988,
	26989,
	26990,
	26991,
	26992,
	26993,
	26994,
	26995,
	26996,
	26997,
	26998,
	26999,
	27000,
	27001,
	27002,
	27003,
	27004,
	27005,
	27006,
	27007,
	27008,
	27009,
	27010,
	27011,
	27012,
	27013,
	27014,
	27015,
	27016,
	27017,
	27018,
	27019,
	27020,
	27021,
	27022,
	27023,
	27024,
	27025,
	27026,
	27027,
	27028,
	27029,
	27030,
	27031,
	27032,
	27033,
	27034,
	27035,
	27036,
	27037,
	27038,
	27039,
	27040,
	27041,
	27042,
	27043,
	27044,
	27045,
	27046,
	27047,
	27048,
	27049,
	27050,
	27051,
	27052,
	27053,
	27054,
	27055,
	27056,
	27057,
	27058,
	27059,
	27060,
	27061,
	27062,
	27063,
	27064,
	27065,
	27066,
	27067,
	27068,
	27069,
	27070,
	27071,
	27072,
	27073,
	27074,
	27075,
	27076,
	27077,
	27078,
	27079,
	27080,
	27081,
	27082,
	27083,
	27084,
	27085,
	27086,
	27087,
	27088,
	27089,
	27090,
	27091,
	27092,
	27093,
	27094,
	27095,
	27096,
	27097,
	27098,
	27099,
	27100,
	27101,
	27102,
	27103,
	27104,
	27105,
	27106,
	27107,
	27108,
	27109,
	27110,
	27111,
	27112,
	27113,
	27114,
	27115,
	27116,
	27117,
	27118,
	27119,
	27120,
	27121,
	27122,
	27123,
	27124,
	27125,
	27126,
	27127,
	27128,
	27129,
	27130,
	27131,
	27132,
	27133,
	27134,
	27135,
	27136,
	27137,
	27138,
	27139,
	27140,
	27141,
	27142,
	27143,
	27144,
	27145,
	27146,
	27147,
	27148,
	27149,
	27150,
	27151,
	27152,
	27153,
	27154,
	27155,
	27156,
	27157,
	27158,
	27159,
	27160,
	27161,
	27162,
	27163,
	27164,
	27165,
	27166,
	27167,
	27168,
	27169,
	27170,
	27171,
	27172,
	27173,
	27174,
	27175,
	27176,
	27177,
	27178,
	27179,
	27180,
	27181,
	27182,
	27183,
	27184,
	27185,
	27186,
	27187,
	27188,
	27189,
	27190,
	27191,
	27192,
	27193,
	27194,
	27195,
	27196,
	27197,
	27198,
	27199,
	27200,
	27201,
	27202,
	27203,
	27204,
	27205,
	27206,
	27207,
	27208,
	27209,
	27210,
	27211,
	27212,
	27213,
	27214,
	27215,
	27216,
	27217,
	27218,
	27219,
	27220,
	27221,
	27222,
	27223,
	27224,
	27225,
	27226,
	27227,
	27228,
	27229,
	27230,
	27231,
	27232,
	27233,
	27234,
	27235,
	27236,
	27237,
	27238,
	27239,
	27240,
	27241,
	27242,
	27243,
	27244,
	27245,
	27246,
	27247,
	27248,
	27249,
	27250,
	27251,
	27252,
	27253,
	27254,
	27255,
	27256,
	27257,
	27258,
	27259,
	27260,
	27261,
	27262,
	27263,
	27264,
	27265,
	27266,
	27267,
	27268,
	27269,
	27270,
	27271,
	27272,
	27273,
	27274,
	27275,
	27276,
	27277,
	27278,
	27279,
	27280,
	27281,
	27282,
	27283,
	27284,
	27285,
	27286,
	27287,
	27288,
	27289,
	27290,
	27291,
	27292,
	27293,
	27294,
	27295,
	27296,
	27297,
	27298,
	27299,
	27300,
	27301,
	27302,
	27303,
	27304,
	27305,
	27306,
	27307,
	27308,
	27309,
	27310,
	27311,
	27312,
	27313,
	27314,
	27315,
	27316,
	27317,
	27318,
	27319,
	27320,
	27321,
	27322,
	27323,
	27324,
	27325,
	27326,
	27327,
	27328,
	27329,
	27330,
	27331,
	27332,
	27333,
	27334,
	27335,
	27336,
	27337,
	27338,
	27339,
	27340,
	27341,
	27342,
	27343,
	27344,
	27345,
	27346,
	27347,
	27348,
	27349,
	27350,
	27351,
	27352,
	27353,
	27354,
	27355,
	27356,
	27357,
	27358,
	27359,
	27360,
	27361,
	27362,
	27363,
	27364,
	27365,
	27366,
	27367,
	27368,
	27369,
	27370,
	27371,
	27372,
	27373,
	27374,
	27375,
	27376,
	27377,
	27378,
	27379,
	27380,
	27381,
	27382,
	27383,
	27384,
	27385,
	27386,
	27387,
	27388,
	27389,
	27390,
	27391,
	27392,
	27393,
	27394,
	27395,
	27396,
	27397,
	27398,
	27399,
	27400,
	27401,
	27402,
	27403,
	27404,
	27405,
	27406,
	27407,
	27408,
	27409,
	27410,
	27411,
	27412,
	27413,
	27414,
	27415,
	27416,
	27417,
	27418,
	27419,
	27420,
	27421,
	27422,
	27423,
	27424,
	27425,
	27426,
	27427,
	27428,
	27429,
	27430,
	27431,
	27432,
	27433,
	27434,
	27435,
	27436,
	27437,
	27438,
	27439,
	27440,
	27441,
	27442,
	27443,
	27444,
	27445,
	27446,
	27447,
	27448,
	27449,
	27450,
	27451,
	27452,
	27453,
	27454,
	27455,
	27456,
	27457,
	27458,
	27459,
	27460,
	27461,
	27462,
	27463,
	27464,
	27465,
	27466,
	27467,
	27468,
	27469,
	27470,
	27471,
	27472,
	27473,
	27474,
	27475,
	27476,
	27477,
	27478,
	27479,
	27480,
	27481,
	27482,
	27483,
	27484,
	27485,
	27486,
	27487,
	27488,
	27489,
	27490,
	27491,
	27492,
	27493,
	27494,
	27495,
	27496,
	27497,
	27498,
	27499,
	27500,
	27501,
	27502,
	27503,
	27504,
	27505,
	27506,
	27507,
	27508,
	27509,
	27510,
	27511,
	27512,
	27513,
	27514,
	27515,
	27516,
	27517,
	27518,
	27519,
	27520,
	27521,
	27522,
	27523,
	27524,
	27525,
	27526,
	27527,
	27528,
	27529,
	27530,
	27531,
	27532,
	27533,
	27534,
	27535,
	27536,
	27537,
	27538,
	27539,
	27540,
	27541,
	27542,
	27543,
	27544,
	27545,
	27546,
	27547,
	27548,
	27549,
	27550,
	27551,
	27552,
	27553,
	27554,
	27555,
	27556,
	27557,
	27558,
	27559,
	27560,
	27561,
	27562,
	27563,
	27564,
	27565,
	27566,
	27567,
	27568,
	27569,
	27570,
	27571,
	27572,
	27573,
	27574,
	27575,
	27576,
	27577,
	27578,
	27579,
	27580,
	27581,
	27582,
	27583,
	27584,
	27585,
	27586,
	27587,
	27588,
	27589,
	27590,
	27591,
	27592,
	27593,
	27594,
	27595,
	27596,
	27597,
	27598,
	27599,
	27600,
	27601,
	27602,
	27603,
	27604,
	27605,
	27606,
	27607,
	27608,
	27609,
	27610,
	27611,
	27612,
	27613,
	27614,
	27615,
	27616,
	27617,
	27618,
	27619,
	27620,
	27621,
	27622,
	27623,
	27624,
	27625,
	27626,
	27627,
	27628,
	27629,
	27630,
	27631,
	27632,
	27633,
	27634,
	27635,
	27636,
	27637,
	27638,
	27639,
	27640,
	27641,
	27642,
	27643,
	27644,
	27645,
	27646,
	27647,
	27648,
	27649,
	27650,
	27651,
	27652,
	27653,
	27654,
	27655,
	27656,
	27657,
	27658,
	27659,
	27660,
	27661,
	27662,
	27663,
	27664,
	27665,
	27666,
	27667,
	27668,
	27669,
	27670,
	27671,
	27672,
	27673,
	27674,
	27675,
	27676,
	27677,
	27678,
	27679,
	27680,
	27681,
	27682,
	27683,
	27684,
	27685,
	27686,
	27687,
	27688,
	27689,
	27690,
	27691,
	27692,
	27693,
	27694,
	27695,
	27696,
	27697,
	27698,
	27699,
	27700,
	27701,
	27702,
	27703,
	27704,
	27705,
	27706,
	27707,
	27708,
	27709,
	27710,
	27711,
	27712,
	27713,
	27714,
	27715,
	27716,
	27717,
	27718,
	27719,
	27720,
	27721,
	27722,
	27723,
	27724,
	27725,
	27726,
	27727,
	27728,
	27729,
	27730,
	27731,
	27732,
	27733,
	27734,
	27735,
	27736,
	27737,
	27738,
	27739,
	27740,
	27741,
	27742,
	27743,
	27744,
	27745,
	27746,
	27747,
	27748,
	27749,
	27750,
	27751,
	27752,
	27753,
	27754,
	27755,
	27756,
	27757,
	27758,
	27759,
	27760,
	27761,
	27762,
	27763,
	27764,
	27765,
	27766,
	27767,
	27768,
	27769,
	27770,
	27771,
	27772,
	27773,
	27774,
	27775,
	27776,
	27777,
	27778,
	27779,
	27780,
	27781,
	27782,
	27783,
	27784,
	27785,
	27786,
	27787,
	27788,
	27789,
	27790,
	27791,
	27792,
	27793,
	27794,
	27795,
	27796,
	27797,
	27798,
	27799,
	27800,
	27801,
	27802,
	27803,
	27804,
	27805,
	27806,
	27807,
	27808,
	27809,
	27810,
	27811,
	27812,
	27813,
	27814,
	27815,
	27816,
	27817,
	27818,
	27819,
	27820,
	27821,
	27822,
	27823,
	27824,
	27825,
	27826,
	27827,
	27828,
	27829,
	27830,
	27831,
	27832,
	27833,
	27834,
	27835,
	27836,
	27837,
	27838,
	27839,
	27840,
	27841,
	27842,
	27843,
	27844,
	27845,
	27846,
	27847,
	27848,
	27849,
	27850,
	27851,
	27852,
	27853,
	27854,
	27855,
	27856,
	27857,
	27858,
	27859,
	27860,
	27861,
	27862,
	27863,
	27864,
	27865,
	27866,
	27867,
	27868,
	27869,
	27870,
	27871,
	27872,
	27873,
	27874,
	27875,
	27876,
	27877,
	27878,
	27879,
	27880,
	27881,
	27882,
	27883,
	27884,
	27885,
	27886,
	27887,
	27888,
	27889,
	27890,
	27891,
	27892,
	27893,
	27894,
	27895,
	27896,
	27897,
	27898,
	27899,
	27900,
	27901,
	27902,
	27903,
	27904,
	27905,
	27906,
	27907,
	27908,
	27909,
	27910,
	27911,
	27912,
	27913,
	27914,
	27915,
	27916,
	27917,
	27918,
	27919,
	27920,
	27921,
	27922,
	27923,
	27924,
	27925,
	27926,
	27927,
	27928,
	27929,
	27930,
	27931,
	27932,
	27933,
	27934,
	27935,
	27936,
	27937,
	27938,
	27939,
	27940,
	27941,
	27942,
	27943,
	27944,
	27945,
	27946,
	27947,
	27948,
	27949,
	27950,
	27951,
	27952,
	27953,
	27954,
	27955,
	27956,
	27957,
	27958,
	27959,
	27960,
	27961,
	27962,
	27963,
	27964,
	27965,
	27966,
	27967,
	27968,
	27969,
	27970,
	27971,
	27972,
	27973,
	27974,
	27975,
	27976,
	27977,
	27978,
	27979,
	27980,
	27981,
	27982,
	27983,
	27984,
	27985,
	27986,
	27987,
	27988,
	27989,
	27990,
	27991,
	27992,
	27993,
	27994,
	27995,
	27996,
	27997,
	27998,
	27999,
	28000,
	28001,
	28002,
	28003,
	28004,
	28005,
	28006,
	28007,
	28008,
	28009,
	28010,
	28011,
	28012,
	28013,
	28014,
	28015,
	28016,
	28017,
	28018,
	28019,
	28020,
	28021,
	28022,
	28023,
	28024,
	28025,
	28026,
	28027,
	28028,
	28029,
	28030,
	28031,
	28032,
	28033,
	28034,
	28035,
	28036,
	28037,
	28038,
	28039,
	28040,
	28041,
	28042,
	28043,
	28044,
	28045,
	28046,
	28047,
	28048,
	28049,
	28050,
	28051,
	28052,
	28053,
	28054,
	28055,
	28056,
	28057,
	28058,
	28059,
	28060,
	28061,
	28062,
	28063,
	28064,
	28065,
	28066,
	28067,
	28068,
	28069,
	28070,
	28071,
	28072,
	28073,
	28074,
	28075,
	28076,
	28077,
	28078,
	28079,
	28080,
	28081,
	28082,
	28083,
	28084,
	28085,
	28086,
	28087,
	28088,
	28089,
	28090,
	28091,
	28092,
	28093,
	28094,
	28095,
	28096,
	28097,
	28098,
	28099,
	28100,
	28101,
	28102,
	28103,
	28104,
	28105,
	28106,
	28107,
	28108,
	28109,
	28110,
	28111,
	28112,
	28113,
	28114,
	28115,
	28116,
	28117,
	28118,
	28119,
	28120,
	28121,
	28122,
	28123,
	28124,
	28125,
	28126,
	28127,
	28128,
	28129,
	28130,
	28131,
	28132,
	28133,
	28134,
	28135,
	28136,
	28137,
	28138,
	28139,
	28140,
	28141,
	28142,
	28143,
	28144,
	28145,
	28146,
	28147,
	28148,
	28149,
	28150,
	28151,
	28152,
	28153,
	28154,
	28155,
	28156,
	28157,
	28158,
	28159,
	28160,
	28161,
	28162,
	28163,
	28164,
	28165,
	28166,
	28167,
	28168,
	28169,
	28170,
	28171,
	28172,
	28173,
	28174,
	28175,
	28176,
	28177,
	28178,
	28179,
	28180,
	28181,
	28182,
	28183,
	28184,
	28185,
	28186,
	28187,
	28188,
	28189,
	28190,
	28191,
	28192,
	28193,
	28194,
	28195,
	28196,
	28197,
	28198,
	28199,
	28200,
	28201,
	28202,
	28203,
	28204,
	28205,
	28206,
	28207,
	28208,
	28209,
	28210,
	28211,
	28212,
	28213,
	28214,
	28215,
	28216,
	28217,
	28218,
	28219,
	28220,
	28221,
	28222,
	28223,
	28224,
	28225,
	28226,
	28227,
	28228,
	28229,
	28230,
	28231,
	28232,
	28233,
	28234,
	28235,
	28236,
	28237,
	28238,
	28239,
	28240,
	28241,
	28242,
	28243,
	28244,
	28245,
	28246,
	28247,
	28248,
	28249,
	28250,
	28251,
	28252,
	28253,
	28254,
	28255,
	28256,
	28257,
	28258,
	28259,
	28260,
	28261,
	28262,
	28263,
	28264,
	28265,
	28266,
	28267,
	28268,
	28269,
	28270,
	28271,
	28272,
	28273,
	28274,
	28275,
	28276,
	28277,
	28278,
	28279,
	28280,
	28281,
	28282,
	28283,
	28284,
	28285,
	28286,
	28287,
	28288,
	28289,
	28290,
	28291,
	28292,
	28293,
	28294,
	28295,
	28296,
	28297,
	28298,
	28299,
	28300,
	28301,
	28302,
	28303,
	28304,
	28305,
	28306,
	28307,
	28308,
	28309,
	28310,
	28311,
	28312,
	28313,
	28314,
	28315,
	28316,
	28317,
	28318,
	28319,
	28320,
	28321,
	28322,
	28323,
	28324,
	28325,
	28326,
	28327,
	28328,
	28329,
	28330,
	28331,
	28332,
	28333,
	28334,
	28335,
	28336,
	28337,
	28338,
	28339,
	28340,
	28341,
	28342,
	28343,
	28344,
	28345,
	28346,
	28347,
	28348,
	28349,
	28350,
	28351,
	28352,
	28353,
	28354,
	28355,
	28356,
	28357,
	28358,
	28359,
	28360,
	28361,
	28362,
	28363,
	28364,
	28365,
	28366,
	28367,
	28368,
	28369,
	28370,
	28371,
	28372,
	28373,
	28374,
	28375,
	28376,
	28377,
	28378,
	28379,
	28380,
	28381,
	28382,
	28383,
	28384,
	28385,
	28386,
	28387,
	28388,
	28389,
	28390,
	28391,
	28392,
	28393,
	28394,
	28395,
	28396,
	28397,
	28398,
	28399,
	28400,
	28401,
	28402,
	28403,
	28404,
	28405,
	28406,
	28407,
	28408,
	28409,
	28410,
	28411,
	28412,
	28413,
	28414,
	28415,
	28416,
	28417,
	28418,
	28419,
	28420,
	28421,
	28422,
	28423,
	28424,
	28425,
	28426,
	28427,
	28428,
	28429,
	28430,
	28431,
	28432,
	28433,
	28434,
	28435,
	28436,
	28437,
	28438,
	28439,
	28440,
	28441,
	28442,
	28443,
	28444,
	28445,
	28446,
	28447,
	28448,
	28449,
	28450,
	28451,
	28452,
	28453,
	28454,
	28455,
	28456,
	28457,
	28458,
	28459,
	28460,
	28461,
	28462,
	28463,
	28464,
	28465,
	28466,
	28467,
	28468,
	28469,
	28470,
	28471,
	28472,
	28473,
	28474,
	28475,
	28476,
	28477,
	28478,
	28479,
	28480,
	28481,
	28482,
	28483,
	28484,
	28485,
	28486,
	28487,
	28488,
	28489,
	28490,
	28491,
	28492,
	28493,
	28494,
	28495,
	28496,
	28497,
	28498,
	28499,
	28500,
	28501,
	28502,
	28503,
	28504,
	28505,
	28506,
	28507,
	28508,
	28509,
	28510,
	28511,
	28512,
	28513,
	28514,
	28515,
	28516,
	28517,
	28518,
	28519,
	28520,
	28521,
	28522,
	28523,
	28524,
	28525,
	28526,
	28527,
	28528,
	28529,
	28530,
	28531,
	28532,
	28533,
	28534,
	28535,
	28536,
	28537,
	28538,
	28539,
	28540,
	28541,
	28542,
	28543,
	28544,
	28545,
	28546,
	28547,
	28548,
	28549,
	28550,
	28551,
	28552,
	28553,
	28554,
	28555,
	28556,
	28557,
	28558,
	28559,
	28560,
	28561,
	28562,
	28563,
	28564,
	28565,
	28566,
	28567,
	28568,
	28569,
	28570,
	28571,
	28572,
	28573,
	28574,
	28575,
	28576,
	28577,
	28578,
	28579,
	28580,
	28581,
	28582,
	28583,
	28584,
	28585,
	28586,
	28587,
	28588,
	28589,
	28590,
	28591,
	28592,
	28593,
	28594,
	28595,
	28596,
	28597,
	28598,
	28599,
	28600,
	28601,
	28602,
	28603,
	28604,
	28605,
	28606,
	28607,
	28608,
	28609,
	28610,
	28611,
	28612,
	28613,
	28614,
	28615,
	28616,
	28617,
	28618,
	28619,
	28620,
	28621,
	28622,
	28623,
	28624,
	28625,
	28626,
	28627,
	28628,
	28629,
	28630,
	28631,
	28632,
	28633,
	28634,
	28635,
	28636,
	28637,
	28638,
	28639,
	28640,
	28641,
	28642,
	28643,
	28644,
	28645,
	28646,
	28647,
	28648,
	28649,
	28650,
	28651,
	28652,
	28653,
	28654,
	28655,
	28656,
	28657,
	28658,
	28659,
	28660,
	28661,
	28662,
	28663,
	28664,
	28665,
	28666,
	28667,
	28668,
	28669,
	28670,
	28671,
	28672,
	28673,
	28674,
	28675,
	28676,
	28677,
	28678,
	28679,
	28680,
	28681,
	28682,
	28683,
	28684,
	28685,
	28686,
	28687,
	28688,
	28689,
	28690,
	28691,
	28692,
	28693,
	28694,
	28695,
	28696,
	28697,
	28698,
	28699,
	28700,
	28701,
	28702,
	28703,
	28704,
	28705,
	28706,
	28707,
	28708,
	28709,
	28710,
	28711,
	28712,
	28713,
	28714,
	28715,
	28716,
	28717,
	28718,
	28719,
	28720,
	28721,
	28722,
	28723,
	28724,
	28725,
	28726,
	28727,
	28728,
	28729,
	28730,
	28731,
	28732,
	28733,
	28734,
	28735,
	28736,
	28737,
	28738,
	28739,
	28740,
	28741,
	28742,
	28743,
	28744,
	28745,
	28746,
	28747,
	28748,
	28749,
	28750,
	28751,
	28752,
	28753,
	28754,
	28755,
	28756,
	28757,
	28758,
	28759,
	28760,
	28761,
	28762,
	28763,
	28764,
	28765,
	28766,
	28767,
	28768,
	28769,
	28770,
	28771,
	28772,
	28773,
	28774,
	28775,
	28776,
	28777,
	28778,
	28779,
	28780,
	28781,
	28782,
	28783,
	28784,
	28785,
	28786,
	28787,
	28788,
	28789,
	28790,
	28791,
	28792,
	28793,
	28794,
	28795,
	28796,
	28797,
	28798,
	28799,
	28800,
	28801,
	28802,
	28803,
	28804,
	28805,
	28806,
	28807,
	28808,
	28809,
	28810,
	28811,
	28812,
	28813,
	28814,
	28815,
	28816,
	28817,
	28818,
	28819,
	28820,
	28821,
	28822,
	28823,
	28824,
	28825,
	28826,
	28827,
	28828,
	28829,
	28830,
	28831,
	28832,
	28833,
	28834,
	28835,
	28836,
	28837,
	28838,
	28839,
	28840,
	28841,
	28842,
	28843,
	28844,
	28845,
	28846,
	28847,
	28848,
	28849,
	28850,
	28851,
	28852,
	28853,
	28854,
	28855,
	28856,
	28857,
	28858,
	28859,
	28860,
	28861,
	28862,
	28863,
	28864,
	28865,
	28866,
	28867,
	28868,
	28869,
	28870,
	28871,
	28872,
	28873,
	28874,
	28875,
	28876,
	28877,
	28878,
	28879,
	28880,
	28881,
	28882,
	28883,
	28884,
	28885,
	28886,
	28887,
	28888,
	28889,
	28890,
	28891,
	28892,
	28893,
	28894,
	28895,
	28896,
	28897,
	28898,
	28899,
	28900,
	28901,
	28902,
	28903,
	28904,
	28905,
	28906,
	28907,
	28908,
	28909,
	28910,
	28911,
	28912,
	28913,
	28914,
	28915,
	28916,
	28917,
	28918,
	28919,
	28920,
	28921,
	28922,
	28923,
	28924,
	28925,
	28926,
	28927,
	28928,
	28929,
	28930,
	28931,
	28932,
	28933,
	28934,
	28935,
	28936,
	28937,
	28938,
	28939,
	28940,
	28941,
	28942,
	28943,
	28944,
	28945,
	28946,
	28947,
	28948,
	28949,
	28950,
	28951,
	28952,
	28953,
	28954,
	28955,
	28956,
	28957,
	28958,
	28959,
	28960,
	28961,
	28962,
	28963,
	28964,
	28965,
	28966,
	28967,
	28968,
	28969,
	28970,
	28971,
	28972,
	28973,
	28974,
	28975,
	28976,
	28977,
	28978,
	28979,
	28980,
	28981,
	28982,
	28983,
	28984,
	28985,
	28986,
	28987,
	28988,
	28989,
	28990,
	28991,
	28992,
	28993,
	28994,
	28995,
	28996,
	28997,
	28998,
	28999,
	29000,
	29001,
	29002,
	29003,
	29004,
	29005,
	29006,
	29007,
	29008,
	29009,
	29010,
	29011,
	29012,
	29013,
	29014,
	29015,
	29016,
	29017,
	29018,
	29019,
	29020,
	29021,
	29022,
	29023,
	29024,
	29025,
	29026,
	29027,
	29028,
	29029,
	29030,
	29031,
	29032,
	29033,
	29034,
	29035,
	29036,
	29037,
	29038,
	29039,
	29040,
	29041,
	29042,
	29043,
	29044,
	29045,
	29046,
	29047,
	29048,
	29049,
	29050,
	29051,
	29052,
	29053,
	29054,
	29055,
	29056,
	29057,
	29058,
	29059,
	29060,
	29061,
	29062,
	29063,
	29064,
	29065,
	29066,
	29067,
	29068,
	29069,
	29070,
	29071,
	29072,
	29073,
	29074,
	29075,
	29076,
	29077,
	29078,
	29079,
	29080,
	29081,
	29082,
	29083,
	29084,
	29085,
	29086,
	29087,
	29088,
	29089,
	29090,
	29091,
	29092,
	29093,
	29094,
	29095,
	29096,
	29097,
	29098,
	29099,
	29100,
	29101,
	29102,
	29103,
	29104,
	29105,
	29106,
	29107,
	29108,
	29109,
	29110,
	29111,
	29112,
	29113,
	29114,
	29115,
	29116,
	29117,
	29118,
	29119,
	29120,
	29121,
	29122,
	29123,
	29124,
	29125,
	29126,
	29127,
	29128,
	29129,
	29130,
	29131,
	29132,
	29133,
	29134,
	29135,
	29136,
	29137,
	29138,
	29139,
	29140,
	29141,
	29142,
	29143,
	29144,
	29145,
	29146,
	29147,
	29148,
	29149,
	29150,
	29151,
	29152,
	29153,
	29154,
	29155,
	29156,
	29157,
	29158,
	29159,
	29160,
	29161,
	29162,
	29163,
	29164,
	29165,
	29166,
	29167,
	29168,
	29169,
	29170,
	29171,
	29172,
	29173,
	29174,
	29175,
	29176,
	29177,
	29178,
	29179,
	29180,
	29181,
	29182,
	29183,
	29184,
	29185,
	29186,
	29187,
	29188,
	29189,
	29190,
	29191,
	29192,
	29193,
	29194,
	29195,
	29196,
	29197,
	29198,
	29199,
	29200,
	29201,
	29202,
	29203,
	29204,
	29205,
	29206,
	29207,
	29208,
	29209,
	29210,
	29211,
	29212,
	29213,
	29214,
	29215,
	29216,
	29217,
	29218,
	29219,
	29220,
	29221,
	29222,
	29223,
	29224,
	29225,
	29226,
	29227,
	29228,
	29229,
	29230,
	29231,
	29232,
	29233,
	29234,
	29235,
	29236,
	29237,
	29238,
	29239,
	29240,
	29241,
	29242,
	29243,
	29244,
	29245,
	29246,
	29247,
	29248,
	29249,
	29250,
	29251,
	29252,
	29253,
	29254,
	29255,
	29256,
	29257,
	29258,
	29259,
	29260,
	29261,
	29262,
	29263,
	29264,
	29265,
	29266,
	29267,
	29268,
	29269,
	29270,
	29271,
	29272,
	29273,
	29274,
	29275,
	29276,
	29277,
	29278,
	29279,
	29280,
	29281,
	29282,
	29283,
	29284,
	29285,
	29286,
	29287,
	29288,
	29289,
	29290,
	29291,
	29292,
	29293,
	29294,
	29295,
	29296,
	29297,
	29298,
	29299,
	29300,
	29301,
	29302,
	29303,
	29304,
	29305,
	29306,
	29307,
	29308,
	29309,
	29310,
	29311,
	29312,
	29313,
	29314,
	29315,
	29316,
	29317,
	29318,
	29319,
	29320,
	29321,
	29322,
	29323,
	29324,
	29325,
	29326,
	29327,
	29328,
	29329,
	29330,
	29331,
	29332,
	29333,
	29334,
	29335,
	29336,
	29337,
	29338,
	29339,
	29340,
	29341,
	29342,
	29343,
	29344,
	29345,
	29346,
	29347,
	29348,
	29349,
	29350,
	29351,
	29352,
	29353,
	29354,
	29355,
	29356,
	29357,
	29358,
	29359,
	29360,
	29361,
	29362,
	29363,
	29364,
	29365,
	29366,
	29367,
	29368,
	29369,
	29370,
	29371,
	29372,
	29373,
	29374,
	29375,
	29376,
	29377,
	29378,
	29379,
	29380,
	29381,
	29382,
	29383,
	29384,
	29385,
	29386,
	29387,
	29388,
	29389,
	29390,
	29391,
	29392,
	29393,
	29394,
	29395,
	29396,
	29397,
	29398,
	29399,
	29400,
	29401,
	29402,
	29403,
	29404,
	29405,
	29406,
	29407,
	29408,
	29409,
	29410,
	29411,
	29412,
	29413,
	29414,
	29415,
	29416,
	29417,
	29418,
	29419,
	29420,
	29421,
	29422,
	29423,
	29424,
	29425,
	29426,
	29427,
	29428,
	29429,
	29430,
	29431,
	29432,
	29433,
	29434,
	29435,
	29436,
	29437,
	29438,
	29439,
	29440,
	29441,
	29442,
	29443,
	29444,
	29445,
	29446,
	29447,
	29448,
	29449,
	29450,
	29451,
	29452,
	29453,
	29454,
	29455,
	29456,
	29457,
	29458,
	29459,
	29460,
	29461,
	29462,
	29463,
	29464,
	29465,
	29466,
	29467,
	29468,
	29469,
	29470,
	29471,
	29472,
	29473,
	29474,
	29475,
	29476,
	29477,
	29478,
	29479,
	29480,
	29481,
	29482,
	29483,
	29484,
	29485,
	29486,
	29487,
	29488,
	29489,
	29490,
	29491,
	29492,
	29493,
	29494,
	29495,
	29496,
	29497,
	29498,
	29499,
	29500,
	29501,
	29502,
	29503,
	29504,
	29505,
	29506,
	29507,
	29508,
	29509,
	29510,
	29511,
	29512,
	29513,
	29514,
	29515,
	29516,
	29517,
	29518,
	29519,
	29520,
	29521,
	29522,
	29523,
	29524,
	29525,
	29526,
	29527,
	29528,
	29529,
	29530,
	29531,
	29532,
	29533,
	29534,
	29535,
	29536,
	29537,
	29538,
	29539,
	29540,
	29541,
	29542,
	29543,
	29544,
	29545,
	29546,
	29547,
	29548,
	29549,
	29550,
	29551,
	29552,
	29553,
	29554,
	29555,
	29556,
	29557,
	29558,
	29559,
	29560,
	29561,
	29562,
	29563,
	29564,
	29565,
	29566,
	29567,
	29568,
	29569,
	29570,
	29571,
	29572,
	29573,
	29574,
	29575,
	29576,
	29577,
	29578,
	29579,
	29580,
	29581,
	29582,
	29583,
	29584,
	29585,
	29586,
	29587,
	29588,
	29589,
	29590,
	29591,
	29592,
	29593,
	29594,
	29595,
	29596,
	29597,
	29598,
	29599,
	29600,
	29601,
	29602,
	29603,
	29604,
	29605,
	29606,
	29607,
	29608,
	29609,
	29610,
	29611,
	29612,
	29613,
	29614,
	29615,
	29616,
	29617,
	29618,
	29619,
	29620,
	29621,
	29622,
	29623,
	29624,
	29625,
	29626,
	29627,
	29628,
	29629,
	29630,
	29631,
	29632,
	29633,
	29634,
	29635,
	29636,
	29637,
	29638,
	29639,
	29640,
	29641,
	29642,
	29643,
	29644,
	29645,
	29646,
	29647,
	29648,
	29649,
	29650,
	29651,
	29652,
	29653,
	29654,
	29655,
	29656,
	29657,
	29658,
	29659,
	29660,
	29661,
	29662,
	29663,
	29664,
	29665,
	29666,
	29667,
	29668,
	29669,
	29670,
	29671,
	29672,
	29673,
	29674,
	29675,
	29676,
	29677,
	29678,
	29679,
	29680,
	29681,
	29682,
	29683,
	29684,
	29685,
	29686,
	29687,
	29688,
	29689,
	29690,
	29691,
	29692,
	29693,
	29694,
	29695,
	29696,
	29697,
	29698,
	29699,
	29700,
	29701,
	29702,
	29703,
	29704,
	29705,
	29706,
	29707,
	29708,
	29709,
	29710,
	29711,
	29712,
	29713,
	29714,
	29715,
	29716,
	29717,
	29718,
	29719,
	29720,
	29721,
	29722,
	29723,
	29724,
	29725,
	29726,
	29727,
	29728,
	29729,
	29730,
	29731,
	29732,
	29733,
	29734,
	29735,
	29736,
	29737,
	29738,
	29739,
	29740,
	29741,
	29742,
	29743,
	29744,
	29745,
	29746,
	29747,
	29748,
	29749,
	29750,
	29751,
	29752,
	29753,
	29754,
	29755,
	29756,
	29757,
	29758,
	29759,
	29760,
	29761,
	29762,
	29763,
	29764,
	29765,
	29766,
	29767,
	29768,
	29769,
	29770,
	29771,
	29772,
	29773,
	29774,
	29775,
	29776,
	29777,
	29778,
	29779,
	29780,
	29781,
	29782,
	29783,
	29784,
	29785,
	29786,
	29787,
	29788,
	29789,
	29790,
	29791,
	29792,
	29793,
	29794,
	29795,
	29796,
	29797,
	29798,
	29799,
	29800,
	29801,
	29802,
	29803,
	29804,
	29805,
	29806,
	29807,
	29808,
	29809,
	29810,
	29811,
	29812,
	29813,
	29814,
	29815,
	29816,
	29817,
	29818,
	29819,
	29820,
	29821,
	29822,
	29823,
	29824,
	29825,
	29826,
	29827,
	29828,
	29829,
	29830,
	29831,
	29832,
	29833,
	29834,
	29835,
	29836,
	29837,
	29838,
	29839,
	29840,
	29841,
	29842,
	29843,
	29844,
	29845,
	29846,
	29847,
	29848,
	29849,
	29850,
	29851,
	29852,
	29853,
	29854,
	29855,
	29856,
	29857,
	29858,
	29859,
	29860,
	29861,
	29862,
	29863,
	29864,
	29865,
	29866,
	29867,
	29868,
	29869,
	29870,
	29871,
	29872,
	29873,
	29874,
	29875,
	29876,
	29877,
	29878,
	29879,
	29880,
	29881,
	29882,
	29883,
	29884,
	29885,
	29886,
	29887,
	29888,
	29889,
	29890,
	29891,
	29892,
	29893,
	29894,
	29895,
	29896,
	29897,
	29898,
	29899,
	29900,
	29901,
	29902,
	29903,
	29904,
	29905,
	29906,
	29907,
	29908,
	29909,
	29910,
	29911,
	29912,
	29913,
	29914,
	29915,
	29916,
	29917,
	29918,
	29919,
	29920,
	29921,
	29922,
	29923,
	29924,
	29925,
	29926,
	29927,
	29928,
	29929,
	29930,
	29931,
	29932,
	29933,
	29934,
	29935,
	29936,
	29937,
	29938,
	29939,
	29940,
	29941,
	29942,
	29943,
	29944,
	29945,
	29946,
	29947,
	29948,
	29949,
	29950,
	29951,
	29952,
	29953,
	29954,
	29955,
	29956,
	29957,
	29958,
	29959,
	29960,
	29961,
	29962,
	29963,
	29964,
	29965,
	29966,
	29967,
	29968,
	29969,
	29970,
	29971,
	29972,
	29973,
	29974,
	29975,
	29976,
	29977,
	29978,
	29979,
	29980,
	29981,
	29982,
	29983,
	29984,
	29985,
	29986,
	29987,
	29988,
	29989,
	29990,
	29991,
	29992,
	29993,
	29994,
	29995,
	29996,
	29997,
	29998,
	29999,
	30000,
	30001,
	30002,
	30003,
	30004,
	30005,
	30006,
	30007,
	30008,
	30009,
	30010,
	30011,
	30012,
	30013,
	30014,
	30015,
	30016,
	30017,
	30018,
	30019,
	30020,
	30021,
	30022,
	30023,
	30024,
	30025,
	30026,
	30027,
	30028,
	30029,
	30030,
	30031,
	30032,
	30033,
	30034,
	30035,
	30036,
	30037,
	30038,
	30039,
	30040,
	30041,
	30042,
	30043,
	30044,
	30045,
	30046,
	30047,
	30048,
	30049,
	30050,
	30051,
	30052,
	30053,
	30054,
	30055,
	30056,
	30057,
	30058,
	30059,
	30060,
	30061,
	30062,
	30063,
	30064,
	30065,
	30066,
	30067,
	30068,
	30069,
	30070,
	30071,
	30072,
	30073,
	30074,
	30075,
	30076,
	30077,
	30078,
	30079,
	30080,
	30081,
	30082,
	30083,
	30084,
	30085,
	30086,
	30087,
	30088,
	30089,
	30090,
	30091,
	30092,
	30093,
	30094,
	30095,
	30096,
	30097,
	30098,
	30099,
	30100,
	30101,
	30102,
	30103,
	30104,
	30105,
	30106,
	30107,
	30108,
	30109,
	30110,
	30111,
	30112,
	30113,
	30114,
	30115,
	30116,
	30117,
	30118,
	30119,
	30120,
	30121,
	30122,
	30123,
	30124,
	30125,
	30126,
	30127,
	30128,
	30129,
	30130,
	30131,
	30132,
	30133,
	30134,
	30135,
	30136,
	30137,
	30138,
	30139,
	30140,
	30141,
	30142,
	30143,
	30144,
	30145,
	30146,
	30147,
	30148,
	30149,
	30150,
	30151,
	30152,
	30153,
	30154,
	30155,
	30156,
	30157,
	30158,
	30159,
	30160,
	30161,
	30162,
	30163,
	30164,
	30165,
	30166,
	30167,
	30168,
	30169,
	30170,
	30171,
	30172,
	30173,
	30174,
	30175,
	30176,
	30177,
	30178,
	30179,
	30180,
	30181,
	30182,
	30183,
	30184,
	30185,
	30186,
	30187,
	30188,
	30189,
	30190,
	30191,
	30192,
	30193,
	30194,
	30195,
	30196,
	30197,
	30198,
	30199,
	30200,
	30201,
	30202,
	30203,
	30204,
	30205,
	30206,
	30207,
	30208,
	30209,
	30210,
	30211,
	30212,
	30213,
	30214,
	30215,
	30216,
	30217,
	30218,
	30219,
	30220,
	30221,
	30222,
	30223,
	30224,
	30225,
	30226,
	30227,
	30228,
	30229,
	30230,
	30231,
	30232,
	30233,
	30234,
	30235,
	30236,
	30237,
	30238,
	30239,
	30240,
	30241,
	30242,
	30243,
	30244,
	30245,
	30246,
	30247,
	30248,
	30249,
	30250,
	30251,
	30252,
	30253,
	30254,
	30255,
	30256,
	30257,
	30258,
	30259,
	30260,
	30261,
	30262,
	30263,
	30264,
	30265,
	30266,
	30267,
	30268,
	30269,
	30270,
	30271,
	30272,
	30273,
	30274,
	30275,
	30276,
	30277,
	30278,
	30279,
	30280,
	30281,
	30282,
	30283,
	30284,
	30285,
	30286,
	30287,
	30288,
	30289,
	30290,
	30291,
	30292,
	30293,
	30294,
	30295,
	30296,
	30297,
	30298,
	30299,
	30300,
	30301,
	30302,
	30303,
	30304,
	30305,
	30306,
	30307,
	30308,
	30309,
	30310,
	30311,
	30312,
	30313,
	30314,
	30315,
	30316,
	30317,
	30318,
	30319,
	30320,
	30321,
	30322,
	30323,
	30324,
	30325,
	30326,
	30327,
	30328,
	30329,
	30330,
	30331,
	30332,
	30333,
	30334,
	30335,
	30336,
	30337,
	30338,
	30339,
	30340,
	30341,
	30342,
	30343,
	30344,
	30345,
	30346,
	30347,
	30348,
	30349,
	30350,
	30351,
	30352,
	30353,
	30354,
	30355,
	30356,
	30357,
	30358,
	30359,
	30360,
	30361,
	30362,
	30363,
	30364,
	30365,
	30366,
	30367,
	30368,
	30369,
	30370,
	30371,
	30372,
	30373,
	30374,
	30375,
	30376,
	30377,
	30378,
	30379,
	30380,
	30381,
	30382,
	30383,
	30384,
	30385,
	30386,
	30387,
	30388,
	30389,
	30390,
	30391,
	30392,
	30393,
	30394,
	30395,
	30396,
	30397,
	30398,
	30399,
	30400,
	30401,
	30402,
	30403,
	30404,
	30405,
	30406,
	30407,
	30408,
	30409,
	30410,
	30411,
	30412,
	30413,
	30414,
	30415,
	30416,
	30417,
	30418,
	30419,
	30420,
	30421,
	30422,
	30423,
	30424,
	30425,
	30426,
	30427,
	30428,
	30429,
	30430,
	30431,
	30432,
	30433,
	30434,
	30435,
	30436,
	30437,
	30438,
	30439,
	30440,
	30441,
	30442,
	30443,
	30444,
	30445,
	30446,
	30447,
	30448,
	30449,
	30450,
	30451,
	30452,
	30453,
	30454,
	30455,
	30456,
	30457,
	30458,
	30459,
	30460,
	30461,
	30462,
	30463,
	30464,
	30465,
	30466,
	30467,
	30468,
	30469,
	30470,
	30471,
	30472,
	30473,
	30474,
	30475,
	30476,
	30477,
	30478,
	30479,
	30480,
	30481,
	30482,
	30483,
	30484,
	30485,
	30486,
	30487,
	30488,
	30489,
	30490,
	30491,
	30492,
	30493,
	30494,
	30495,
	30496,
	30497,
	30498,
	30499,
	30500,
	30501,
	30502,
	30503,
	30504,
	30505,
	30506,
	30507,
	30508,
	30509,
	30510,
	30511,
	30512,
	30513,
	30514,
	30515,
	30516,
	30517,
	30518,
	30519,
	30520,
	30521,
	30522,
	30523,
	30524,
	30525,
	30526,
	30527,
	30528,
	30529,
	30530,
	30531,
	30532,
	30533,
	30534,
	30535,
	30536,
	30537,
	30538,
	30539,
	30540,
	30541,
	30542,
	30543,
	30544,
	30545,
	30546,
	30547,
	30548,
	30549,
	30550,
	30551,
	30552,
	30553,
	30554,
	30555,
	30556,
	30557,
	30558,
	30559,
	30560,
	30561,
	30562,
	30563,
	30564,
	30565,
	30566,
	30567,
	30568,
	30569,
	30570,
	30571,
	30572,
	30573,
	30574,
	30575,
	30576,
	30577,
	30578,
	30579,
	30580,
	30581,
	30582,
	30583,
	30584,
	30585,
	30586,
	30587,
	30588,
	30589,
	30590,
	30591,
	30592,
	30593,
	30594,
	30595,
	30596,
	30597,
	30598,
	30599,
	30600,
	30601,
	30602,
	30603,
	30604,
	30605,
	30606,
	30607,
	30608,
	30609,
	30610,
	30611,
	30612,
	30613,
	30614,
	30615,
	30616,
	30617,
	30618,
	30619,
	30620,
	30621,
	30622,
	30623,
	30624,
	30625,
	30626,
	30627,
	30628,
	30629,
	30630,
	30631,
	30632,
	30633,
	30634,
	30635,
	30636,
	30637,
	30638,
	30639,
	30640,
	30641,
	30642,
	30643,
	30644,
	30645,
	30646,
	30647,
	30648,
	30649,
	30650,
	30651,
	30652,
	30653,
	30654,
	30655,
	30656,
	30657,
	30658,
	30659,
	30660,
	30661,
	30662,
	30663,
	30664,
	30665,
	30666,
	30667,
	30668,
	30669,
	30670,
	30671,
	30672,
	30673,
	30674,
	30675,
	30676,
	30677,
	30678,
	30679,
	30680,
	30681,
	30682,
	30683,
	30684,
	30685,
	30686,
	30687,
	30688,
	30689,
	30690,
	30691,
	30692,
	30693,
	30694,
	30695,
	30696,
	30697,
	30698,
	30699,
	30700,
	30701,
	30702,
	30703,
	30704,
	30705,
	30706,
	30707,
	30708,
	30709,
	30710,
	30711,
	30712,
	30713,
	30714,
	30715,
	30716,
	30717,
	30718,
	30719,
	30720,
	30721,
	30722,
	30723,
	30724,
	30725,
	30726,
	30727,
	30728,
	30729,
	30730,
	30731,
	30732,
	30733,
	30734,
	30735,
	30736,
	30737,
	30738,
	30739,
	30740,
	30741,
	30742,
	30743,
	30744,
	30745,
	30746,
	30747,
	30748,
	30749,
	30750,
	30751,
	30752,
	30753,
	30754,
	30755,
	30756,
	30757,
	30758,
	30759,
	30760,
	30761,
	30762,
	30763,
	30764,
	30765,
	30766,
	30767,
	30768,
	30769,
	30770,
	30771,
	30772,
	30773,
	30774,
	30775,
	30776,
	30777,
	30778,
	30779,
	30780,
	30781,
	30782,
	30783,
	30784,
	30785,
	30786,
	30787,
	30788,
	30789,
	30790,
	30791,
	30792,
	30793,
	30794,
	30795,
	30796,
	30797,
	30798,
	30799,
	30800,
	30801,
	30802,
	30803,
	30804,
	30805,
	30806,
	30807,
	30808,
	30809,
	30810,
	30811,
	30812,
	30813,
	30814,
	30815,
	30816,
	30817,
	30818,
	30819,
	30820,
	30821,
	30822,
	30823,
	30824,
	30825,
	30826,
	30827,
	30828,
	30829,
	30830,
	30831,
	30832,
	30833,
	30834,
	30835,
	30836,
	30837,
	30838,
	30839,
	30840,
	30841,
	30842,
	30843,
	30844,
	30845,
	30846,
	30847,
	30848,
	30849,
	30850,
	30851,
	30852,
	30853,
	30854,
	30855,
	30856,
	30857,
	30858,
	30859,
	30860,
	30861,
	30862,
	30863,
	30864,
	30865,
	30866,
	30867,
	30868,
	30869,
	30870,
	30871,
	30872,
	30873,
	30874,
	30875,
	30876,
	30877,
	30878,
	30879,
	30880,
	30881,
	30882,
	30883,
	30884,
	30885,
	30886,
	30887,
	30888,
	30889,
	30890,
	30891,
	30892,
	30893,
	30894,
	30895,
	30896,
	30897,
	30898,
	30899,
	30900,
	30901,
	30902,
	30903,
	30904,
	30905,
	30906,
	30907,
	30908,
	30909,
	30910,
	30911,
	30912,
	30913,
	30914,
	30915,
	30916,
	30917,
	30918,
	30919,
	30920,
	30921,
	30922,
	30923,
	30924,
	30925,
	30926,
	30927,
	30928,
	30929,
	30930,
	30931,
	30932,
	30933,
	30934,
	30935,
	30936,
	30937,
	30938,
	30939,
	30940,
	30941,
	30942,
	30943,
	30944,
	30945,
	30946,
	30947,
	30948,
	30949,
	30950,
	30951,
	30952,
	30953,
	30954,
	30955,
	30956,
	30957,
	30958,
	30959,
	30960,
	30961,
	30962,
	30963,
	30964,
	30965,
	30966,
	30967,
	30968,
	30969,
	30970,
	30971,
	30972,
	30973,
	30974,
	30975,
	30976,
	30977,
	30978,
	30979,
	30980,
	30981,
	30982,
	30983,
	30984,
	30985,
	30986,
	30987,
	30988,
	30989,
	30990,
	30991,
	30992,
	30993,
	30994,
	30995,
	30996,
	30997,
	30998,
	30999,
	31000,
	31001,
	31002,
	31003,
	31004,
	31005,
	31006,
	31007,
	31008,
	31009,
	31010,
	31011,
	31012,
	31013,
	31014,
	31015,
	31016,
	31017,
	31018,
	31019,
	31020,
	31021,
	31022,
	31023,
	31024,
	31025,
	31026,
	31027,
	31028,
	31029,
	31030,
	31031,
	31032,
	31033,
	31034,
	31035,
	31036,
	31037,
	31038,
	31039,
	31040,
	31041,
	31042,
	31043,
	31044,
	31045,
	31046,
	31047,
	31048,
	31049,
	31050,
	31051,
	31052,
	31053,
	31054,
	31055,
	31056,
	31057,
	31058,
	31059,
	31060,
	31061,
	31062,
	31063,
	31064,
	31065,
	31066,
	31067,
	31068,
	31069,
	31070,
	31071,
	31072,
	31073,
	31074,
	31075,
	31076,
	31077,
	31078,
	31079,
	31080,
	31081,
	31082,
	31083,
	31084,
	31085,
	31086,
	31087,
	31088,
	31089,
	31090,
	31091,
	31092,
	31093,
	31094,
	31095,
	31096,
	31097,
	31098,
	31099,
	31100,
	31101,
	31102,
	31103,
	31104,
	31105,
	31106,
	31107,
	31108,
	31109,
	31110,
	31111,
	31112,
	31113,
	31114,
	31115,
	31116,
	31117,
	31118,
	31119,
	31120,
	31121,
	31122,
	31123,
	31124,
	31125,
	31126,
	31127,
	31128,
	31129,
	31130,
	31131,
	31132,
	31133,
	31134,
	31135,
	31136,
	31137,
	31138,
	31139,
	31140,
	31141,
	31142,
	31143,
	31144,
	31145,
	31146,
	31147,
	31148,
	31149,
	31150,
	31151,
	31152,
	31153,
	31154,
	31155,
	31156,
	31157,
	31158,
	31159,
	31160,
	31161,
	31162,
	31163,
	31164,
	31165,
	31166,
	31167,
	31168,
	31169,
	31170,
	31171,
	31172,
	31173,
	31174,
	31175,
	31176,
	31177,
	31178,
	31179,
	31180,
	31181,
	31182,
	31183,
	31184,
	31185,
	31186,
	31187,
	31188,
	31189,
	31190,
	31191,
	31192,
	31193,
	31194,
	31195,
	31196,
	31197,
	31198,
	31199,
	31200,
	31201,
	31202,
	31203,
	31204,
	31205,
	31206,
	31207,
	31208,
	31209,
	31210,
	31211,
	31212,
	31213,
	31214,
	31215,
	31216,
	31217,
	31218,
	31219,
	31220,
	31221,
	31222,
	31223,
	31224,
	31225,
	31226,
	31227,
	31228,
	31229,
	31230,
	31231,
	31232,
	31233,
	31234,
	31235,
	31236,
	31237,
	31238,
	31239,
	31240,
	31241,
	31242,
	31243,
	31244,
	31245,
	31246,
	31247,
	31248,
	31249,
	31250,
	31251,
	31252,
	31253,
	31254,
	31255,
	31256,
	31257,
	31258,
	31259,
	31260,
	31261,
	31262,
	31263,
	31264,
	31265,
	31266,
	31267,
	31268,
	31269,
	31270,
	31271,
	31272,
	31273,
	31274,
	31275,
	31276,
	31277,
	31278,
	31279,
	31280,
	31281,
	31282,
	31283,
	31284,
	31285,
	31286,
	31287,
	31288,
	31289,
	31290,
	31291,
	31292,
	31293,
	31294,
	31295,
	31296,
	31297,
	31298,
	31299,
	31300,
	31301,
	31302,
	31303,
	31304,
	31305,
	31306,
	31307,
	31308,
	31309,
	31310,
	31311,
	31312,
	31313,
	31314,
	31315,
	31316,
	31317,
	31318,
	31319,
	31320,
	31321,
	31322,
	31323,
	31324,
	31325,
	31326,
	31327,
	31328,
	31329,
	31330,
	31331,
	31332,
	31333,
	31334,
	31335,
	31336,
	31337,
	31338,
	31339,
	31340,
	31341,
	31342,
	31343,
	31344,
	31345,
	31346,
	31347,
	31348,
	31349,
	31350,
	31351,
	31352,
	31353,
	31354,
	31355,
	31356,
	31357,
	31358,
	31359,
	31360,
	31361,
	31362,
	31363,
	31364,
	31365,
	31366,
	31367,
	31368,
	31369,
	31370,
	31371,
	31372,
	31373,
	31374,
	31375,
	31376,
	31377,
	31378,
	31379,
	31380,
	31381,
	31382,
	31383,
	31384,
	31385,
	31386,
	31387,
	31388,
	31389,
	31390,
	31391,
	31392,
	31393,
	31394,
	31395,
	31396,
	31397,
	31398,
	31399,
	31400,
	31401,
	31402,
	31403,
	31404,
	31405,
	31406,
	31407,
	31408,
	31409,
	31410,
	31411,
	31412,
	31413,
	31414,
	31415,
	31416,
	31417,
	31418,
	31419,
	31420,
	31421,
	31422,
	31423,
	31424,
	31425,
	31426,
	31427,
	31428,
	31429,
	31430,
	31431,
	31432,
	31433,
	31434,
	31435,
	31436,
	31437,
	31438,
	31439,
	31440,
	31441,
	31442,
	31443,
	31444,
	31445,
	31446,
	31447,
	31448,
	31449,
	31450,
	31451,
	31452,
	31453,
	31454,
	31455,
	31456,
	31457,
	31458,
	31459,
	31460,
	31461,
	31462,
	31463,
	31464,
	31465,
	31466,
	31467,
	31468,
	31469,
	31470,
	31471,
	31472,
	31473,
	31474,
	31475,
	31476,
	31477,
	31478,
	31479,
	31480,
	31481,
	31482,
	31483,
	31484,
	31485,
	31486,
	31487,
	31488,
	31489,
	31490,
	31491,
	31492,
	31493,
	31494,
	31495,
	31496,
	31497,
	31498,
	31499,
	31500,
	31501,
	31502,
	31503,
	31504,
	31505,
	31506,
	31507,
	31508,
	31509,
	31510,
	31511,
	31512,
	31513,
	31514,
	31515,
	31516,
	31517,
	31518,
	31519,
	31520,
	31521,
	31522,
	31523,
	31524,
	31525,
	31526,
	31527,
	31528,
	31529,
	31530,
	31531,
	31532,
	31533,
	31534,
	31535,
	31536,
	31537,
	31538,
	31539,
	31540,
	31541,
	31542,
	31543,
	31544,
	31545,
	31546,
	31547,
	31548,
	31549,
	31550,
	31551,
	31552,
	31553,
	31554,
	31555,
	31556,
	31557,
	31558,
	31559,
	31560,
	31561,
	31562,
	31563,
	31564,
	31565,
	31566,
	31567,
	31568,
	31569,
	31570,
	31571,
	31572,
	31573,
	31574,
	31575,
	31576,
	31577,
	31578,
	31579,
	31580,
	31581,
	31582,
	31583,
	31584,
	31585,
	31586,
	31587,
	31588,
	31589,
	31590,
	31591,
	31592,
	31593,
	31594,
	31595,
	31596,
	31597,
	31598,
	31599,
	31600,
	31601,
	31602,
	31603,
	31604,
	31605,
	31606,
	31607,
	31608,
	31609,
	31610,
	31611,
	31612,
	31613,
	31614,
	31615,
	31616,
	31617,
	31618,
	31619,
	31620,
	31621,
	31622,
	31623,
	31624,
	31625,
	31626,
	31627,
	31628,
	31629,
	31630,
	31631,
	31632,
	31633,
	31634,
	31635,
	31636,
	31637,
	31638,
	31639,
	31640,
	31641,
	31642,
	31643,
	31644,
	31645,
	31646,
	31647,
	31648,
	31649,
	31650,
	31651,
	31652,
	31653,
	31654,
	31655,
	31656,
	31657,
	31658,
	31659,
	31660,
	31661,
	31662,
	31663,
	31664,
	31665,
	31666,
	31667,
	31668,
	31669,
	31670,
	31671,
	31672,
	31673,
	31674,
	31675,
	31676,
	31677,
	31678,
	31679,
	31680,
	31681,
	31682,
	31683,
	31684,
	31685,
	31686,
	31687,
	31688,
	31689,
	31690,
	31691,
	31692,
	31693,
	31694,
	31695,
	31696,
	31697,
	31698,
	31699,
	31700,
	31701,
	31702,
	31703,
	31704,
	31705,
	31706,
	31707,
	31708,
	31709,
	31710,
	31711,
	31712,
	31713,
	31714,
	31715,
	31716,
	31717,
	31718,
	31719,
	31720,
	31721,
	31722,
	31723,
	31724,
	31725,
	31726,
	31727,
	31728,
	31729,
	31730,
	31731,
	31732,
	31733,
	31734,
	31735,
	31736,
	31737,
	31738,
	31739,
	31740,
	31741,
	31742,
	31743,
	31744,
	31745,
	31746,
	31747,
	31748,
	31749,
	31750,
	31751,
	31752,
	31753,
	31754,
	31755,
	31756,
	31757,
	31758,
	31759,
	31760,
	31761,
	31762,
	31763,
	31764,
	31765,
	31766,
	31767,
	31768,
	31769,
	31770,
	31771,
	31772,
	31773,
	31774,
	31775,
	31776,
	31777,
	31778,
	31779,
	31780,
	31781,
	31782,
	31783,
	31784,
	31785,
	31786,
	31787,
	31788,
	31789,
	31790,
	31791,
	31792,
	31793,
	31794,
	31795,
	31796,
	31797,
	31798,
	31799,
	31800,
	31801,
	31802,
	31803,
	31804,
	31805,
	31806,
	31807,
	31808,
	31809,
	31810,
	31811,
	31812,
	31813,
	31814,
	31815,
	31816,
	31817,
	31818,
	31819,
	31820,
	31821,
	31822,
	31823,
	31824,
	31825,
	31826,
	31827,
	31828,
	31829,
	31830,
	31831,
	31832,
	31833,
	31834,
	31835,
	31836,
	31837,
	31838,
	31839,
	31840,
	31841,
	31842,
	31843,
	31844,
	31845,
	31846,
	31847,
	31848,
	31849,
	31850,
	31851,
	31852,
	31853,
	31854,
	31855,
	31856,
	31857,
	31858,
	31859,
	31860,
	31861,
	31862,
	31863,
	31864,
	31865,
	31866,
	31867,
	31868,
	31869,
	31870,
	31871,
	31872,
	31873,
	31874,
	31875,
	31876,
	31877,
	31878,
	31879,
	31880,
	31881,
	31882,
	31883,
	31884,
	31885,
	31886,
	31887,
	31888,
	31889,
	31890,
	31891,
	31892,
	31893,
	31894,
	31895,
	31896,
	31897,
	31898,
	31899,
	31900,
	31901,
	31902,
	31903,
	31904,
	31905,
	31906,
	31907,
	31908,
	31909,
	31910,
	31911,
	31912,
	31913,
	31914,
	31915,
	31916,
	31917,
	31918,
	31919,
	31920,
	31921,
	31922,
	31923,
	31924,
	31925,
	31926,
	31927,
	31928,
	31929,
	31930,
	31931,
	31932,
	31933,
	31934,
	31935,
	31936,
	31937,
	31938,
	31939,
	31940,
	31941,
	31942,
	31943,
	31944,
	31945,
	31946,
	31947,
	31948,
	31949,
	31950,
	31951,
	31952,
	31953,
	31954,
	31955,
	31956,
	31957,
	31958,
	31959,
	31960,
	31961,
	31962,
	31963,
	31964,
	31965,
	31966,
	31967,
	31968,
	31969,
	31970,
	31971,
	31972,
	31973,
	31974,
	31975,
	31976,
	31977,
	31978,
	31979,
	31980,
	31981,
	31982,
	31983,
	31984,
	31985,
	31986,
	31987,
	31988,
	31989,
	31990,
	31991,
	31992,
	31993,
	31994,
	31995,
	31996,
	31997,
	31998,
	31999,
	32000,
	32001,
	32002,
	32003,
	32004,
	32005,
	32006,
	32007,
	32008,
	32009,
	32010,
	32011,
	32012,
	32013,
	32014,
	32015,
	32016,
	32017,
	32018,
	32019,
	32020,
	32021,
	32022,
	32023,
	32024,
	32025,
	32026,
	32027,
	32028,
	32029,
	32030,
	32031,
	32032,
	32033,
	32034,
	32035,
	32036,
	32037,
	32038,
	32039,
	32040,
	32041,
	32042,
	32043,
	32044,
	32045,
	32046,
	32047,
	32048,
	32049,
	32050,
	32051,
	32052,
	32053,
	32054,
	32055,
	32056,
	32057,
	32058,
	32059,
	32060,
	32061,
	32062,
	32063,
	32064,
	32065,
	32066,
	32067,
	32068,
	32069,
	32070,
	32071,
	32072,
	32073,
	32074,
	32075,
	32076,
	32077,
	32078,
	32079,
	32080,
	32081,
	32082,
	32083,
	32084,
	32085,
	32086,
	32087,
	32088,
	32089,
	32090,
	32091,
	32092,
	32093,
	32094,
	32095,
	32096,
	32097,
	32098,
	32099,
	32100,
	32101,
	32102,
	32103,
	32104,
	32105,
	32106,
	32107,
	32108,
	32109,
	32110,
	32111,
	32112,
	32113,
	32114,
	32115,
	32116,
	32117,
	32118,
	32119,
	32120,
	32121,
	32122,
	32123,
	32124,
	32125,
	32126,
	32127,
	32128,
	32129,
	32130,
	32131,
	32132,
	32133,
	32134,
	32135,
	32136,
	32137,
	32138,
	32139,
	32140,
	32141,
	32142,
	32143,
	32144,
	32145,
	32146,
	32147,
	32148,
	32149,
	32150,
	32151,
	32152,
	32153,
	32154,
	32155,
	32156,
	32157,
	32158,
	32159,
	32160,
	32161,
	32162,
	32163,
	32164,
	32165,
	32166,
	32167,
	32168,
	32169,
	32170,
	32171,
	32172,
	32173,
	32174,
	32175,
	32176,
	32177,
	32178,
	32179,
	32180,
	32181,
	32182,
	32183,
	32184,
	32185,
	32186,
	32187,
	32188,
	32189,
	32190,
	32191,
	32192,
	32193,
	32194,
	32195,
	32196,
	32197,
	32198,
	32199,
	32200,
	32201,
	32202,
	32203,
	32204,
	32205,
	32206,
	32207,
	32208,
	32209,
	32210,
	32211,
	32212,
	32213,
	32214,
	32215,
	32216,
	32217,
	32218,
	32219,
	32220,
	32221,
	32222,
	32223,
	32224,
	32225,
	32226,
	32227,
	32228,
	32229,
	32230,
	32231,
	32232,
	32233,
	32234,
	32235,
	32236,
	32237,
	32238,
	32239,
	32240,
	32241,
	32242,
	32243,
	32244,
	32245,
	32246,
	32247,
	32248,
	32249,
	32250,
	32251,
	32252,
	32253,
	32254,
	32255,
	32256,
	32257,
	32258,
	32259,
	32260,
	32261,
	32262,
	32263,
	32264,
	32265,
	32266,
	32267,
	32268,
	32269,
	32270,
	32271,
	32272,
	32273,
	32274,
	32275,
	32276,
	32277,
	32278,
	32279,
	32280,
	32281,
	32282,
	32283,
	32284,
	32285,
	32286,
	32287,
	32288,
	32289,
	32290,
	32291,
	32292,
	32293,
	32294,
	32295,
	32296,
	32297,
	32298,
	32299,
	32300,
	32301,
	32302,
	32303,
	32304,
	32305,
	32306,
	32307,
	32308,
	32309,
	32310,
	32311,
	32312,
	32313,
	32314,
	32315,
	32316,
	32317,
	32318,
	32319,
	32320,
	32321,
	32322,
	32323,
	32324,
	32325,
	32326,
	32327,
	32328,
	32329,
	32330,
	32331,
	32332,
	32333,
	32334,
	32335,
	32336,
	32337,
	32338,
	32339,
	32340,
	32341,
	32342,
	32343,
	32344,
	32345,
	32346,
	32347,
	32348,
	32349,
	32350,
	32351,
	32352,
	32353,
	32354,
	32355,
	32356,
	32357,
	32358,
	32359,
	32360,
	32361,
	32362,
	32363,
	32364,
	32365,
	32366,
	32367,
	32368,
	32369,
	32370,
	32371,
	32372,
	32373,
	32374,
	32375,
	32376,
	32377,
	32378,
	32379,
	32380,
	32381,
	32382,
	32383,
	32384,
	32385,
	32386,
	32387,
	32388,
	32389,
	32390,
	32391,
	32392,
	32393,
	32394,
	32395,
	32396,
	32397,
	32398,
	32399,
	32400,
	32401,
	32402,
	32403,
	32404,
	32405,
	32406,
	32407,
	32408,
	32409,
	32410,
	32411,
	32412,
	32413,
	32414,
	32415,
	32416,
	32417,
	32418,
	32419,
	32420,
	32421,
	32422,
	32423,
	32424,
	32425,
	32426,
	32427,
	32428,
	32429,
	32430,
	32431,
	32432,
	32433,
	32434,
	32435,
	32436,
	32437,
	32438,
	32439,
	32440,
	32441,
	32442,
	32443,
	32444,
	32445,
	32446,
	32447,
	32448,
	32449,
	32450,
	32451,
	32452,
	32453,
	32454,
	32455,
	32456,
	32457,
	32458,
	32459,
	32460,
	32461,
	32462,
	32463,
	32464,
	32465,
	32466,
	32467,
	32468,
	32469,
	32470,
	32471,
	32472,
	32473,
	32474,
	32475,
	32476,
	32477,
	32478,
	32479,
	32480,
	32481,
	32482,
	32483,
	32484,
	32485,
	32486,
	32487,
	32488,
	32489,
	32490,
	32491,
	32492,
	32493,
	32494,
	32495,
	32496,
	32497,
	32498,
	32499,
	32500,
	32501,
	32502,
	32503,
	32504,
	32505,
	32506,
	32507,
	32508,
	32509,
	32510,
	32511,
	32512,
	32513,
	32514,
	32515,
	32516,
	32517,
	32518,
	32519,
	32520,
	32521,
	32522,
	32523,
	32524,
	32525,
	32526,
	32527,
	32528,
	32529,
	32530,
	32531,
	32532,
	32533,
	32534,
	32535,
	32536,
	32537,
	32538,
	32539,
	32540,
	32541,
	32542,
	32543,
	32544,
	32545,
	32546,
	32547,
	32548,
	32549,
	32550,
	32551,
	32552,
	32553,
	32554,
	32555,
	32556,
	32557,
	32558,
	32559,
	32560,
	32561,
	32562,
	32563,
	32564,
	32565,
	32566,
	32567,
	32568,
	32569,
	32570,
	32571,
	32572,
	32573,
	32574,
	32575,
	32576,
	32577,
	32578,
	32579,
	32580,
	32581,
	32582,
	32583,
	32584,
	32585,
	32586,
	32587,
	32588,
	32589,
	32590,
	32591,
	32592,
	32593,
	32594,
	32595,
	32596,
	32597,
	32598,
	32599,
	32600,
	32601,
	32602,
	32603,
	32604,
	32605,
	32606,
	32607,
	32608,
	32609,
	32610,
	32611,
	32612,
	32613,
	32614,
	32615,
	32616,
	32617,
	32618,
	32619,
	32620,
	32621,
	32622,
	32623,
	32624,
	32625,
	32626,
	32627,
	32628,
	32629,
	32630,
	32631,
	32632,
	32633,
	32634,
	32635,
	32636,
	32637,
	32638,
	32639,
	32640,
	32641,
	32642,
	32643,
	32644,
	32645,
	32646,
	32647,
	32648,
	32649,
	32650,
	32651,
	32652,
	32653,
	32654,
	32655,
	32656,
	32657,
	32658,
	32659,
	32660,
	32661,
	32662,
	32663,
	32664,
	32665,
	32666,
	32667,
	32668,
	32669,
	32670,
	32671,
	32672,
	32673,
	32674,
	32675,
	32676,
	32677,
	32678,
	32679,
	32680,
	32681,
	32682,
	32683,
	32684,
	32685,
	32686,
	32687,
	32688,
	32689,
	32690,
	32691,
	32692,
	32693,
	32694,
	32695,
	32696,
	32697,
	32698,
	32699,
	32700,
	32701,
	32702,
	32703,
	32704,
	32705,
	32706,
	32707,
	32708,
	32709,
	32710,
	32711,
	32712,
	32713,
	32714,
	32715,
	32716,
	32717,
	32718,
	32719,
	32720,
	32721,
	32722,
	32723,
	32724,
	32725,
	32726,
	32727,
	32728,
	32729,
	32730,
	32731,
	32732,
	32733,
	32734,
	32735,
	32736,
	32737,
	32738,
	32739,
	32740,
	32741,
	32742,
	32743,
	32744,
	32745,
	32746,
	32747,
	32748,
	32749,
	32750,
	32751,
	32752,
	32753,
	32754,
	32755,
	32756,
	32757,
	32758,
	32759,
	32760,
	32761,
	32762,
	32763,
	32764,
	32765,
	32766,
	32767,
	32768,
	32769,
	32770,
	32771,
	32772,
	32773,
	32774,
	32775,
	32776,
	32777,
	32778,
	32779,
	32780,
	32781,
	32782,
	32783,
	32784,
	32785,
	32786,
	32787,
	32788,
	32789,
	32790,
	32791,
	32792,
	32793,
	32794,
	32795,
	32796,
	32797,
	32798,
	32799,
	32800,
	32801,
	32802,
	32803,
	32804,
	32805,
	32806,
	32807,
	32808,
	32809,
	32810,
	32811,
	32812,
	32813,
	32814,
	32815,
	32816,
	32817,
	32818,
	32819,
	32820,
	32821,
	32822,
	32823,
	32824,
	32825,
	32826,
	32827,
	32828,
	32829,
	32830,
	32831,
	32832,
	32833,
	32834,
	32835,
	32836,
	32837,
	32838,
	32839,
	32840,
	32841,
	32842,
	32843,
	32844,
	32845,
	32846,
	32847,
	32848,
	32849,
	32850,
	32851,
	32852,
	32853,
	32854,
	32855,
	32856,
	32857,
	32858,
	32859,
	32860,
	32861,
	32862,
	32863,
	32864,
	32865,
	32866,
	32867,
	32868,
	32869,
	32870,
	32871,
	32872,
	32873,
	32874,
	32875,
	32876,
	32877,
	32878,
	32879,
	32880,
	32881,
	32882,
	32883,
	32884,
	32885,
	32886,
	32887,
	32888,
	32889,
	32890,
	32891,
	32892,
	32893,
	32894,
	32895,
	32896,
	32897,
	32898,
	32899,
	32900,
	32901,
	32902,
	32903,
	32904,
	32905,
	32906,
	32907,
	32908,
	32909,
	32910,
	32911,
	32912,
	32913,
	32914,
	32915,
	32916,
	32917,
	32918,
	32919,
	32920,
	32921,
	32922,
	32923,
	32924,
	32925,
	32926,
	32927,
	32928,
	32929,
	32930,
	32931,
	32932,
	32933,
	32934,
	32935,
	32936,
	32937,
	32938,
	32939,
	32940,
	32941,
	32942,
	32943,
	32944,
	32945,
	32946,
	32947,
	32948,
	32949,
	32950,
	32951,
	32952,
	32953,
	32954,
	32955,
	32956,
	32957,
	32958,
	32959,
	32960,
	32961,
	32962,
	32963,
	32964,
	32965,
	32966,
	32967,
	32968,
	32969,
	32970,
	32971,
	32972,
	32973,
	32974,
	32975,
	32976,
	32977,
	32978,
	32979,
	32980,
	32981,
	32982,
	32983,
	32984,
	32985,
	32986,
	32987,
	32988,
	32989,
	32990,
	32991,
	32992,
	32993,
	32994,
	32995,
	32996,
	32997,
	32998,
	32999,
	33000,
	33001,
	33002,
	33003,
	33004,
	33005,
	33006,
	33007,
	33008,
	33009,
	33010,
	33011,
	33012,
	33013,
	33014,
	33015,
	33016,
	33017,
	33018,
	33019,
	33020,
	33021,
	33022,
	33023,
	33024,
	33025,
	33026,
	33027,
	33028,
	33029,
	33030,
	33031,
	33032,
	33033,
	33034,
	33035,
	33036,
	33037,
	33038,
	33039,
	33040,
	33041,
	33042,
	33043,
	33044,
	33045,
	33046,
	33047,
	33048,
	33049,
	33050,
	33051,
	33052,
	33053,
	33054,
	33055,
	33056,
	33057,
	33058,
	33059,
	33060,
	33061,
	33062,
	33063,
	33064,
	33065,
	33066,
	33067,
	33068,
	33069,
	33070,
	33071,
	33072,
	33073,
	33074,
	33075,
	33076,
	33077,
	33078,
	33079,
	33080,
	33081,
	33082,
	33083,
	33084,
	33085,
	33086,
	33087,
	33088,
	33089,
	33090,
	33091,
	33092,
	33093,
	33094,
	33095,
	33096,
	33097,
	33098,
	33099,
	33100,
	33101,
	33102,
	33103,
	33104,
	33105,
	33106,
	33107,
	33108,
	33109,
	33110,
	33111,
	33112,
	33113,
	33114,
	33115,
	33116,
	33117,
	33118,
	33119,
	33120,
	33121,
	33122,
	33123,
	33124,
	33125,
	33126,
	33127,
	33128,
	33129,
	33130,
	33131,
	33132,
	33133,
	33134,
	33135,
	33136,
	33137,
	33138,
	33139,
	33140,
	33141,
	33142,
	33143,
	33144,
	33145,
	33146,
	33147,
	33148,
	33149,
	33150,
	33151,
	33152,
	33153,
	33154,
	33155,
	33156,
	33157,
	33158,
	33159,
	33160,
	33161,
	33162,
	33163,
	33164,
	33165,
	33166,
	33167,
	33168,
	33169,
	33170,
	33171,
	33172,
	33173,
	33174,
	33175,
	33176,
	33177,
	33178,
	33179,
	33180,
	33181,
	33182,
	33183,
	33184,
	33185,
	33186,
	33187,
	33188,
	33189,
	33190,
	33191,
	33192,
	33193,
	33194,
	33195,
	33196,
	33197,
	33198,
	33199,
	33200,
	33201,
	33202,
	33203,
	33204,
	33205,
	33206,
	33207,
	33208,
	33209,
	33210,
	33211,
	33212,
	33213,
	33214,
	33215,
	33216,
	33217,
	33218,
	33219,
	33220,
	33221,
	33222,
	33223,
	33224,
	33225,
	33226,
	33227,
	33228,
	33229,
	33230,
	33231,
	33232,
	33233,
	33234,
	33235,
	33236,
	33237,
	33238,
	33239,
	33240,
	33241,
	33242,
	33243,
	33244,
	33245,
	33246,
	33247,
	33248,
	33249,
	33250,
	33251,
	33252,
	33253,
	33254,
	33255,
	33256,
	33257,
	33258,
	33259,
	33260,
	33261,
	33262,
	33263,
	33264,
	33265,
	33266,
	33267,
	33268,
	33269,
	33270,
	33271,
	33272,
	33273,
	33274,
	33275,
	33276,
	33277,
	33278,
	33279,
	33280,
	33281,
	33282,
	33283,
	33284,
	33285,
	33286,
	33287,
	33288,
	33289,
	33290,
	33291,
	33292,
	33293,
	33294,
	33295,
	33296,
	33297,
	33298,
	33299,
	33300,
	33301,
	33302,
	33303,
	33304,
	33305,
	33306,
	33307,
	33308,
	33309,
	33310,
	33311,
	33312,
	33313,
	33314,
	33315,
	33316,
	33317,
	33318,
	33319,
	33320,
	33321,
	33322,
	33323,
	33324,
	33325,
	33326,
	33327,
	33328,
	33329,
	33330,
	33331,
	33332,
	33333,
	33334,
	33335,
	33336,
	33337,
	33338,
	33339,
	33340,
	33341,
	33342,
	33343,
	33344,
	33345,
	33346,
	33347,
	33348,
	33349,
	33350,
	33351,
	33352,
	33353,
	33354,
	33355,
	33356,
	33357,
	33358,
	33359,
	33360,
	33361,
	33362,
	33363,
	33364,
	33365,
	33366,
	33367,
	33368,
	33369,
	33370,
	33371,
	33372,
	33373,
	33374,
	33375,
	33376,
	33377,
	33378,
	33379,
	33380,
	33381,
	33382,
	33383,
	33384,
	33385,
	33386,
	33387,
	33388,
	33389,
	33390,
	33391,
	33392,
	33393,
	33394,
	33395,
	33396,
	33397,
	33398,
	33399,
	33400,
	33401,
	33402,
	33403,
	33404,
	33405,
	33406,
	33407,
	33408,
	33409,
	33410,
	33411,
	33412,
	33413,
	33414,
	33415,
	33416,
	33417,
	33418,
	33419,
	33420,
	33421,
	33422,
	33423,
	33424,
	33425,
	33426,
	33427,
	33428,
	33429,
	33430,
	33431,
	33432,
	33433,
	33434,
	33435,
	33436,
	33437,
	33438,
	33439,
	33440,
	33441,
	33442,
	33443,
	33444,
	33445,
	33446,
	33447,
	33448,
	33449,
	33450,
	33451,
	33452,
	33453,
	33454,
	33455,
	33456,
	33457,
	33458,
	33459,
	33460,
	33461,
	33462,
	33463,
	33464,
	33465,
	33466,
	33467,
	33468,
	33469,
	33470,
	33471,
	33472,
	33473,
	33474,
	33475,
	33476,
	33477,
	33478,
	33479,
	33480,
	33481,
	33482,
	33483,
	33484,
	33485,
	33486,
	33487,
	33488,
	33489,
	33490,
	33491,
	33492,
	33493,
	33494,
	33495,
	33496,
	33497,
	33498,
	33499,
	33500,
	33501,
	33502,
	33503,
	33504,
	33505,
	33506,
	33507,
	33508,
	33509,
	33510,
	33511,
	33512,
	33513,
	33514,
	33515,
	33516,
	33517,
	33518,
	33519,
	33520,
	33521,
	33522,
	33523,
	33524,
	33525,
	33526,
	33527,
	33528,
	33529,
	33530,
	33531,
	33532,
	33533,
	33534,
	33535,
	33536,
	33537,
	33538,
	33539,
	33540,
	33541,
	33542,
	33543,
	33544,
	33545,
	33546,
	33547,
	33548,
	33549,
	33550,
	33551,
	33552,
	33553,
	33554,
	33555,
	33556,
	33557,
	33558,
	33559,
	33560,
	33561,
	33562,
	33563,
	33564,
	33565,
	33566,
	33567,
	33568,
	33569,
	33570,
	33571,
	33572,
	33573,
	33574,
	33575,
	33576,
	33577,
	33578,
	33579,
	33580,
	33581,
	33582,
	33583,
	33584,
	33585,
	33586,
	33587,
	33588,
	33589,
	33590,
	33591,
	33592,
	33593,
	33594,
	33595,
	33596,
	33597,
	33598,
	33599,
	33600,
	33601,
	33602,
	33603,
	33604,
	33605,
	33606,
	33607,
	33608,
	33609,
	33610,
	33611,
	33612,
	33613,
	33614,
	33615,
	33616,
	33617,
	33618,
	33619,
	33620,
	33621,
	33622,
	33623,
	33624,
	33625,
	33626,
	33627,
	33628,
	33629,
	33630,
	33631,
	33632,
	33633,
	33634,
	33635,
	33636,
	33637,
	33638,
	33639,
	33640,
	33641,
	33642,
	33643,
	33644,
	33645,
	33646,
	33647,
	33648,
	33649,
	33650,
	33651,
	33652,
	33653,
	33654,
	33655,
	33656,
	33657,
	33658,
	33659,
	33660,
	33661,
	33662,
	33663,
	33664,
	33665,
	33666,
	33667,
	33668,
	33669,
	33670,
	33671,
	33672,
	33673,
	33674,
	33675,
	33676,
	33677,
	33678,
	33679,
	33680,
	33681,
	33682,
	33683,
	33684,
	33685,
	33686,
	33687,
	33688,
	33689,
	33690,
	33691,
	33692,
	33693,
	33694,
	33695,
	33696,
	33697,
	33698,
	33699,
	33700,
	33701,
	33702,
	33703,
	33704,
	33705,
	33706,
	33707,
	33708,
	33709,
	33710,
	33711,
	33712,
	33713,
	33714,
	33715,
	33716,
	33717,
	33718,
	33719,
	33720,
	33721,
	33722,
	33723,
	33724,
	33725,
	33726,
	33727,
	33728,
	33729,
	33730,
	33731,
	33732,
	33733,
	33734,
	33735,
	33736,
	33737,
	33738,
	33739,
	33740,
	33741,
	33742,
	33743,
	33744,
	33745,
	33746,
	33747,
	33748,
	33749,
	33750,
	33751,
	33752,
	33753,
	33754,
	33755,
	33756,
	33757,
	33758,
	33759,
	33760,
	33761,
	33762,
	33763,
	33764,
	33765,
	33766,
	33767,
	33768,
	33769,
	33770,
	33771,
	33772,
	33773,
	33774,
	33775,
	33776,
	33777,
	33778,
	33779,
	33780,
	33781,
	33782,
	33783,
	33784,
	33785,
	33786,
	33787,
	33788,
	33789,
	33790,
	33791,
	33792,
	33793,
	33794,
	33795,
	33796,
	33797,
	33798,
	33799,
	33800,
	33801,
	33802,
	33803,
	33804,
	33805,
	33806,
	33807,
	33808,
	33809,
	33810,
	33811,
	33812,
	33813,
	33814,
	33815,
	33816,
	33817,
	33818,
	33819,
	33820,
	33821,
	33822,
	33823,
	33824,
	33825,
	33826,
	33827,
	33828,
	33829,
	33830,
	33831,
	33832,
	33833,
	33834,
	33835,
	33836,
	33837,
	33838,
	33839,
	33840,
	33841,
	33842,
	33843,
	33844,
	33845,
	33846,
	33847,
	33848,
	33849,
	33850,
	33851,
	33852,
	33853,
	33854,
	33855,
	33856,
	33857,
	33858,
	33859,
	33860,
	33861,
	33862,
	33863,
	33864,
	33865,
	33866,
	33867,
	33868,
	33869,
	33870,
	33871,
	33872,
	33873,
	33874,
	33875,
	33876,
	33877,
	33878,
	33879,
	33880,
	33881,
	33882,
	33883,
	33884,
	33885,
	33886,
	33887,
	33888,
	33889,
	33890,
	33891,
	33892,
	33893,
	33894,
	33895,
	33896,
	33897,
	33898,
	33899,
	33900,
	33901,
	33902,
	33903,
	33904,
	33905,
	33906,
	33907,
	33908,
	33909,
	33910,
	33911,
	33912,
	33913,
	33914,
	33915,
	33916,
	33917,
	33918,
	33919,
	33920,
	33921,
	33922,
	33923,
	33924,
	33925,
	33926,
	33927,
	33928,
	33929,
	33930,
	33931,
	33932,
	33933,
	33934,
	33935,
	33936,
	33937,
	33938,
	33939,
	33940,
	33941,
	33942,
	33943,
	33944,
	33945,
	33946,
	33947,
	33948,
	33949,
	33950,
	33951,
	33952,
	33953,
	33954,
	33955,
	33956,
	33957,
	33958,
	33959,
	33960,
	33961,
	33962,
	33963,
	33964,
	33965,
	33966,
	33967,
	33968,
	33969,
	33970,
	33971,
	33972,
	33973,
	33974,
	33975,
	33976,
	33977,
	33978,
	33979,
	33980,
	33981,
	33982,
	33983,
	33984,
	33985,
	33986,
	33987,
	33988,
	33989,
	33990,
	33991,
	33992,
	33993,
	33994,
	33995,
	33996,
	33997,
	33998,
	33999,
	34000,
	34001,
	34002,
	34003,
	34004,
	34005,
	34006,
	34007,
	34008,
	34009,
	34010,
	34011,
	34012,
	34013,
	34014,
	34015,
	34016,
	34017,
	34018,
	34019,
	34020,
	34021,
	34022,
	34023,
	34024,
	34025,
	34026,
	34027,
	34028,
	34029,
	34030,
	34031,
	34032,
	34033,
	34034,
	34035,
	34036,
	34037,
	34038,
	34039,
	34040,
	34041,
	34042,
	34043,
	34044,
	34045,
	34046,
	34047,
	34048,
	34049,
	34050,
	34051,
	34052,
	34053,
	34054,
	34055,
	34056,
	34057,
	34058,
	34059,
	34060,
	34061,
	34062,
	34063,
	34064,
	34065,
	34066,
	34067,
	34068,
	34069,
	34070,
	34071,
	34072,
	34073,
	34074,
	34075,
	34076,
	34077,
	34078,
	34079,
	34080,
	34081,
	34082,
	34083,
	34084,
	34085,
	34086,
	34087,
	34088,
	34089,
	34090,
	34091,
	34092,
	34093,
	34094,
	34095,
	34096,
	34097,
	34098,
	34099,
	34100,
	34101,
	34102,
	34103,
	34104,
	34105,
	34106,
	34107,
	34108,
	34109,
	34110,
	34111,
	34112,
	34113,
	34114,
	34115,
	34116,
	34117,
	34118,
	34119,
	34120,
	34121,
	34122,
	34123,
	34124,
	34125,
	34126,
	34127,
	34128,
	34129,
	34130,
	34131,
	34132,
	34133,
	34134,
	34135,
	34136,
	34137,
	34138,
	34139,
	34140,
	34141,
	34142,
	34143,
	34144,
	34145,
	34146,
	34147,
	34148,
	34149,
	34150,
	34151,
	34152,
	34153,
	34154,
	34155,
	34156,
	34157,
	34158,
	34159,
	34160,
	34161,
	34162,
	34163,
	34164,
	34165,
	34166,
	34167,
	34168,
	34169,
	34170,
	34171,
	34172,
	34173,
	34174,
	34175,
	34176,
	34177,
	34178,
	34179,
	34180,
	34181,
	34182,
	34183,
	34184,
	34185,
	34186,
	34187,
	34188,
	34189,
	34190,
	34191,
	34192,
	34193,
	34194,
	34195,
	34196,
	34197,
	34198,
	34199,
	34200,
	34201,
	34202,
	34203,
	34204,
	34205,
	34206,
	34207,
	34208,
	34209,
	34210,
	34211,
	34212,
	34213,
	34214,
	34215,
	34216,
	34217,
	34218,
	34219,
	34220,
	34221,
	34222,
	34223,
	34224,
	34225,
	34226,
	34227,
	34228,
	34229,
	34230,
	34231,
	34232,
	34233,
	34234,
	34235,
	34236,
	34237,
	34238,
	34239,
	34240,
	34241,
	34242,
	34243,
	34244,
	34245,
	34246,
	34247,
	34248,
	34249,
	34250,
	34251,
	34252,
	34253,
	34254,
	34255,
	34256,
	34257,
	34258,
	34259,
	34260,
	34261,
	34262,
	34263,
	34264,
	34265,
	34266,
	34267,
	34268,
	34269,
	34270,
	34271,
	34272,
	34273,
	34274,
	34275,
	34276,
	34277,
	34278,
	34279,
	34280,
	34281,
	34282,
	34283,
	34284,
	34285,
	34286,
	34287,
	34288,
	34289,
	34290,
	34291,
	34292,
	34293,
	34294,
	34295,
	34296,
	34297,
	34298,
	34299,
	34300,
	34301,
	34302,
	34303,
	34304,
	34305,
	34306,
	34307,
	34308,
	34309,
	34310,
	34311,
	34312,
	34313,
	34314,
	34315,
	34316,
	34317,
	34318,
	34319,
	34320,
	34321,
	34322,
	34323,
	34324,
	34325,
	34326,
	34327,
	34328,
	34329,
	34330,
	34331,
	34332,
	34333,
	34334,
	34335,
	34336,
	34337,
	34338,
	34339,
	34340,
	34341,
	34342,
	34343,
	34344,
	34345,
	34346,
	34347,
	34348,
	34349,
	34350,
	34351,
	34352,
	34353,
	34354,
	34355,
	34356,
	34357,
	34358,
	34359,
	34360,
	34361,
	34362,
	34363,
	34364,
	34365,
	34366,
	34367,
	34368,
	34369,
	34370,
	34371,
	34372,
	34373,
	34374,
	34375,
	34376,
	34377,
	34378,
	34379,
	34380,
	34381,
	34382,
	34383,
	34384,
	34385,
	34386,
	34387,
	34388,
	34389,
	34390,
	34391,
	34392,
	34393,
	34394,
	34395,
	34396,
	34397,
	34398,
	34399,
	34400,
	34401,
	34402,
	34403,
	34404,
	34405,
	34406,
	34407,
	34408,
	34409,
	34410,
	34411,
	34412,
	34413,
	34414,
	34415,
	34416,
	34417,
	34418,
	34419,
	34420,
	34421,
	34422,
	34423,
	34424,
	34425,
	34426,
	34427,
	34428,
	34429,
	34430,
	34431,
	34432,
	34433,
	34434,
	34435,
	34436,
	34437,
	34438,
	34439,
	34440,
	34441,
	34442,
	34443,
	34444,
	34445,
	34446,
	34447,
	34448,
	34449,
	34450,
	34451,
	34452,
	34453,
	34454,
	34455,
	34456,
	34457,
	34458,
	34459,
	34460,
	34461,
	34462,
	34463,
	34464,
	34465,
	34466,
	34467,
	34468,
	34469,
	34470,
	34471,
	34472,
	34473,
	34474,
	34475,
	34476,
	34477,
	34478,
	34479,
	34480,
	34481,
	34482,
	34483,
	34484,
	34485,
	34486,
	34487,
	34488,
	34489,
	34490,
	34491,
	34492,
	34493,
	34494,
	34495,
	34496,
	34497,
	34498,
	34499,
	34500,
	34501,
	34502,
	34503,
	34504,
	34505,
	34506,
	34507,
	34508,
	34509,
	34510,
	34511,
	34512,
	34513,
	34514,
	34515,
	34516,
	34517,
	34518,
	34519,
	34520,
	34521,
	34522,
	34523,
	34524,
	34525,
	34526,
	34527,
	34528,
	34529,
	34530,
	34531,
	34532,
	34533,
	34534,
	34535,
	34536,
	34537,
	34538,
	34539,
	34540,
	34541,
	34542,
	34543,
	34544,
	34545,
	34546,
	34547,
	34548,
	34549,
	34550,
	34551,
	34552,
	34553,
	34554,
	34555,
	34556,
	34557,
	34558,
	34559,
	34560,
	34561,
	34562,
	34563,
	34564,
	34565,
	34566,
	34567,
	34568,
	34569,
	34570,
	34571,
	34572,
	34573,
	34574,
	34575,
	34576,
	34577,
	34578,
	34579,
	34580,
	34581,
	34582,
	34583,
	34584,
	34585,
	34586,
	34587,
	34588,
	34589,
	34590,
	34591,
	34592,
	34593,
	34594,
	34595,
	34596,
	34597,
	34598,
	34599,
	34600,
	34601,
	34602,
	34603,
	34604,
	34605,
	34606,
	34607,
	34608,
	34609,
	34610,
	34611,
	34612,
	34613,
	34614,
	34615,
	34616,
	34617,
	34618,
	34619,
	34620,
	34621,
	34622,
	34623,
	34624,
	34625,
	34626,
	34627,
	34628,
	34629,
	34630,
	34631,
	34632,
	34633,
	34634,
	34635,
	34636,
	34637,
	34638,
	34639,
	34640,
	34641,
	34642,
	34643,
	34644,
	34645,
	34646,
	34647,
	34648,
	34649,
	34650,
	34651,
	34652,
	34653,
	34654,
	34655,
	34656,
	34657,
	34658,
	34659,
	34660,
	34661,
	34662,
	34663,
	34664,
	34665,
	34666,
	34667,
	34668,
	34669,
	34670,
	34671,
	34672,
	34673,
	34674,
	34675,
	34676,
	34677,
	34678,
	34679,
	34680,
	34681,
	34682,
	34683,
	34684,
	34685,
	34686,
	34687,
	34688,
	34689,
	34690,
	34691,
	34692,
	34693,
	34694,
	34695,
	34696,
	34697,
	34698,
	34699,
	34700,
	34701,
	34702,
	34703,
	34704,
	34705,
	34706,
	34707,
	34708,
	34709,
	34710,
	34711,
	34712,
	34713,
	34714,
	34715,
	34716,
	34717,
	34718,
	34719,
	34720,
	34721,
	34722,
	34723,
	34724,
	34725,
	34726,
	34727,
	34728,
	34729,
	34730,
	34731,
	34732,
	34733,
	34734,
	34735,
	34736,
	34737,
	34738,
	34739,
	34740,
	34741,
	34742,
	34743,
	34744,
	34745,
	34746,
	34747,
	34748,
	34749,
	34750,
	34751,
	34752,
	34753,
	34754,
	34755,
	34756,
	34757,
	34758,
	34759,
	34760,
	34761,
	34762,
	34763,
	34764,
	34765,
	34766,
	34767,
	34768,
	34769,
	34770,
	34771,
	34772,
	34773,
	34774,
	34775,
	34776,
	34777,
	34778,
	34779,
	34780,
	34781,
	34782,
	34783,
	34784,
	34785,
	34786,
	34787,
	34788,
	34789,
	34790,
	34791,
	34792,
	34793,
	34794,
	34795,
	34796,
	34797,
	34798,
	34799,
	34800,
	34801,
	34802,
	34803,
	34804,
	34805,
	34806,
	34807,
	34808,
	34809,
	34810,
	34811,
	34812,
	34813,
	34814,
	34815,
	34816,
	34817,
	34818,
	34819,
	34820,
	34821,
	34822,
	34823,
	34824,
	34825,
	34826,
	34827,
	34828,
	34829,
	34830,
	34831,
	34832,
	34833,
	34834,
	34835,
	34836,
	34837,
	34838,
	34839,
	34840,
	34841,
	34842,
	34843,
	34844,
	34845,
	34846,
	34847,
	34848,
	34849,
	34850,
	34851,
	34852,
	34853,
	34854,
	34855,
	34856,
	34857,
	34858,
	34859,
	34860,
	34861,
	34862,
	34863,
	34864,
	34865,
	34866,
	34867,
	34868,
	34869,
	34870,
	34871,
	34872,
	34873,
	34874,
	34875,
	34876,
	34877,
	34878,
	34879,
	34880,
	34881,
	34882,
	34883,
	34884,
	34885,
	34886,
	34887,
	34888,
	34889,
	34890,
	34891,
	34892,
	34893,
	34894,
	34895,
	34896,
	34897,
	34898,
	34899,
	34900,
	34901,
	34902,
	34903,
	34904,
	34905,
	34906,
	34907,
	34908,
	34909,
	34910,
	34911,
	34912,
	34913,
	34914,
	34915,
	34916,
	34917,
	34918,
	34919,
	34920,
	34921,
	34922,
	34923,
	34924,
	34925,
	34926,
	34927,
	34928,
	34929,
	34930,
	34931,
	34932,
	34933,
	34934,
	34935,
	34936,
	34937,
	34938,
	34939,
	34940,
	34941,
	34942,
	34943,
	34944,
	34945,
	34946,
	34947,
	34948,
	34949,
	34950,
	34951,
	34952,
	34953,
	34954,
	34955,
	34956,
	34957,
	34958,
	34959,
	34960,
	34961,
	34962,
	34963,
	34964,
	34965,
	34966,
	34967,
	34968,
	34969,
	34970,
	34971,
	34972,
	34973,
	34974,
	34975,
	34976,
	34977,
	34978,
	34979,
	34980,
	34981,
	34982,
	34983,
	34984,
	34985,
	34986,
	34987,
	34988,
	34989,
	34990,
	34991,
	34992,
	34993,
	34994,
	34995,
	34996,
	34997,
	34998,
	34999,
	35000,
	35001,
	35002,
	35003,
	35004,
	35005,
	35006,
	35007,
	35008,
	35009,
	35010,
	35011,
	35012,
	35013,
	35014,
	35015,
	35016,
	35017,
	35018,
	35019,
	35020,
	35021,
	35022,
	35023,
	35024,
	35025,
	35026,
	35027,
	35028,
	35029,
	35030,
	35031,
	35032,
	35033,
	35034,
	35035,
	35036,
	35037,
	35038,
	35039,
	35040,
	35041,
	35042,
	35043,
	35044,
	35045,
	35046,
	35047,
	35048,
	35049,
	35050,
	35051,
	35052,
	35053,
	35054,
	35055,
	35056,
	35057,
	35058,
	35059,
	35060,
	35061,
	35062,
	35063,
	35064,
	35065,
	35066,
	35067,
	35068,
	35069,
	35070,
	35071,
	35072,
	35073,
	35074,
	35075,
	35076,
	35077,
	35078,
	35079,
	35080,
	35081,
	35082,
	35083,
	35084,
	35085,
	35086,
	35087,
	35088,
	35089,
	35090,
	35091,
	35092,
	35093,
	35094,
	35095,
	35096,
	35097,
	35098,
	35099,
	35100,
	35101,
	35102,
	35103,
	35104,
	35105,
	35106,
	35107,
	35108,
	35109,
	35110,
	35111,
	35112,
	35113,
	35114,
	35115,
	35116,
	35117,
	35118,
	35119,
	35120,
	35121,
	35122,
	35123,
	35124,
	35125,
	35126,
	35127,
	35128,
	35129,
	35130,
	35131,
	35132,
	35133,
	35134,
	35135,
	35136,
	35137,
	35138,
	35139,
	35140,
	35141,
	35142,
	35143,
	35144,
	35145,
	35146,
	35147,
	35148,
	35149,
	35150,
	35151,
	35152,
	35153,
	35154,
	35155,
	35156,
	35157,
	35158,
	35159,
	35160,
	35161,
	35162,
	35163,
	35164,
	35165,
	35166,
	35167,
	35168,
	35169,
	35170,
	35171,
	35172,
	35173,
	35174,
	35175,
	35176,
	35177,
	35178,
	35179,
	35180,
	35181,
	35182,
	35183,
	35184,
	35185,
	35186,
	35187,
	35188,
	35189,
	35190,
	35191,
	35192,
	35193,
	35194,
	35195,
	35196,
	35197,
	35198,
	35199,
	35200,
	35201,
	35202,
	35203,
	35204,
	35205,
	35206,
	35207,
	35208,
	35209,
	35210,
	35211,
	35212,
	35213,
	35214,
	35215,
	35216,
	35217,
	35218,
	35219,
	35220,
	35221,
	35222,
	35223,
	35224,
	35225,
	35226,
	35227,
	35228,
	35229,
	35230,
	35231,
	35232,
	35233,
	35234,
	35235,
	35236,
	35237,
	35238,
	35239,
	35240,
	35241,
	35242,
	35243,
	35244,
	35245,
	35246,
	35247,
	35248,
	35249,
	35250,
	35251,
	35252,
	35253,
	35254,
	35255,
	35256,
	35257,
	35258,
	35259,
	35260,
	35261,
	35262,
	35263,
	35264,
	35265,
	35266,
	35267,
	35268,
	35269,
	35270,
	35271,
	35272,
	35273,
	35274,
	35275,
	35276,
	35277,
	35278,
	35279,
	35280,
	35281,
	35282,
	35283,
	35284,
	35285,
	35286,
	35287,
	35288,
	35289,
	35290,
	35291,
	35292,
	35293,
	35294,
	35295,
	35296,
	35297,
	35298,
	35299,
	35300,
	35301,
	35302,
	35303,
	35304,
	35305,
	35306,
	35307,
	35308,
	35309,
	35310,
	35311,
	35312,
	35313,
	35314,
	35315,
	35316,
	35317,
	35318,
	35319,
	35320,
	35321,
	35322,
	35323,
	35324,
	35325,
	35326,
	35327,
	35328,
	35329,
	35330,
	35331,
	35332,
	35333,
	35334,
	35335,
	35336,
	35337,
	35338,
	35339,
	35340,
	35341,
	35342,
	35343,
	35344,
	35345,
	35346,
	35347,
	35348,
	35349,
	35350,
	35351,
	35352,
	35353,
	35354,
	35355,
	35356,
	35357,
	35358,
	35359,
	35360,
	35361,
	35362,
	35363,
	35364,
	35365,
	35366,
	35367,
	35368,
	35369,
	35370,
	35371,
	35372,
	35373,
	35374,
	35375,
	35376,
	35377,
	35378,
	35379,
	35380,
	35381,
	35382,
	35383,
	35384,
	35385,
	35386,
	35387,
	35388,
	35389,
	35390,
	35391,
	35392,
	35393,
	35394,
	35395,
	35396,
	35397,
	35398,
	35399,
	35400,
	35401,
	35402,
	35403,
	35404,
	35405,
	35406,
	35407,
	35408,
	35409,
	35410,
	35411,
	35412,
	35413,
	35414,
	35415,
	35416,
	35417,
	35418,
	35419,
	35420,
	35421,
	35422,
	35423,
	35424,
	35425,
	35426,
	35427,
	35428,
	35429,
	35430,
	35431,
	35432,
	35433,
	35434,
	35435,
	35436,
	35437,
	35438,
	35439,
	35440,
	35441,
	35442,
	35443,
	35444,
	35445,
	35446,
	35447,
	35448,
	35449,
	35450,
	35451,
	35452,
	35453,
	35454,
	35455,
	35456,
	35457,
	35458,
	35459,
	35460,
	35461,
	35462,
	35463,
	35464,
	35465,
	35466,
	35467,
	35468,
	35469,
	35470,
	35471,
	35472,
	35473,
	35474,
	35475,
	35476,
	35477,
	35478,
	35479,
	35480,
	35481,
	35482,
	35483,
	35484,
	35485,
	35486,
	35487,
	35488,
	35489,
	35490,
	35491,
	35492,
	35493,
	35494,
	35495,
	35496,
	35497,
	35498,
	35499,
	35500,
	35501,
	35502,
	35503,
	35504,
	35505,
	35506,
	35507,
	35508,
	35509,
	35510,
	35511,
	35512,
	35513,
	35514,
	35515,
	35516,
	35517,
	35518,
	35519,
	35520,
	35521,
	35522,
	35523,
	35524,
	35525,
	35526,
	35527,
	35528,
	35529,
	35530,
	35531,
	35532,
	35533,
	35534,
	35535,
	35536,
	35537,
	35538,
	35539,
	35540,
	35541,
	35542,
	35543,
	35544,
	35545,
	35546,
	35547,
	35548,
	35549,
	35550,
	35551,
	35552,
	35553,
	35554,
	35555,
	35556,
	35557,
	35558,
	35559,
	35560,
	35561,
	35562,
	35563,
	35564,
	35565,
	35566,
	35567,
	35568,
	35569,
	35570,
	35571,
	35572,
	35573,
	35574,
	35575,
	35576,
	35577,
	35578,
	35579,
	35580,
	35581,
	35582,
	35583,
	35584,
	35585,
	35586,
	35587,
	35588,
	35589,
	35590,
	35591,
	35592,
	35593,
	35594,
	35595,
	35596,
	35597,
	35598,
	35599,
	35600,
	35601,
	35602,
	35603,
	35604,
	35605,
	35606,
	35607,
	35608,
	35609,
	35610,
	35611,
	35612,
	35613,
	35614,
	35615,
	35616,
	35617,
	35618,
	35619,
	35620,
	35621,
	35622,
	35623,
	35624,
	35625,
	35626,
	35627,
	35628,
	35629,
	35630,
	35631,
	35632,
	35633,
	35634,
	35635,
	35636,
	35637,
	35638,
	35639,
	35640,
	35641,
	35642,
	35643,
	35644,
	35645,
	35646,
	35647,
	35648,
	35649,
	35650,
	35651,
	35652,
	35653,
	35654,
	35655,
	35656,
	35657,
	35658,
	35659,
	35660,
	35661,
	35662,
	35663,
	35664,
	35665,
	35666,
	35667,
	35668,
	35669,
	35670,
	35671,
	35672,
	35673,
	35674,
	35675,
	35676,
	35677,
	35678,
	35679,
	35680,
	35681,
	35682,
	35683,
	35684,
	35685,
	35686,
	35687,
	35688,
	35689,
	35690,
	35691,
	35692,
	35693,
	35694,
	35695,
	35696,
	35697,
	35698,
	35699,
	35700,
	35701,
	35702,
	35703,
	35704,
	35705,
	35706,
	35707,
	35708,
	35709,
	35710,
	35711,
	35712,
	35713,
	35714,
	35715,
	35716,
	35717,
	35718,
	35719,
	35720,
	35721,
	35722,
	35723,
	35724,
	35725,
	35726,
	35727,
	35728,
	35729,
	35730,
	35731,
	35732,
	35733,
	35734,
	35735,
	35736,
	35737,
	35738,
	35739,
	35740,
	35741,
	35742,
	35743,
	35744,
	35745,
	35746,
	35747,
	35748,
	35749,
	35750,
	35751,
	35752,
	35753,
	35754,
	35755,
	35756,
	35757,
	35758,
	35759,
	35760,
	35761,
	35762,
	35763,
	35764,
	35765,
	35766,
	35767,
	35768,
	35769,
	35770,
	35771,
	35772,
	35773,
	35774,
	35775,
	35776,
	35777,
	35778,
	35779,
	35780,
	35781,
	35782,
	35783,
	35784,
	35785,
	35786,
	35787,
	35788,
	35789,
	35790,
	35791,
	35792,
	35793,
	35794,
	35795,
	35796,
	35797,
	35798,
	35799,
	35800,
	35801,
	35802,
	35803,
	35804,
	35805,
	35806,
	35807,
	35808,
	35809,
	35810,
	35811,
	35812,
	35813,
	35814,
	35815,
	35816,
	35817,
	35818,
	35819,
	35820,
	35821,
	35822,
	35823,
	35824,
	35825,
	35826,
	35827,
	35828,
	35829,
	35830,
	35831,
	35832,
	35833,
	35834,
	35835,
	35836,
	35837,
	35838,
	35839,
	35840,
	35841,
	35842,
	35843,
	35844,
	35845,
	35846,
	35847,
	35848,
	35849,
	35850,
	35851,
	35852,
	35853,
	35854,
	35855,
	35856,
	35857,
	35858,
	35859,
	35860,
	35861,
	35862,
	35863,
	35864,
	35865,
	35866,
	35867,
	35868,
	35869,
	35870,
	35871,
	35872,
	35873,
	35874,
	35875,
	35876,
	35877,
	35878,
	35879,
	35880,
	35881,
	35882,
	35883,
	35884,
	35885,
	35886,
	35887,
	35888,
	35889,
	35890,
	35891,
	35892,
	35893,
	35894,
	35895,
	35896,
	35897,
	35898,
	35899,
	35900,
	35901,
	35902,
	35903,
	35904,
	35905,
	35906,
	35907,
	35908,
	35909,
	35910,
	35911,
	35912,
	35913,
	35914,
	35915,
	35916,
	35917,
	35918,
	35919,
	35920,
	35921,
	35922,
	35923,
	35924,
	35925,
	35926,
	35927,
	35928,
	35929,
	35930,
	35931,
	35932,
	35933,
	35934,
	35935,
	35936,
	35937,
	35938,
	35939,
	35940,
	35941,
	35942,
	35943,
	35944,
	35945,
	35946,
	35947,
	35948,
	35949,
	35950,
	35951,
	35952,
	35953,
	35954,
	35955,
	35956,
	35957,
	35958,
	35959,
	35960,
	35961,
	35962,
	35963,
	35964,
	35965,
	35966,
	35967,
	35968,
	35969,
	35970,
	35971,
	35972,
	35973,
	35974,
	35975,
	35976,
	35977,
	35978,
	35979,
	35980,
	35981,
	35982,
	35983,
	35984,
	35985,
	35986,
	35987,
	35988,
	35989,
	35990,
	35991,
	35992,
	35993,
	35994,
	35995,
	35996,
	35997,
	35998,
	35999,
	36000,
	36001,
	36002,
	36003,
	36004,
	36005,
	36006,
	36007,
	36008,
	36009,
	36010,
	36011,
	36012,
	36013,
	36014,
	36015,
	36016,
	36017,
	36018,
	36019,
	36020,
	36021,
	36022,
	36023,
	36024,
	36025,
	36026,
	36027,
	36028,
	36029,
	36030,
	36031,
	36032,
	36033,
	36034,
	36035,
	36036,
	36037,
	36038,
	36039,
	36040,
	36041,
	36042,
	36043,
	36044,
	36045,
	36046,
	36047,
	36048,
	36049,
	36050,
	36051,
	36052,
	36053,
	36054,
	36055,
	36056,
	36057,
	36058,
	36059,
	36060,
	36061,
	36062,
	36063,
	36064,
	36065,
	36066,
	36067,
	36068,
	36069,
	36070,
	36071,
	36072,
	36073,
	36074,
	36075,
	36076,
	36077,
	36078,
	36079,
	36080,
	36081,
	36082,
	36083,
	36084,
	36085,
	36086,
	36087,
	36088,
	36089,
	36090,
	36091,
	36092,
	36093,
	36094,
	36095,
	36096,
	36097,
	36098,
	36099,
	36100,
	36101,
	36102,
	36103,
	36104,
	36105,
	36106,
	36107,
	36108,
	36109,
	36110,
	36111,
	36112,
	36113,
	36114,
	36115,
	36116,
	36117,
	36118,
	36119,
	36120,
	36121,
	36122,
	36123,
	36124,
	36125,
	36126,
	36127,
	36128,
	36129,
	36130,
	36131,
	36132,
	36133,
	36134,
	36135,
	36136,
	36137,
	36138,
	36139,
	36140,
	36141,
	36142,
	36143,
	36144,
	36145,
	36146,
	36147,
	36148,
	36149,
	36150,
	36151,
	36152,
	36153,
	36154,
	36155,
	36156,
	36157,
	36158,
	36159,
	36160,
	36161,
	36162,
	36163,
	36164,
	36165,
	36166,
	36167,
	36168,
	36169,
	36170,
	36171,
	36172,
	36173,
	36174,
	36175,
	36176,
	36177,
	36178,
	36179,
	36180,
	36181,
	36182,
	36183,
	36184,
	36185,
	36186,
	36187,
	36188,
	36189,
	36190,
	36191,
	36192,
	36193,
	36194,
	36195,
	36196,
	36197,
	36198,
	36199,
	36200,
	36201,
	36202,
	36203,
	36204,
	36205,
	36206,
	36207,
	36208,
	36209,
	36210,
	36211,
	36212,
	36213,
	36214,
	36215,
	36216,
	36217,
	36218,
	36219,
	36220,
	36221,
	36222,
	36223,
	36224,
	36225,
	36226,
	36227,
	36228,
	36229,
	36230,
	36231,
	36232,
	36233,
	36234,
	36235,
	36236,
	36237,
	36238,
	36239,
	36240,
	36241,
	36242,
	36243,
	36244,
	36245,
	36246,
	36247,
	36248,
	36249,
	36250,
	36251,
	36252,
	36253,
	36254,
	36255,
	36256,
	36257,
	36258,
	36259,
	36260,
	36261,
	36262,
	36263,
	36264,
	36265,
	36266,
	36267,
	36268,
	36269,
	36270,
	36271,
	36272,
	36273,
	36274,
	36275,
	36276,
	36277,
	36278,
	36279,
	36280,
	36281,
	36282,
	36283,
	36284,
	36285,
	36286,
	36287,
	36288,
	36289,
	36290,
	36291,
	36292,
	36293,
	36294,
	36295,
	36296,
	36297,
	36298,
	36299,
	36300,
	36301,
	36302,
	36303,
	36304,
	36305,
	36306,
	36307,
	36308,
	36309,
	36310,
	36311,
	36312,
	36313,
	36314,
	36315,
	36316,
	36317,
	36318,
	36319,
	36320,
	36321,
	36322,
	36323,
	36324,
	36325,
	36326,
	36327,
	36328,
	36329,
	36330,
	36331,
	36332,
	36333,
	36334,
	36335,
	36336,
	36337,
	36338,
	36339,
	36340,
	36341,
	36342,
	36343,
	36344,
	36345,
	36346,
	36347,
	36348,
	36349,
	36350,
	36351,
	36352,
	36353,
	36354,
	36355,
	36356,
	36357,
	36358,
	36359,
	36360,
	36361,
	36362,
	36363,
	36364,
	36365,
	36366,
	36367,
	36368,
	36369,
	36370,
	36371,
	36372,
	36373,
	36374,
	36375,
	36376,
	36377,
	36378,
	36379,
	36380,
	36381,
	36382,
	36383,
	36384,
	36385,
	36386,
	36387,
	36388,
	36389,
	36390,
	36391,
	36392,
	36393,
	36394,
	36395,
	36396,
	36397,
	36398,
	36399,
	36400,
	36401,
	36402,
	36403,
	36404,
	36405,
	36406,
	36407,
	36408,
	36409,
	36410,
	36411,
	36412,
	36413,
	36414,
	36415,
	36416,
	36417,
	36418,
	36419,
	36420,
	36421,
	36422,
	36423,
	36424,
	36425,
	36426,
	36427,
	36428,
	36429,
	36430,
	36431,
	36432,
	36433,
	36434,
	36435,
	36436,
	36437,
	36438,
	36439,
	36440,
	36441,
	36442,
	36443,
	36444,
	36445,
	36446,
	36447,
	36448,
	36449,
	36450,
	36451,
	36452,
	36453,
	36454,
	36455,
	36456,
	36457,
	36458,
	36459,
	36460,
	36461,
	36462,
	36463,
	36464,
	36465,
	36466,
	36467,
	36468,
	36469,
	36470,
	36471,
	36472,
	36473,
	36474,
	36475,
	36476,
	36477,
	36478,
	36479,
	36480,
	36481,
	36482,
	36483,
	36484,
	36485,
	36486,
	36487,
	36488,
	36489,
	36490,
	36491,
	36492,
	36493,
	36494,
	36495,
	36496,
	36497,
	36498,
	36499,
	36500,
	36501,
	36502,
	36503,
	36504,
	36505,
	36506,
	36507,
	36508,
	36509,
	36510,
	36511,
	36512,
	36513,
	36514,
	36515,
	36516,
	36517,
	36518,
	36519,
	36520,
	36521,
	36522,
	36523,
	36524,
	36525,
	36526,
	36527,
	36528,
	36529,
	36530,
	36531,
	36532,
	36533,
	36534,
	36535,
	36536,
	36537,
	36538,
	36539,
	36540,
	36541,
	36542,
	36543,
	36544,
	36545,
	36546,
	36547,
	36548,
	36549,
	36550,
	36551,
	36552,
	36553,
	36554,
	36555,
	36556,
	36557,
	36558,
	36559,
	36560,
	36561,
	36562,
	36563,
	36564,
	36565,
	36566,
	36567,
	36568,
	36569,
	36570,
	36571,
	36572,
	36573,
	36574,
	36575,
	36576,
	36577,
	36578,
	36579,
	36580,
	36581,
	36582,
	36583,
	36584,
	36585,
	36586,
	36587,
	36588,
	36589,
	36590,
	36591,
	36592,
	36593,
	36594,
	36595,
	36596,
	36597,
	36598,
	36599,
	36600,
	36601,
	36602,
	36603,
	36604,
	36605,
	36606,
	36607,
	36608,
	36609,
	36610,
	36611,
	36612,
	36613,
	36614,
	36615,
	36616,
	36617,
	36618,
	36619,
	36620,
	36621,
	36622,
	36623,
	36624,
	36625,
	36626,
	36627,
	36628,
	36629,
	36630,
	36631,
	36632,
	36633,
	36634,
	36635,
	36636,
	36637,
	36638,
	36639,
	36640,
	36641,
	36642,
	36643,
	36644,
	36645,
	36646,
	36647,
	36648,
	36649,
	36650,
	36651,
	36652,
	36653,
	36654,
	36655,
	36656,
	36657,
	36658,
	36659,
	36660,
	36661,
	36662,
	36663,
	36664,
	36665,
	36666,
	36667,
	36668,
	36669,
	36670,
	36671,
	36672,
	36673,
	36674,
	36675,
	36676,
	36677,
	36678,
	36679,
	36680,
	36681,
	36682,
	36683,
	36684,
	36685,
	36686,
	36687,
	36688,
	36689,
	36690,
	36691,
	36692,
	36693,
	36694,
	36695,
	36696,
	36697,
	36698,
	36699,
	36700,
	36701,
	36702,
	36703,
	36704,
	36705,
	36706,
	36707,
	36708,
	36709,
	36710,
	36711,
	36712,
	36713,
	36714,
	36715,
	36716,
	36717,
	36718,
	36719,
	36720,
	36721,
	36722,
	36723,
	36724,
	36725,
	36726,
	36727,
	36728,
	36729,
	36730,
	36731,
	36732,
	36733,
	36734,
	36735,
	36736,
	36737,
	36738,
	36739,
	36740,
	36741,
	36742,
	36743,
	36744,
	36745,
	36746,
	36747,
	36748,
	36749,
	36750,
	36751,
	36752,
	36753,
	36754,
	36755,
	36756,
	36757,
	36758,
	36759,
	36760,
	36761,
	36762,
	36763,
	36764,
	36765,
	36766,
	36767,
	36768,
	36769,
	36770,
	36771,
	36772,
	36773,
	36774,
	36775,
	36776,
	36777,
	36778,
	36779,
	36780,
	36781,
	36782,
	36783,
	36784,
	36785,
	36786,
	36787,
	36788,
	36789,
	36790,
	36791,
	36792,
	36793,
	36794,
	36795,
	36796,
	36797,
	36798,
	36799,
	36800,
	36801,
	36802,
	36803,
	36804,
	36805,
	36806,
	36807,
	36808,
	36809,
	36810,
	36811,
	36812,
	36813,
	36814,
	36815,
	36816,
	36817,
	36818,
	36819,
	36820,
	36821,
	36822,
	36823,
	36824,
	36825,
	36826,
	36827,
	36828,
	36829,
	36830,
	36831,
	36832,
	36833,
	36834,
	36835,
	36836,
	36837,
	36838,
	36839,
	36840,
	36841,
	36842,
	36843,
	36844,
	36845,
	36846,
	36847,
	36848,
	36849,
	36850,
	36851,
	36852,
	36853,
	36854,
	36855,
	36856,
	36857,
	36858,
	36859,
	36860,
	36861,
	36862,
	36863,
	36864,
	36865,
	36866,
	36867,
	36868,
	36869,
	36870,
	36871,
	36872,
	36873,
	36874,
	36875,
	36876,
	36877,
	36878,
	36879,
	36880,
	36881,
	36882,
	36883,
	36884,
	36885,
	36886,
	36887,
	36888,
	36889,
	36890,
	36891,
	36892,
	36893,
	36894,
	36895,
	36896,
	36897,
	36898,
	36899,
	36900,
	36901,
	36902,
	36903,
	36904,
	36905,
	36906,
	36907,
	36908,
	36909,
	36910,
	36911,
	36912,
	36913,
	36914,
	36915,
	36916,
	36917,
	36918,
	36919,
	36920,
	36921,
	36922,
	36923,
	36924,
	36925,
	36926,
	36927,
	36928,
	36929,
	36930,
	36931,
	36932,
	36933,
	36934,
	36935,
	36936,
	36937,
	36938,
	36939,
	36940,
	36941,
	36942,
	36943,
	36944,
	36945,
	36946,
	36947,
	36948,
	36949,
	36950,
	36951,
	36952,
	36953,
	36954,
	36955,
	36956,
	36957,
	36958,
	36959,
	36960,
	36961,
	36962,
	36963,
	36964,
	36965,
	36966,
	36967,
	36968,
	36969,
	36970,
	36971,
	36972,
	36973,
	36974,
	36975,
	36976,
	36977,
	36978,
	36979,
	36980,
	36981,
	36982,
	36983,
	36984,
	36985,
	36986,
	36987,
	36988,
	36989,
	36990,
	36991,
	36992,
	36993,
	36994,
	36995,
	36996,
	36997,
	36998,
	36999,
	37000,
	37001,
	37002,
	37003,
	37004,
	37005,
	37006,
	37007,
	37008,
	37009,
	37010,
	37011,
	37012,
	37013,
	37014,
	37015,
	37016,
	37017,
	37018,
	37019,
	37020,
	37021,
	37022,
	37023,
	37024,
	37025,
	37026,
	37027,
	37028,
	37029,
	37030,
	37031,
	37032,
	37033,
	37034,
	37035,
	37036,
	37037,
	37038,
	37039,
	37040,
	37041,
	37042,
	37043,
	37044,
	37045,
	37046,
	37047,
	37048,
	37049,
	37050,
	37051,
	37052,
	37053,
	37054,
	37055,
	37056,
	37057,
	37058,
	37059,
	37060,
	37061,
	37062,
	37063,
	37064,
	37065,
	37066,
	37067,
	37068,
	37069,
	37070,
	37071,
	37072,
	37073,
	37074,
	37075,
	37076,
	37077,
	37078,
	37079,
	37080,
	37081,
	37082,
	37083,
	37084,
	37085,
	37086,
	37087,
	37088,
	37089,
	37090,
	37091,
	37092,
	37093,
	37094,
	37095,
	37096,
	37097,
	37098,
	37099,
	37100,
	37101,
	37102,
	37103,
	37104,
	37105,
	37106,
	37107,
	37108,
	37109,
	37110,
	37111,
	37112,
	37113,
	37114,
	37115,
	37116,
	37117,
	37118,
	37119,
	37120,
	37121,
	37122,
	37123,
	37124,
	37125,
	37126,
	37127,
	37128,
	37129,
	37130,
	37131,
	37132,
	37133,
	37134,
	37135,
	37136,
	37137,
	37138,
	37139,
	37140,
	37141,
	37142,
	37143,
	37144,
	37145,
	37146,
	37147,
	37148,
	37149,
	37150,
	37151,
	37152,
	37153,
	37154,
	37155,
	37156,
	37157,
	37158,
	37159,
	37160,
	37161,
	37162,
	37163,
	37164,
	37165,
	37166,
	37167,
	37168,
	37169,
	37170,
	37171,
	37172,
	37173,
	37174,
	37175,
	37176,
	37177,
	37178,
	37179,
	37180,
	37181,
	37182,
	37183,
	37184,
	37185,
	37186,
	37187,
	37188,
	37189,
	37190,
	37191,
	37192,
	37193,
	37194,
	37195,
	37196,
	37197,
	37198,
	37199,
	37200,
	37201,
	37202,
	37203,
	37204,
	37205,
	37206,
	37207,
	37208,
	37209,
	37210,
	37211,
	37212,
	37213,
	37214,
	37215,
	37216,
	37217,
	37218,
	37219,
	37220,
	37221,
	37222,
	37223,
	37224,
	37225,
	37226,
	37227,
	37228,
	37229,
	37230,
	37231,
	37232,
	37233,
	37234,
	37235,
	37236,
	37237,
	37238,
	37239,
	37240,
	37241,
	37242,
	37243,
	37244,
	37245,
	37246,
	37247,
	37248,
	37249,
	37250,
	37251,
	37252,
	37253,
	37254,
	37255,
	37256,
	37257,
	37258,
	37259,
	37260,
	37261,
	37262,
	37263,
	37264,
	37265,
	37266,
	37267,
	37268,
	37269,
	37270,
	37271,
	37272,
	37273,
	37274,
	37275,
	37276,
	37277,
	37278,
	37279,
	37280,
	37281,
	37282,
	37283,
	37284,
	37285,
	37286,
	37287,
	37288,
	37289,
	37290,
	37291,
	37292,
	37293,
	37294,
	37295,
	37296,
	37297,
	37298,
	37299,
	37300,
	37301,
	37302,
	37303,
	37304,
	37305,
	37306,
	37307,
	37308,
	37309,
	37310,
	37311,
	37312,
	37313,
	37314,
	37315,
	37316,
	37317,
	37318,
	37319,
	37320,
	37321,
	37322,
	37323,
	37324,
	37325,
	37326,
	37327,
	37328,
	37329,
	37330,
	37331,
	37332,
	37333,
	37334,
	37335,
	37336,
	37337,
	37338,
	37339,
	37340,
	37341,
	37342,
	37343,
	37344,
	37345,
	37346,
	37347,
	37348,
	37349,
	37350,
	37351,
	37352,
	37353,
	37354,
	37355,
	37356,
	37357,
	37358,
	37359,
	37360,
	37361,
	37362,
	37363,
	37364,
	37365,
	37366,
	37367,
	37368,
	37369,
	37370,
	37371,
	37372,
	37373,
	37374,
	37375,
	37376,
	37377,
	37378,
	37379,
	37380,
	37381,
	37382,
	37383,
	37384,
	37385,
	37386,
	37387,
	37388,
	37389,
	37390,
	37391,
	37392,
	37393,
	37394,
	37395,
	37396,
	37397,
	37398,
	37399,
	37400,
	37401,
	37402,
	37403,
	37404,
	37405,
	37406,
	37407,
	37408,
	37409,
	37410,
	37411,
	37412,
	37413,
	37414,
	37415,
	37416,
	37417,
	37418,
	37419,
	37420,
	37421,
	37422,
	37423,
	37424,
	37425,
	37426,
	37427,
	37428,
	37429,
	37430,
	37431,
	37432,
	37433,
	37434,
	37435,
	37436,
	37437,
	37438,
	37439,
	37440,
	37441,
	37442,
	37443,
	37444,
	37445,
	37446,
	37447,
	37448,
	37449,
	37450,
	37451,
	37452,
	37453,
	37454,
	37455,
	37456,
	37457,
	37458,
	37459,
	37460,
	37461,
	37462,
	37463,
	37464,
	37465,
	37466,
	37467,
	37468,
	37469,
	37470,
	37471,
	37472,
	37473,
	37474,
	37475,
	37476,
	37477,
	37478,
	37479,
	37480,
	37481,
	37482,
	37483,
	37484,
	37485,
	37486,
	37487,
	37488,
	37489,
	37490,
	37491,
	37492,
	37493,
	37494,
	37495,
	37496,
	37497,
	37498,
	37499,
	37500,
	37501,
	37502,
	37503,
	37504,
	37505,
	37506,
	37507,
	37508,
	37509,
	37510,
	37511,
	37512,
	37513,
	37514,
	37515,
	37516,
	37517,
	37518,
	37519,
	37520,
	37521,
	37522,
	37523,
	37524,
	37525,
	37526,
	37527,
	37528,
	37529,
	37530,
	37531,
	37532,
	37533,
	37534,
	37535,
	37536,
	37537,
	37538,
	37539,
	37540,
	37541,
	37542,
	37543,
	37544,
	37545,
	37546,
	37547,
	37548,
	37549,
	37550,
	37551,
	37552,
	37553,
	37554,
	37555,
	37556,
	37557,
	37558,
	37559,
	37560,
	37561,
	37562,
	37563,
	37564,
	37565,
	37566,
	37567,
	37568,
	37569,
	37570,
	37571,
	37572,
	37573,
	37574,
	37575,
	37576,
	37577,
	37578,
	37579,
	37580,
	37581,
	37582,
	37583,
	37584,
	37585,
	37586,
	37587,
	37588,
	37589,
	37590,
	37591,
	37592,
	37593,
	37594,
	37595,
	37596,
	37597,
	37598,
	37599,
	37600,
	37601,
	37602,
	37603,
	37604,
	37605,
	37606,
	37607,
	37608,
	37609,
	37610,
	37611,
	37612,
	37613,
	37614,
	37615,
	37616,
	37617,
	37618,
	37619,
	37620,
	37621,
	37622,
	37623,
	37624,
	37625,
	37626,
	37627,
	37628,
	37629,
	37630,
	37631,
	37632,
	37633,
	37634,
	37635,
	37636,
	37637,
	37638,
	37639,
	37640,
	37641,
	37642,
	37643,
	37644,
	37645,
	37646,
	37647,
	37648,
	37649,
	37650,
	37651,
	37652,
	37653,
	37654,
	37655,
	37656,
	37657,
	37658,
	37659,
	37660,
	37661,
	37662,
	37663,
	37664,
	37665,
	37666,
	37667,
	37668,
	37669,
	37670,
	37671,
	37672,
	37673,
	37674,
	37675,
	37676,
	37677,
	37678,
	37679,
	37680,
	37681,
	37682,
	37683,
	37684,
	37685,
	37686,
	37687,
	37688,
	37689,
	37690,
	37691,
	37692,
	37693,
	37694,
	37695,
	37696,
	37697,
	37698,
	37699,
	37700,
	37701,
	37702,
	37703,
	37704,
	37705,
	37706,
	37707,
	37708,
	37709,
	37710,
	37711,
	37712,
	37713,
	37714,
	37715,
	37716,
	37717,
	37718,
	37719,
	37720,
	37721,
	37722,
	37723,
	37724,
	37725,
	37726,
	37727,
	37728,
	37729,
	37730,
	37731,
	37732,
	37733,
	37734,
	37735,
	37736,
	37737,
	37738,
	37739,
	37740,
	37741,
	37742,
	37743,
	37744,
	37745,
	37746,
	37747,
	37748,
	37749,
	37750,
	37751,
	37752,
	37753,
	37754,
	37755,
	37756,
	37757,
	37758,
	37759,
	37760,
	37761,
	37762,
	37763,
	37764,
	37765,
	37766,
	37767,
	37768,
	37769,
	37770,
	37771,
	37772,
	37773,
	37774,
	37775,
	37776,
	37777,
	37778,
	37779,
	37780,
	37781,
	37782,
	37783,
	37784,
	37785,
	37786,
	37787,
	37788,
	37789,
	37790,
	37791,
	37792,
	37793,
	37794,
	37795,
	37796,
	37797,
	37798,
	37799,
	37800,
	37801,
	37802,
	37803,
	37804,
	37805,
	37806,
	37807,
	37808,
	37809,
	37810,
	37811,
	37812,
	37813,
	37814,
	37815,
	37816,
	37817,
	37818,
	37819,
	37820,
	37821,
	37822,
	37823,
	37824,
	37825,
	37826,
	37827,
	37828,
	37829,
	37830,
	37831,
	37832,
	37833,
	37834,
	37835,
	37836,
	37837,
	37838,
	37839,
	37840,
	37841,
	37842,
	37843,
	37844,
	37845,
	37846,
	37847,
	37848,
	37849,
	37850,
	37851,
	37852,
	37853,
	37854,
	37855,
	37856,
	37857,
	37858,
	37859,
	37860,
	37861,
	37862,
	37863,
	37864,
	37865,
	37866,
	37867,
	37868,
	37869,
	37870,
	37871,
	37872,
	37873,
	37874,
	37875,
	37876,
	37877,
	37878,
	37879,
	37880,
	37881,
	37882,
	37883,
	37884,
	37885,
	37886,
	37887,
	37888,
	37889,
	37890,
	37891,
	37892,
	37893,
	37894,
	37895,
	37896,
	37897,
	37898,
	37899,
	37900,
	37901,
	37902,
	37903,
	37904,
	37905,
	37906,
	37907,
	37908,
	37909,
	37910,
	37911,
	37912,
	37913,
	37914,
	37915,
	37916,
	37917,
	37918,
	37919,
	37920,
	37921,
	37922,
	37923,
	37924,
	37925,
	37926,
	37927,
	37928,
	37929,
	37930,
	37931,
	37932,
	37933,
	37934,
	37935,
	37936,
	37937,
	37938,
	37939,
	37940,
	37941,
	37942,
	37943,
	37944,
	37945,
	37946,
	37947,
	37948,
	37949,
	37950,
	37951,
	37952,
	37953,
	37954,
	37955,
	37956,
	37957,
	37958,
	37959,
	37960,
	37961,
	37962,
	37963,
	37964,
	37965,
	37966,
	37967,
	37968,
	37969,
	37970,
	37971,
	37972,
	37973,
	37974,
	37975,
	37976,
	37977,
	37978,
	37979,
	37980,
	37981,
	37982,
	37983,
	37984,
	37985,
	37986,
	37987,
	37988,
	37989,
	37990,
	37991,
	37992,
	37993,
	37994,
	37995,
	37996,
	37997,
	37998,
	37999,
	38000,
	38001,
	38002,
	38003,
	38004,
	38005,
	38006,
	38007,
	38008,
	38009,
	38010,
	38011,
	38012,
	38013,
	38014,
	38015,
	38016,
	38017,
	38018,
	38019,
	38020,
	38021,
	38022,
	38023,
	38024,
	38025,
	38026,
	38027,
	38028,
	38029,
	38030,
	38031,
	38032,
	38033,
	38034,
	38035,
	38036,
	38037,
	38038,
	38039,
	38040,
	38041,
	38042,
	38043,
	38044,
	38045,
	38046,
	38047,
	38048,
	38049,
	38050,
	38051,
	38052,
	38053,
	38054,
	38055,
	38056,
	38057,
	38058,
	38059,
	38060,
	38061,
	38062,
	38063,
	38064,
	38065,
	38066,
	38067,
	38068,
	38069,
	38070,
	38071,
	38072,
	38073,
	38074,
	38075,
	38076,
	38077,
	38078,
	38079,
	38080,
	38081,
	38082,
	38083,
	38084,
	38085,
	38086,
	38087,
	38088,
	38089,
	38090,
	38091,
	38092,
	38093,
	38094,
	38095,
	38096,
	38097,
	38098,
	38099,
	38100,
	38101,
	38102,
	38103,
	38104,
	38105,
	38106,
	38107,
	38108,
	38109,
	38110,
	38111,
	38112,
	38113,
	38114,
	38115,
	38116,
	38117,
	38118,
	38119,
	38120,
	38121,
	38122,
	38123,
	38124,
	38125,
	38126,
	38127,
	38128,
	38129,
	38130,
	38131,
	38132,
	38133,
	38134,
	38135,
	38136,
	38137,
	38138,
	38139,
	38140,
	38141,
	38142,
	38143,
	38144,
	38145,
	38146,
	38147,
	38148,
	38149,
	38150,
	38151,
	38152,
	38153,
	38154,
	38155,
	38156,
	38157,
	38158,
	38159,
	38160,
	38161,
	38162,
	38163,
	38164,
	38165,
	38166,
	38167,
	38168,
	38169,
	38170,
	38171,
	38172,
	38173,
	38174,
	38175,
	38176,
	38177,
	38178,
	38179,
	38180,
	38181,
	38182,
	38183,
	38184,
	38185,
	38186,
	38187,
	38188,
	38189,
	38190,
	38191,
	38192,
	38193,
	38194,
	38195,
	38196,
	38197,
	38198,
	38199,
	38200,
	38201,
	38202,
	38203,
	38204,
	38205,
	38206,
	38207,
	38208,
	38209,
	38210,
	38211,
	38212,
	38213,
	38214,
	38215,
	38216,
	38217,
	38218,
	38219,
	38220,
	38221,
	38222,
	38223,
	38224,
	38225,
	38226,
	38227,
	38228,
	38229,
	38230,
	38231,
	38232,
	38233,
	38234,
	38235,
	38236,
	38237,
	38238,
	38239,
	38240,
	38241,
	38242,
	38243,
	38244,
	38245,
	38246,
	38247,
	38248,
	38249,
	38250,
	38251,
	38252,
	38253,
	38254,
	38255,
	38256,
	38257,
	38258,
	38259,
	38260,
	38261,
	38262,
	38263,
	38264,
	38265,
	38266,
	38267,
	38268,
	38269,
	38270,
	38271,
	38272,
	38273,
	38274,
	38275,
	38276,
	38277,
	38278,
	38279,
	38280,
	38281,
	38282,
	38283,
	38284,
	38285,
	38286,
	38287,
	38288,
	38289,
	38290,
	38291,
	38292,
	38293,
	38294,
	38295,
	38296,
	38297,
	38298,
	38299,
	38300,
	38301,
	38302,
	38303,
	38304,
	38305,
	38306,
	38307,
	38308,
	38309,
	38310,
	38311,
	38312,
	38313,
	38314,
	38315,
	38316,
	38317,
	38318,
	38319,
	38320,
	38321,
	38322,
	38323,
	38324,
	38325,
	38326,
	38327,
	38328,
	38329,
	38330,
	38331,
	38332,
	38333,
	38334,
	38335,
	38336,
	38337,
	38338,
	38339,
	38340,
	38341,
	38342,
	38343,
	38344,
	38345,
	38346,
	38347,
	38348,
	38349,
	38350,
	38351,
	38352,
	38353,
	38354,
	38355,
	38356,
	38357,
	38358,
	38359,
	38360,
	38361,
	38362,
	38363,
	38364,
	38365,
	38366,
	38367,
	38368,
	38369,
	38370,
	38371,
	38372,
	38373,
	38374,
	38375,
	38376,
	38377,
	38378,
	38379,
	38380,
	38381,
	38382,
	38383,
	38384,
	38385,
	38386,
	38387,
	38388,
	38389,
	38390,
	38391,
	38392,
	38393,
	38394,
	38395,
	38396,
	38397,
	38398,
	38399,
	38400,
	38401,
	38402,
	38403,
	38404,
	38405,
	38406,
	38407,
	38408,
	38409,
	38410,
	38411,
	38412,
	38413,
	38414,
	38415,
	38416,
	38417,
	38418,
	38419,
	38420,
	38421,
	38422,
	38423,
	38424,
	38425,
	38426,
	38427,
	38428,
	38429,
	38430,
	38431,
	38432,
	38433,
	38434,
	38435,
	38436,
	38437,
	38438,
	38439,
	38440,
	38441,
	38442,
	38443,
	38444,
	38445,
	38446,
	38447,
	38448,
	38449,
	38450,
	38451,
	38452,
	38453,
	38454,
	38455,
	38456,
	38457,
	38458,
	38459,
	38460,
	38461,
	38462,
	38463,
	38464,
	38465,
	38466,
	38467,
	38468,
	38469,
	38470,
	38471,
	38472,
	38473,
	38474,
	38475,
	38476,
	38477,
	38478,
	38479,
	38480,
	38481,
	38482,
	38483,
	38484,
	38485,
	38486,
	38487,
	38488,
	38489,
	38490,
	38491,
	38492,
	38493,
	38494,
	38495,
	38496,
	38497,
	38498,
	38499,
	38500,
	38501,
	38502,
	38503,
	38504,
	38505,
	38506,
	38507,
	38508,
	38509,
	38510,
	38511,
	38512,
	38513,
	38514,
	38515,
	38516,
	38517,
	38518,
	38519,
	38520,
	38521,
	38522,
	38523,
	38524,
	38525,
	38526,
	38527,
	38528,
	38529,
	38530,
	38531,
	38532,
	38533,
	38534,
	38535,
	38536,
	38537,
	38538,
	38539,
	38540,
	38541,
	38542,
	38543,
	38544,
	38545,
	38546,
	38547,
	38548,
	38549,
	38550,
	38551,
	38552,
	38553,
	38554,
	38555,
	38556,
	38557,
	38558,
	38559,
	38560,
	38561,
	38562,
	38563,
	38564,
	38565,
	38566,
	38567,
	38568,
	38569,
	38570,
	38571,
	38572,
	38573,
	38574,
	38575,
	38576,
	38577,
	38578,
	38579,
	38580,
	38581,
	38582,
	38583,
	38584,
	38585,
	38586,
	38587,
	38588,
	38589,
	38590,
	38591,
	38592,
	38593,
	38594,
	38595,
	38596,
	38597,
	38598,
	38599,
	38600,
	38601,
	38602,
	38603,
	38604,
	38605,
	38606,
	38607,
	38608,
	38609,
	38610,
	38611,
	38612,
	38613,
	38614,
	38615,
	38616,
	38617,
	38618,
	38619,
	38620,
	38621,
	38622,
	38623,
	38624,
	38625,
	38626,
	38627,
	38628,
	38629,
	38630,
	38631,
	38632,
	38633,
	38634,
	38635,
	38636,
	38637,
	38638,
	38639,
	38640,
	38641,
	38642,
	38643,
	38644,
	38645,
	38646,
	38647,
	38648,
	38649,
	38650,
	38651,
	38652,
	38653,
	38654,
	38655,
	38656,
	38657,
	38658,
	38659,
	38660,
	38661,
	38662,
	38663,
	38664,
	38665,
	38666,
	38667,
	38668,
	38669,
	38670,
	38671,
	38672,
	38673,
	38674,
	38675,
	38676,
	38677,
	38678,
	38679,
	38680,
	38681,
	38682,
	38683,
	38684,
	38685,
	38686,
	38687,
	38688,
	38689,
	38690,
	38691,
	38692,
	38693,
	38694,
	38695,
	38696,
	38697,
	38698,
	38699,
	38700,
	38701,
	38702,
	38703,
	38704,
	38705,
	38706,
	38707,
	38708,
	38709,
	38710,
	38711,
	38712,
	38713,
	38714,
	38715,
	38716,
	38717,
	38718,
	38719,
	38720,
	38721,
	38722,
	38723,
	38724,
	38725,
	38726,
	38727,
	38728,
	38729,
	38730,
	38731,
	38732,
	38733,
	38734,
	38735,
	38736,
	38737,
	38738,
	38739,
	38740,
	38741,
	38742,
	38743,
	38744,
	38745,
	38746,
	38747,
	38748,
	38749,
	38750,
	38751,
	38752,
	38753,
	38754,
	38755,
	38756,
	38757,
	38758,
	38759,
	38760,
	38761,
	38762,
	38763,
	38764,
	38765,
	38766,
	38767,
	38768,
	38769,
	38770,
	38771,
	38772,
	38773,
	38774,
	38775,
	38776,
	38777,
	38778,
	38779,
	38780,
	38781,
	38782,
	38783,
	38784,
	38785,
	38786,
	38787,
	38788,
	38789,
	38790,
	38791,
	38792,
	38793,
	38794,
	38795,
	38796,
	38797,
	38798,
	38799,
	38800,
	38801,
	38802,
	38803,
	38804,
	38805,
	38806,
	38807,
	38808,
	38809,
	38810,
	38811,
	38812,
	38813,
	38814,
	38815,
	38816,
	38817,
	38818,
	38819,
	38820,
	38821,
	38822,
	38823,
	38824,
	38825,
	38826,
	38827,
	38828,
	38829,
	38830,
	38831,
	38832,
	38833,
	38834,
	38835,
	38836,
	38837,
	38838,
	38839,
	38840,
	38841,
	38842,
	38843,
	38844,
	38845,
	38846,
	38847,
	38848,
	38849,
	38850,
	38851,
	38852,
	38853,
	38854,
	38855,
	38856,
	38857,
	38858,
	38859,
	38860,
	38861,
	38862,
	38863,
	38864,
	38865,
	38866,
	38867,
	38868,
	38869,
	38870,
	38871,
	38872,
	38873,
	38874,
	38875,
	38876,
	38877,
	38878,
	38879,
	38880,
	38881,
	38882,
	38883,
	38884,
	38885,
	38886,
	38887,
	38888,
	38889,
	38890,
	38891,
	38892,
	38893,
	38894,
	38895,
	38896,
	38897,
	38898,
	38899,
	38900,
	38901,
	38902,
	38903,
	38904,
	38905,
	38906,
	38907,
	38908,
	38909,
	38910,
	38911,
	38912,
	38913,
	38914,
	38915,
	38916,
	38917,
	38918,
	38919,
	38920,
	38921,
	38922,
	38923,
	38924,
	38925,
	38926,
	38927,
	38928,
	38929,
	38930,
	38931,
	38932,
	38933,
	38934,
	38935,
	38936,
	38937,
	38938,
	38939,
	38940,
	38941,
	38942,
	38943,
	38944,
	38945,
	38946,
	38947,
	38948,
	38949,
	38950,
	38951,
	38952,
	38953,
	38954,
	38955,
	38956,
	38957,
	38958,
	38959,
	38960,
	38961,
	38962,
	38963,
	38964,
	38965,
	38966,
	38967,
	38968,
	38969,
	38970,
	38971,
	38972,
	38973,
	38974,
	38975,
	38976,
	38977,
	38978,
	38979,
	38980,
	38981,
	38982,
	38983,
	38984,
	38985,
	38986,
	38987,
	38988,
	38989,
	38990,
	38991,
	38992,
	38993,
	38994,
	38995,
	38996,
	38997,
	38998,
	38999,
	39000,
	39001,
	39002,
	39003,
	39004,
	39005,
	39006,
	39007,
	39008,
	39009,
	39010,
	39011,
	39012,
	39013,
	39014,
	39015,
	39016,
	39017,
	39018,
	39019,
	39020,
	39021,
	39022,
	39023,
	39024,
	39025,
	39026,
	39027,
	39028,
	39029,
	39030,
	39031,
	39032,
	39033,
	39034,
	39035,
	39036,
	39037,
	39038,
	39039,
	39040,
	39041,
	39042,
	39043,
	39044,
	39045,
	39046,
	39047,
	39048,
	39049,
	39050,
	39051,
	39052,
	39053,
	39054,
	39055,
	39056,
	39057,
	39058,
	39059,
	39060,
	39061,
	39062,
	39063,
	39064,
	39065,
	39066,
	39067,
	39068,
	39069,
	39070,
	39071,
	39072,
	39073,
	39074,
	39075,
	39076,
	39077,
	39078,
	39079,
	39080,
	39081,
	39082,
	39083,
	39084,
	39085,
	39086,
	39087,
	39088,
	39089,
	39090,
	39091,
	39092,
	39093,
	39094,
	39095,
	39096,
	39097,
	39098,
	39099,
	39100,
	39101,
	39102,
	39103,
	39104,
	39105,
	39106,
	39107,
	39108,
	39109,
	39110,
	39111,
	39112,
	39113,
	39114,
	39115,
	39116,
	39117,
	39118,
	39119,
	39120,
	39121,
	39122,
	39123,
	39124,
	39125,
	39126,
	39127,
	39128,
	39129,
	39130,
	39131,
	39132,
	39133,
	39134,
	39135,
	39136,
	39137,
	39138,
	39139,
	39140,
	39141,
	39142,
	39143,
	39144,
	39145,
	39146,
	39147,
	39148,
	39149,
	39150,
	39151,
	39152,
	39153,
	39154,
	39155,
	39156,
	39157,
	39158,
	39159,
	39160,
	39161,
	39162,
	39163,
	39164,
	39165,
	39166,
	39167,
	39168,
	39169,
	39170,
	39171,
	39172,
	39173,
	39174,
	39175,
	39176,
	39177,
	39178,
	39179,
	39180,
	39181,
	39182,
	39183,
	39184,
	39185,
	39186,
	39187,
	39188,
	39189,
	39190,
	39191,
	39192,
	39193,
	39194,
	39195,
	39196,
	39197,
	39198,
	39199,
	39200,
	39201,
	39202,
	39203,
	39204,
	39205,
	39206,
	39207,
	39208,
	39209,
	39210,
	39211,
	39212,
	39213,
	39214,
	39215,
	39216,
	39217,
	39218,
	39219,
	39220,
	39221,
	39222,
	39223,
	39224,
	39225,
	39226,
	39227,
	39228,
	39229,
	39230,
	39231,
	39232,
	39233,
	39234,
	39235,
	39236,
	39237,
	39238,
	39239,
	39240,
	39241,
	39242,
	39243,
	39244,
	39245,
	39246,
	39247,
	39248,
	39249,
	39250,
	39251,
	39252,
	39253,
	39254,
	39255,
	39256,
	39257,
	39258,
	39259,
	39260,
	39261,
	39262,
	39263,
	39264,
	39265,
	39266,
	39267,
	39268,
	39269,
	39270,
	39271,
	39272,
	39273,
	39274,
	39275,
	39276,
	39277,
	39278,
	39279,
	39280,
	39281,
	39282,
	39283,
	39284,
	39285,
	39286,
	39287,
	39288,
	39289,
	39290,
	39291,
	39292,
	39293,
	39294,
	39295,
	39296,
	39297,
	39298,
	39299,
	39300,
	39301,
	39302,
	39303,
	39304,
	39305,
	39306,
	39307,
	39308,
	39309,
	39310,
	39311,
	39312,
	39313,
	39314,
	39315,
	39316,
	39317,
	39318,
	39319,
	39320,
	39321,
	39322,
	39323,
	39324,
	39325,
	39326,
	39327,
	39328,
	39329,
	39330,
	39331,
	39332,
	39333,
	39334,
	39335,
	39336,
	39337,
	39338,
	39339,
	39340,
	39341,
	39342,
	39343,
	39344,
	39345,
	39346,
	39347,
	39348,
	39349,
	39350,
	39351,
	39352,
	39353,
	39354,
	39355,
	39356,
	39357,
	39358,
	39359,
	39360,
	39361,
	39362,
	39363,
	39364,
	39365,
	39366,
	39367,
	39368,
	39369,
	39370,
	39371,
	39372,
	39373,
	39374,
	39375,
	39376,
	39377,
	39378,
	39379,
	39380,
	39381,
	39382,
	39383,
	39384,
	39385,
	39386,
	39387,
	39388,
	39389,
	39390,
	39391,
	39392,
	39393,
	39394,
	39395,
	39396,
	39397,
	39398,
	39399,
	39400,
	39401,
	39402,
	39403,
	39404,
	39405,
	39406,
	39407,
	39408,
	39409,
	39410,
	39411,
	39412,
	39413,
	39414,
	39415,
	39416,
	39417,
	39418,
	39419,
	39420,
	39421,
	39422,
	39423,
	39424,
	39425,
	39426,
	39427,
	39428,
	39429,
	39430,
	39431,
	39432,
	39433,
	39434,
	39435,
	39436,
	39437,
	39438,
	39439,
	39440,
	39441,
	39442,
	39443,
	39444,
	39445,
	39446,
	39447,
	39448,
	39449,
	39450,
	39451,
	39452,
	39453,
	39454,
	39455,
	39456,
	39457,
	39458,
	39459,
	39460,
	39461,
	39462,
	39463,
	39464,
	39465,
	39466,
	39467,
	39468,
	39469,
	39470,
	39471,
	39472,
	39473,
	39474,
	39475,
	39476,
	39477,
	39478,
	39479,
	39480,
	39481,
	39482,
	39483,
	39484,
	39485,
	39486,
	39487,
	39488,
	39489,
	39490,
	39491,
	39492,
	39493,
	39494,
	39495,
	39496,
	39497,
	39498,
	39499,
	39500,
	39501,
	39502,
	39503,
	39504,
	39505,
	39506,
	39507,
	39508,
	39509,
	39510,
	39511,
	39512,
	39513,
	39514,
	39515,
	39516,
	39517,
	39518,
	39519,
	39520,
	39521,
	39522,
	39523,
	39524,
	39525,
	39526,
	39527,
	39528,
	39529,
	39530,
	39531,
	39532,
	39533,
	39534,
	39535,
	39536,
	39537,
	39538,
	39539,
	39540,
	39541,
	39542,
	39543,
	39544,
	39545,
	39546,
	39547,
	39548,
	39549,
	39550,
	39551,
	39552,
	39553,
	39554,
	39555,
	39556,
	39557,
	39558,
	39559,
	39560,
	39561,
	39562,
	39563,
	39564,
	39565,
	39566,
	39567,
	39568,
	39569,
	39570,
	39571,
	39572,
	39573,
	39574,
	39575,
	39576,
	39577,
	39578,
	39579,
	39580,
	39581,
	39582,
	39583,
	39584,
	39585,
	39586,
	39587,
	39588,
	39589,
	39590,
	39591,
	39592,
	39593,
	39594,
	39595,
	39596,
	39597,
	39598,
	39599,
	39600,
	39601,
	39602,
	39603,
	39604,
	39605,
	39606,
	39607,
	39608,
	39609,
	39610,
	39611,
	39612,
	39613,
	39614,
	39615,
	39616,
	39617,
	39618,
	39619,
	39620,
	39621,
	39622,
	39623,
	39624,
	39625,
	39626,
	39627,
	39628,
	39629,
	39630,
	39631,
	39632,
	39633,
	39634,
	39635,
	39636,
	39637,
	39638,
	39639,
	39640,
	39641,
	39642,
	39643,
	39644,
	39645,
	39646,
	39647,
	39648,
	39649,
	39650,
	39651,
	39652,
	39653,
	39654,
	39655,
	39656,
	39657,
	39658,
	39659,
	39660,
	39661,
	39662,
	39663,
	39664,
	39665,
	39666,
	39667,
	39668,
	39669,
	39670,
	39671,
	39672,
	39673,
	39674,
	39675,
	39676,
	39677,
	39678,
	39679,
	39680,
	39681,
	39682,
	39683,
	39684,
	39685,
	39686,
	39687,
	39688,
	39689,
	39690,
	39691,
	39692,
	39693,
	39694,
	39695,
	39696,
	39697,
	39698,
	39699,
	39700,
	39701,
	39702,
	39703,
	39704,
	39705,
	39706,
	39707,
	39708,
	39709,
	39710,
	39711,
	39712,
	39713,
	39714,
	39715,
	39716,
	39717,
	39718,
	39719,
	39720,
	39721,
	39722,
	39723,
	39724,
	39725,
	39726,
	39727,
	39728,
	39729,
	39730,
	39731,
	39732,
	39733,
	39734,
	39735,
	39736,
	39737,
	39738,
	39739,
	39740,
	39741,
	39742,
	39743,
	39744,
	39745,
	39746,
	39747,
	39748,
	39749,
	39750,
	39751,
	39752,
	39753,
	39754,
	39755,
	39756,
	39757,
	39758,
	39759,
	39760,
	39761,
	39762,
	39763,
	39764,
	39765,
	39766,
	39767,
	39768,
	39769,
	39770,
	39771,
	39772,
	39773,
	39774,
	39775,
	39776,
	39777,
	39778,
	39779,
	39780,
	39781,
	39782,
	39783,
	39784,
	39785,
	39786,
	39787,
	39788,
	39789,
	39790,
	39791,
	39792,
	39793,
	39794,
	39795,
	39796,
	39797,
	39798,
	39799,
	39800,
	39801,
	39802,
	39803,
	39804,
	39805,
	39806,
	39807,
	39808,
	39809,
	39810,
	39811,
	39812,
	39813,
	39814,
	39815,
	39816,
	39817,
	39818,
	39819,
	39820,
	39821,
	39822,
	39823,
	39824,
	39825,
	39826,
	39827,
	39828,
	39829,
	39830,
	39831,
	39832,
	39833,
	39834,
	39835,
	39836,
	39837,
	39838,
	39839,
	39840,
	39841,
	39842,
	39843,
	39844,
	39845,
	39846,
	39847,
	39848,
	39849,
	39850,
	39851,
	39852,
	39853,
	39854,
	39855,
	39856,
	39857,
	39858,
	39859,
	39860,
	39861,
	39862,
	39863,
	39864,
	39865,
	39866,
	39867,
	39868,
	39869,
	39870,
	39871,
	39872,
	39873,
	39874,
	39875,
	39876,
	39877,
	39878,
	39879,
	39880,
	39881,
	39882,
	39883,
	39884,
	39885,
	39886,
	39887,
	39888,
	39889,
	39890,
	39891,
	39892,
	39893,
	39894,
	39895,
	39896,
	39897,
	39898,
	39899,
	39900,
	39901,
	39902,
	39903,
	39904,
	39905,
	39906,
	39907,
	39908,
	39909,
	39910,
	39911,
	39912,
	39913,
	39914,
	39915,
	39916,
	39917,
	39918,
	39919,
	39920,
	39921,
	39922,
	39923,
	39924,
	39925,
	39926,
	39927,
	39928,
	39929,
	39930,
	39931,
	39932,
	39933,
	39934,
	39935,
	39936,
	39937,
	39938,
	39939,
	39940,
	39941,
	39942,
	39943,
	39944,
	39945,
	39946,
	39947,
	39948,
	39949,
	39950,
	39951,
	39952,
	39953,
	39954,
	39955,
	39956,
	39957,
	39958,
	39959,
	39960,
	39961,
	39962,
	39963,
	39964,
	39965,
	39966,
	39967,
	39968,
	39969,
	39970,
	39971,
	39972,
	39973,
	39974,
	39975,
	39976,
	39977,
	39978,
	39979,
	39980,
	39981,
	39982,
	39983,
	39984,
	39985,
	39986,
	39987,
	39988,
	39989,
	39990,
	39991,
	39992,
	39993,
	39994,
	39995,
	39996,
	39997,
	39998,
	39999,
	40000,
	40001,
	40002,
	40003,
	40004,
	40005,
	40006,
	40007,
	40008,
	40009,
	40010,
	40011,
	40012,
	40013,
	40014,
	40015,
	40016,
	40017,
	40018,
	40019,
	40020,
	40021,
	40022,
	40023,
	40024,
	40025,
	40026,
	40027,
	40028,
	40029,
	40030,
	40031,
	40032,
	40033,
	40034,
	40035,
	40036,
	40037,
	40038,
	40039,
	40040,
	40041,
	40042,
	40043,
	40044,
	40045,
	40046,
	40047,
	40048,
	40049,
	40050,
	40051,
	40052,
	40053,
	40054,
	40055,
	40056,
	40057,
	40058,
	40059,
	40060,
	40061,
	40062,
	40063,
	40064,
	40065,
	40066,
	40067,
	40068,
	40069,
	40070,
	40071,
	40072,
	40073,
	40074,
	40075,
	40076,
	40077,
	40078,
	40079,
	40080,
	40081,
	40082,
	40083,
	40084,
	40085,
	40086,
	40087,
	40088,
	40089,
	40090,
	40091,
	40092,
	40093,
	40094,
	40095,
	40096,
	40097,
	40098,
	40099,
	40100,
	40101,
	40102,
	40103,
	40104,
	40105,
	40106,
	40107,
	40108,
	40109,
	40110,
	40111,
	40112,
	40113,
	40114,
	40115,
	40116,
	40117,
	40118,
	40119,
	40120,
	40121,
	40122,
	40123,
	40124,
	40125,
	40126,
	40127,
	40128,
	40129,
	40130,
	40131,
	40132,
	40133,
	40134,
	40135,
	40136,
	40137,
	40138,
	40139,
	40140,
	40141,
	40142,
	40143,
	40144,
	40145,
	40146,
	40147,
	40148,
	40149,
	40150,
	40151,
	40152,
	40153,
	40154,
	40155,
	40156,
	40157,
	40158,
	40159,
	40160,
	40161,
	40162,
	40163,
	40164,
	40165,
	40166,
	40167,
	40168,
	40169,
	40170,
	40171,
	40172,
	40173,
	40174,
	40175,
	40176,
	40177,
	40178,
	40179,
	40180,
	40181,
	40182,
	40183,
	40184,
	40185,
	40186,
	40187,
	40188,
	40189,
	40190,
	40191,
	40192,
	40193,
	40194,
	40195,
	40196,
	40197,
	40198,
	40199,
	40200,
	40201,
	40202,
	40203,
	40204,
	40205,
	40206,
	40207,
	40208,
	40209,
	40210,
	40211,
	40212,
	40213,
	40214,
	40215,
	40216,
	40217,
	40218,
	40219,
	40220,
	40221,
	40222,
	40223,
	40224,
	40225,
	40226,
	40227,
	40228,
	40229,
	40230,
	40231,
	40232,
	40233,
	40234,
	40235,
	40236,
	40237,
	40238,
	40239,
	40240,
	40241,
	40242,
	40243,
	40244,
	40245,
	40246,
	40247,
	40248,
	40249,
	40250,
	40251,
	40252,
	40253,
	40254,
	40255,
	40256,
	40257,
	40258,
	40259,
	40260,
	40261,
	40262,
	40263,
	40264,
	40265,
	40266,
	40267,
	40268,
	40269,
	40270,
	40271,
	40272,
	40273,
	40274,
	40275,
	40276,
	40277,
	40278,
	40279,
	40280,
	40281,
	40282,
	40283,
	40284,
	40285,
	40286,
	40287,
	40288,
	40289,
	40290,
	40291,
	40292,
	40293,
	40294,
	40295,
	40296,
	40297,
	40298,
	40299,
	40300,
	40301,
	40302,
	40303,
	40304,
	40305,
	40306,
	40307,
	40308,
	40309,
	40310,
	40311,
	40312,
	40313,
	40314,
	40315,
	40316,
	40317,
	40318,
	40319,
	40320,
	40321,
	40322,
	40323,
	40324,
	40325,
	40326,
	40327,
	40328,
	40329,
	40330,
	40331,
	40332,
	40333,
	40334,
	40335,
	40336,
	40337,
	40338,
	40339,
	40340,
	40341,
	40342,
	40343,
	40344,
	40345,
	40346,
	40347,
	40348,
	40349,
	40350,
	40351,
	40352,
	40353,
	40354,
	40355,
	40356,
	40357,
	40358,
	40359,
	40360,
	40361,
	40362,
	40363,
	40364,
	40365,
	40366,
	40367,
	40368,
	40369,
	40370,
	40371,
	40372,
	40373,
	40374,
	40375,
	40376,
	40377,
	40378,
	40379,
	40380,
	40381,
	40382,
	40383,
	40384,
	40385,
	40386,
	40387,
	40388,
	40389,
	40390,
	40391,
	40392,
	40393,
	40394,
	40395,
	40396,
	40397,
	40398,
	40399,
	40400,
	40401,
	40402,
	40403,
	40404,
	40405,
	40406,
	40407,
	40408,
	40409,
	40410,
	40411,
	40412,
	40413,
	40414,
	40415,
	40416,
	40417,
	40418,
	40419,
	40420,
	40421,
	40422,
	40423,
	40424,
	40425,
	40426,
	40427,
	40428,
	40429,
	40430,
	40431,
	40432,
	40433,
	40434,
	40435,
	40436,
	40437,
	40438,
	40439,
	40440,
	40441,
	40442,
	40443,
	40444,
	40445,
	40446,
	40447,
	40448,
	40449,
	40450,
	40451,
	40452,
	40453,
	40454,
	40455,
	40456,
	40457,
	40458,
	40459,
	40460,
	40461,
	40462,
	40463,
	40464,
	40465,
	40466,
	40467,
	40468,
	40469,
	40470,
	40471,
	40472,
	40473,
	40474,
	40475,
	40476,
	40477,
	40478,
	40479,
	40480,
	40481,
	40482,
	40483,
	40484,
	40485,
	40486,
	40487,
	40488,
	40489,
	40490,
	40491,
	40492,
	40493,
	40494,
	40495,
	40496,
	40497,
	40498,
	40499,
	40500,
	40501,
	40502,
	40503,
	40504,
	40505,
	40506,
	40507,
	40508,
	40509,
	40510,
	40511,
	40512,
	40513,
	40514,
	40515,
	40516,
	40517,
	40518,
	40519,
	40520,
	40521,
	40522,
	40523,
	40524,
	40525,
	40526,
	40527,
	40528,
	40529,
	40530,
	40531,
	40532,
	40533,
	40534,
	40535,
	40536,
	40537,
	40538,
	40539,
	40540,
	40541,
	40542,
	40543,
	40544,
	40545,
	40546,
	40547,
	40548,
	40549,
	40550,
	40551,
	40552,
	40553,
	40554,
	40555,
	40556,
	40557,
	40558,
	40559,
	40560,
	40561,
	40562,
	40563,
	40564,
	40565,
	40566,
	40567,
	40568,
	40569,
	40570,
	40571,
	40572,
	40573,
	40574,
	40575,
	40576,
	40577,
	40578,
	40579,
	40580,
	40581,
	40582,
	40583,
	40584,
	40585,
	40586,
	40587,
	40588,
	40589,
	40590,
	40591,
	40592,
	40593,
	40594,
	40595,
	40596,
	40597,
	40598,
	40599,
	40600,
	40601,
	40602,
	40603,
	40604,
	40605,
	40606,
	40607,
	40608,
	40609,
	40610,
	40611,
	40612,
	40613,
	40614,
	40615,
	40616,
	40617,
	40618,
	40619,
	40620,
	40621,
	40622,
	40623,
	40624,
	40625,
	40626,
	40627,
	40628,
	40629,
	40630,
	40631,
	40632,
	40633,
	40634,
	40635,
	40636,
	40637,
	40638,
	40639,
	40640,
	40641,
	40642,
	40643,
	40644,
	40645,
	40646,
	40647,
	40648,
	40649,
	40650,
	40651,
	40652,
	40653,
	40654,
	40655,
	40656,
	40657,
	40658,
	40659,
	40660,
	40661,
	40662,
	40663,
	40664,
	40665,
	40666,
	40667,
	40668,
	40669,
	40670,
	40671,
	40672,
	40673,
	40674,
	40675,
	40676,
	40677,
	40678,
	40679,
	40680,
	40681,
	40682,
	40683,
	40684,
	40685,
	40686,
	40687,
	40688,
	40689,
	40690,
	40691,
	40692,
	40693,
	40694,
	40695,
	40696,
	40697,
	40698,
	40699,
	40700,
	40701,
	40702,
	40703,
	40704,
	40705,
	40706,
	40707,
	40708,
	40709,
	40710,
	40711,
	40712,
	40713,
	40714,
	40715,
	40716,
	40717,
	40718,
	40719,
	40720,
	40721,
	40722,
	40723,
	40724,
	40725,
	40726,
	40727,
	40728,
	40729,
	40730,
	40731,
	40732,
	40733,
	40734,
	40735,
	40736,
	40737,
	40738,
	40739,
	40740,
	40741,
	40742,
	40743,
	40744,
	40745,
	40746,
	40747,
	40748,
	40749,
	40750,
	40751,
	40752,
	40753,
	40754,
	40755,
	40756,
	40757,
	40758,
	40759,
	40760,
	40761,
	40762,
	40763,
	40764,
	40765,
	40766,
	40767,
	40768,
	40769,
	40770,
	40771,
	40772,
	40773,
	40774,
	40775,
	40776,
	40777,
	40778,
	40779,
	40780,
	40781,
	40782,
	40783,
	40784,
	40785,
	40786,
	40787,
	40788,
	40789,
	40790,
	40791,
	40792,
	40793,
	40794,
	40795,
	40796,
	40797,
	40798,
	40799,
	40800,
	40801,
	40802,
	40803,
	40804,
	40805,
	40806,
	40807,
	40808,
	40809,
	40810,
	40811,
	40812,
	40813,
	40814,
	40815,
	40816,
	40817,
	40818,
	40819,
	40820,
	40821,
	40822,
	40823,
	40824,
	40825,
	40826,
	40827,
	40828,
	40829,
	40830,
	40831,
	40832,
	40833,
	40834,
	40835,
	40836,
	40837,
	40838,
	40839,
	40840,
	40841,
	40842,
	40843,
	40844,
	40845,
	40846,
	40847,
	40848,
	40849,
	40850,
	40851,
	40852,
	40853,
	40854,
	40855,
	40856,
	40857,
	40858,
	40859,
	40860,
	40861,
	40862,
	40863,
	40864,
	40865,
	40866,
	40867,
	40868,
	40869,
	40870,
	40871,
	40872,
	40873,
	40874,
	40875,
	40876,
	40877,
	40878,
	40879,
	40880,
	40881,
	40882,
	40883,
	40884,
	40885,
	40886,
	40887,
	40888,
	40889,
	40890,
	40891,
	40892,
	40893,
	40894,
	40895,
	40896,
	40897,
	40898,
	40899,
	40900,
	40901,
	40902,
	40903,
	40904,
	40905,
	40906,
	40907,
	40908,
	40960,
	40961,
	40962,
	40963,
	40964,
	40965,
	40966,
	40967,
	40968,
	40969,
	40970,
	40971,
	40972,
	40973,
	40974,
	40975,
	40976,
	40977,
	40978,
	40979,
	40980,
	40981,
	40982,
	40983,
	40984,
	40985,
	40986,
	40987,
	40988,
	40989,
	40990,
	40991,
	40992,
	40993,
	40994,
	40995,
	40996,
	40997,
	40998,
	40999,
	41000,
	41001,
	41002,
	41003,
	41004,
	41005,
	41006,
	41007,
	41008,
	41009,
	41010,
	41011,
	41012,
	41013,
	41014,
	41015,
	41016,
	41017,
	41018,
	41019,
	41020,
	41021,
	41022,
	41023,
	41024,
	41025,
	41026,
	41027,
	41028,
	41029,
	41030,
	41031,
	41032,
	41033,
	41034,
	41035,
	41036,
	41037,
	41038,
	41039,
	41040,
	41041,
	41042,
	41043,
	41044,
	41045,
	41046,
	41047,
	41048,
	41049,
	41050,
	41051,
	41052,
	41053,
	41054,
	41055,
	41056,
	41057,
	41058,
	41059,
	41060,
	41061,
	41062,
	41063,
	41064,
	41065,
	41066,
	41067,
	41068,
	41069,
	41070,
	41071,
	41072,
	41073,
	41074,
	41075,
	41076,
	41077,
	41078,
	41079,
	41080,
	41081,
	41082,
	41083,
	41084,
	41085,
	41086,
	41087,
	41088,
	41089,
	41090,
	41091,
	41092,
	41093,
	41094,
	41095,
	41096,
	41097,
	41098,
	41099,
	41100,
	41101,
	41102,
	41103,
	41104,
	41105,
	41106,
	41107,
	41108,
	41109,
	41110,
	41111,
	41112,
	41113,
	41114,
	41115,
	41116,
	41117,
	41118,
	41119,
	41120,
	41121,
	41122,
	41123,
	41124,
	41125,
	41126,
	41127,
	41128,
	41129,
	41130,
	41131,
	41132,
	41133,
	41134,
	41135,
	41136,
	41137,
	41138,
	41139,
	41140,
	41141,
	41142,
	41143,
	41144,
	41145,
	41146,
	41147,
	41148,
	41149,
	41150,
	41151,
	41152,
	41153,
	41154,
	41155,
	41156,
	41157,
	41158,
	41159,
	41160,
	41161,
	41162,
	41163,
	41164,
	41165,
	41166,
	41167,
	41168,
	41169,
	41170,
	41171,
	41172,
	41173,
	41174,
	41175,
	41176,
	41177,
	41178,
	41179,
	41180,
	41181,
	41182,
	41183,
	41184,
	41185,
	41186,
	41187,
	41188,
	41189,
	41190,
	41191,
	41192,
	41193,
	41194,
	41195,
	41196,
	41197,
	41198,
	41199,
	41200,
	41201,
	41202,
	41203,
	41204,
	41205,
	41206,
	41207,
	41208,
	41209,
	41210,
	41211,
	41212,
	41213,
	41214,
	41215,
	41216,
	41217,
	41218,
	41219,
	41220,
	41221,
	41222,
	41223,
	41224,
	41225,
	41226,
	41227,
	41228,
	41229,
	41230,
	41231,
	41232,
	41233,
	41234,
	41235,
	41236,
	41237,
	41238,
	41239,
	41240,
	41241,
	41242,
	41243,
	41244,
	41245,
	41246,
	41247,
	41248,
	41249,
	41250,
	41251,
	41252,
	41253,
	41254,
	41255,
	41256,
	41257,
	41258,
	41259,
	41260,
	41261,
	41262,
	41263,
	41264,
	41265,
	41266,
	41267,
	41268,
	41269,
	41270,
	41271,
	41272,
	41273,
	41274,
	41275,
	41276,
	41277,
	41278,
	41279,
	41280,
	41281,
	41282,
	41283,
	41284,
	41285,
	41286,
	41287,
	41288,
	41289,
	41290,
	41291,
	41292,
	41293,
	41294,
	41295,
	41296,
	41297,
	41298,
	41299,
	41300,
	41301,
	41302,
	41303,
	41304,
	41305,
	41306,
	41307,
	41308,
	41309,
	41310,
	41311,
	41312,
	41313,
	41314,
	41315,
	41316,
	41317,
	41318,
	41319,
	41320,
	41321,
	41322,
	41323,
	41324,
	41325,
	41326,
	41327,
	41328,
	41329,
	41330,
	41331,
	41332,
	41333,
	41334,
	41335,
	41336,
	41337,
	41338,
	41339,
	41340,
	41341,
	41342,
	41343,
	41344,
	41345,
	41346,
	41347,
	41348,
	41349,
	41350,
	41351,
	41352,
	41353,
	41354,
	41355,
	41356,
	41357,
	41358,
	41359,
	41360,
	41361,
	41362,
	41363,
	41364,
	41365,
	41366,
	41367,
	41368,
	41369,
	41370,
	41371,
	41372,
	41373,
	41374,
	41375,
	41376,
	41377,
	41378,
	41379,
	41380,
	41381,
	41382,
	41383,
	41384,
	41385,
	41386,
	41387,
	41388,
	41389,
	41390,
	41391,
	41392,
	41393,
	41394,
	41395,
	41396,
	41397,
	41398,
	41399,
	41400,
	41401,
	41402,
	41403,
	41404,
	41405,
	41406,
	41407,
	41408,
	41409,
	41410,
	41411,
	41412,
	41413,
	41414,
	41415,
	41416,
	41417,
	41418,
	41419,
	41420,
	41421,
	41422,
	41423,
	41424,
	41425,
	41426,
	41427,
	41428,
	41429,
	41430,
	41431,
	41432,
	41433,
	41434,
	41435,
	41436,
	41437,
	41438,
	41439,
	41440,
	41441,
	41442,
	41443,
	41444,
	41445,
	41446,
	41447,
	41448,
	41449,
	41450,
	41451,
	41452,
	41453,
	41454,
	41455,
	41456,
	41457,
	41458,
	41459,
	41460,
	41461,
	41462,
	41463,
	41464,
	41465,
	41466,
	41467,
	41468,
	41469,
	41470,
	41471,
	41472,
	41473,
	41474,
	41475,
	41476,
	41477,
	41478,
	41479,
	41480,
	41481,
	41482,
	41483,
	41484,
	41485,
	41486,
	41487,
	41488,
	41489,
	41490,
	41491,
	41492,
	41493,
	41494,
	41495,
	41496,
	41497,
	41498,
	41499,
	41500,
	41501,
	41502,
	41503,
	41504,
	41505,
	41506,
	41507,
	41508,
	41509,
	41510,
	41511,
	41512,
	41513,
	41514,
	41515,
	41516,
	41517,
	41518,
	41519,
	41520,
	41521,
	41522,
	41523,
	41524,
	41525,
	41526,
	41527,
	41528,
	41529,
	41530,
	41531,
	41532,
	41533,
	41534,
	41535,
	41536,
	41537,
	41538,
	41539,
	41540,
	41541,
	41542,
	41543,
	41544,
	41545,
	41546,
	41547,
	41548,
	41549,
	41550,
	41551,
	41552,
	41553,
	41554,
	41555,
	41556,
	41557,
	41558,
	41559,
	41560,
	41561,
	41562,
	41563,
	41564,
	41565,
	41566,
	41567,
	41568,
	41569,
	41570,
	41571,
	41572,
	41573,
	41574,
	41575,
	41576,
	41577,
	41578,
	41579,
	41580,
	41581,
	41582,
	41583,
	41584,
	41585,
	41586,
	41587,
	41588,
	41589,
	41590,
	41591,
	41592,
	41593,
	41594,
	41595,
	41596,
	41597,
	41598,
	41599,
	41600,
	41601,
	41602,
	41603,
	41604,
	41605,
	41606,
	41607,
	41608,
	41609,
	41610,
	41611,
	41612,
	41613,
	41614,
	41615,
	41616,
	41617,
	41618,
	41619,
	41620,
	41621,
	41622,
	41623,
	41624,
	41625,
	41626,
	41627,
	41628,
	41629,
	41630,
	41631,
	41632,
	41633,
	41634,
	41635,
	41636,
	41637,
	41638,
	41639,
	41640,
	41641,
	41642,
	41643,
	41644,
	41645,
	41646,
	41647,
	41648,
	41649,
	41650,
	41651,
	41652,
	41653,
	41654,
	41655,
	41656,
	41657,
	41658,
	41659,
	41660,
	41661,
	41662,
	41663,
	41664,
	41665,
	41666,
	41667,
	41668,
	41669,
	41670,
	41671,
	41672,
	41673,
	41674,
	41675,
	41676,
	41677,
	41678,
	41679,
	41680,
	41681,
	41682,
	41683,
	41684,
	41685,
	41686,
	41687,
	41688,
	41689,
	41690,
	41691,
	41692,
	41693,
	41694,
	41695,
	41696,
	41697,
	41698,
	41699,
	41700,
	41701,
	41702,
	41703,
	41704,
	41705,
	41706,
	41707,
	41708,
	41709,
	41710,
	41711,
	41712,
	41713,
	41714,
	41715,
	41716,
	41717,
	41718,
	41719,
	41720,
	41721,
	41722,
	41723,
	41724,
	41725,
	41726,
	41727,
	41728,
	41729,
	41730,
	41731,
	41732,
	41733,
	41734,
	41735,
	41736,
	41737,
	41738,
	41739,
	41740,
	41741,
	41742,
	41743,
	41744,
	41745,
	41746,
	41747,
	41748,
	41749,
	41750,
	41751,
	41752,
	41753,
	41754,
	41755,
	41756,
	41757,
	41758,
	41759,
	41760,
	41761,
	41762,
	41763,
	41764,
	41765,
	41766,
	41767,
	41768,
	41769,
	41770,
	41771,
	41772,
	41773,
	41774,
	41775,
	41776,
	41777,
	41778,
	41779,
	41780,
	41781,
	41782,
	41783,
	41784,
	41785,
	41786,
	41787,
	41788,
	41789,
	41790,
	41791,
	41792,
	41793,
	41794,
	41795,
	41796,
	41797,
	41798,
	41799,
	41800,
	41801,
	41802,
	41803,
	41804,
	41805,
	41806,
	41807,
	41808,
	41809,
	41810,
	41811,
	41812,
	41813,
	41814,
	41815,
	41816,
	41817,
	41818,
	41819,
	41820,
	41821,
	41822,
	41823,
	41824,
	41825,
	41826,
	41827,
	41828,
	41829,
	41830,
	41831,
	41832,
	41833,
	41834,
	41835,
	41836,
	41837,
	41838,
	41839,
	41840,
	41841,
	41842,
	41843,
	41844,
	41845,
	41846,
	41847,
	41848,
	41849,
	41850,
	41851,
	41852,
	41853,
	41854,
	41855,
	41856,
	41857,
	41858,
	41859,
	41860,
	41861,
	41862,
	41863,
	41864,
	41865,
	41866,
	41867,
	41868,
	41869,
	41870,
	41871,
	41872,
	41873,
	41874,
	41875,
	41876,
	41877,
	41878,
	41879,
	41880,
	41881,
	41882,
	41883,
	41884,
	41885,
	41886,
	41887,
	41888,
	41889,
	41890,
	41891,
	41892,
	41893,
	41894,
	41895,
	41896,
	41897,
	41898,
	41899,
	41900,
	41901,
	41902,
	41903,
	41904,
	41905,
	41906,
	41907,
	41908,
	41909,
	41910,
	41911,
	41912,
	41913,
	41914,
	41915,
	41916,
	41917,
	41918,
	41919,
	41920,
	41921,
	41922,
	41923,
	41924,
	41925,
	41926,
	41927,
	41928,
	41929,
	41930,
	41931,
	41932,
	41933,
	41934,
	41935,
	41936,
	41937,
	41938,
	41939,
	41940,
	41941,
	41942,
	41943,
	41944,
	41945,
	41946,
	41947,
	41948,
	41949,
	41950,
	41951,
	41952,
	41953,
	41954,
	41955,
	41956,
	41957,
	41958,
	41959,
	41960,
	41961,
	41962,
	41963,
	41964,
	41965,
	41966,
	41967,
	41968,
	41969,
	41970,
	41971,
	41972,
	41973,
	41974,
	41975,
	41976,
	41977,
	41978,
	41979,
	41980,
	41981,
	41982,
	41983,
	41984,
	41985,
	41986,
	41987,
	41988,
	41989,
	41990,
	41991,
	41992,
	41993,
	41994,
	41995,
	41996,
	41997,
	41998,
	41999,
	42000,
	42001,
	42002,
	42003,
	42004,
	42005,
	42006,
	42007,
	42008,
	42009,
	42010,
	42011,
	42012,
	42013,
	42014,
	42015,
	42016,
	42017,
	42018,
	42019,
	42020,
	42021,
	42022,
	42023,
	42024,
	42025,
	42026,
	42027,
	42028,
	42029,
	42030,
	42031,
	42032,
	42033,
	42034,
	42035,
	42036,
	42037,
	42038,
	42039,
	42040,
	42041,
	42042,
	42043,
	42044,
	42045,
	42046,
	42047,
	42048,
	42049,
	42050,
	42051,
	42052,
	42053,
	42054,
	42055,
	42056,
	42057,
	42058,
	42059,
	42060,
	42061,
	42062,
	42063,
	42064,
	42065,
	42066,
	42067,
	42068,
	42069,
	42070,
	42071,
	42072,
	42073,
	42074,
	42075,
	42076,
	42077,
	42078,
	42079,
	42080,
	42081,
	42082,
	42083,
	42084,
	42085,
	42086,
	42087,
	42088,
	42089,
	42090,
	42091,
	42092,
	42093,
	42094,
	42095,
	42096,
	42097,
	42098,
	42099,
	42100,
	42101,
	42102,
	42103,
	42104,
	42105,
	42106,
	42107,
	42108,
	42109,
	42110,
	42111,
	42112,
	42113,
	42114,
	42115,
	42116,
	42117,
	42118,
	42119,
	42120,
	42121,
	42122,
	42123,
	42124,
	42192,
	42193,
	42194,
	42195,
	42196,
	42197,
	42198,
	42199,
	42200,
	42201,
	42202,
	42203,
	42204,
	42205,
	42206,
	42207,
	42208,
	42209,
	42210,
	42211,
	42212,
	42213,
	42214,
	42215,
	42216,
	42217,
	42218,
	42219,
	42220,
	42221,
	42222,
	42223,
	42224,
	42225,
	42226,
	42227,
	42228,
	42229,
	42230,
	42231,
	42232,
	42233,
	42234,
	42235,
	42236,
	42237,
	42240,
	42241,
	42242,
	42243,
	42244,
	42245,
	42246,
	42247,
	42248,
	42249,
	42250,
	42251,
	42252,
	42253,
	42254,
	42255,
	42256,
	42257,
	42258,
	42259,
	42260,
	42261,
	42262,
	42263,
	42264,
	42265,
	42266,
	42267,
	42268,
	42269,
	42270,
	42271,
	42272,
	42273,
	42274,
	42275,
	42276,
	42277,
	42278,
	42279,
	42280,
	42281,
	42282,
	42283,
	42284,
	42285,
	42286,
	42287,
	42288,
	42289,
	42290,
	42291,
	42292,
	42293,
	42294,
	42295,
	42296,
	42297,
	42298,
	42299,
	42300,
	42301,
	42302,
	42303,
	42304,
	42305,
	42306,
	42307,
	42308,
	42309,
	42310,
	42311,
	42312,
	42313,
	42314,
	42315,
	42316,
	42317,
	42318,
	42319,
	42320,
	42321,
	42322,
	42323,
	42324,
	42325,
	42326,
	42327,
	42328,
	42329,
	42330,
	42331,
	42332,
	42333,
	42334,
	42335,
	42336,
	42337,
	42338,
	42339,
	42340,
	42341,
	42342,
	42343,
	42344,
	42345,
	42346,
	42347,
	42348,
	42349,
	42350,
	42351,
	42352,
	42353,
	42354,
	42355,
	42356,
	42357,
	42358,
	42359,
	42360,
	42361,
	42362,
	42363,
	42364,
	42365,
	42366,
	42367,
	42368,
	42369,
	42370,
	42371,
	42372,
	42373,
	42374,
	42375,
	42376,
	42377,
	42378,
	42379,
	42380,
	42381,
	42382,
	42383,
	42384,
	42385,
	42386,
	42387,
	42388,
	42389,
	42390,
	42391,
	42392,
	42393,
	42394,
	42395,
	42396,
	42397,
	42398,
	42399,
	42400,
	42401,
	42402,
	42403,
	42404,
	42405,
	42406,
	42407,
	42408,
	42409,
	42410,
	42411,
	42412,
	42413,
	42414,
	42415,
	42416,
	42417,
	42418,
	42419,
	42420,
	42421,
	42422,
	42423,
	42424,
	42425,
	42426,
	42427,
	42428,
	42429,
	42430,
	42431,
	42432,
	42433,
	42434,
	42435,
	42436,
	42437,
	42438,
	42439,
	42440,
	42441,
	42442,
	42443,
	42444,
	42445,
	42446,
	42447,
	42448,
	42449,
	42450,
	42451,
	42452,
	42453,
	42454,
	42455,
	42456,
	42457,
	42458,
	42459,
	42460,
	42461,
	42462,
	42463,
	42464,
	42465,
	42466,
	42467,
	42468,
	42469,
	42470,
	42471,
	42472,
	42473,
	42474,
	42475,
	42476,
	42477,
	42478,
	42479,
	42480,
	42481,
	42482,
	42483,
	42484,
	42485,
	42486,
	42487,
	42488,
	42489,
	42490,
	42491,
	42492,
	42493,
	42494,
	42495,
	42496,
	42497,
	42498,
	42499,
	42500,
	42501,
	42502,
	42503,
	42504,
	42505,
	42506,
	42507,
	42508,
	42512,
	42513,
	42514,
	42515,
	42516,
	42517,
	42518,
	42519,
	42520,
	42521,
	42522,
	42523,
	42524,
	42525,
	42526,
	42527,
	42538,
	42539,
	42560,
	42561,
	42562,
	42563,
	42564,
	42565,
	42566,
	42567,
	42568,
	42569,
	42570,
	42571,
	42572,
	42573,
	42574,
	42575,
	42576,
	42577,
	42578,
	42579,
	42580,
	42581,
	42582,
	42583,
	42584,
	42585,
	42586,
	42587,
	42588,
	42589,
	42590,
	42591,
	42592,
	42593,
	42594,
	42595,
	42596,
	42597,
	42598,
	42599,
	42600,
	42601,
	42602,
	42603,
	42604,
	42605,
	42606,
	42623,
	42624,
	42625,
	42626,
	42627,
	42628,
	42629,
	42630,
	42631,
	42632,
	42633,
	42634,
	42635,
	42636,
	42637,
	42638,
	42639,
	42640,
	42641,
	42642,
	42643,
	42644,
	42645,
	42646,
	42647,
	42656,
	42657,
	42658,
	42659,
	42660,
	42661,
	42662,
	42663,
	42664,
	42665,
	42666,
	42667,
	42668,
	42669,
	42670,
	42671,
	42672,
	42673,
	42674,
	42675,
	42676,
	42677,
	42678,
	42679,
	42680,
	42681,
	42682,
	42683,
	42684,
	42685,
	42686,
	42687,
	42688,
	42689,
	42690,
	42691,
	42692,
	42693,
	42694,
	42695,
	42696,
	42697,
	42698,
	42699,
	42700,
	42701,
	42702,
	42703,
	42704,
	42705,
	42706,
	42707,
	42708,
	42709,
	42710,
	42711,
	42712,
	42713,
	42714,
	42715,
	42716,
	42717,
	42718,
	42719,
	42720,
	42721,
	42722,
	42723,
	42724,
	42725,
	42726,
	42727,
	42728,
	42729,
	42730,
	42731,
	42732,
	42733,
	42734,
	42735,
	42775,
	42776,
	42777,
	42778,
	42779,
	42780,
	42781,
	42782,
	42783,
	42786,
	42787,
	42788,
	42789,
	42790,
	42791,
	42792,
	42793,
	42794,
	42795,
	42796,
	42797,
	42798,
	42799,
	42800,
	42801,
	42802,
	42803,
	42804,
	42805,
	42806,
	42807,
	42808,
	42809,
	42810,
	42811,
	42812,
	42813,
	42814,
	42815,
	42816,
	42817,
	42818,
	42819,
	42820,
	42821,
	42822,
	42823,
	42824,
	42825,
	42826,
	42827,
	42828,
	42829,
	42830,
	42831,
	42832,
	42833,
	42834,
	42835,
	42836,
	42837,
	42838,
	42839,
	42840,
	42841,
	42842,
	42843,
	42844,
	42845,
	42846,
	42847,
	42848,
	42849,
	42850,
	42851,
	42852,
	42853,
	42854,
	42855,
	42856,
	42857,
	42858,
	42859,
	42860,
	42861,
	42862,
	42863,
	42864,
	42865,
	42866,
	42867,
	42868,
	42869,
	42870,
	42871,
	42872,
	42873,
	42874,
	42875,
	42876,
	42877,
	42878,
	42879,
	42880,
	42881,
	42882,
	42883,
	42884,
	42885,
	42886,
	42887,
	42888,
	42891,
	42892,
	42893,
	42894,
	42896,
	42897,
	42898,
	42899,
	42912,
	42913,
	42914,
	42915,
	42916,
	42917,
	42918,
	42919,
	42920,
	42921,
	42922,
	43000,
	43001,
	43002,
	43003,
	43004,
	43005,
	43006,
	43007,
	43008,
	43009,
	43011,
	43012,
	43013,
	43015,
	43016,
	43017,
	43018,
	43020,
	43021,
	43022,
	43023,
	43024,
	43025,
	43026,
	43027,
	43028,
	43029,
	43030,
	43031,
	43032,
	43033,
	43034,
	43035,
	43036,
	43037,
	43038,
	43039,
	43040,
	43041,
	43042,
	43072,
	43073,
	43074,
	43075,
	43076,
	43077,
	43078,
	43079,
	43080,
	43081,
	43082,
	43083,
	43084,
	43085,
	43086,
	43087,
	43088,
	43089,
	43090,
	43091,
	43092,
	43093,
	43094,
	43095,
	43096,
	43097,
	43098,
	43099,
	43100,
	43101,
	43102,
	43103,
	43104,
	43105,
	43106,
	43107,
	43108,
	43109,
	43110,
	43111,
	43112,
	43113,
	43114,
	43115,
	43116,
	43117,
	43118,
	43119,
	43120,
	43121,
	43122,
	43123,
	43138,
	43139,
	43140,
	43141,
	43142,
	43143,
	43144,
	43145,
	43146,
	43147,
	43148,
	43149,
	43150,
	43151,
	43152,
	43153,
	43154,
	43155,
	43156,
	43157,
	43158,
	43159,
	43160,
	43161,
	43162,
	43163,
	43164,
	43165,
	43166,
	43167,
	43168,
	43169,
	43170,
	43171,
	43172,
	43173,
	43174,
	43175,
	43176,
	43177,
	43178,
	43179,
	43180,
	43181,
	43182,
	43183,
	43184,
	43185,
	43186,
	43187,
	43250,
	43251,
	43252,
	43253,
	43254,
	43255,
	43259,
	43274,
	43275,
	43276,
	43277,
	43278,
	43279,
	43280,
	43281,
	43282,
	43283,
	43284,
	43285,
	43286,
	43287,
	43288,
	43289,
	43290,
	43291,
	43292,
	43293,
	43294,
	43295,
	43296,
	43297,
	43298,
	43299,
	43300,
	43301,
	43312,
	43313,
	43314,
	43315,
	43316,
	43317,
	43318,
	43319,
	43320,
	43321,
	43322,
	43323,
	43324,
	43325,
	43326,
	43327,
	43328,
	43329,
	43330,
	43331,
	43332,
	43333,
	43334,
	43360,
	43361,
	43362,
	43363,
	43364,
	43365,
	43366,
	43367,
	43368,
	43369,
	43370,
	43371,
	43372,
	43373,
	43374,
	43375,
	43376,
	43377,
	43378,
	43379,
	43380,
	43381,
	43382,
	43383,
	43384,
	43385,
	43386,
	43387,
	43388,
	43396,
	43397,
	43398,
	43399,
	43400,
	43401,
	43402,
	43403,
	43404,
	43405,
	43406,
	43407,
	43408,
	43409,
	43410,
	43411,
	43412,
	43413,
	43414,
	43415,
	43416,
	43417,
	43418,
	43419,
	43420,
	43421,
	43422,
	43423,
	43424,
	43425,
	43426,
	43427,
	43428,
	43429,
	43430,
	43431,
	43432,
	43433,
	43434,
	43435,
	43436,
	43437,
	43438,
	43439,
	43440,
	43441,
	43442,
	43471,
	43520,
	43521,
	43522,
	43523,
	43524,
	43525,
	43526,
	43527,
	43528,
	43529,
	43530,
	43531,
	43532,
	43533,
	43534,
	43535,
	43536,
	43537,
	43538,
	43539,
	43540,
	43541,
	43542,
	43543,
	43544,
	43545,
	43546,
	43547,
	43548,
	43549,
	43550,
	43551,
	43552,
	43553,
	43554,
	43555,
	43556,
	43557,
	43558,
	43559,
	43560,
	43584,
	43585,
	43586,
	43588,
	43589,
	43590,
	43591,
	43592,
	43593,
	43594,
	43595,
	43616,
	43617,
	43618,
	43619,
	43620,
	43621,
	43622,
	43623,
	43624,
	43625,
	43626,
	43627,
	43628,
	43629,
	43630,
	43631,
	43632,
	43633,
	43634,
	43635,
	43636,
	43637,
	43638,
	43642,
	43648,
	43649,
	43650,
	43651,
	43652,
	43653,
	43654,
	43655,
	43656,
	43657,
	43658,
	43659,
	43660,
	43661,
	43662,
	43663,
	43664,
	43665,
	43666,
	43667,
	43668,
	43669,
	43670,
	43671,
	43672,
	43673,
	43674,
	43675,
	43676,
	43677,
	43678,
	43679,
	43680,
	43681,
	43682,
	43683,
	43684,
	43685,
	43686,
	43687,
	43688,
	43689,
	43690,
	43691,
	43692,
	43693,
	43694,
	43695,
	43697,
	43701,
	43702,
	43705,
	43706,
	43707,
	43708,
	43709,
	43712,
	43714,
	43739,
	43740,
	43741,
	43744,
	43745,
	43746,
	43747,
	43748,
	43749,
	43750,
	43751,
	43752,
	43753,
	43754,
	43762,
	43763,
	43764,
	43777,
	43778,
	43779,
	43780,
	43781,
	43782,
	43785,
	43786,
	43787,
	43788,
	43789,
	43790,
	43793,
	43794,
	43795,
	43796,
	43797,
	43798,
	43808,
	43809,
	43810,
	43811,
	43812,
	43813,
	43814,
	43816,
	43817,
	43818,
	43819,
	43820,
	43821,
	43822,
	43968,
	43969,
	43970,
	43971,
	43972,
	43973,
	43974,
	43975,
	43976,
	43977,
	43978,
	43979,
	43980,
	43981,
	43982,
	43983,
	43984,
	43985,
	43986,
	43987,
	43988,
	43989,
	43990,
	43991,
	43992,
	43993,
	43994,
	43995,
	43996,
	43997,
	43998,
	43999,
	44000,
	44001,
	44002,
	44032,
	44033,
	44034,
	44035,
	44036,
	44037,
	44038,
	44039,
	44040,
	44041,
	44042,
	44043,
	44044,
	44045,
	44046,
	44047,
	44048,
	44049,
	44050,
	44051,
	44052,
	44053,
	44054,
	44055,
	44056,
	44057,
	44058,
	44059,
	44060,
	44061,
	44062,
	44063,
	44064,
	44065,
	44066,
	44067,
	44068,
	44069,
	44070,
	44071,
	44072,
	44073,
	44074,
	44075,
	44076,
	44077,
	44078,
	44079,
	44080,
	44081,
	44082,
	44083,
	44084,
	44085,
	44086,
	44087,
	44088,
	44089,
	44090,
	44091,
	44092,
	44093,
	44094,
	44095,
	44096,
	44097,
	44098,
	44099,
	44100,
	44101,
	44102,
	44103,
	44104,
	44105,
	44106,
	44107,
	44108,
	44109,
	44110,
	44111,
	44112,
	44113,
	44114,
	44115,
	44116,
	44117,
	44118,
	44119,
	44120,
	44121,
	44122,
	44123,
	44124,
	44125,
	44126,
	44127,
	44128,
	44129,
	44130,
	44131,
	44132,
	44133,
	44134,
	44135,
	44136,
	44137,
	44138,
	44139,
	44140,
	44141,
	44142,
	44143,
	44144,
	44145,
	44146,
	44147,
	44148,
	44149,
	44150,
	44151,
	44152,
	44153,
	44154,
	44155,
	44156,
	44157,
	44158,
	44159,
	44160,
	44161,
	44162,
	44163,
	44164,
	44165,
	44166,
	44167,
	44168,
	44169,
	44170,
	44171,
	44172,
	44173,
	44174,
	44175,
	44176,
	44177,
	44178,
	44179,
	44180,
	44181,
	44182,
	44183,
	44184,
	44185,
	44186,
	44187,
	44188,
	44189,
	44190,
	44191,
	44192,
	44193,
	44194,
	44195,
	44196,
	44197,
	44198,
	44199,
	44200,
	44201,
	44202,
	44203,
	44204,
	44205,
	44206,
	44207,
	44208,
	44209,
	44210,
	44211,
	44212,
	44213,
	44214,
	44215,
	44216,
	44217,
	44218,
	44219,
	44220,
	44221,
	44222,
	44223,
	44224,
	44225,
	44226,
	44227,
	44228,
	44229,
	44230,
	44231,
	44232,
	44233,
	44234,
	44235,
	44236,
	44237,
	44238,
	44239,
	44240,
	44241,
	44242,
	44243,
	44244,
	44245,
	44246,
	44247,
	44248,
	44249,
	44250,
	44251,
	44252,
	44253,
	44254,
	44255,
	44256,
	44257,
	44258,
	44259,
	44260,
	44261,
	44262,
	44263,
	44264,
	44265,
	44266,
	44267,
	44268,
	44269,
	44270,
	44271,
	44272,
	44273,
	44274,
	44275,
	44276,
	44277,
	44278,
	44279,
	44280,
	44281,
	44282,
	44283,
	44284,
	44285,
	44286,
	44287,
	44288,
	44289,
	44290,
	44291,
	44292,
	44293,
	44294,
	44295,
	44296,
	44297,
	44298,
	44299,
	44300,
	44301,
	44302,
	44303,
	44304,
	44305,
	44306,
	44307,
	44308,
	44309,
	44310,
	44311,
	44312,
	44313,
	44314,
	44315,
	44316,
	44317,
	44318,
	44319,
	44320,
	44321,
	44322,
	44323,
	44324,
	44325,
	44326,
	44327,
	44328,
	44329,
	44330,
	44331,
	44332,
	44333,
	44334,
	44335,
	44336,
	44337,
	44338,
	44339,
	44340,
	44341,
	44342,
	44343,
	44344,
	44345,
	44346,
	44347,
	44348,
	44349,
	44350,
	44351,
	44352,
	44353,
	44354,
	44355,
	44356,
	44357,
	44358,
	44359,
	44360,
	44361,
	44362,
	44363,
	44364,
	44365,
	44366,
	44367,
	44368,
	44369,
	44370,
	44371,
	44372,
	44373,
	44374,
	44375,
	44376,
	44377,
	44378,
	44379,
	44380,
	44381,
	44382,
	44383,
	44384,
	44385,
	44386,
	44387,
	44388,
	44389,
	44390,
	44391,
	44392,
	44393,
	44394,
	44395,
	44396,
	44397,
	44398,
	44399,
	44400,
	44401,
	44402,
	44403,
	44404,
	44405,
	44406,
	44407,
	44408,
	44409,
	44410,
	44411,
	44412,
	44413,
	44414,
	44415,
	44416,
	44417,
	44418,
	44419,
	44420,
	44421,
	44422,
	44423,
	44424,
	44425,
	44426,
	44427,
	44428,
	44429,
	44430,
	44431,
	44432,
	44433,
	44434,
	44435,
	44436,
	44437,
	44438,
	44439,
	44440,
	44441,
	44442,
	44443,
	44444,
	44445,
	44446,
	44447,
	44448,
	44449,
	44450,
	44451,
	44452,
	44453,
	44454,
	44455,
	44456,
	44457,
	44458,
	44459,
	44460,
	44461,
	44462,
	44463,
	44464,
	44465,
	44466,
	44467,
	44468,
	44469,
	44470,
	44471,
	44472,
	44473,
	44474,
	44475,
	44476,
	44477,
	44478,
	44479,
	44480,
	44481,
	44482,
	44483,
	44484,
	44485,
	44486,
	44487,
	44488,
	44489,
	44490,
	44491,
	44492,
	44493,
	44494,
	44495,
	44496,
	44497,
	44498,
	44499,
	44500,
	44501,
	44502,
	44503,
	44504,
	44505,
	44506,
	44507,
	44508,
	44509,
	44510,
	44511,
	44512,
	44513,
	44514,
	44515,
	44516,
	44517,
	44518,
	44519,
	44520,
	44521,
	44522,
	44523,
	44524,
	44525,
	44526,
	44527,
	44528,
	44529,
	44530,
	44531,
	44532,
	44533,
	44534,
	44535,
	44536,
	44537,
	44538,
	44539,
	44540,
	44541,
	44542,
	44543,
	44544,
	44545,
	44546,
	44547,
	44548,
	44549,
	44550,
	44551,
	44552,
	44553,
	44554,
	44555,
	44556,
	44557,
	44558,
	44559,
	44560,
	44561,
	44562,
	44563,
	44564,
	44565,
	44566,
	44567,
	44568,
	44569,
	44570,
	44571,
	44572,
	44573,
	44574,
	44575,
	44576,
	44577,
	44578,
	44579,
	44580,
	44581,
	44582,
	44583,
	44584,
	44585,
	44586,
	44587,
	44588,
	44589,
	44590,
	44591,
	44592,
	44593,
	44594,
	44595,
	44596,
	44597,
	44598,
	44599,
	44600,
	44601,
	44602,
	44603,
	44604,
	44605,
	44606,
	44607,
	44608,
	44609,
	44610,
	44611,
	44612,
	44613,
	44614,
	44615,
	44616,
	44617,
	44618,
	44619,
	44620,
	44621,
	44622,
	44623,
	44624,
	44625,
	44626,
	44627,
	44628,
	44629,
	44630,
	44631,
	44632,
	44633,
	44634,
	44635,
	44636,
	44637,
	44638,
	44639,
	44640,
	44641,
	44642,
	44643,
	44644,
	44645,
	44646,
	44647,
	44648,
	44649,
	44650,
	44651,
	44652,
	44653,
	44654,
	44655,
	44656,
	44657,
	44658,
	44659,
	44660,
	44661,
	44662,
	44663,
	44664,
	44665,
	44666,
	44667,
	44668,
	44669,
	44670,
	44671,
	44672,
	44673,
	44674,
	44675,
	44676,
	44677,
	44678,
	44679,
	44680,
	44681,
	44682,
	44683,
	44684,
	44685,
	44686,
	44687,
	44688,
	44689,
	44690,
	44691,
	44692,
	44693,
	44694,
	44695,
	44696,
	44697,
	44698,
	44699,
	44700,
	44701,
	44702,
	44703,
	44704,
	44705,
	44706,
	44707,
	44708,
	44709,
	44710,
	44711,
	44712,
	44713,
	44714,
	44715,
	44716,
	44717,
	44718,
	44719,
	44720,
	44721,
	44722,
	44723,
	44724,
	44725,
	44726,
	44727,
	44728,
	44729,
	44730,
	44731,
	44732,
	44733,
	44734,
	44735,
	44736,
	44737,
	44738,
	44739,
	44740,
	44741,
	44742,
	44743,
	44744,
	44745,
	44746,
	44747,
	44748,
	44749,
	44750,
	44751,
	44752,
	44753,
	44754,
	44755,
	44756,
	44757,
	44758,
	44759,
	44760,
	44761,
	44762,
	44763,
	44764,
	44765,
	44766,
	44767,
	44768,
	44769,
	44770,
	44771,
	44772,
	44773,
	44774,
	44775,
	44776,
	44777,
	44778,
	44779,
	44780,
	44781,
	44782,
	44783,
	44784,
	44785,
	44786,
	44787,
	44788,
	44789,
	44790,
	44791,
	44792,
	44793,
	44794,
	44795,
	44796,
	44797,
	44798,
	44799,
	44800,
	44801,
	44802,
	44803,
	44804,
	44805,
	44806,
	44807,
	44808,
	44809,
	44810,
	44811,
	44812,
	44813,
	44814,
	44815,
	44816,
	44817,
	44818,
	44819,
	44820,
	44821,
	44822,
	44823,
	44824,
	44825,
	44826,
	44827,
	44828,
	44829,
	44830,
	44831,
	44832,
	44833,
	44834,
	44835,
	44836,
	44837,
	44838,
	44839,
	44840,
	44841,
	44842,
	44843,
	44844,
	44845,
	44846,
	44847,
	44848,
	44849,
	44850,
	44851,
	44852,
	44853,
	44854,
	44855,
	44856,
	44857,
	44858,
	44859,
	44860,
	44861,
	44862,
	44863,
	44864,
	44865,
	44866,
	44867,
	44868,
	44869,
	44870,
	44871,
	44872,
	44873,
	44874,
	44875,
	44876,
	44877,
	44878,
	44879,
	44880,
	44881,
	44882,
	44883,
	44884,
	44885,
	44886,
	44887,
	44888,
	44889,
	44890,
	44891,
	44892,
	44893,
	44894,
	44895,
	44896,
	44897,
	44898,
	44899,
	44900,
	44901,
	44902,
	44903,
	44904,
	44905,
	44906,
	44907,
	44908,
	44909,
	44910,
	44911,
	44912,
	44913,
	44914,
	44915,
	44916,
	44917,
	44918,
	44919,
	44920,
	44921,
	44922,
	44923,
	44924,
	44925,
	44926,
	44927,
	44928,
	44929,
	44930,
	44931,
	44932,
	44933,
	44934,
	44935,
	44936,
	44937,
	44938,
	44939,
	44940,
	44941,
	44942,
	44943,
	44944,
	44945,
	44946,
	44947,
	44948,
	44949,
	44950,
	44951,
	44952,
	44953,
	44954,
	44955,
	44956,
	44957,
	44958,
	44959,
	44960,
	44961,
	44962,
	44963,
	44964,
	44965,
	44966,
	44967,
	44968,
	44969,
	44970,
	44971,
	44972,
	44973,
	44974,
	44975,
	44976,
	44977,
	44978,
	44979,
	44980,
	44981,
	44982,
	44983,
	44984,
	44985,
	44986,
	44987,
	44988,
	44989,
	44990,
	44991,
	44992,
	44993,
	44994,
	44995,
	44996,
	44997,
	44998,
	44999,
	45000,
	45001,
	45002,
	45003,
	45004,
	45005,
	45006,
	45007,
	45008,
	45009,
	45010,
	45011,
	45012,
	45013,
	45014,
	45015,
	45016,
	45017,
	45018,
	45019,
	45020,
	45021,
	45022,
	45023,
	45024,
	45025,
	45026,
	45027,
	45028,
	45029,
	45030,
	45031,
	45032,
	45033,
	45034,
	45035,
	45036,
	45037,
	45038,
	45039,
	45040,
	45041,
	45042,
	45043,
	45044,
	45045,
	45046,
	45047,
	45048,
	45049,
	45050,
	45051,
	45052,
	45053,
	45054,
	45055,
	45056,
	45057,
	45058,
	45059,
	45060,
	45061,
	45062,
	45063,
	45064,
	45065,
	45066,
	45067,
	45068,
	45069,
	45070,
	45071,
	45072,
	45073,
	45074,
	45075,
	45076,
	45077,
	45078,
	45079,
	45080,
	45081,
	45082,
	45083,
	45084,
	45085,
	45086,
	45087,
	45088,
	45089,
	45090,
	45091,
	45092,
	45093,
	45094,
	45095,
	45096,
	45097,
	45098,
	45099,
	45100,
	45101,
	45102,
	45103,
	45104,
	45105,
	45106,
	45107,
	45108,
	45109,
	45110,
	45111,
	45112,
	45113,
	45114,
	45115,
	45116,
	45117,
	45118,
	45119,
	45120,
	45121,
	45122,
	45123,
	45124,
	45125,
	45126,
	45127,
	45128,
	45129,
	45130,
	45131,
	45132,
	45133,
	45134,
	45135,
	45136,
	45137,
	45138,
	45139,
	45140,
	45141,
	45142,
	45143,
	45144,
	45145,
	45146,
	45147,
	45148,
	45149,
	45150,
	45151,
	45152,
	45153,
	45154,
	45155,
	45156,
	45157,
	45158,
	45159,
	45160,
	45161,
	45162,
	45163,
	45164,
	45165,
	45166,
	45167,
	45168,
	45169,
	45170,
	45171,
	45172,
	45173,
	45174,
	45175,
	45176,
	45177,
	45178,
	45179,
	45180,
	45181,
	45182,
	45183,
	45184,
	45185,
	45186,
	45187,
	45188,
	45189,
	45190,
	45191,
	45192,
	45193,
	45194,
	45195,
	45196,
	45197,
	45198,
	45199,
	45200,
	45201,
	45202,
	45203,
	45204,
	45205,
	45206,
	45207,
	45208,
	45209,
	45210,
	45211,
	45212,
	45213,
	45214,
	45215,
	45216,
	45217,
	45218,
	45219,
	45220,
	45221,
	45222,
	45223,
	45224,
	45225,
	45226,
	45227,
	45228,
	45229,
	45230,
	45231,
	45232,
	45233,
	45234,
	45235,
	45236,
	45237,
	45238,
	45239,
	45240,
	45241,
	45242,
	45243,
	45244,
	45245,
	45246,
	45247,
	45248,
	45249,
	45250,
	45251,
	45252,
	45253,
	45254,
	45255,
	45256,
	45257,
	45258,
	45259,
	45260,
	45261,
	45262,
	45263,
	45264,
	45265,
	45266,
	45267,
	45268,
	45269,
	45270,
	45271,
	45272,
	45273,
	45274,
	45275,
	45276,
	45277,
	45278,
	45279,
	45280,
	45281,
	45282,
	45283,
	45284,
	45285,
	45286,
	45287,
	45288,
	45289,
	45290,
	45291,
	45292,
	45293,
	45294,
	45295,
	45296,
	45297,
	45298,
	45299,
	45300,
	45301,
	45302,
	45303,
	45304,
	45305,
	45306,
	45307,
	45308,
	45309,
	45310,
	45311,
	45312,
	45313,
	45314,
	45315,
	45316,
	45317,
	45318,
	45319,
	45320,
	45321,
	45322,
	45323,
	45324,
	45325,
	45326,
	45327,
	45328,
	45329,
	45330,
	45331,
	45332,
	45333,
	45334,
	45335,
	45336,
	45337,
	45338,
	45339,
	45340,
	45341,
	45342,
	45343,
	45344,
	45345,
	45346,
	45347,
	45348,
	45349,
	45350,
	45351,
	45352,
	45353,
	45354,
	45355,
	45356,
	45357,
	45358,
	45359,
	45360,
	45361,
	45362,
	45363,
	45364,
	45365,
	45366,
	45367,
	45368,
	45369,
	45370,
	45371,
	45372,
	45373,
	45374,
	45375,
	45376,
	45377,
	45378,
	45379,
	45380,
	45381,
	45382,
	45383,
	45384,
	45385,
	45386,
	45387,
	45388,
	45389,
	45390,
	45391,
	45392,
	45393,
	45394,
	45395,
	45396,
	45397,
	45398,
	45399,
	45400,
	45401,
	45402,
	45403,
	45404,
	45405,
	45406,
	45407,
	45408,
	45409,
	45410,
	45411,
	45412,
	45413,
	45414,
	45415,
	45416,
	45417,
	45418,
	45419,
	45420,
	45421,
	45422,
	45423,
	45424,
	45425,
	45426,
	45427,
	45428,
	45429,
	45430,
	45431,
	45432,
	45433,
	45434,
	45435,
	45436,
	45437,
	45438,
	45439,
	45440,
	45441,
	45442,
	45443,
	45444,
	45445,
	45446,
	45447,
	45448,
	45449,
	45450,
	45451,
	45452,
	45453,
	45454,
	45455,
	45456,
	45457,
	45458,
	45459,
	45460,
	45461,
	45462,
	45463,
	45464,
	45465,
	45466,
	45467,
	45468,
	45469,
	45470,
	45471,
	45472,
	45473,
	45474,
	45475,
	45476,
	45477,
	45478,
	45479,
	45480,
	45481,
	45482,
	45483,
	45484,
	45485,
	45486,
	45487,
	45488,
	45489,
	45490,
	45491,
	45492,
	45493,
	45494,
	45495,
	45496,
	45497,
	45498,
	45499,
	45500,
	45501,
	45502,
	45503,
	45504,
	45505,
	45506,
	45507,
	45508,
	45509,
	45510,
	45511,
	45512,
	45513,
	45514,
	45515,
	45516,
	45517,
	45518,
	45519,
	45520,
	45521,
	45522,
	45523,
	45524,
	45525,
	45526,
	45527,
	45528,
	45529,
	45530,
	45531,
	45532,
	45533,
	45534,
	45535,
	45536,
	45537,
	45538,
	45539,
	45540,
	45541,
	45542,
	45543,
	45544,
	45545,
	45546,
	45547,
	45548,
	45549,
	45550,
	45551,
	45552,
	45553,
	45554,
	45555,
	45556,
	45557,
	45558,
	45559,
	45560,
	45561,
	45562,
	45563,
	45564,
	45565,
	45566,
	45567,
	45568,
	45569,
	45570,
	45571,
	45572,
	45573,
	45574,
	45575,
	45576,
	45577,
	45578,
	45579,
	45580,
	45581,
	45582,
	45583,
	45584,
	45585,
	45586,
	45587,
	45588,
	45589,
	45590,
	45591,
	45592,
	45593,
	45594,
	45595,
	45596,
	45597,
	45598,
	45599,
	45600,
	45601,
	45602,
	45603,
	45604,
	45605,
	45606,
	45607,
	45608,
	45609,
	45610,
	45611,
	45612,
	45613,
	45614,
	45615,
	45616,
	45617,
	45618,
	45619,
	45620,
	45621,
	45622,
	45623,
	45624,
	45625,
	45626,
	45627,
	45628,
	45629,
	45630,
	45631,
	45632,
	45633,
	45634,
	45635,
	45636,
	45637,
	45638,
	45639,
	45640,
	45641,
	45642,
	45643,
	45644,
	45645,
	45646,
	45647,
	45648,
	45649,
	45650,
	45651,
	45652,
	45653,
	45654,
	45655,
	45656,
	45657,
	45658,
	45659,
	45660,
	45661,
	45662,
	45663,
	45664,
	45665,
	45666,
	45667,
	45668,
	45669,
	45670,
	45671,
	45672,
	45673,
	45674,
	45675,
	45676,
	45677,
	45678,
	45679,
	45680,
	45681,
	45682,
	45683,
	45684,
	45685,
	45686,
	45687,
	45688,
	45689,
	45690,
	45691,
	45692,
	45693,
	45694,
	45695,
	45696,
	45697,
	45698,
	45699,
	45700,
	45701,
	45702,
	45703,
	45704,
	45705,
	45706,
	45707,
	45708,
	45709,
	45710,
	45711,
	45712,
	45713,
	45714,
	45715,
	45716,
	45717,
	45718,
	45719,
	45720,
	45721,
	45722,
	45723,
	45724,
	45725,
	45726,
	45727,
	45728,
	45729,
	45730,
	45731,
	45732,
	45733,
	45734,
	45735,
	45736,
	45737,
	45738,
	45739,
	45740,
	45741,
	45742,
	45743,
	45744,
	45745,
	45746,
	45747,
	45748,
	45749,
	45750,
	45751,
	45752,
	45753,
	45754,
	45755,
	45756,
	45757,
	45758,
	45759,
	45760,
	45761,
	45762,
	45763,
	45764,
	45765,
	45766,
	45767,
	45768,
	45769,
	45770,
	45771,
	45772,
	45773,
	45774,
	45775,
	45776,
	45777,
	45778,
	45779,
	45780,
	45781,
	45782,
	45783,
	45784,
	45785,
	45786,
	45787,
	45788,
	45789,
	45790,
	45791,
	45792,
	45793,
	45794,
	45795,
	45796,
	45797,
	45798,
	45799,
	45800,
	45801,
	45802,
	45803,
	45804,
	45805,
	45806,
	45807,
	45808,
	45809,
	45810,
	45811,
	45812,
	45813,
	45814,
	45815,
	45816,
	45817,
	45818,
	45819,
	45820,
	45821,
	45822,
	45823,
	45824,
	45825,
	45826,
	45827,
	45828,
	45829,
	45830,
	45831,
	45832,
	45833,
	45834,
	45835,
	45836,
	45837,
	45838,
	45839,
	45840,
	45841,
	45842,
	45843,
	45844,
	45845,
	45846,
	45847,
	45848,
	45849,
	45850,
	45851,
	45852,
	45853,
	45854,
	45855,
	45856,
	45857,
	45858,
	45859,
	45860,
	45861,
	45862,
	45863,
	45864,
	45865,
	45866,
	45867,
	45868,
	45869,
	45870,
	45871,
	45872,
	45873,
	45874,
	45875,
	45876,
	45877,
	45878,
	45879,
	45880,
	45881,
	45882,
	45883,
	45884,
	45885,
	45886,
	45887,
	45888,
	45889,
	45890,
	45891,
	45892,
	45893,
	45894,
	45895,
	45896,
	45897,
	45898,
	45899,
	45900,
	45901,
	45902,
	45903,
	45904,
	45905,
	45906,
	45907,
	45908,
	45909,
	45910,
	45911,
	45912,
	45913,
	45914,
	45915,
	45916,
	45917,
	45918,
	45919,
	45920,
	45921,
	45922,
	45923,
	45924,
	45925,
	45926,
	45927,
	45928,
	45929,
	45930,
	45931,
	45932,
	45933,
	45934,
	45935,
	45936,
	45937,
	45938,
	45939,
	45940,
	45941,
	45942,
	45943,
	45944,
	45945,
	45946,
	45947,
	45948,
	45949,
	45950,
	45951,
	45952,
	45953,
	45954,
	45955,
	45956,
	45957,
	45958,
	45959,
	45960,
	45961,
	45962,
	45963,
	45964,
	45965,
	45966,
	45967,
	45968,
	45969,
	45970,
	45971,
	45972,
	45973,
	45974,
	45975,
	45976,
	45977,
	45978,
	45979,
	45980,
	45981,
	45982,
	45983,
	45984,
	45985,
	45986,
	45987,
	45988,
	45989,
	45990,
	45991,
	45992,
	45993,
	45994,
	45995,
	45996,
	45997,
	45998,
	45999,
	46000,
	46001,
	46002,
	46003,
	46004,
	46005,
	46006,
	46007,
	46008,
	46009,
	46010,
	46011,
	46012,
	46013,
	46014,
	46015,
	46016,
	46017,
	46018,
	46019,
	46020,
	46021,
	46022,
	46023,
	46024,
	46025,
	46026,
	46027,
	46028,
	46029,
	46030,
	46031,
	46032,
	46033,
	46034,
	46035,
	46036,
	46037,
	46038,
	46039,
	46040,
	46041,
	46042,
	46043,
	46044,
	46045,
	46046,
	46047,
	46048,
	46049,
	46050,
	46051,
	46052,
	46053,
	46054,
	46055,
	46056,
	46057,
	46058,
	46059,
	46060,
	46061,
	46062,
	46063,
	46064,
	46065,
	46066,
	46067,
	46068,
	46069,
	46070,
	46071,
	46072,
	46073,
	46074,
	46075,
	46076,
	46077,
	46078,
	46079,
	46080,
	46081,
	46082,
	46083,
	46084,
	46085,
	46086,
	46087,
	46088,
	46089,
	46090,
	46091,
	46092,
	46093,
	46094,
	46095,
	46096,
	46097,
	46098,
	46099,
	46100,
	46101,
	46102,
	46103,
	46104,
	46105,
	46106,
	46107,
	46108,
	46109,
	46110,
	46111,
	46112,
	46113,
	46114,
	46115,
	46116,
	46117,
	46118,
	46119,
	46120,
	46121,
	46122,
	46123,
	46124,
	46125,
	46126,
	46127,
	46128,
	46129,
	46130,
	46131,
	46132,
	46133,
	46134,
	46135,
	46136,
	46137,
	46138,
	46139,
	46140,
	46141,
	46142,
	46143,
	46144,
	46145,
	46146,
	46147,
	46148,
	46149,
	46150,
	46151,
	46152,
	46153,
	46154,
	46155,
	46156,
	46157,
	46158,
	46159,
	46160,
	46161,
	46162,
	46163,
	46164,
	46165,
	46166,
	46167,
	46168,
	46169,
	46170,
	46171,
	46172,
	46173,
	46174,
	46175,
	46176,
	46177,
	46178,
	46179,
	46180,
	46181,
	46182,
	46183,
	46184,
	46185,
	46186,
	46187,
	46188,
	46189,
	46190,
	46191,
	46192,
	46193,
	46194,
	46195,
	46196,
	46197,
	46198,
	46199,
	46200,
	46201,
	46202,
	46203,
	46204,
	46205,
	46206,
	46207,
	46208,
	46209,
	46210,
	46211,
	46212,
	46213,
	46214,
	46215,
	46216,
	46217,
	46218,
	46219,
	46220,
	46221,
	46222,
	46223,
	46224,
	46225,
	46226,
	46227,
	46228,
	46229,
	46230,
	46231,
	46232,
	46233,
	46234,
	46235,
	46236,
	46237,
	46238,
	46239,
	46240,
	46241,
	46242,
	46243,
	46244,
	46245,
	46246,
	46247,
	46248,
	46249,
	46250,
	46251,
	46252,
	46253,
	46254,
	46255,
	46256,
	46257,
	46258,
	46259,
	46260,
	46261,
	46262,
	46263,
	46264,
	46265,
	46266,
	46267,
	46268,
	46269,
	46270,
	46271,
	46272,
	46273,
	46274,
	46275,
	46276,
	46277,
	46278,
	46279,
	46280,
	46281,
	46282,
	46283,
	46284,
	46285,
	46286,
	46287,
	46288,
	46289,
	46290,
	46291,
	46292,
	46293,
	46294,
	46295,
	46296,
	46297,
	46298,
	46299,
	46300,
	46301,
	46302,
	46303,
	46304,
	46305,
	46306,
	46307,
	46308,
	46309,
	46310,
	46311,
	46312,
	46313,
	46314,
	46315,
	46316,
	46317,
	46318,
	46319,
	46320,
	46321,
	46322,
	46323,
	46324,
	46325,
	46326,
	46327,
	46328,
	46329,
	46330,
	46331,
	46332,
	46333,
	46334,
	46335,
	46336,
	46337,
	46338,
	46339,
	46340,
	46341,
	46342,
	46343,
	46344,
	46345,
	46346,
	46347,
	46348,
	46349,
	46350,
	46351,
	46352,
	46353,
	46354,
	46355,
	46356,
	46357,
	46358,
	46359,
	46360,
	46361,
	46362,
	46363,
	46364,
	46365,
	46366,
	46367,
	46368,
	46369,
	46370,
	46371,
	46372,
	46373,
	46374,
	46375,
	46376,
	46377,
	46378,
	46379,
	46380,
	46381,
	46382,
	46383,
	46384,
	46385,
	46386,
	46387,
	46388,
	46389,
	46390,
	46391,
	46392,
	46393,
	46394,
	46395,
	46396,
	46397,
	46398,
	46399,
	46400,
	46401,
	46402,
	46403,
	46404,
	46405,
	46406,
	46407,
	46408,
	46409,
	46410,
	46411,
	46412,
	46413,
	46414,
	46415,
	46416,
	46417,
	46418,
	46419,
	46420,
	46421,
	46422,
	46423,
	46424,
	46425,
	46426,
	46427,
	46428,
	46429,
	46430,
	46431,
	46432,
	46433,
	46434,
	46435,
	46436,
	46437,
	46438,
	46439,
	46440,
	46441,
	46442,
	46443,
	46444,
	46445,
	46446,
	46447,
	46448,
	46449,
	46450,
	46451,
	46452,
	46453,
	46454,
	46455,
	46456,
	46457,
	46458,
	46459,
	46460,
	46461,
	46462,
	46463,
	46464,
	46465,
	46466,
	46467,
	46468,
	46469,
	46470,
	46471,
	46472,
	46473,
	46474,
	46475,
	46476,
	46477,
	46478,
	46479,
	46480,
	46481,
	46482,
	46483,
	46484,
	46485,
	46486,
	46487,
	46488,
	46489,
	46490,
	46491,
	46492,
	46493,
	46494,
	46495,
	46496,
	46497,
	46498,
	46499,
	46500,
	46501,
	46502,
	46503,
	46504,
	46505,
	46506,
	46507,
	46508,
	46509,
	46510,
	46511,
	46512,
	46513,
	46514,
	46515,
	46516,
	46517,
	46518,
	46519,
	46520,
	46521,
	46522,
	46523,
	46524,
	46525,
	46526,
	46527,
	46528,
	46529,
	46530,
	46531,
	46532,
	46533,
	46534,
	46535,
	46536,
	46537,
	46538,
	46539,
	46540,
	46541,
	46542,
	46543,
	46544,
	46545,
	46546,
	46547,
	46548,
	46549,
	46550,
	46551,
	46552,
	46553,
	46554,
	46555,
	46556,
	46557,
	46558,
	46559,
	46560,
	46561,
	46562,
	46563,
	46564,
	46565,
	46566,
	46567,
	46568,
	46569,
	46570,
	46571,
	46572,
	46573,
	46574,
	46575,
	46576,
	46577,
	46578,
	46579,
	46580,
	46581,
	46582,
	46583,
	46584,
	46585,
	46586,
	46587,
	46588,
	46589,
	46590,
	46591,
	46592,
	46593,
	46594,
	46595,
	46596,
	46597,
	46598,
	46599,
	46600,
	46601,
	46602,
	46603,
	46604,
	46605,
	46606,
	46607,
	46608,
	46609,
	46610,
	46611,
	46612,
	46613,
	46614,
	46615,
	46616,
	46617,
	46618,
	46619,
	46620,
	46621,
	46622,
	46623,
	46624,
	46625,
	46626,
	46627,
	46628,
	46629,
	46630,
	46631,
	46632,
	46633,
	46634,
	46635,
	46636,
	46637,
	46638,
	46639,
	46640,
	46641,
	46642,
	46643,
	46644,
	46645,
	46646,
	46647,
	46648,
	46649,
	46650,
	46651,
	46652,
	46653,
	46654,
	46655,
	46656,
	46657,
	46658,
	46659,
	46660,
	46661,
	46662,
	46663,
	46664,
	46665,
	46666,
	46667,
	46668,
	46669,
	46670,
	46671,
	46672,
	46673,
	46674,
	46675,
	46676,
	46677,
	46678,
	46679,
	46680,
	46681,
	46682,
	46683,
	46684,
	46685,
	46686,
	46687,
	46688,
	46689,
	46690,
	46691,
	46692,
	46693,
	46694,
	46695,
	46696,
	46697,
	46698,
	46699,
	46700,
	46701,
	46702,
	46703,
	46704,
	46705,
	46706,
	46707,
	46708,
	46709,
	46710,
	46711,
	46712,
	46713,
	46714,
	46715,
	46716,
	46717,
	46718,
	46719,
	46720,
	46721,
	46722,
	46723,
	46724,
	46725,
	46726,
	46727,
	46728,
	46729,
	46730,
	46731,
	46732,
	46733,
	46734,
	46735,
	46736,
	46737,
	46738,
	46739,
	46740,
	46741,
	46742,
	46743,
	46744,
	46745,
	46746,
	46747,
	46748,
	46749,
	46750,
	46751,
	46752,
	46753,
	46754,
	46755,
	46756,
	46757,
	46758,
	46759,
	46760,
	46761,
	46762,
	46763,
	46764,
	46765,
	46766,
	46767,
	46768,
	46769,
	46770,
	46771,
	46772,
	46773,
	46774,
	46775,
	46776,
	46777,
	46778,
	46779,
	46780,
	46781,
	46782,
	46783,
	46784,
	46785,
	46786,
	46787,
	46788,
	46789,
	46790,
	46791,
	46792,
	46793,
	46794,
	46795,
	46796,
	46797,
	46798,
	46799,
	46800,
	46801,
	46802,
	46803,
	46804,
	46805,
	46806,
	46807,
	46808,
	46809,
	46810,
	46811,
	46812,
	46813,
	46814,
	46815,
	46816,
	46817,
	46818,
	46819,
	46820,
	46821,
	46822,
	46823,
	46824,
	46825,
	46826,
	46827,
	46828,
	46829,
	46830,
	46831,
	46832,
	46833,
	46834,
	46835,
	46836,
	46837,
	46838,
	46839,
	46840,
	46841,
	46842,
	46843,
	46844,
	46845,
	46846,
	46847,
	46848,
	46849,
	46850,
	46851,
	46852,
	46853,
	46854,
	46855,
	46856,
	46857,
	46858,
	46859,
	46860,
	46861,
	46862,
	46863,
	46864,
	46865,
	46866,
	46867,
	46868,
	46869,
	46870,
	46871,
	46872,
	46873,
	46874,
	46875,
	46876,
	46877,
	46878,
	46879,
	46880,
	46881,
	46882,
	46883,
	46884,
	46885,
	46886,
	46887,
	46888,
	46889,
	46890,
	46891,
	46892,
	46893,
	46894,
	46895,
	46896,
	46897,
	46898,
	46899,
	46900,
	46901,
	46902,
	46903,
	46904,
	46905,
	46906,
	46907,
	46908,
	46909,
	46910,
	46911,
	46912,
	46913,
	46914,
	46915,
	46916,
	46917,
	46918,
	46919,
	46920,
	46921,
	46922,
	46923,
	46924,
	46925,
	46926,
	46927,
	46928,
	46929,
	46930,
	46931,
	46932,
	46933,
	46934,
	46935,
	46936,
	46937,
	46938,
	46939,
	46940,
	46941,
	46942,
	46943,
	46944,
	46945,
	46946,
	46947,
	46948,
	46949,
	46950,
	46951,
	46952,
	46953,
	46954,
	46955,
	46956,
	46957,
	46958,
	46959,
	46960,
	46961,
	46962,
	46963,
	46964,
	46965,
	46966,
	46967,
	46968,
	46969,
	46970,
	46971,
	46972,
	46973,
	46974,
	46975,
	46976,
	46977,
	46978,
	46979,
	46980,
	46981,
	46982,
	46983,
	46984,
	46985,
	46986,
	46987,
	46988,
	46989,
	46990,
	46991,
	46992,
	46993,
	46994,
	46995,
	46996,
	46997,
	46998,
	46999,
	47000,
	47001,
	47002,
	47003,
	47004,
	47005,
	47006,
	47007,
	47008,
	47009,
	47010,
	47011,
	47012,
	47013,
	47014,
	47015,
	47016,
	47017,
	47018,
	47019,
	47020,
	47021,
	47022,
	47023,
	47024,
	47025,
	47026,
	47027,
	47028,
	47029,
	47030,
	47031,
	47032,
	47033,
	47034,
	47035,
	47036,
	47037,
	47038,
	47039,
	47040,
	47041,
	47042,
	47043,
	47044,
	47045,
	47046,
	47047,
	47048,
	47049,
	47050,
	47051,
	47052,
	47053,
	47054,
	47055,
	47056,
	47057,
	47058,
	47059,
	47060,
	47061,
	47062,
	47063,
	47064,
	47065,
	47066,
	47067,
	47068,
	47069,
	47070,
	47071,
	47072,
	47073,
	47074,
	47075,
	47076,
	47077,
	47078,
	47079,
	47080,
	47081,
	47082,
	47083,
	47084,
	47085,
	47086,
	47087,
	47088,
	47089,
	47090,
	47091,
	47092,
	47093,
	47094,
	47095,
	47096,
	47097,
	47098,
	47099,
	47100,
	47101,
	47102,
	47103,
	47104,
	47105,
	47106,
	47107,
	47108,
	47109,
	47110,
	47111,
	47112,
	47113,
	47114,
	47115,
	47116,
	47117,
	47118,
	47119,
	47120,
	47121,
	47122,
	47123,
	47124,
	47125,
	47126,
	47127,
	47128,
	47129,
	47130,
	47131,
	47132,
	47133,
	47134,
	47135,
	47136,
	47137,
	47138,
	47139,
	47140,
	47141,
	47142,
	47143,
	47144,
	47145,
	47146,
	47147,
	47148,
	47149,
	47150,
	47151,
	47152,
	47153,
	47154,
	47155,
	47156,
	47157,
	47158,
	47159,
	47160,
	47161,
	47162,
	47163,
	47164,
	47165,
	47166,
	47167,
	47168,
	47169,
	47170,
	47171,
	47172,
	47173,
	47174,
	47175,
	47176,
	47177,
	47178,
	47179,
	47180,
	47181,
	47182,
	47183,
	47184,
	47185,
	47186,
	47187,
	47188,
	47189,
	47190,
	47191,
	47192,
	47193,
	47194,
	47195,
	47196,
	47197,
	47198,
	47199,
	47200,
	47201,
	47202,
	47203,
	47204,
	47205,
	47206,
	47207,
	47208,
	47209,
	47210,
	47211,
	47212,
	47213,
	47214,
	47215,
	47216,
	47217,
	47218,
	47219,
	47220,
	47221,
	47222,
	47223,
	47224,
	47225,
	47226,
	47227,
	47228,
	47229,
	47230,
	47231,
	47232,
	47233,
	47234,
	47235,
	47236,
	47237,
	47238,
	47239,
	47240,
	47241,
	47242,
	47243,
	47244,
	47245,
	47246,
	47247,
	47248,
	47249,
	47250,
	47251,
	47252,
	47253,
	47254,
	47255,
	47256,
	47257,
	47258,
	47259,
	47260,
	47261,
	47262,
	47263,
	47264,
	47265,
	47266,
	47267,
	47268,
	47269,
	47270,
	47271,
	47272,
	47273,
	47274,
	47275,
	47276,
	47277,
	47278,
	47279,
	47280,
	47281,
	47282,
	47283,
	47284,
	47285,
	47286,
	47287,
	47288,
	47289,
	47290,
	47291,
	47292,
	47293,
	47294,
	47295,
	47296,
	47297,
	47298,
	47299,
	47300,
	47301,
	47302,
	47303,
	47304,
	47305,
	47306,
	47307,
	47308,
	47309,
	47310,
	47311,
	47312,
	47313,
	47314,
	47315,
	47316,
	47317,
	47318,
	47319,
	47320,
	47321,
	47322,
	47323,
	47324,
	47325,
	47326,
	47327,
	47328,
	47329,
	47330,
	47331,
	47332,
	47333,
	47334,
	47335,
	47336,
	47337,
	47338,
	47339,
	47340,
	47341,
	47342,
	47343,
	47344,
	47345,
	47346,
	47347,
	47348,
	47349,
	47350,
	47351,
	47352,
	47353,
	47354,
	47355,
	47356,
	47357,
	47358,
	47359,
	47360,
	47361,
	47362,
	47363,
	47364,
	47365,
	47366,
	47367,
	47368,
	47369,
	47370,
	47371,
	47372,
	47373,
	47374,
	47375,
	47376,
	47377,
	47378,
	47379,
	47380,
	47381,
	47382,
	47383,
	47384,
	47385,
	47386,
	47387,
	47388,
	47389,
	47390,
	47391,
	47392,
	47393,
	47394,
	47395,
	47396,
	47397,
	47398,
	47399,
	47400,
	47401,
	47402,
	47403,
	47404,
	47405,
	47406,
	47407,
	47408,
	47409,
	47410,
	47411,
	47412,
	47413,
	47414,
	47415,
	47416,
	47417,
	47418,
	47419,
	47420,
	47421,
	47422,
	47423,
	47424,
	47425,
	47426,
	47427,
	47428,
	47429,
	47430,
	47431,
	47432,
	47433,
	47434,
	47435,
	47436,
	47437,
	47438,
	47439,
	47440,
	47441,
	47442,
	47443,
	47444,
	47445,
	47446,
	47447,
	47448,
	47449,
	47450,
	47451,
	47452,
	47453,
	47454,
	47455,
	47456,
	47457,
	47458,
	47459,
	47460,
	47461,
	47462,
	47463,
	47464,
	47465,
	47466,
	47467,
	47468,
	47469,
	47470,
	47471,
	47472,
	47473,
	47474,
	47475,
	47476,
	47477,
	47478,
	47479,
	47480,
	47481,
	47482,
	47483,
	47484,
	47485,
	47486,
	47487,
	47488,
	47489,
	47490,
	47491,
	47492,
	47493,
	47494,
	47495,
	47496,
	47497,
	47498,
	47499,
	47500,
	47501,
	47502,
	47503,
	47504,
	47505,
	47506,
	47507,
	47508,
	47509,
	47510,
	47511,
	47512,
	47513,
	47514,
	47515,
	47516,
	47517,
	47518,
	47519,
	47520,
	47521,
	47522,
	47523,
	47524,
	47525,
	47526,
	47527,
	47528,
	47529,
	47530,
	47531,
	47532,
	47533,
	47534,
	47535,
	47536,
	47537,
	47538,
	47539,
	47540,
	47541,
	47542,
	47543,
	47544,
	47545,
	47546,
	47547,
	47548,
	47549,
	47550,
	47551,
	47552,
	47553,
	47554,
	47555,
	47556,
	47557,
	47558,
	47559,
	47560,
	47561,
	47562,
	47563,
	47564,
	47565,
	47566,
	47567,
	47568,
	47569,
	47570,
	47571,
	47572,
	47573,
	47574,
	47575,
	47576,
	47577,
	47578,
	47579,
	47580,
	47581,
	47582,
	47583,
	47584,
	47585,
	47586,
	47587,
	47588,
	47589,
	47590,
	47591,
	47592,
	47593,
	47594,
	47595,
	47596,
	47597,
	47598,
	47599,
	47600,
	47601,
	47602,
	47603,
	47604,
	47605,
	47606,
	47607,
	47608,
	47609,
	47610,
	47611,
	47612,
	47613,
	47614,
	47615,
	47616,
	47617,
	47618,
	47619,
	47620,
	47621,
	47622,
	47623,
	47624,
	47625,
	47626,
	47627,
	47628,
	47629,
	47630,
	47631,
	47632,
	47633,
	47634,
	47635,
	47636,
	47637,
	47638,
	47639,
	47640,
	47641,
	47642,
	47643,
	47644,
	47645,
	47646,
	47647,
	47648,
	47649,
	47650,
	47651,
	47652,
	47653,
	47654,
	47655,
	47656,
	47657,
	47658,
	47659,
	47660,
	47661,
	47662,
	47663,
	47664,
	47665,
	47666,
	47667,
	47668,
	47669,
	47670,
	47671,
	47672,
	47673,
	47674,
	47675,
	47676,
	47677,
	47678,
	47679,
	47680,
	47681,
	47682,
	47683,
	47684,
	47685,
	47686,
	47687,
	47688,
	47689,
	47690,
	47691,
	47692,
	47693,
	47694,
	47695,
	47696,
	47697,
	47698,
	47699,
	47700,
	47701,
	47702,
	47703,
	47704,
	47705,
	47706,
	47707,
	47708,
	47709,
	47710,
	47711,
	47712,
	47713,
	47714,
	47715,
	47716,
	47717,
	47718,
	47719,
	47720,
	47721,
	47722,
	47723,
	47724,
	47725,
	47726,
	47727,
	47728,
	47729,
	47730,
	47731,
	47732,
	47733,
	47734,
	47735,
	47736,
	47737,
	47738,
	47739,
	47740,
	47741,
	47742,
	47743,
	47744,
	47745,
	47746,
	47747,
	47748,
	47749,
	47750,
	47751,
	47752,
	47753,
	47754,
	47755,
	47756,
	47757,
	47758,
	47759,
	47760,
	47761,
	47762,
	47763,
	47764,
	47765,
	47766,
	47767,
	47768,
	47769,
	47770,
	47771,
	47772,
	47773,
	47774,
	47775,
	47776,
	47777,
	47778,
	47779,
	47780,
	47781,
	47782,
	47783,
	47784,
	47785,
	47786,
	47787,
	47788,
	47789,
	47790,
	47791,
	47792,
	47793,
	47794,
	47795,
	47796,
	47797,
	47798,
	47799,
	47800,
	47801,
	47802,
	47803,
	47804,
	47805,
	47806,
	47807,
	47808,
	47809,
	47810,
	47811,
	47812,
	47813,
	47814,
	47815,
	47816,
	47817,
	47818,
	47819,
	47820,
	47821,
	47822,
	47823,
	47824,
	47825,
	47826,
	47827,
	47828,
	47829,
	47830,
	47831,
	47832,
	47833,
	47834,
	47835,
	47836,
	47837,
	47838,
	47839,
	47840,
	47841,
	47842,
	47843,
	47844,
	47845,
	47846,
	47847,
	47848,
	47849,
	47850,
	47851,
	47852,
	47853,
	47854,
	47855,
	47856,
	47857,
	47858,
	47859,
	47860,
	47861,
	47862,
	47863,
	47864,
	47865,
	47866,
	47867,
	47868,
	47869,
	47870,
	47871,
	47872,
	47873,
	47874,
	47875,
	47876,
	47877,
	47878,
	47879,
	47880,
	47881,
	47882,
	47883,
	47884,
	47885,
	47886,
	47887,
	47888,
	47889,
	47890,
	47891,
	47892,
	47893,
	47894,
	47895,
	47896,
	47897,
	47898,
	47899,
	47900,
	47901,
	47902,
	47903,
	47904,
	47905,
	47906,
	47907,
	47908,
	47909,
	47910,
	47911,
	47912,
	47913,
	47914,
	47915,
	47916,
	47917,
	47918,
	47919,
	47920,
	47921,
	47922,
	47923,
	47924,
	47925,
	47926,
	47927,
	47928,
	47929,
	47930,
	47931,
	47932,
	47933,
	47934,
	47935,
	47936,
	47937,
	47938,
	47939,
	47940,
	47941,
	47942,
	47943,
	47944,
	47945,
	47946,
	47947,
	47948,
	47949,
	47950,
	47951,
	47952,
	47953,
	47954,
	47955,
	47956,
	47957,
	47958,
	47959,
	47960,
	47961,
	47962,
	47963,
	47964,
	47965,
	47966,
	47967,
	47968,
	47969,
	47970,
	47971,
	47972,
	47973,
	47974,
	47975,
	47976,
	47977,
	47978,
	47979,
	47980,
	47981,
	47982,
	47983,
	47984,
	47985,
	47986,
	47987,
	47988,
	47989,
	47990,
	47991,
	47992,
	47993,
	47994,
	47995,
	47996,
	47997,
	47998,
	47999,
	48000,
	48001,
	48002,
	48003,
	48004,
	48005,
	48006,
	48007,
	48008,
	48009,
	48010,
	48011,
	48012,
	48013,
	48014,
	48015,
	48016,
	48017,
	48018,
	48019,
	48020,
	48021,
	48022,
	48023,
	48024,
	48025,
	48026,
	48027,
	48028,
	48029,
	48030,
	48031,
	48032,
	48033,
	48034,
	48035,
	48036,
	48037,
	48038,
	48039,
	48040,
	48041,
	48042,
	48043,
	48044,
	48045,
	48046,
	48047,
	48048,
	48049,
	48050,
	48051,
	48052,
	48053,
	48054,
	48055,
	48056,
	48057,
	48058,
	48059,
	48060,
	48061,
	48062,
	48063,
	48064,
	48065,
	48066,
	48067,
	48068,
	48069,
	48070,
	48071,
	48072,
	48073,
	48074,
	48075,
	48076,
	48077,
	48078,
	48079,
	48080,
	48081,
	48082,
	48083,
	48084,
	48085,
	48086,
	48087,
	48088,
	48089,
	48090,
	48091,
	48092,
	48093,
	48094,
	48095,
	48096,
	48097,
	48098,
	48099,
	48100,
	48101,
	48102,
	48103,
	48104,
	48105,
	48106,
	48107,
	48108,
	48109,
	48110,
	48111,
	48112,
	48113,
	48114,
	48115,
	48116,
	48117,
	48118,
	48119,
	48120,
	48121,
	48122,
	48123,
	48124,
	48125,
	48126,
	48127,
	48128,
	48129,
	48130,
	48131,
	48132,
	48133,
	48134,
	48135,
	48136,
	48137,
	48138,
	48139,
	48140,
	48141,
	48142,
	48143,
	48144,
	48145,
	48146,
	48147,
	48148,
	48149,
	48150,
	48151,
	48152,
	48153,
	48154,
	48155,
	48156,
	48157,
	48158,
	48159,
	48160,
	48161,
	48162,
	48163,
	48164,
	48165,
	48166,
	48167,
	48168,
	48169,
	48170,
	48171,
	48172,
	48173,
	48174,
	48175,
	48176,
	48177,
	48178,
	48179,
	48180,
	48181,
	48182,
	48183,
	48184,
	48185,
	48186,
	48187,
	48188,
	48189,
	48190,
	48191,
	48192,
	48193,
	48194,
	48195,
	48196,
	48197,
	48198,
	48199,
	48200,
	48201,
	48202,
	48203,
	48204,
	48205,
	48206,
	48207,
	48208,
	48209,
	48210,
	48211,
	48212,
	48213,
	48214,
	48215,
	48216,
	48217,
	48218,
	48219,
	48220,
	48221,
	48222,
	48223,
	48224,
	48225,
	48226,
	48227,
	48228,
	48229,
	48230,
	48231,
	48232,
	48233,
	48234,
	48235,
	48236,
	48237,
	48238,
	48239,
	48240,
	48241,
	48242,
	48243,
	48244,
	48245,
	48246,
	48247,
	48248,
	48249,
	48250,
	48251,
	48252,
	48253,
	48254,
	48255,
	48256,
	48257,
	48258,
	48259,
	48260,
	48261,
	48262,
	48263,
	48264,
	48265,
	48266,
	48267,
	48268,
	48269,
	48270,
	48271,
	48272,
	48273,
	48274,
	48275,
	48276,
	48277,
	48278,
	48279,
	48280,
	48281,
	48282,
	48283,
	48284,
	48285,
	48286,
	48287,
	48288,
	48289,
	48290,
	48291,
	48292,
	48293,
	48294,
	48295,
	48296,
	48297,
	48298,
	48299,
	48300,
	48301,
	48302,
	48303,
	48304,
	48305,
	48306,
	48307,
	48308,
	48309,
	48310,
	48311,
	48312,
	48313,
	48314,
	48315,
	48316,
	48317,
	48318,
	48319,
	48320,
	48321,
	48322,
	48323,
	48324,
	48325,
	48326,
	48327,
	48328,
	48329,
	48330,
	48331,
	48332,
	48333,
	48334,
	48335,
	48336,
	48337,
	48338,
	48339,
	48340,
	48341,
	48342,
	48343,
	48344,
	48345,
	48346,
	48347,
	48348,
	48349,
	48350,
	48351,
	48352,
	48353,
	48354,
	48355,
	48356,
	48357,
	48358,
	48359,
	48360,
	48361,
	48362,
	48363,
	48364,
	48365,
	48366,
	48367,
	48368,
	48369,
	48370,
	48371,
	48372,
	48373,
	48374,
	48375,
	48376,
	48377,
	48378,
	48379,
	48380,
	48381,
	48382,
	48383,
	48384,
	48385,
	48386,
	48387,
	48388,
	48389,
	48390,
	48391,
	48392,
	48393,
	48394,
	48395,
	48396,
	48397,
	48398,
	48399,
	48400,
	48401,
	48402,
	48403,
	48404,
	48405,
	48406,
	48407,
	48408,
	48409,
	48410,
	48411,
	48412,
	48413,
	48414,
	48415,
	48416,
	48417,
	48418,
	48419,
	48420,
	48421,
	48422,
	48423,
	48424,
	48425,
	48426,
	48427,
	48428,
	48429,
	48430,
	48431,
	48432,
	48433,
	48434,
	48435,
	48436,
	48437,
	48438,
	48439,
	48440,
	48441,
	48442,
	48443,
	48444,
	48445,
	48446,
	48447,
	48448,
	48449,
	48450,
	48451,
	48452,
	48453,
	48454,
	48455,
	48456,
	48457,
	48458,
	48459,
	48460,
	48461,
	48462,
	48463,
	48464,
	48465,
	48466,
	48467,
	48468,
	48469,
	48470,
	48471,
	48472,
	48473,
	48474,
	48475,
	48476,
	48477,
	48478,
	48479,
	48480,
	48481,
	48482,
	48483,
	48484,
	48485,
	48486,
	48487,
	48488,
	48489,
	48490,
	48491,
	48492,
	48493,
	48494,
	48495,
	48496,
	48497,
	48498,
	48499,
	48500,
	48501,
	48502,
	48503,
	48504,
	48505,
	48506,
	48507,
	48508,
	48509,
	48510,
	48511,
	48512,
	48513,
	48514,
	48515,
	48516,
	48517,
	48518,
	48519,
	48520,
	48521,
	48522,
	48523,
	48524,
	48525,
	48526,
	48527,
	48528,
	48529,
	48530,
	48531,
	48532,
	48533,
	48534,
	48535,
	48536,
	48537,
	48538,
	48539,
	48540,
	48541,
	48542,
	48543,
	48544,
	48545,
	48546,
	48547,
	48548,
	48549,
	48550,
	48551,
	48552,
	48553,
	48554,
	48555,
	48556,
	48557,
	48558,
	48559,
	48560,
	48561,
	48562,
	48563,
	48564,
	48565,
	48566,
	48567,
	48568,
	48569,
	48570,
	48571,
	48572,
	48573,
	48574,
	48575,
	48576,
	48577,
	48578,
	48579,
	48580,
	48581,
	48582,
	48583,
	48584,
	48585,
	48586,
	48587,
	48588,
	48589,
	48590,
	48591,
	48592,
	48593,
	48594,
	48595,
	48596,
	48597,
	48598,
	48599,
	48600,
	48601,
	48602,
	48603,
	48604,
	48605,
	48606,
	48607,
	48608,
	48609,
	48610,
	48611,
	48612,
	48613,
	48614,
	48615,
	48616,
	48617,
	48618,
	48619,
	48620,
	48621,
	48622,
	48623,
	48624,
	48625,
	48626,
	48627,
	48628,
	48629,
	48630,
	48631,
	48632,
	48633,
	48634,
	48635,
	48636,
	48637,
	48638,
	48639,
	48640,
	48641,
	48642,
	48643,
	48644,
	48645,
	48646,
	48647,
	48648,
	48649,
	48650,
	48651,
	48652,
	48653,
	48654,
	48655,
	48656,
	48657,
	48658,
	48659,
	48660,
	48661,
	48662,
	48663,
	48664,
	48665,
	48666,
	48667,
	48668,
	48669,
	48670,
	48671,
	48672,
	48673,
	48674,
	48675,
	48676,
	48677,
	48678,
	48679,
	48680,
	48681,
	48682,
	48683,
	48684,
	48685,
	48686,
	48687,
	48688,
	48689,
	48690,
	48691,
	48692,
	48693,
	48694,
	48695,
	48696,
	48697,
	48698,
	48699,
	48700,
	48701,
	48702,
	48703,
	48704,
	48705,
	48706,
	48707,
	48708,
	48709,
	48710,
	48711,
	48712,
	48713,
	48714,
	48715,
	48716,
	48717,
	48718,
	48719,
	48720,
	48721,
	48722,
	48723,
	48724,
	48725,
	48726,
	48727,
	48728,
	48729,
	48730,
	48731,
	48732,
	48733,
	48734,
	48735,
	48736,
	48737,
	48738,
	48739,
	48740,
	48741,
	48742,
	48743,
	48744,
	48745,
	48746,
	48747,
	48748,
	48749,
	48750,
	48751,
	48752,
	48753,
	48754,
	48755,
	48756,
	48757,
	48758,
	48759,
	48760,
	48761,
	48762,
	48763,
	48764,
	48765,
	48766,
	48767,
	48768,
	48769,
	48770,
	48771,
	48772,
	48773,
	48774,
	48775,
	48776,
	48777,
	48778,
	48779,
	48780,
	48781,
	48782,
	48783,
	48784,
	48785,
	48786,
	48787,
	48788,
	48789,
	48790,
	48791,
	48792,
	48793,
	48794,
	48795,
	48796,
	48797,
	48798,
	48799,
	48800,
	48801,
	48802,
	48803,
	48804,
	48805,
	48806,
	48807,
	48808,
	48809,
	48810,
	48811,
	48812,
	48813,
	48814,
	48815,
	48816,
	48817,
	48818,
	48819,
	48820,
	48821,
	48822,
	48823,
	48824,
	48825,
	48826,
	48827,
	48828,
	48829,
	48830,
	48831,
	48832,
	48833,
	48834,
	48835,
	48836,
	48837,
	48838,
	48839,
	48840,
	48841,
	48842,
	48843,
	48844,
	48845,
	48846,
	48847,
	48848,
	48849,
	48850,
	48851,
	48852,
	48853,
	48854,
	48855,
	48856,
	48857,
	48858,
	48859,
	48860,
	48861,
	48862,
	48863,
	48864,
	48865,
	48866,
	48867,
	48868,
	48869,
	48870,
	48871,
	48872,
	48873,
	48874,
	48875,
	48876,
	48877,
	48878,
	48879,
	48880,
	48881,
	48882,
	48883,
	48884,
	48885,
	48886,
	48887,
	48888,
	48889,
	48890,
	48891,
	48892,
	48893,
	48894,
	48895,
	48896,
	48897,
	48898,
	48899,
	48900,
	48901,
	48902,
	48903,
	48904,
	48905,
	48906,
	48907,
	48908,
	48909,
	48910,
	48911,
	48912,
	48913,
	48914,
	48915,
	48916,
	48917,
	48918,
	48919,
	48920,
	48921,
	48922,
	48923,
	48924,
	48925,
	48926,
	48927,
	48928,
	48929,
	48930,
	48931,
	48932,
	48933,
	48934,
	48935,
	48936,
	48937,
	48938,
	48939,
	48940,
	48941,
	48942,
	48943,
	48944,
	48945,
	48946,
	48947,
	48948,
	48949,
	48950,
	48951,
	48952,
	48953,
	48954,
	48955,
	48956,
	48957,
	48958,
	48959,
	48960,
	48961,
	48962,
	48963,
	48964,
	48965,
	48966,
	48967,
	48968,
	48969,
	48970,
	48971,
	48972,
	48973,
	48974,
	48975,
	48976,
	48977,
	48978,
	48979,
	48980,
	48981,
	48982,
	48983,
	48984,
	48985,
	48986,
	48987,
	48988,
	48989,
	48990,
	48991,
	48992,
	48993,
	48994,
	48995,
	48996,
	48997,
	48998,
	48999,
	49000,
	49001,
	49002,
	49003,
	49004,
	49005,
	49006,
	49007,
	49008,
	49009,
	49010,
	49011,
	49012,
	49013,
	49014,
	49015,
	49016,
	49017,
	49018,
	49019,
	49020,
	49021,
	49022,
	49023,
	49024,
	49025,
	49026,
	49027,
	49028,
	49029,
	49030,
	49031,
	49032,
	49033,
	49034,
	49035,
	49036,
	49037,
	49038,
	49039,
	49040,
	49041,
	49042,
	49043,
	49044,
	49045,
	49046,
	49047,
	49048,
	49049,
	49050,
	49051,
	49052,
	49053,
	49054,
	49055,
	49056,
	49057,
	49058,
	49059,
	49060,
	49061,
	49062,
	49063,
	49064,
	49065,
	49066,
	49067,
	49068,
	49069,
	49070,
	49071,
	49072,
	49073,
	49074,
	49075,
	49076,
	49077,
	49078,
	49079,
	49080,
	49081,
	49082,
	49083,
	49084,
	49085,
	49086,
	49087,
	49088,
	49089,
	49090,
	49091,
	49092,
	49093,
	49094,
	49095,
	49096,
	49097,
	49098,
	49099,
	49100,
	49101,
	49102,
	49103,
	49104,
	49105,
	49106,
	49107,
	49108,
	49109,
	49110,
	49111,
	49112,
	49113,
	49114,
	49115,
	49116,
	49117,
	49118,
	49119,
	49120,
	49121,
	49122,
	49123,
	49124,
	49125,
	49126,
	49127,
	49128,
	49129,
	49130,
	49131,
	49132,
	49133,
	49134,
	49135,
	49136,
	49137,
	49138,
	49139,
	49140,
	49141,
	49142,
	49143,
	49144,
	49145,
	49146,
	49147,
	49148,
	49149,
	49150,
	49151,
	49152,
	49153,
	49154,
	49155,
	49156,
	49157,
	49158,
	49159,
	49160,
	49161,
	49162,
	49163,
	49164,
	49165,
	49166,
	49167,
	49168,
	49169,
	49170,
	49171,
	49172,
	49173,
	49174,
	49175,
	49176,
	49177,
	49178,
	49179,
	49180,
	49181,
	49182,
	49183,
	49184,
	49185,
	49186,
	49187,
	49188,
	49189,
	49190,
	49191,
	49192,
	49193,
	49194,
	49195,
	49196,
	49197,
	49198,
	49199,
	49200,
	49201,
	49202,
	49203,
	49204,
	49205,
	49206,
	49207,
	49208,
	49209,
	49210,
	49211,
	49212,
	49213,
	49214,
	49215,
	49216,
	49217,
	49218,
	49219,
	49220,
	49221,
	49222,
	49223,
	49224,
	49225,
	49226,
	49227,
	49228,
	49229,
	49230,
	49231,
	49232,
	49233,
	49234,
	49235,
	49236,
	49237,
	49238,
	49239,
	49240,
	49241,
	49242,
	49243,
	49244,
	49245,
	49246,
	49247,
	49248,
	49249,
	49250,
	49251,
	49252,
	49253,
	49254,
	49255,
	49256,
	49257,
	49258,
	49259,
	49260,
	49261,
	49262,
	49263,
	49264,
	49265,
	49266,
	49267,
	49268,
	49269,
	49270,
	49271,
	49272,
	49273,
	49274,
	49275,
	49276,
	49277,
	49278,
	49279,
	49280,
	49281,
	49282,
	49283,
	49284,
	49285,
	49286,
	49287,
	49288,
	49289,
	49290,
	49291,
	49292,
	49293,
	49294,
	49295,
	49296,
	49297,
	49298,
	49299,
	49300,
	49301,
	49302,
	49303,
	49304,
	49305,
	49306,
	49307,
	49308,
	49309,
	49310,
	49311,
	49312,
	49313,
	49314,
	49315,
	49316,
	49317,
	49318,
	49319,
	49320,
	49321,
	49322,
	49323,
	49324,
	49325,
	49326,
	49327,
	49328,
	49329,
	49330,
	49331,
	49332,
	49333,
	49334,
	49335,
	49336,
	49337,
	49338,
	49339,
	49340,
	49341,
	49342,
	49343,
	49344,
	49345,
	49346,
	49347,
	49348,
	49349,
	49350,
	49351,
	49352,
	49353,
	49354,
	49355,
	49356,
	49357,
	49358,
	49359,
	49360,
	49361,
	49362,
	49363,
	49364,
	49365,
	49366,
	49367,
	49368,
	49369,
	49370,
	49371,
	49372,
	49373,
	49374,
	49375,
	49376,
	49377,
	49378,
	49379,
	49380,
	49381,
	49382,
	49383,
	49384,
	49385,
	49386,
	49387,
	49388,
	49389,
	49390,
	49391,
	49392,
	49393,
	49394,
	49395,
	49396,
	49397,
	49398,
	49399,
	49400,
	49401,
	49402,
	49403,
	49404,
	49405,
	49406,
	49407,
	49408,
	49409,
	49410,
	49411,
	49412,
	49413,
	49414,
	49415,
	49416,
	49417,
	49418,
	49419,
	49420,
	49421,
	49422,
	49423,
	49424,
	49425,
	49426,
	49427,
	49428,
	49429,
	49430,
	49431,
	49432,
	49433,
	49434,
	49435,
	49436,
	49437,
	49438,
	49439,
	49440,
	49441,
	49442,
	49443,
	49444,
	49445,
	49446,
	49447,
	49448,
	49449,
	49450,
	49451,
	49452,
	49453,
	49454,
	49455,
	49456,
	49457,
	49458,
	49459,
	49460,
	49461,
	49462,
	49463,
	49464,
	49465,
	49466,
	49467,
	49468,
	49469,
	49470,
	49471,
	49472,
	49473,
	49474,
	49475,
	49476,
	49477,
	49478,
	49479,
	49480,
	49481,
	49482,
	49483,
	49484,
	49485,
	49486,
	49487,
	49488,
	49489,
	49490,
	49491,
	49492,
	49493,
	49494,
	49495,
	49496,
	49497,
	49498,
	49499,
	49500,
	49501,
	49502,
	49503,
	49504,
	49505,
	49506,
	49507,
	49508,
	49509,
	49510,
	49511,
	49512,
	49513,
	49514,
	49515,
	49516,
	49517,
	49518,
	49519,
	49520,
	49521,
	49522,
	49523,
	49524,
	49525,
	49526,
	49527,
	49528,
	49529,
	49530,
	49531,
	49532,
	49533,
	49534,
	49535,
	49536,
	49537,
	49538,
	49539,
	49540,
	49541,
	49542,
	49543,
	49544,
	49545,
	49546,
	49547,
	49548,
	49549,
	49550,
	49551,
	49552,
	49553,
	49554,
	49555,
	49556,
	49557,
	49558,
	49559,
	49560,
	49561,
	49562,
	49563,
	49564,
	49565,
	49566,
	49567,
	49568,
	49569,
	49570,
	49571,
	49572,
	49573,
	49574,
	49575,
	49576,
	49577,
	49578,
	49579,
	49580,
	49581,
	49582,
	49583,
	49584,
	49585,
	49586,
	49587,
	49588,
	49589,
	49590,
	49591,
	49592,
	49593,
	49594,
	49595,
	49596,
	49597,
	49598,
	49599,
	49600,
	49601,
	49602,
	49603,
	49604,
	49605,
	49606,
	49607,
	49608,
	49609,
	49610,
	49611,
	49612,
	49613,
	49614,
	49615,
	49616,
	49617,
	49618,
	49619,
	49620,
	49621,
	49622,
	49623,
	49624,
	49625,
	49626,
	49627,
	49628,
	49629,
	49630,
	49631,
	49632,
	49633,
	49634,
	49635,
	49636,
	49637,
	49638,
	49639,
	49640,
	49641,
	49642,
	49643,
	49644,
	49645,
	49646,
	49647,
	49648,
	49649,
	49650,
	49651,
	49652,
	49653,
	49654,
	49655,
	49656,
	49657,
	49658,
	49659,
	49660,
	49661,
	49662,
	49663,
	49664,
	49665,
	49666,
	49667,
	49668,
	49669,
	49670,
	49671,
	49672,
	49673,
	49674,
	49675,
	49676,
	49677,
	49678,
	49679,
	49680,
	49681,
	49682,
	49683,
	49684,
	49685,
	49686,
	49687,
	49688,
	49689,
	49690,
	49691,
	49692,
	49693,
	49694,
	49695,
	49696,
	49697,
	49698,
	49699,
	49700,
	49701,
	49702,
	49703,
	49704,
	49705,
	49706,
	49707,
	49708,
	49709,
	49710,
	49711,
	49712,
	49713,
	49714,
	49715,
	49716,
	49717,
	49718,
	49719,
	49720,
	49721,
	49722,
	49723,
	49724,
	49725,
	49726,
	49727,
	49728,
	49729,
	49730,
	49731,
	49732,
	49733,
	49734,
	49735,
	49736,
	49737,
	49738,
	49739,
	49740,
	49741,
	49742,
	49743,
	49744,
	49745,
	49746,
	49747,
	49748,
	49749,
	49750,
	49751,
	49752,
	49753,
	49754,
	49755,
	49756,
	49757,
	49758,
	49759,
	49760,
	49761,
	49762,
	49763,
	49764,
	49765,
	49766,
	49767,
	49768,
	49769,
	49770,
	49771,
	49772,
	49773,
	49774,
	49775,
	49776,
	49777,
	49778,
	49779,
	49780,
	49781,
	49782,
	49783,
	49784,
	49785,
	49786,
	49787,
	49788,
	49789,
	49790,
	49791,
	49792,
	49793,
	49794,
	49795,
	49796,
	49797,
	49798,
	49799,
	49800,
	49801,
	49802,
	49803,
	49804,
	49805,
	49806,
	49807,
	49808,
	49809,
	49810,
	49811,
	49812,
	49813,
	49814,
	49815,
	49816,
	49817,
	49818,
	49819,
	49820,
	49821,
	49822,
	49823,
	49824,
	49825,
	49826,
	49827,
	49828,
	49829,
	49830,
	49831,
	49832,
	49833,
	49834,
	49835,
	49836,
	49837,
	49838,
	49839,
	49840,
	49841,
	49842,
	49843,
	49844,
	49845,
	49846,
	49847,
	49848,
	49849,
	49850,
	49851,
	49852,
	49853,
	49854,
	49855,
	49856,
	49857,
	49858,
	49859,
	49860,
	49861,
	49862,
	49863,
	49864,
	49865,
	49866,
	49867,
	49868,
	49869,
	49870,
	49871,
	49872,
	49873,
	49874,
	49875,
	49876,
	49877,
	49878,
	49879,
	49880,
	49881,
	49882,
	49883,
	49884,
	49885,
	49886,
	49887,
	49888,
	49889,
	49890,
	49891,
	49892,
	49893,
	49894,
	49895,
	49896,
	49897,
	49898,
	49899,
	49900,
	49901,
	49902,
	49903,
	49904,
	49905,
	49906,
	49907,
	49908,
	49909,
	49910,
	49911,
	49912,
	49913,
	49914,
	49915,
	49916,
	49917,
	49918,
	49919,
	49920,
	49921,
	49922,
	49923,
	49924,
	49925,
	49926,
	49927,
	49928,
	49929,
	49930,
	49931,
	49932,
	49933,
	49934,
	49935,
	49936,
	49937,
	49938,
	49939,
	49940,
	49941,
	49942,
	49943,
	49944,
	49945,
	49946,
	49947,
	49948,
	49949,
	49950,
	49951,
	49952,
	49953,
	49954,
	49955,
	49956,
	49957,
	49958,
	49959,
	49960,
	49961,
	49962,
	49963,
	49964,
	49965,
	49966,
	49967,
	49968,
	49969,
	49970,
	49971,
	49972,
	49973,
	49974,
	49975,
	49976,
	49977,
	49978,
	49979,
	49980,
	49981,
	49982,
	49983,
	49984,
	49985,
	49986,
	49987,
	49988,
	49989,
	49990,
	49991,
	49992,
	49993,
	49994,
	49995,
	49996,
	49997,
	49998,
	49999,
	50000,
	50001,
	50002,
	50003,
	50004,
	50005,
	50006,
	50007,
	50008,
	50009,
	50010,
	50011,
	50012,
	50013,
	50014,
	50015,
	50016,
	50017,
	50018,
	50019,
	50020,
	50021,
	50022,
	50023,
	50024,
	50025,
	50026,
	50027,
	50028,
	50029,
	50030,
	50031,
	50032,
	50033,
	50034,
	50035,
	50036,
	50037,
	50038,
	50039,
	50040,
	50041,
	50042,
	50043,
	50044,
	50045,
	50046,
	50047,
	50048,
	50049,
	50050,
	50051,
	50052,
	50053,
	50054,
	50055,
	50056,
	50057,
	50058,
	50059,
	50060,
	50061,
	50062,
	50063,
	50064,
	50065,
	50066,
	50067,
	50068,
	50069,
	50070,
	50071,
	50072,
	50073,
	50074,
	50075,
	50076,
	50077,
	50078,
	50079,
	50080,
	50081,
	50082,
	50083,
	50084,
	50085,
	50086,
	50087,
	50088,
	50089,
	50090,
	50091,
	50092,
	50093,
	50094,
	50095,
	50096,
	50097,
	50098,
	50099,
	50100,
	50101,
	50102,
	50103,
	50104,
	50105,
	50106,
	50107,
	50108,
	50109,
	50110,
	50111,
	50112,
	50113,
	50114,
	50115,
	50116,
	50117,
	50118,
	50119,
	50120,
	50121,
	50122,
	50123,
	50124,
	50125,
	50126,
	50127,
	50128,
	50129,
	50130,
	50131,
	50132,
	50133,
	50134,
	50135,
	50136,
	50137,
	50138,
	50139,
	50140,
	50141,
	50142,
	50143,
	50144,
	50145,
	50146,
	50147,
	50148,
	50149,
	50150,
	50151,
	50152,
	50153,
	50154,
	50155,
	50156,
	50157,
	50158,
	50159,
	50160,
	50161,
	50162,
	50163,
	50164,
	50165,
	50166,
	50167,
	50168,
	50169,
	50170,
	50171,
	50172,
	50173,
	50174,
	50175,
	50176,
	50177,
	50178,
	50179,
	50180,
	50181,
	50182,
	50183,
	50184,
	50185,
	50186,
	50187,
	50188,
	50189,
	50190,
	50191,
	50192,
	50193,
	50194,
	50195,
	50196,
	50197,
	50198,
	50199,
	50200,
	50201,
	50202,
	50203,
	50204,
	50205,
	50206,
	50207,
	50208,
	50209,
	50210,
	50211,
	50212,
	50213,
	50214,
	50215,
	50216,
	50217,
	50218,
	50219,
	50220,
	50221,
	50222,
	50223,
	50224,
	50225,
	50226,
	50227,
	50228,
	50229,
	50230,
	50231,
	50232,
	50233,
	50234,
	50235,
	50236,
	50237,
	50238,
	50239,
	50240,
	50241,
	50242,
	50243,
	50244,
	50245,
	50246,
	50247,
	50248,
	50249,
	50250,
	50251,
	50252,
	50253,
	50254,
	50255,
	50256,
	50257,
	50258,
	50259,
	50260,
	50261,
	50262,
	50263,
	50264,
	50265,
	50266,
	50267,
	50268,
	50269,
	50270,
	50271,
	50272,
	50273,
	50274,
	50275,
	50276,
	50277,
	50278,
	50279,
	50280,
	50281,
	50282,
	50283,
	50284,
	50285,
	50286,
	50287,
	50288,
	50289,
	50290,
	50291,
	50292,
	50293,
	50294,
	50295,
	50296,
	50297,
	50298,
	50299,
	50300,
	50301,
	50302,
	50303,
	50304,
	50305,
	50306,
	50307,
	50308,
	50309,
	50310,
	50311,
	50312,
	50313,
	50314,
	50315,
	50316,
	50317,
	50318,
	50319,
	50320,
	50321,
	50322,
	50323,
	50324,
	50325,
	50326,
	50327,
	50328,
	50329,
	50330,
	50331,
	50332,
	50333,
	50334,
	50335,
	50336,
	50337,
	50338,
	50339,
	50340,
	50341,
	50342,
	50343,
	50344,
	50345,
	50346,
	50347,
	50348,
	50349,
	50350,
	50351,
	50352,
	50353,
	50354,
	50355,
	50356,
	50357,
	50358,
	50359,
	50360,
	50361,
	50362,
	50363,
	50364,
	50365,
	50366,
	50367,
	50368,
	50369,
	50370,
	50371,
	50372,
	50373,
	50374,
	50375,
	50376,
	50377,
	50378,
	50379,
	50380,
	50381,
	50382,
	50383,
	50384,
	50385,
	50386,
	50387,
	50388,
	50389,
	50390,
	50391,
	50392,
	50393,
	50394,
	50395,
	50396,
	50397,
	50398,
	50399,
	50400,
	50401,
	50402,
	50403,
	50404,
	50405,
	50406,
	50407,
	50408,
	50409,
	50410,
	50411,
	50412,
	50413,
	50414,
	50415,
	50416,
	50417,
	50418,
	50419,
	50420,
	50421,
	50422,
	50423,
	50424,
	50425,
	50426,
	50427,
	50428,
	50429,
	50430,
	50431,
	50432,
	50433,
	50434,
	50435,
	50436,
	50437,
	50438,
	50439,
	50440,
	50441,
	50442,
	50443,
	50444,
	50445,
	50446,
	50447,
	50448,
	50449,
	50450,
	50451,
	50452,
	50453,
	50454,
	50455,
	50456,
	50457,
	50458,
	50459,
	50460,
	50461,
	50462,
	50463,
	50464,
	50465,
	50466,
	50467,
	50468,
	50469,
	50470,
	50471,
	50472,
	50473,
	50474,
	50475,
	50476,
	50477,
	50478,
	50479,
	50480,
	50481,
	50482,
	50483,
	50484,
	50485,
	50486,
	50487,
	50488,
	50489,
	50490,
	50491,
	50492,
	50493,
	50494,
	50495,
	50496,
	50497,
	50498,
	50499,
	50500,
	50501,
	50502,
	50503,
	50504,
	50505,
	50506,
	50507,
	50508,
	50509,
	50510,
	50511,
	50512,
	50513,
	50514,
	50515,
	50516,
	50517,
	50518,
	50519,
	50520,
	50521,
	50522,
	50523,
	50524,
	50525,
	50526,
	50527,
	50528,
	50529,
	50530,
	50531,
	50532,
	50533,
	50534,
	50535,
	50536,
	50537,
	50538,
	50539,
	50540,
	50541,
	50542,
	50543,
	50544,
	50545,
	50546,
	50547,
	50548,
	50549,
	50550,
	50551,
	50552,
	50553,
	50554,
	50555,
	50556,
	50557,
	50558,
	50559,
	50560,
	50561,
	50562,
	50563,
	50564,
	50565,
	50566,
	50567,
	50568,
	50569,
	50570,
	50571,
	50572,
	50573,
	50574,
	50575,
	50576,
	50577,
	50578,
	50579,
	50580,
	50581,
	50582,
	50583,
	50584,
	50585,
	50586,
	50587,
	50588,
	50589,
	50590,
	50591,
	50592,
	50593,
	50594,
	50595,
	50596,
	50597,
	50598,
	50599,
	50600,
	50601,
	50602,
	50603,
	50604,
	50605,
	50606,
	50607,
	50608,
	50609,
	50610,
	50611,
	50612,
	50613,
	50614,
	50615,
	50616,
	50617,
	50618,
	50619,
	50620,
	50621,
	50622,
	50623,
	50624,
	50625,
	50626,
	50627,
	50628,
	50629,
	50630,
	50631,
	50632,
	50633,
	50634,
	50635,
	50636,
	50637,
	50638,
	50639,
	50640,
	50641,
	50642,
	50643,
	50644,
	50645,
	50646,
	50647,
	50648,
	50649,
	50650,
	50651,
	50652,
	50653,
	50654,
	50655,
	50656,
	50657,
	50658,
	50659,
	50660,
	50661,
	50662,
	50663,
	50664,
	50665,
	50666,
	50667,
	50668,
	50669,
	50670,
	50671,
	50672,
	50673,
	50674,
	50675,
	50676,
	50677,
	50678,
	50679,
	50680,
	50681,
	50682,
	50683,
	50684,
	50685,
	50686,
	50687,
	50688,
	50689,
	50690,
	50691,
	50692,
	50693,
	50694,
	50695,
	50696,
	50697,
	50698,
	50699,
	50700,
	50701,
	50702,
	50703,
	50704,
	50705,
	50706,
	50707,
	50708,
	50709,
	50710,
	50711,
	50712,
	50713,
	50714,
	50715,
	50716,
	50717,
	50718,
	50719,
	50720,
	50721,
	50722,
	50723,
	50724,
	50725,
	50726,
	50727,
	50728,
	50729,
	50730,
	50731,
	50732,
	50733,
	50734,
	50735,
	50736,
	50737,
	50738,
	50739,
	50740,
	50741,
	50742,
	50743,
	50744,
	50745,
	50746,
	50747,
	50748,
	50749,
	50750,
	50751,
	50752,
	50753,
	50754,
	50755,
	50756,
	50757,
	50758,
	50759,
	50760,
	50761,
	50762,
	50763,
	50764,
	50765,
	50766,
	50767,
	50768,
	50769,
	50770,
	50771,
	50772,
	50773,
	50774,
	50775,
	50776,
	50777,
	50778,
	50779,
	50780,
	50781,
	50782,
	50783,
	50784,
	50785,
	50786,
	50787,
	50788,
	50789,
	50790,
	50791,
	50792,
	50793,
	50794,
	50795,
	50796,
	50797,
	50798,
	50799,
	50800,
	50801,
	50802,
	50803,
	50804,
	50805,
	50806,
	50807,
	50808,
	50809,
	50810,
	50811,
	50812,
	50813,
	50814,
	50815,
	50816,
	50817,
	50818,
	50819,
	50820,
	50821,
	50822,
	50823,
	50824,
	50825,
	50826,
	50827,
	50828,
	50829,
	50830,
	50831,
	50832,
	50833,
	50834,
	50835,
	50836,
	50837,
	50838,
	50839,
	50840,
	50841,
	50842,
	50843,
	50844,
	50845,
	50846,
	50847,
	50848,
	50849,
	50850,
	50851,
	50852,
	50853,
	50854,
	50855,
	50856,
	50857,
	50858,
	50859,
	50860,
	50861,
	50862,
	50863,
	50864,
	50865,
	50866,
	50867,
	50868,
	50869,
	50870,
	50871,
	50872,
	50873,
	50874,
	50875,
	50876,
	50877,
	50878,
	50879,
	50880,
	50881,
	50882,
	50883,
	50884,
	50885,
	50886,
	50887,
	50888,
	50889,
	50890,
	50891,
	50892,
	50893,
	50894,
	50895,
	50896,
	50897,
	50898,
	50899,
	50900,
	50901,
	50902,
	50903,
	50904,
	50905,
	50906,
	50907,
	50908,
	50909,
	50910,
	50911,
	50912,
	50913,
	50914,
	50915,
	50916,
	50917,
	50918,
	50919,
	50920,
	50921,
	50922,
	50923,
	50924,
	50925,
	50926,
	50927,
	50928,
	50929,
	50930,
	50931,
	50932,
	50933,
	50934,
	50935,
	50936,
	50937,
	50938,
	50939,
	50940,
	50941,
	50942,
	50943,
	50944,
	50945,
	50946,
	50947,
	50948,
	50949,
	50950,
	50951,
	50952,
	50953,
	50954,
	50955,
	50956,
	50957,
	50958,
	50959,
	50960,
	50961,
	50962,
	50963,
	50964,
	50965,
	50966,
	50967,
	50968,
	50969,
	50970,
	50971,
	50972,
	50973,
	50974,
	50975,
	50976,
	50977,
	50978,
	50979,
	50980,
	50981,
	50982,
	50983,
	50984,
	50985,
	50986,
	50987,
	50988,
	50989,
	50990,
	50991,
	50992,
	50993,
	50994,
	50995,
	50996,
	50997,
	50998,
	50999,
	51000,
	51001,
	51002,
	51003,
	51004,
	51005,
	51006,
	51007,
	51008,
	51009,
	51010,
	51011,
	51012,
	51013,
	51014,
	51015,
	51016,
	51017,
	51018,
	51019,
	51020,
	51021,
	51022,
	51023,
	51024,
	51025,
	51026,
	51027,
	51028,
	51029,
	51030,
	51031,
	51032,
	51033,
	51034,
	51035,
	51036,
	51037,
	51038,
	51039,
	51040,
	51041,
	51042,
	51043,
	51044,
	51045,
	51046,
	51047,
	51048,
	51049,
	51050,
	51051,
	51052,
	51053,
	51054,
	51055,
	51056,
	51057,
	51058,
	51059,
	51060,
	51061,
	51062,
	51063,
	51064,
	51065,
	51066,
	51067,
	51068,
	51069,
	51070,
	51071,
	51072,
	51073,
	51074,
	51075,
	51076,
	51077,
	51078,
	51079,
	51080,
	51081,
	51082,
	51083,
	51084,
	51085,
	51086,
	51087,
	51088,
	51089,
	51090,
	51091,
	51092,
	51093,
	51094,
	51095,
	51096,
	51097,
	51098,
	51099,
	51100,
	51101,
	51102,
	51103,
	51104,
	51105,
	51106,
	51107,
	51108,
	51109,
	51110,
	51111,
	51112,
	51113,
	51114,
	51115,
	51116,
	51117,
	51118,
	51119,
	51120,
	51121,
	51122,
	51123,
	51124,
	51125,
	51126,
	51127,
	51128,
	51129,
	51130,
	51131,
	51132,
	51133,
	51134,
	51135,
	51136,
	51137,
	51138,
	51139,
	51140,
	51141,
	51142,
	51143,
	51144,
	51145,
	51146,
	51147,
	51148,
	51149,
	51150,
	51151,
	51152,
	51153,
	51154,
	51155,
	51156,
	51157,
	51158,
	51159,
	51160,
	51161,
	51162,
	51163,
	51164,
	51165,
	51166,
	51167,
	51168,
	51169,
	51170,
	51171,
	51172,
	51173,
	51174,
	51175,
	51176,
	51177,
	51178,
	51179,
	51180,
	51181,
	51182,
	51183,
	51184,
	51185,
	51186,
	51187,
	51188,
	51189,
	51190,
	51191,
	51192,
	51193,
	51194,
	51195,
	51196,
	51197,
	51198,
	51199,
	51200,
	51201,
	51202,
	51203,
	51204,
	51205,
	51206,
	51207,
	51208,
	51209,
	51210,
	51211,
	51212,
	51213,
	51214,
	51215,
	51216,
	51217,
	51218,
	51219,
	51220,
	51221,
	51222,
	51223,
	51224,
	51225,
	51226,
	51227,
	51228,
	51229,
	51230,
	51231,
	51232,
	51233,
	51234,
	51235,
	51236,
	51237,
	51238,
	51239,
	51240,
	51241,
	51242,
	51243,
	51244,
	51245,
	51246,
	51247,
	51248,
	51249,
	51250,
	51251,
	51252,
	51253,
	51254,
	51255,
	51256,
	51257,
	51258,
	51259,
	51260,
	51261,
	51262,
	51263,
	51264,
	51265,
	51266,
	51267,
	51268,
	51269,
	51270,
	51271,
	51272,
	51273,
	51274,
	51275,
	51276,
	51277,
	51278,
	51279,
	51280,
	51281,
	51282,
	51283,
	51284,
	51285,
	51286,
	51287,
	51288,
	51289,
	51290,
	51291,
	51292,
	51293,
	51294,
	51295,
	51296,
	51297,
	51298,
	51299,
	51300,
	51301,
	51302,
	51303,
	51304,
	51305,
	51306,
	51307,
	51308,
	51309,
	51310,
	51311,
	51312,
	51313,
	51314,
	51315,
	51316,
	51317,
	51318,
	51319,
	51320,
	51321,
	51322,
	51323,
	51324,
	51325,
	51326,
	51327,
	51328,
	51329,
	51330,
	51331,
	51332,
	51333,
	51334,
	51335,
	51336,
	51337,
	51338,
	51339,
	51340,
	51341,
	51342,
	51343,
	51344,
	51345,
	51346,
	51347,
	51348,
	51349,
	51350,
	51351,
	51352,
	51353,
	51354,
	51355,
	51356,
	51357,
	51358,
	51359,
	51360,
	51361,
	51362,
	51363,
	51364,
	51365,
	51366,
	51367,
	51368,
	51369,
	51370,
	51371,
	51372,
	51373,
	51374,
	51375,
	51376,
	51377,
	51378,
	51379,
	51380,
	51381,
	51382,
	51383,
	51384,
	51385,
	51386,
	51387,
	51388,
	51389,
	51390,
	51391,
	51392,
	51393,
	51394,
	51395,
	51396,
	51397,
	51398,
	51399,
	51400,
	51401,
	51402,
	51403,
	51404,
	51405,
	51406,
	51407,
	51408,
	51409,
	51410,
	51411,
	51412,
	51413,
	51414,
	51415,
	51416,
	51417,
	51418,
	51419,
	51420,
	51421,
	51422,
	51423,
	51424,
	51425,
	51426,
	51427,
	51428,
	51429,
	51430,
	51431,
	51432,
	51433,
	51434,
	51435,
	51436,
	51437,
	51438,
	51439,
	51440,
	51441,
	51442,
	51443,
	51444,
	51445,
	51446,
	51447,
	51448,
	51449,
	51450,
	51451,
	51452,
	51453,
	51454,
	51455,
	51456,
	51457,
	51458,
	51459,
	51460,
	51461,
	51462,
	51463,
	51464,
	51465,
	51466,
	51467,
	51468,
	51469,
	51470,
	51471,
	51472,
	51473,
	51474,
	51475,
	51476,
	51477,
	51478,
	51479,
	51480,
	51481,
	51482,
	51483,
	51484,
	51485,
	51486,
	51487,
	51488,
	51489,
	51490,
	51491,
	51492,
	51493,
	51494,
	51495,
	51496,
	51497,
	51498,
	51499,
	51500,
	51501,
	51502,
	51503,
	51504,
	51505,
	51506,
	51507,
	51508,
	51509,
	51510,
	51511,
	51512,
	51513,
	51514,
	51515,
	51516,
	51517,
	51518,
	51519,
	51520,
	51521,
	51522,
	51523,
	51524,
	51525,
	51526,
	51527,
	51528,
	51529,
	51530,
	51531,
	51532,
	51533,
	51534,
	51535,
	51536,
	51537,
	51538,
	51539,
	51540,
	51541,
	51542,
	51543,
	51544,
	51545,
	51546,
	51547,
	51548,
	51549,
	51550,
	51551,
	51552,
	51553,
	51554,
	51555,
	51556,
	51557,
	51558,
	51559,
	51560,
	51561,
	51562,
	51563,
	51564,
	51565,
	51566,
	51567,
	51568,
	51569,
	51570,
	51571,
	51572,
	51573,
	51574,
	51575,
	51576,
	51577,
	51578,
	51579,
	51580,
	51581,
	51582,
	51583,
	51584,
	51585,
	51586,
	51587,
	51588,
	51589,
	51590,
	51591,
	51592,
	51593,
	51594,
	51595,
	51596,
	51597,
	51598,
	51599,
	51600,
	51601,
	51602,
	51603,
	51604,
	51605,
	51606,
	51607,
	51608,
	51609,
	51610,
	51611,
	51612,
	51613,
	51614,
	51615,
	51616,
	51617,
	51618,
	51619,
	51620,
	51621,
	51622,
	51623,
	51624,
	51625,
	51626,
	51627,
	51628,
	51629,
	51630,
	51631,
	51632,
	51633,
	51634,
	51635,
	51636,
	51637,
	51638,
	51639,
	51640,
	51641,
	51642,
	51643,
	51644,
	51645,
	51646,
	51647,
	51648,
	51649,
	51650,
	51651,
	51652,
	51653,
	51654,
	51655,
	51656,
	51657,
	51658,
	51659,
	51660,
	51661,
	51662,
	51663,
	51664,
	51665,
	51666,
	51667,
	51668,
	51669,
	51670,
	51671,
	51672,
	51673,
	51674,
	51675,
	51676,
	51677,
	51678,
	51679,
	51680,
	51681,
	51682,
	51683,
	51684,
	51685,
	51686,
	51687,
	51688,
	51689,
	51690,
	51691,
	51692,
	51693,
	51694,
	51695,
	51696,
	51697,
	51698,
	51699,
	51700,
	51701,
	51702,
	51703,
	51704,
	51705,
	51706,
	51707,
	51708,
	51709,
	51710,
	51711,
	51712,
	51713,
	51714,
	51715,
	51716,
	51717,
	51718,
	51719,
	51720,
	51721,
	51722,
	51723,
	51724,
	51725,
	51726,
	51727,
	51728,
	51729,
	51730,
	51731,
	51732,
	51733,
	51734,
	51735,
	51736,
	51737,
	51738,
	51739,
	51740,
	51741,
	51742,
	51743,
	51744,
	51745,
	51746,
	51747,
	51748,
	51749,
	51750,
	51751,
	51752,
	51753,
	51754,
	51755,
	51756,
	51757,
	51758,
	51759,
	51760,
	51761,
	51762,
	51763,
	51764,
	51765,
	51766,
	51767,
	51768,
	51769,
	51770,
	51771,
	51772,
	51773,
	51774,
	51775,
	51776,
	51777,
	51778,
	51779,
	51780,
	51781,
	51782,
	51783,
	51784,
	51785,
	51786,
	51787,
	51788,
	51789,
	51790,
	51791,
	51792,
	51793,
	51794,
	51795,
	51796,
	51797,
	51798,
	51799,
	51800,
	51801,
	51802,
	51803,
	51804,
	51805,
	51806,
	51807,
	51808,
	51809,
	51810,
	51811,
	51812,
	51813,
	51814,
	51815,
	51816,
	51817,
	51818,
	51819,
	51820,
	51821,
	51822,
	51823,
	51824,
	51825,
	51826,
	51827,
	51828,
	51829,
	51830,
	51831,
	51832,
	51833,
	51834,
	51835,
	51836,
	51837,
	51838,
	51839,
	51840,
	51841,
	51842,
	51843,
	51844,
	51845,
	51846,
	51847,
	51848,
	51849,
	51850,
	51851,
	51852,
	51853,
	51854,
	51855,
	51856,
	51857,
	51858,
	51859,
	51860,
	51861,
	51862,
	51863,
	51864,
	51865,
	51866,
	51867,
	51868,
	51869,
	51870,
	51871,
	51872,
	51873,
	51874,
	51875,
	51876,
	51877,
	51878,
	51879,
	51880,
	51881,
	51882,
	51883,
	51884,
	51885,
	51886,
	51887,
	51888,
	51889,
	51890,
	51891,
	51892,
	51893,
	51894,
	51895,
	51896,
	51897,
	51898,
	51899,
	51900,
	51901,
	51902,
	51903,
	51904,
	51905,
	51906,
	51907,
	51908,
	51909,
	51910,
	51911,
	51912,
	51913,
	51914,
	51915,
	51916,
	51917,
	51918,
	51919,
	51920,
	51921,
	51922,
	51923,
	51924,
	51925,
	51926,
	51927,
	51928,
	51929,
	51930,
	51931,
	51932,
	51933,
	51934,
	51935,
	51936,
	51937,
	51938,
	51939,
	51940,
	51941,
	51942,
	51943,
	51944,
	51945,
	51946,
	51947,
	51948,
	51949,
	51950,
	51951,
	51952,
	51953,
	51954,
	51955,
	51956,
	51957,
	51958,
	51959,
	51960,
	51961,
	51962,
	51963,
	51964,
	51965,
	51966,
	51967,
	51968,
	51969,
	51970,
	51971,
	51972,
	51973,
	51974,
	51975,
	51976,
	51977,
	51978,
	51979,
	51980,
	51981,
	51982,
	51983,
	51984,
	51985,
	51986,
	51987,
	51988,
	51989,
	51990,
	51991,
	51992,
	51993,
	51994,
	51995,
	51996,
	51997,
	51998,
	51999,
	52000,
	52001,
	52002,
	52003,
	52004,
	52005,
	52006,
	52007,
	52008,
	52009,
	52010,
	52011,
	52012,
	52013,
	52014,
	52015,
	52016,
	52017,
	52018,
	52019,
	52020,
	52021,
	52022,
	52023,
	52024,
	52025,
	52026,
	52027,
	52028,
	52029,
	52030,
	52031,
	52032,
	52033,
	52034,
	52035,
	52036,
	52037,
	52038,
	52039,
	52040,
	52041,
	52042,
	52043,
	52044,
	52045,
	52046,
	52047,
	52048,
	52049,
	52050,
	52051,
	52052,
	52053,
	52054,
	52055,
	52056,
	52057,
	52058,
	52059,
	52060,
	52061,
	52062,
	52063,
	52064,
	52065,
	52066,
	52067,
	52068,
	52069,
	52070,
	52071,
	52072,
	52073,
	52074,
	52075,
	52076,
	52077,
	52078,
	52079,
	52080,
	52081,
	52082,
	52083,
	52084,
	52085,
	52086,
	52087,
	52088,
	52089,
	52090,
	52091,
	52092,
	52093,
	52094,
	52095,
	52096,
	52097,
	52098,
	52099,
	52100,
	52101,
	52102,
	52103,
	52104,
	52105,
	52106,
	52107,
	52108,
	52109,
	52110,
	52111,
	52112,
	52113,
	52114,
	52115,
	52116,
	52117,
	52118,
	52119,
	52120,
	52121,
	52122,
	52123,
	52124,
	52125,
	52126,
	52127,
	52128,
	52129,
	52130,
	52131,
	52132,
	52133,
	52134,
	52135,
	52136,
	52137,
	52138,
	52139,
	52140,
	52141,
	52142,
	52143,
	52144,
	52145,
	52146,
	52147,
	52148,
	52149,
	52150,
	52151,
	52152,
	52153,
	52154,
	52155,
	52156,
	52157,
	52158,
	52159,
	52160,
	52161,
	52162,
	52163,
	52164,
	52165,
	52166,
	52167,
	52168,
	52169,
	52170,
	52171,
	52172,
	52173,
	52174,
	52175,
	52176,
	52177,
	52178,
	52179,
	52180,
	52181,
	52182,
	52183,
	52184,
	52185,
	52186,
	52187,
	52188,
	52189,
	52190,
	52191,
	52192,
	52193,
	52194,
	52195,
	52196,
	52197,
	52198,
	52199,
	52200,
	52201,
	52202,
	52203,
	52204,
	52205,
	52206,
	52207,
	52208,
	52209,
	52210,
	52211,
	52212,
	52213,
	52214,
	52215,
	52216,
	52217,
	52218,
	52219,
	52220,
	52221,
	52222,
	52223,
	52224,
	52225,
	52226,
	52227,
	52228,
	52229,
	52230,
	52231,
	52232,
	52233,
	52234,
	52235,
	52236,
	52237,
	52238,
	52239,
	52240,
	52241,
	52242,
	52243,
	52244,
	52245,
	52246,
	52247,
	52248,
	52249,
	52250,
	52251,
	52252,
	52253,
	52254,
	52255,
	52256,
	52257,
	52258,
	52259,
	52260,
	52261,
	52262,
	52263,
	52264,
	52265,
	52266,
	52267,
	52268,
	52269,
	52270,
	52271,
	52272,
	52273,
	52274,
	52275,
	52276,
	52277,
	52278,
	52279,
	52280,
	52281,
	52282,
	52283,
	52284,
	52285,
	52286,
	52287,
	52288,
	52289,
	52290,
	52291,
	52292,
	52293,
	52294,
	52295,
	52296,
	52297,
	52298,
	52299,
	52300,
	52301,
	52302,
	52303,
	52304,
	52305,
	52306,
	52307,
	52308,
	52309,
	52310,
	52311,
	52312,
	52313,
	52314,
	52315,
	52316,
	52317,
	52318,
	52319,
	52320,
	52321,
	52322,
	52323,
	52324,
	52325,
	52326,
	52327,
	52328,
	52329,
	52330,
	52331,
	52332,
	52333,
	52334,
	52335,
	52336,
	52337,
	52338,
	52339,
	52340,
	52341,
	52342,
	52343,
	52344,
	52345,
	52346,
	52347,
	52348,
	52349,
	52350,
	52351,
	52352,
	52353,
	52354,
	52355,
	52356,
	52357,
	52358,
	52359,
	52360,
	52361,
	52362,
	52363,
	52364,
	52365,
	52366,
	52367,
	52368,
	52369,
	52370,
	52371,
	52372,
	52373,
	52374,
	52375,
	52376,
	52377,
	52378,
	52379,
	52380,
	52381,
	52382,
	52383,
	52384,
	52385,
	52386,
	52387,
	52388,
	52389,
	52390,
	52391,
	52392,
	52393,
	52394,
	52395,
	52396,
	52397,
	52398,
	52399,
	52400,
	52401,
	52402,
	52403,
	52404,
	52405,
	52406,
	52407,
	52408,
	52409,
	52410,
	52411,
	52412,
	52413,
	52414,
	52415,
	52416,
	52417,
	52418,
	52419,
	52420,
	52421,
	52422,
	52423,
	52424,
	52425,
	52426,
	52427,
	52428,
	52429,
	52430,
	52431,
	52432,
	52433,
	52434,
	52435,
	52436,
	52437,
	52438,
	52439,
	52440,
	52441,
	52442,
	52443,
	52444,
	52445,
	52446,
	52447,
	52448,
	52449,
	52450,
	52451,
	52452,
	52453,
	52454,
	52455,
	52456,
	52457,
	52458,
	52459,
	52460,
	52461,
	52462,
	52463,
	52464,
	52465,
	52466,
	52467,
	52468,
	52469,
	52470,
	52471,
	52472,
	52473,
	52474,
	52475,
	52476,
	52477,
	52478,
	52479,
	52480,
	52481,
	52482,
	52483,
	52484,
	52485,
	52486,
	52487,
	52488,
	52489,
	52490,
	52491,
	52492,
	52493,
	52494,
	52495,
	52496,
	52497,
	52498,
	52499,
	52500,
	52501,
	52502,
	52503,
	52504,
	52505,
	52506,
	52507,
	52508,
	52509,
	52510,
	52511,
	52512,
	52513,
	52514,
	52515,
	52516,
	52517,
	52518,
	52519,
	52520,
	52521,
	52522,
	52523,
	52524,
	52525,
	52526,
	52527,
	52528,
	52529,
	52530,
	52531,
	52532,
	52533,
	52534,
	52535,
	52536,
	52537,
	52538,
	52539,
	52540,
	52541,
	52542,
	52543,
	52544,
	52545,
	52546,
	52547,
	52548,
	52549,
	52550,
	52551,
	52552,
	52553,
	52554,
	52555,
	52556,
	52557,
	52558,
	52559,
	52560,
	52561,
	52562,
	52563,
	52564,
	52565,
	52566,
	52567,
	52568,
	52569,
	52570,
	52571,
	52572,
	52573,
	52574,
	52575,
	52576,
	52577,
	52578,
	52579,
	52580,
	52581,
	52582,
	52583,
	52584,
	52585,
	52586,
	52587,
	52588,
	52589,
	52590,
	52591,
	52592,
	52593,
	52594,
	52595,
	52596,
	52597,
	52598,
	52599,
	52600,
	52601,
	52602,
	52603,
	52604,
	52605,
	52606,
	52607,
	52608,
	52609,
	52610,
	52611,
	52612,
	52613,
	52614,
	52615,
	52616,
	52617,
	52618,
	52619,
	52620,
	52621,
	52622,
	52623,
	52624,
	52625,
	52626,
	52627,
	52628,
	52629,
	52630,
	52631,
	52632,
	52633,
	52634,
	52635,
	52636,
	52637,
	52638,
	52639,
	52640,
	52641,
	52642,
	52643,
	52644,
	52645,
	52646,
	52647,
	52648,
	52649,
	52650,
	52651,
	52652,
	52653,
	52654,
	52655,
	52656,
	52657,
	52658,
	52659,
	52660,
	52661,
	52662,
	52663,
	52664,
	52665,
	52666,
	52667,
	52668,
	52669,
	52670,
	52671,
	52672,
	52673,
	52674,
	52675,
	52676,
	52677,
	52678,
	52679,
	52680,
	52681,
	52682,
	52683,
	52684,
	52685,
	52686,
	52687,
	52688,
	52689,
	52690,
	52691,
	52692,
	52693,
	52694,
	52695,
	52696,
	52697,
	52698,
	52699,
	52700,
	52701,
	52702,
	52703,
	52704,
	52705,
	52706,
	52707,
	52708,
	52709,
	52710,
	52711,
	52712,
	52713,
	52714,
	52715,
	52716,
	52717,
	52718,
	52719,
	52720,
	52721,
	52722,
	52723,
	52724,
	52725,
	52726,
	52727,
	52728,
	52729,
	52730,
	52731,
	52732,
	52733,
	52734,
	52735,
	52736,
	52737,
	52738,
	52739,
	52740,
	52741,
	52742,
	52743,
	52744,
	52745,
	52746,
	52747,
	52748,
	52749,
	52750,
	52751,
	52752,
	52753,
	52754,
	52755,
	52756,
	52757,
	52758,
	52759,
	52760,
	52761,
	52762,
	52763,
	52764,
	52765,
	52766,
	52767,
	52768,
	52769,
	52770,
	52771,
	52772,
	52773,
	52774,
	52775,
	52776,
	52777,
	52778,
	52779,
	52780,
	52781,
	52782,
	52783,
	52784,
	52785,
	52786,
	52787,
	52788,
	52789,
	52790,
	52791,
	52792,
	52793,
	52794,
	52795,
	52796,
	52797,
	52798,
	52799,
	52800,
	52801,
	52802,
	52803,
	52804,
	52805,
	52806,
	52807,
	52808,
	52809,
	52810,
	52811,
	52812,
	52813,
	52814,
	52815,
	52816,
	52817,
	52818,
	52819,
	52820,
	52821,
	52822,
	52823,
	52824,
	52825,
	52826,
	52827,
	52828,
	52829,
	52830,
	52831,
	52832,
	52833,
	52834,
	52835,
	52836,
	52837,
	52838,
	52839,
	52840,
	52841,
	52842,
	52843,
	52844,
	52845,
	52846,
	52847,
	52848,
	52849,
	52850,
	52851,
	52852,
	52853,
	52854,
	52855,
	52856,
	52857,
	52858,
	52859,
	52860,
	52861,
	52862,
	52863,
	52864,
	52865,
	52866,
	52867,
	52868,
	52869,
	52870,
	52871,
	52872,
	52873,
	52874,
	52875,
	52876,
	52877,
	52878,
	52879,
	52880,
	52881,
	52882,
	52883,
	52884,
	52885,
	52886,
	52887,
	52888,
	52889,
	52890,
	52891,
	52892,
	52893,
	52894,
	52895,
	52896,
	52897,
	52898,
	52899,
	52900,
	52901,
	52902,
	52903,
	52904,
	52905,
	52906,
	52907,
	52908,
	52909,
	52910,
	52911,
	52912,
	52913,
	52914,
	52915,
	52916,
	52917,
	52918,
	52919,
	52920,
	52921,
	52922,
	52923,
	52924,
	52925,
	52926,
	52927,
	52928,
	52929,
	52930,
	52931,
	52932,
	52933,
	52934,
	52935,
	52936,
	52937,
	52938,
	52939,
	52940,
	52941,
	52942,
	52943,
	52944,
	52945,
	52946,
	52947,
	52948,
	52949,
	52950,
	52951,
	52952,
	52953,
	52954,
	52955,
	52956,
	52957,
	52958,
	52959,
	52960,
	52961,
	52962,
	52963,
	52964,
	52965,
	52966,
	52967,
	52968,
	52969,
	52970,
	52971,
	52972,
	52973,
	52974,
	52975,
	52976,
	52977,
	52978,
	52979,
	52980,
	52981,
	52982,
	52983,
	52984,
	52985,
	52986,
	52987,
	52988,
	52989,
	52990,
	52991,
	52992,
	52993,
	52994,
	52995,
	52996,
	52997,
	52998,
	52999,
	53000,
	53001,
	53002,
	53003,
	53004,
	53005,
	53006,
	53007,
	53008,
	53009,
	53010,
	53011,
	53012,
	53013,
	53014,
	53015,
	53016,
	53017,
	53018,
	53019,
	53020,
	53021,
	53022,
	53023,
	53024,
	53025,
	53026,
	53027,
	53028,
	53029,
	53030,
	53031,
	53032,
	53033,
	53034,
	53035,
	53036,
	53037,
	53038,
	53039,
	53040,
	53041,
	53042,
	53043,
	53044,
	53045,
	53046,
	53047,
	53048,
	53049,
	53050,
	53051,
	53052,
	53053,
	53054,
	53055,
	53056,
	53057,
	53058,
	53059,
	53060,
	53061,
	53062,
	53063,
	53064,
	53065,
	53066,
	53067,
	53068,
	53069,
	53070,
	53071,
	53072,
	53073,
	53074,
	53075,
	53076,
	53077,
	53078,
	53079,
	53080,
	53081,
	53082,
	53083,
	53084,
	53085,
	53086,
	53087,
	53088,
	53089,
	53090,
	53091,
	53092,
	53093,
	53094,
	53095,
	53096,
	53097,
	53098,
	53099,
	53100,
	53101,
	53102,
	53103,
	53104,
	53105,
	53106,
	53107,
	53108,
	53109,
	53110,
	53111,
	53112,
	53113,
	53114,
	53115,
	53116,
	53117,
	53118,
	53119,
	53120,
	53121,
	53122,
	53123,
	53124,
	53125,
	53126,
	53127,
	53128,
	53129,
	53130,
	53131,
	53132,
	53133,
	53134,
	53135,
	53136,
	53137,
	53138,
	53139,
	53140,
	53141,
	53142,
	53143,
	53144,
	53145,
	53146,
	53147,
	53148,
	53149,
	53150,
	53151,
	53152,
	53153,
	53154,
	53155,
	53156,
	53157,
	53158,
	53159,
	53160,
	53161,
	53162,
	53163,
	53164,
	53165,
	53166,
	53167,
	53168,
	53169,
	53170,
	53171,
	53172,
	53173,
	53174,
	53175,
	53176,
	53177,
	53178,
	53179,
	53180,
	53181,
	53182,
	53183,
	53184,
	53185,
	53186,
	53187,
	53188,
	53189,
	53190,
	53191,
	53192,
	53193,
	53194,
	53195,
	53196,
	53197,
	53198,
	53199,
	53200,
	53201,
	53202,
	53203,
	53204,
	53205,
	53206,
	53207,
	53208,
	53209,
	53210,
	53211,
	53212,
	53213,
	53214,
	53215,
	53216,
	53217,
	53218,
	53219,
	53220,
	53221,
	53222,
	53223,
	53224,
	53225,
	53226,
	53227,
	53228,
	53229,
	53230,
	53231,
	53232,
	53233,
	53234,
	53235,
	53236,
	53237,
	53238,
	53239,
	53240,
	53241,
	53242,
	53243,
	53244,
	53245,
	53246,
	53247,
	53248,
	53249,
	53250,
	53251,
	53252,
	53253,
	53254,
	53255,
	53256,
	53257,
	53258,
	53259,
	53260,
	53261,
	53262,
	53263,
	53264,
	53265,
	53266,
	53267,
	53268,
	53269,
	53270,
	53271,
	53272,
	53273,
	53274,
	53275,
	53276,
	53277,
	53278,
	53279,
	53280,
	53281,
	53282,
	53283,
	53284,
	53285,
	53286,
	53287,
	53288,
	53289,
	53290,
	53291,
	53292,
	53293,
	53294,
	53295,
	53296,
	53297,
	53298,
	53299,
	53300,
	53301,
	53302,
	53303,
	53304,
	53305,
	53306,
	53307,
	53308,
	53309,
	53310,
	53311,
	53312,
	53313,
	53314,
	53315,
	53316,
	53317,
	53318,
	53319,
	53320,
	53321,
	53322,
	53323,
	53324,
	53325,
	53326,
	53327,
	53328,
	53329,
	53330,
	53331,
	53332,
	53333,
	53334,
	53335,
	53336,
	53337,
	53338,
	53339,
	53340,
	53341,
	53342,
	53343,
	53344,
	53345,
	53346,
	53347,
	53348,
	53349,
	53350,
	53351,
	53352,
	53353,
	53354,
	53355,
	53356,
	53357,
	53358,
	53359,
	53360,
	53361,
	53362,
	53363,
	53364,
	53365,
	53366,
	53367,
	53368,
	53369,
	53370,
	53371,
	53372,
	53373,
	53374,
	53375,
	53376,
	53377,
	53378,
	53379,
	53380,
	53381,
	53382,
	53383,
	53384,
	53385,
	53386,
	53387,
	53388,
	53389,
	53390,
	53391,
	53392,
	53393,
	53394,
	53395,
	53396,
	53397,
	53398,
	53399,
	53400,
	53401,
	53402,
	53403,
	53404,
	53405,
	53406,
	53407,
	53408,
	53409,
	53410,
	53411,
	53412,
	53413,
	53414,
	53415,
	53416,
	53417,
	53418,
	53419,
	53420,
	53421,
	53422,
	53423,
	53424,
	53425,
	53426,
	53427,
	53428,
	53429,
	53430,
	53431,
	53432,
	53433,
	53434,
	53435,
	53436,
	53437,
	53438,
	53439,
	53440,
	53441,
	53442,
	53443,
	53444,
	53445,
	53446,
	53447,
	53448,
	53449,
	53450,
	53451,
	53452,
	53453,
	53454,
	53455,
	53456,
	53457,
	53458,
	53459,
	53460,
	53461,
	53462,
	53463,
	53464,
	53465,
	53466,
	53467,
	53468,
	53469,
	53470,
	53471,
	53472,
	53473,
	53474,
	53475,
	53476,
	53477,
	53478,
	53479,
	53480,
	53481,
	53482,
	53483,
	53484,
	53485,
	53486,
	53487,
	53488,
	53489,
	53490,
	53491,
	53492,
	53493,
	53494,
	53495,
	53496,
	53497,
	53498,
	53499,
	53500,
	53501,
	53502,
	53503,
	53504,
	53505,
	53506,
	53507,
	53508,
	53509,
	53510,
	53511,
	53512,
	53513,
	53514,
	53515,
	53516,
	53517,
	53518,
	53519,
	53520,
	53521,
	53522,
	53523,
	53524,
	53525,
	53526,
	53527,
	53528,
	53529,
	53530,
	53531,
	53532,
	53533,
	53534,
	53535,
	53536,
	53537,
	53538,
	53539,
	53540,
	53541,
	53542,
	53543,
	53544,
	53545,
	53546,
	53547,
	53548,
	53549,
	53550,
	53551,
	53552,
	53553,
	53554,
	53555,
	53556,
	53557,
	53558,
	53559,
	53560,
	53561,
	53562,
	53563,
	53564,
	53565,
	53566,
	53567,
	53568,
	53569,
	53570,
	53571,
	53572,
	53573,
	53574,
	53575,
	53576,
	53577,
	53578,
	53579,
	53580,
	53581,
	53582,
	53583,
	53584,
	53585,
	53586,
	53587,
	53588,
	53589,
	53590,
	53591,
	53592,
	53593,
	53594,
	53595,
	53596,
	53597,
	53598,
	53599,
	53600,
	53601,
	53602,
	53603,
	53604,
	53605,
	53606,
	53607,
	53608,
	53609,
	53610,
	53611,
	53612,
	53613,
	53614,
	53615,
	53616,
	53617,
	53618,
	53619,
	53620,
	53621,
	53622,
	53623,
	53624,
	53625,
	53626,
	53627,
	53628,
	53629,
	53630,
	53631,
	53632,
	53633,
	53634,
	53635,
	53636,
	53637,
	53638,
	53639,
	53640,
	53641,
	53642,
	53643,
	53644,
	53645,
	53646,
	53647,
	53648,
	53649,
	53650,
	53651,
	53652,
	53653,
	53654,
	53655,
	53656,
	53657,
	53658,
	53659,
	53660,
	53661,
	53662,
	53663,
	53664,
	53665,
	53666,
	53667,
	53668,
	53669,
	53670,
	53671,
	53672,
	53673,
	53674,
	53675,
	53676,
	53677,
	53678,
	53679,
	53680,
	53681,
	53682,
	53683,
	53684,
	53685,
	53686,
	53687,
	53688,
	53689,
	53690,
	53691,
	53692,
	53693,
	53694,
	53695,
	53696,
	53697,
	53698,
	53699,
	53700,
	53701,
	53702,
	53703,
	53704,
	53705,
	53706,
	53707,
	53708,
	53709,
	53710,
	53711,
	53712,
	53713,
	53714,
	53715,
	53716,
	53717,
	53718,
	53719,
	53720,
	53721,
	53722,
	53723,
	53724,
	53725,
	53726,
	53727,
	53728,
	53729,
	53730,
	53731,
	53732,
	53733,
	53734,
	53735,
	53736,
	53737,
	53738,
	53739,
	53740,
	53741,
	53742,
	53743,
	53744,
	53745,
	53746,
	53747,
	53748,
	53749,
	53750,
	53751,
	53752,
	53753,
	53754,
	53755,
	53756,
	53757,
	53758,
	53759,
	53760,
	53761,
	53762,
	53763,
	53764,
	53765,
	53766,
	53767,
	53768,
	53769,
	53770,
	53771,
	53772,
	53773,
	53774,
	53775,
	53776,
	53777,
	53778,
	53779,
	53780,
	53781,
	53782,
	53783,
	53784,
	53785,
	53786,
	53787,
	53788,
	53789,
	53790,
	53791,
	53792,
	53793,
	53794,
	53795,
	53796,
	53797,
	53798,
	53799,
	53800,
	53801,
	53802,
	53803,
	53804,
	53805,
	53806,
	53807,
	53808,
	53809,
	53810,
	53811,
	53812,
	53813,
	53814,
	53815,
	53816,
	53817,
	53818,
	53819,
	53820,
	53821,
	53822,
	53823,
	53824,
	53825,
	53826,
	53827,
	53828,
	53829,
	53830,
	53831,
	53832,
	53833,
	53834,
	53835,
	53836,
	53837,
	53838,
	53839,
	53840,
	53841,
	53842,
	53843,
	53844,
	53845,
	53846,
	53847,
	53848,
	53849,
	53850,
	53851,
	53852,
	53853,
	53854,
	53855,
	53856,
	53857,
	53858,
	53859,
	53860,
	53861,
	53862,
	53863,
	53864,
	53865,
	53866,
	53867,
	53868,
	53869,
	53870,
	53871,
	53872,
	53873,
	53874,
	53875,
	53876,
	53877,
	53878,
	53879,
	53880,
	53881,
	53882,
	53883,
	53884,
	53885,
	53886,
	53887,
	53888,
	53889,
	53890,
	53891,
	53892,
	53893,
	53894,
	53895,
	53896,
	53897,
	53898,
	53899,
	53900,
	53901,
	53902,
	53903,
	53904,
	53905,
	53906,
	53907,
	53908,
	53909,
	53910,
	53911,
	53912,
	53913,
	53914,
	53915,
	53916,
	53917,
	53918,
	53919,
	53920,
	53921,
	53922,
	53923,
	53924,
	53925,
	53926,
	53927,
	53928,
	53929,
	53930,
	53931,
	53932,
	53933,
	53934,
	53935,
	53936,
	53937,
	53938,
	53939,
	53940,
	53941,
	53942,
	53943,
	53944,
	53945,
	53946,
	53947,
	53948,
	53949,
	53950,
	53951,
	53952,
	53953,
	53954,
	53955,
	53956,
	53957,
	53958,
	53959,
	53960,
	53961,
	53962,
	53963,
	53964,
	53965,
	53966,
	53967,
	53968,
	53969,
	53970,
	53971,
	53972,
	53973,
	53974,
	53975,
	53976,
	53977,
	53978,
	53979,
	53980,
	53981,
	53982,
	53983,
	53984,
	53985,
	53986,
	53987,
	53988,
	53989,
	53990,
	53991,
	53992,
	53993,
	53994,
	53995,
	53996,
	53997,
	53998,
	53999,
	54000,
	54001,
	54002,
	54003,
	54004,
	54005,
	54006,
	54007,
	54008,
	54009,
	54010,
	54011,
	54012,
	54013,
	54014,
	54015,
	54016,
	54017,
	54018,
	54019,
	54020,
	54021,
	54022,
	54023,
	54024,
	54025,
	54026,
	54027,
	54028,
	54029,
	54030,
	54031,
	54032,
	54033,
	54034,
	54035,
	54036,
	54037,
	54038,
	54039,
	54040,
	54041,
	54042,
	54043,
	54044,
	54045,
	54046,
	54047,
	54048,
	54049,
	54050,
	54051,
	54052,
	54053,
	54054,
	54055,
	54056,
	54057,
	54058,
	54059,
	54060,
	54061,
	54062,
	54063,
	54064,
	54065,
	54066,
	54067,
	54068,
	54069,
	54070,
	54071,
	54072,
	54073,
	54074,
	54075,
	54076,
	54077,
	54078,
	54079,
	54080,
	54081,
	54082,
	54083,
	54084,
	54085,
	54086,
	54087,
	54088,
	54089,
	54090,
	54091,
	54092,
	54093,
	54094,
	54095,
	54096,
	54097,
	54098,
	54099,
	54100,
	54101,
	54102,
	54103,
	54104,
	54105,
	54106,
	54107,
	54108,
	54109,
	54110,
	54111,
	54112,
	54113,
	54114,
	54115,
	54116,
	54117,
	54118,
	54119,
	54120,
	54121,
	54122,
	54123,
	54124,
	54125,
	54126,
	54127,
	54128,
	54129,
	54130,
	54131,
	54132,
	54133,
	54134,
	54135,
	54136,
	54137,
	54138,
	54139,
	54140,
	54141,
	54142,
	54143,
	54144,
	54145,
	54146,
	54147,
	54148,
	54149,
	54150,
	54151,
	54152,
	54153,
	54154,
	54155,
	54156,
	54157,
	54158,
	54159,
	54160,
	54161,
	54162,
	54163,
	54164,
	54165,
	54166,
	54167,
	54168,
	54169,
	54170,
	54171,
	54172,
	54173,
	54174,
	54175,
	54176,
	54177,
	54178,
	54179,
	54180,
	54181,
	54182,
	54183,
	54184,
	54185,
	54186,
	54187,
	54188,
	54189,
	54190,
	54191,
	54192,
	54193,
	54194,
	54195,
	54196,
	54197,
	54198,
	54199,
	54200,
	54201,
	54202,
	54203,
	54204,
	54205,
	54206,
	54207,
	54208,
	54209,
	54210,
	54211,
	54212,
	54213,
	54214,
	54215,
	54216,
	54217,
	54218,
	54219,
	54220,
	54221,
	54222,
	54223,
	54224,
	54225,
	54226,
	54227,
	54228,
	54229,
	54230,
	54231,
	54232,
	54233,
	54234,
	54235,
	54236,
	54237,
	54238,
	54239,
	54240,
	54241,
	54242,
	54243,
	54244,
	54245,
	54246,
	54247,
	54248,
	54249,
	54250,
	54251,
	54252,
	54253,
	54254,
	54255,
	54256,
	54257,
	54258,
	54259,
	54260,
	54261,
	54262,
	54263,
	54264,
	54265,
	54266,
	54267,
	54268,
	54269,
	54270,
	54271,
	54272,
	54273,
	54274,
	54275,
	54276,
	54277,
	54278,
	54279,
	54280,
	54281,
	54282,
	54283,
	54284,
	54285,
	54286,
	54287,
	54288,
	54289,
	54290,
	54291,
	54292,
	54293,
	54294,
	54295,
	54296,
	54297,
	54298,
	54299,
	54300,
	54301,
	54302,
	54303,
	54304,
	54305,
	54306,
	54307,
	54308,
	54309,
	54310,
	54311,
	54312,
	54313,
	54314,
	54315,
	54316,
	54317,
	54318,
	54319,
	54320,
	54321,
	54322,
	54323,
	54324,
	54325,
	54326,
	54327,
	54328,
	54329,
	54330,
	54331,
	54332,
	54333,
	54334,
	54335,
	54336,
	54337,
	54338,
	54339,
	54340,
	54341,
	54342,
	54343,
	54344,
	54345,
	54346,
	54347,
	54348,
	54349,
	54350,
	54351,
	54352,
	54353,
	54354,
	54355,
	54356,
	54357,
	54358,
	54359,
	54360,
	54361,
	54362,
	54363,
	54364,
	54365,
	54366,
	54367,
	54368,
	54369,
	54370,
	54371,
	54372,
	54373,
	54374,
	54375,
	54376,
	54377,
	54378,
	54379,
	54380,
	54381,
	54382,
	54383,
	54384,
	54385,
	54386,
	54387,
	54388,
	54389,
	54390,
	54391,
	54392,
	54393,
	54394,
	54395,
	54396,
	54397,
	54398,
	54399,
	54400,
	54401,
	54402,
	54403,
	54404,
	54405,
	54406,
	54407,
	54408,
	54409,
	54410,
	54411,
	54412,
	54413,
	54414,
	54415,
	54416,
	54417,
	54418,
	54419,
	54420,
	54421,
	54422,
	54423,
	54424,
	54425,
	54426,
	54427,
	54428,
	54429,
	54430,
	54431,
	54432,
	54433,
	54434,
	54435,
	54436,
	54437,
	54438,
	54439,
	54440,
	54441,
	54442,
	54443,
	54444,
	54445,
	54446,
	54447,
	54448,
	54449,
	54450,
	54451,
	54452,
	54453,
	54454,
	54455,
	54456,
	54457,
	54458,
	54459,
	54460,
	54461,
	54462,
	54463,
	54464,
	54465,
	54466,
	54467,
	54468,
	54469,
	54470,
	54471,
	54472,
	54473,
	54474,
	54475,
	54476,
	54477,
	54478,
	54479,
	54480,
	54481,
	54482,
	54483,
	54484,
	54485,
	54486,
	54487,
	54488,
	54489,
	54490,
	54491,
	54492,
	54493,
	54494,
	54495,
	54496,
	54497,
	54498,
	54499,
	54500,
	54501,
	54502,
	54503,
	54504,
	54505,
	54506,
	54507,
	54508,
	54509,
	54510,
	54511,
	54512,
	54513,
	54514,
	54515,
	54516,
	54517,
	54518,
	54519,
	54520,
	54521,
	54522,
	54523,
	54524,
	54525,
	54526,
	54527,
	54528,
	54529,
	54530,
	54531,
	54532,
	54533,
	54534,
	54535,
	54536,
	54537,
	54538,
	54539,
	54540,
	54541,
	54542,
	54543,
	54544,
	54545,
	54546,
	54547,
	54548,
	54549,
	54550,
	54551,
	54552,
	54553,
	54554,
	54555,
	54556,
	54557,
	54558,
	54559,
	54560,
	54561,
	54562,
	54563,
	54564,
	54565,
	54566,
	54567,
	54568,
	54569,
	54570,
	54571,
	54572,
	54573,
	54574,
	54575,
	54576,
	54577,
	54578,
	54579,
	54580,
	54581,
	54582,
	54583,
	54584,
	54585,
	54586,
	54587,
	54588,
	54589,
	54590,
	54591,
	54592,
	54593,
	54594,
	54595,
	54596,
	54597,
	54598,
	54599,
	54600,
	54601,
	54602,
	54603,
	54604,
	54605,
	54606,
	54607,
	54608,
	54609,
	54610,
	54611,
	54612,
	54613,
	54614,
	54615,
	54616,
	54617,
	54618,
	54619,
	54620,
	54621,
	54622,
	54623,
	54624,
	54625,
	54626,
	54627,
	54628,
	54629,
	54630,
	54631,
	54632,
	54633,
	54634,
	54635,
	54636,
	54637,
	54638,
	54639,
	54640,
	54641,
	54642,
	54643,
	54644,
	54645,
	54646,
	54647,
	54648,
	54649,
	54650,
	54651,
	54652,
	54653,
	54654,
	54655,
	54656,
	54657,
	54658,
	54659,
	54660,
	54661,
	54662,
	54663,
	54664,
	54665,
	54666,
	54667,
	54668,
	54669,
	54670,
	54671,
	54672,
	54673,
	54674,
	54675,
	54676,
	54677,
	54678,
	54679,
	54680,
	54681,
	54682,
	54683,
	54684,
	54685,
	54686,
	54687,
	54688,
	54689,
	54690,
	54691,
	54692,
	54693,
	54694,
	54695,
	54696,
	54697,
	54698,
	54699,
	54700,
	54701,
	54702,
	54703,
	54704,
	54705,
	54706,
	54707,
	54708,
	54709,
	54710,
	54711,
	54712,
	54713,
	54714,
	54715,
	54716,
	54717,
	54718,
	54719,
	54720,
	54721,
	54722,
	54723,
	54724,
	54725,
	54726,
	54727,
	54728,
	54729,
	54730,
	54731,
	54732,
	54733,
	54734,
	54735,
	54736,
	54737,
	54738,
	54739,
	54740,
	54741,
	54742,
	54743,
	54744,
	54745,
	54746,
	54747,
	54748,
	54749,
	54750,
	54751,
	54752,
	54753,
	54754,
	54755,
	54756,
	54757,
	54758,
	54759,
	54760,
	54761,
	54762,
	54763,
	54764,
	54765,
	54766,
	54767,
	54768,
	54769,
	54770,
	54771,
	54772,
	54773,
	54774,
	54775,
	54776,
	54777,
	54778,
	54779,
	54780,
	54781,
	54782,
	54783,
	54784,
	54785,
	54786,
	54787,
	54788,
	54789,
	54790,
	54791,
	54792,
	54793,
	54794,
	54795,
	54796,
	54797,
	54798,
	54799,
	54800,
	54801,
	54802,
	54803,
	54804,
	54805,
	54806,
	54807,
	54808,
	54809,
	54810,
	54811,
	54812,
	54813,
	54814,
	54815,
	54816,
	54817,
	54818,
	54819,
	54820,
	54821,
	54822,
	54823,
	54824,
	54825,
	54826,
	54827,
	54828,
	54829,
	54830,
	54831,
	54832,
	54833,
	54834,
	54835,
	54836,
	54837,
	54838,
	54839,
	54840,
	54841,
	54842,
	54843,
	54844,
	54845,
	54846,
	54847,
	54848,
	54849,
	54850,
	54851,
	54852,
	54853,
	54854,
	54855,
	54856,
	54857,
	54858,
	54859,
	54860,
	54861,
	54862,
	54863,
	54864,
	54865,
	54866,
	54867,
	54868,
	54869,
	54870,
	54871,
	54872,
	54873,
	54874,
	54875,
	54876,
	54877,
	54878,
	54879,
	54880,
	54881,
	54882,
	54883,
	54884,
	54885,
	54886,
	54887,
	54888,
	54889,
	54890,
	54891,
	54892,
	54893,
	54894,
	54895,
	54896,
	54897,
	54898,
	54899,
	54900,
	54901,
	54902,
	54903,
	54904,
	54905,
	54906,
	54907,
	54908,
	54909,
	54910,
	54911,
	54912,
	54913,
	54914,
	54915,
	54916,
	54917,
	54918,
	54919,
	54920,
	54921,
	54922,
	54923,
	54924,
	54925,
	54926,
	54927,
	54928,
	54929,
	54930,
	54931,
	54932,
	54933,
	54934,
	54935,
	54936,
	54937,
	54938,
	54939,
	54940,
	54941,
	54942,
	54943,
	54944,
	54945,
	54946,
	54947,
	54948,
	54949,
	54950,
	54951,
	54952,
	54953,
	54954,
	54955,
	54956,
	54957,
	54958,
	54959,
	54960,
	54961,
	54962,
	54963,
	54964,
	54965,
	54966,
	54967,
	54968,
	54969,
	54970,
	54971,
	54972,
	54973,
	54974,
	54975,
	54976,
	54977,
	54978,
	54979,
	54980,
	54981,
	54982,
	54983,
	54984,
	54985,
	54986,
	54987,
	54988,
	54989,
	54990,
	54991,
	54992,
	54993,
	54994,
	54995,
	54996,
	54997,
	54998,
	54999,
	55000,
	55001,
	55002,
	55003,
	55004,
	55005,
	55006,
	55007,
	55008,
	55009,
	55010,
	55011,
	55012,
	55013,
	55014,
	55015,
	55016,
	55017,
	55018,
	55019,
	55020,
	55021,
	55022,
	55023,
	55024,
	55025,
	55026,
	55027,
	55028,
	55029,
	55030,
	55031,
	55032,
	55033,
	55034,
	55035,
	55036,
	55037,
	55038,
	55039,
	55040,
	55041,
	55042,
	55043,
	55044,
	55045,
	55046,
	55047,
	55048,
	55049,
	55050,
	55051,
	55052,
	55053,
	55054,
	55055,
	55056,
	55057,
	55058,
	55059,
	55060,
	55061,
	55062,
	55063,
	55064,
	55065,
	55066,
	55067,
	55068,
	55069,
	55070,
	55071,
	55072,
	55073,
	55074,
	55075,
	55076,
	55077,
	55078,
	55079,
	55080,
	55081,
	55082,
	55083,
	55084,
	55085,
	55086,
	55087,
	55088,
	55089,
	55090,
	55091,
	55092,
	55093,
	55094,
	55095,
	55096,
	55097,
	55098,
	55099,
	55100,
	55101,
	55102,
	55103,
	55104,
	55105,
	55106,
	55107,
	55108,
	55109,
	55110,
	55111,
	55112,
	55113,
	55114,
	55115,
	55116,
	55117,
	55118,
	55119,
	55120,
	55121,
	55122,
	55123,
	55124,
	55125,
	55126,
	55127,
	55128,
	55129,
	55130,
	55131,
	55132,
	55133,
	55134,
	55135,
	55136,
	55137,
	55138,
	55139,
	55140,
	55141,
	55142,
	55143,
	55144,
	55145,
	55146,
	55147,
	55148,
	55149,
	55150,
	55151,
	55152,
	55153,
	55154,
	55155,
	55156,
	55157,
	55158,
	55159,
	55160,
	55161,
	55162,
	55163,
	55164,
	55165,
	55166,
	55167,
	55168,
	55169,
	55170,
	55171,
	55172,
	55173,
	55174,
	55175,
	55176,
	55177,
	55178,
	55179,
	55180,
	55181,
	55182,
	55183,
	55184,
	55185,
	55186,
	55187,
	55188,
	55189,
	55190,
	55191,
	55192,
	55193,
	55194,
	55195,
	55196,
	55197,
	55198,
	55199,
	55200,
	55201,
	55202,
	55203,
	55216,
	55217,
	55218,
	55219,
	55220,
	55221,
	55222,
	55223,
	55224,
	55225,
	55226,
	55227,
	55228,
	55229,
	55230,
	55231,
	55232,
	55233,
	55234,
	55235,
	55236,
	55237,
	55238,
	55243,
	55244,
	55245,
	55246,
	55247,
	55248,
	55249,
	55250,
	55251,
	55252,
	55253,
	55254,
	55255,
	55256,
	55257,
	55258,
	55259,
	55260,
	55261,
	55262,
	55263,
	55264,
	55265,
	55266,
	55267,
	55268,
	55269,
	55270,
	55271,
	55272,
	55273,
	55274,
	55275,
	55276,
	55277,
	55278,
	55279,
	55280,
	55281,
	55282,
	55283,
	55284,
	55285,
	55286,
	55287,
	55288,
	55289,
	55290,
	55291,
	63744,
	63745,
	63746,
	63747,
	63748,
	63749,
	63750,
	63751,
	63752,
	63753,
	63754,
	63755,
	63756,
	63757,
	63758,
	63759,
	63760,
	63761,
	63762,
	63763,
	63764,
	63765,
	63766,
	63767,
	63768,
	63769,
	63770,
	63771,
	63772,
	63773,
	63774,
	63775,
	63776,
	63777,
	63778,
	63779,
	63780,
	63781,
	63782,
	63783,
	63784,
	63785,
	63786,
	63787,
	63788,
	63789,
	63790,
	63791,
	63792,
	63793,
	63794,
	63795,
	63796,
	63797,
	63798,
	63799,
	63800,
	63801,
	63802,
	63803,
	63804,
	63805,
	63806,
	63807,
	63808,
	63809,
	63810,
	63811,
	63812,
	63813,
	63814,
	63815,
	63816,
	63817,
	63818,
	63819,
	63820,
	63821,
	63822,
	63823,
	63824,
	63825,
	63826,
	63827,
	63828,
	63829,
	63830,
	63831,
	63832,
	63833,
	63834,
	63835,
	63836,
	63837,
	63838,
	63839,
	63840,
	63841,
	63842,
	63843,
	63844,
	63845,
	63846,
	63847,
	63848,
	63849,
	63850,
	63851,
	63852,
	63853,
	63854,
	63855,
	63856,
	63857,
	63858,
	63859,
	63860,
	63861,
	63862,
	63863,
	63864,
	63865,
	63866,
	63867,
	63868,
	63869,
	63870,
	63871,
	63872,
	63873,
	63874,
	63875,
	63876,
	63877,
	63878,
	63879,
	63880,
	63881,
	63882,
	63883,
	63884,
	63885,
	63886,
	63887,
	63888,
	63889,
	63890,
	63891,
	63892,
	63893,
	63894,
	63895,
	63896,
	63897,
	63898,
	63899,
	63900,
	63901,
	63902,
	63903,
	63904,
	63905,
	63906,
	63907,
	63908,
	63909,
	63910,
	63911,
	63912,
	63913,
	63914,
	63915,
	63916,
	63917,
	63918,
	63919,
	63920,
	63921,
	63922,
	63923,
	63924,
	63925,
	63926,
	63927,
	63928,
	63929,
	63930,
	63931,
	63932,
	63933,
	63934,
	63935,
	63936,
	63937,
	63938,
	63939,
	63940,
	63941,
	63942,
	63943,
	63944,
	63945,
	63946,
	63947,
	63948,
	63949,
	63950,
	63951,
	63952,
	63953,
	63954,
	63955,
	63956,
	63957,
	63958,
	63959,
	63960,
	63961,
	63962,
	63963,
	63964,
	63965,
	63966,
	63967,
	63968,
	63969,
	63970,
	63971,
	63972,
	63973,
	63974,
	63975,
	63976,
	63977,
	63978,
	63979,
	63980,
	63981,
	63982,
	63983,
	63984,
	63985,
	63986,
	63987,
	63988,
	63989,
	63990,
	63991,
	63992,
	63993,
	63994,
	63995,
	63996,
	63997,
	63998,
	63999,
	64000,
	64001,
	64002,
	64003,
	64004,
	64005,
	64006,
	64007,
	64008,
	64009,
	64010,
	64011,
	64012,
	64013,
	64014,
	64015,
	64016,
	64017,
	64018,
	64019,
	64020,
	64021,
	64022,
	64023,
	64024,
	64025,
	64026,
	64027,
	64028,
	64029,
	64030,
	64031,
	64032,
	64033,
	64034,
	64035,
	64036,
	64037,
	64038,
	64039,
	64040,
	64041,
	64042,
	64043,
	64044,
	64045,
	64046,
	64047,
	64048,
	64049,
	64050,
	64051,
	64052,
	64053,
	64054,
	64055,
	64056,
	64057,
	64058,
	64059,
	64060,
	64061,
	64062,
	64063,
	64064,
	64065,
	64066,
	64067,
	64068,
	64069,
	64070,
	64071,
	64072,
	64073,
	64074,
	64075,
	64076,
	64077,
	64078,
	64079,
	64080,
	64081,
	64082,
	64083,
	64084,
	64085,
	64086,
	64087,
	64088,
	64089,
	64090,
	64091,
	64092,
	64093,
	64094,
	64095,
	64096,
	64097,
	64098,
	64099,
	64100,
	64101,
	64102,
	64103,
	64104,
	64105,
	64106,
	64107,
	64108,
	64109,
	64112,
	64113,
	64114,
	64115,
	64116,
	64117,
	64118,
	64119,
	64120,
	64121,
	64122,
	64123,
	64124,
	64125,
	64126,
	64127,
	64128,
	64129,
	64130,
	64131,
	64132,
	64133,
	64134,
	64135,
	64136,
	64137,
	64138,
	64139,
	64140,
	64141,
	64142,
	64143,
	64144,
	64145,
	64146,
	64147,
	64148,
	64149,
	64150,
	64151,
	64152,
	64153,
	64154,
	64155,
	64156,
	64157,
	64158,
	64159,
	64160,
	64161,
	64162,
	64163,
	64164,
	64165,
	64166,
	64167,
	64168,
	64169,
	64170,
	64171,
	64172,
	64173,
	64174,
	64175,
	64176,
	64177,
	64178,
	64179,
	64180,
	64181,
	64182,
	64183,
	64184,
	64185,
	64186,
	64187,
	64188,
	64189,
	64190,
	64191,
	64192,
	64193,
	64194,
	64195,
	64196,
	64197,
	64198,
	64199,
	64200,
	64201,
	64202,
	64203,
	64204,
	64205,
	64206,
	64207,
	64208,
	64209,
	64210,
	64211,
	64212,
	64213,
	64214,
	64215,
	64216,
	64217,
	64256,
	64257,
	64258,
	64259,
	64260,
	64261,
	64262,
	64275,
	64276,
	64277,
	64278,
	64279,
	64285,
	64287,
	64288,
	64289,
	64290,
	64291,
	64292,
	64293,
	64294,
	64295,
	64296,
	64298,
	64299,
	64300,
	64301,
	64302,
	64303,
	64304,
	64305,
	64306,
	64307,
	64308,
	64309,
	64310,
	64312,
	64313,
	64314,
	64315,
	64316,
	64318,
	64320,
	64321,
	64323,
	64324,
	64326,
	64327,
	64328,
	64329,
	64330,
	64331,
	64332,
	64333,
	64334,
	64335,
	64336,
	64337,
	64338,
	64339,
	64340,
	64341,
	64342,
	64343,
	64344,
	64345,
	64346,
	64347,
	64348,
	64349,
	64350,
	64351,
	64352,
	64353,
	64354,
	64355,
	64356,
	64357,
	64358,
	64359,
	64360,
	64361,
	64362,
	64363,
	64364,
	64365,
	64366,
	64367,
	64368,
	64369,
	64370,
	64371,
	64372,
	64373,
	64374,
	64375,
	64376,
	64377,
	64378,
	64379,
	64380,
	64381,
	64382,
	64383,
	64384,
	64385,
	64386,
	64387,
	64388,
	64389,
	64390,
	64391,
	64392,
	64393,
	64394,
	64395,
	64396,
	64397,
	64398,
	64399,
	64400,
	64401,
	64402,
	64403,
	64404,
	64405,
	64406,
	64407,
	64408,
	64409,
	64410,
	64411,
	64412,
	64413,
	64414,
	64415,
	64416,
	64417,
	64418,
	64419,
	64420,
	64421,
	64422,
	64423,
	64424,
	64425,
	64426,
	64427,
	64428,
	64429,
	64430,
	64431,
	64432,
	64433,
	64467,
	64468,
	64469,
	64470,
	64471,
	64472,
	64473,
	64474,
	64475,
	64476,
	64477,
	64478,
	64479,
	64480,
	64481,
	64482,
	64483,
	64484,
	64485,
	64486,
	64487,
	64488,
	64489,
	64490,
	64491,
	64492,
	64493,
	64494,
	64495,
	64496,
	64497,
	64498,
	64499,
	64500,
	64501,
	64502,
	64503,
	64504,
	64505,
	64506,
	64507,
	64508,
	64509,
	64510,
	64511,
	64512,
	64513,
	64514,
	64515,
	64516,
	64517,
	64518,
	64519,
	64520,
	64521,
	64522,
	64523,
	64524,
	64525,
	64526,
	64527,
	64528,
	64529,
	64530,
	64531,
	64532,
	64533,
	64534,
	64535,
	64536,
	64537,
	64538,
	64539,
	64540,
	64541,
	64542,
	64543,
	64544,
	64545,
	64546,
	64547,
	64548,
	64549,
	64550,
	64551,
	64552,
	64553,
	64554,
	64555,
	64556,
	64557,
	64558,
	64559,
	64560,
	64561,
	64562,
	64563,
	64564,
	64565,
	64566,
	64567,
	64568,
	64569,
	64570,
	64571,
	64572,
	64573,
	64574,
	64575,
	64576,
	64577,
	64578,
	64579,
	64580,
	64581,
	64582,
	64583,
	64584,
	64585,
	64586,
	64587,
	64588,
	64589,
	64590,
	64591,
	64592,
	64593,
	64594,
	64595,
	64596,
	64597,
	64598,
	64599,
	64600,
	64601,
	64602,
	64603,
	64604,
	64605,
	64606,
	64607,
	64608,
	64609,
	64610,
	64611,
	64612,
	64613,
	64614,
	64615,
	64616,
	64617,
	64618,
	64619,
	64620,
	64621,
	64622,
	64623,
	64624,
	64625,
	64626,
	64627,
	64628,
	64629,
	64630,
	64631,
	64632,
	64633,
	64634,
	64635,
	64636,
	64637,
	64638,
	64639,
	64640,
	64641,
	64642,
	64643,
	64644,
	64645,
	64646,
	64647,
	64648,
	64649,
	64650,
	64651,
	64652,
	64653,
	64654,
	64655,
	64656,
	64657,
	64658,
	64659,
	64660,
	64661,
	64662,
	64663,
	64664,
	64665,
	64666,
	64667,
	64668,
	64669,
	64670,
	64671,
	64672,
	64673,
	64674,
	64675,
	64676,
	64677,
	64678,
	64679,
	64680,
	64681,
	64682,
	64683,
	64684,
	64685,
	64686,
	64687,
	64688,
	64689,
	64690,
	64691,
	64692,
	64693,
	64694,
	64695,
	64696,
	64697,
	64698,
	64699,
	64700,
	64701,
	64702,
	64703,
	64704,
	64705,
	64706,
	64707,
	64708,
	64709,
	64710,
	64711,
	64712,
	64713,
	64714,
	64715,
	64716,
	64717,
	64718,
	64719,
	64720,
	64721,
	64722,
	64723,
	64724,
	64725,
	64726,
	64727,
	64728,
	64729,
	64730,
	64731,
	64732,
	64733,
	64734,
	64735,
	64736,
	64737,
	64738,
	64739,
	64740,
	64741,
	64742,
	64743,
	64744,
	64745,
	64746,
	64747,
	64748,
	64749,
	64750,
	64751,
	64752,
	64753,
	64754,
	64755,
	64756,
	64757,
	64758,
	64759,
	64760,
	64761,
	64762,
	64763,
	64764,
	64765,
	64766,
	64767,
	64768,
	64769,
	64770,
	64771,
	64772,
	64773,
	64774,
	64775,
	64776,
	64777,
	64778,
	64779,
	64780,
	64781,
	64782,
	64783,
	64784,
	64785,
	64786,
	64787,
	64788,
	64789,
	64790,
	64791,
	64792,
	64793,
	64794,
	64795,
	64796,
	64797,
	64798,
	64799,
	64800,
	64801,
	64802,
	64803,
	64804,
	64805,
	64806,
	64807,
	64808,
	64809,
	64810,
	64811,
	64812,
	64813,
	64814,
	64815,
	64816,
	64817,
	64818,
	64819,
	64820,
	64821,
	64822,
	64823,
	64824,
	64825,
	64826,
	64827,
	64828,
	64829,
	64848,
	64849,
	64850,
	64851,
	64852,
	64853,
	64854,
	64855,
	64856,
	64857,
	64858,
	64859,
	64860,
	64861,
	64862,
	64863,
	64864,
	64865,
	64866,
	64867,
	64868,
	64869,
	64870,
	64871,
	64872,
	64873,
	64874,
	64875,
	64876,
	64877,
	64878,
	64879,
	64880,
	64881,
	64882,
	64883,
	64884,
	64885,
	64886,
	64887,
	64888,
	64889,
	64890,
	64891,
	64892,
	64893,
	64894,
	64895,
	64896,
	64897,
	64898,
	64899,
	64900,
	64901,
	64902,
	64903,
	64904,
	64905,
	64906,
	64907,
	64908,
	64909,
	64910,
	64911,
	64914,
	64915,
	64916,
	64917,
	64918,
	64919,
	64920,
	64921,
	64922,
	64923,
	64924,
	64925,
	64926,
	64927,
	64928,
	64929,
	64930,
	64931,
	64932,
	64933,
	64934,
	64935,
	64936,
	64937,
	64938,
	64939,
	64940,
	64941,
	64942,
	64943,
	64944,
	64945,
	64946,
	64947,
	64948,
	64949,
	64950,
	64951,
	64952,
	64953,
	64954,
	64955,
	64956,
	64957,
	64958,
	64959,
	64960,
	64961,
	64962,
	64963,
	64964,
	64965,
	64966,
	64967,
	65008,
	65009,
	65010,
	65011,
	65012,
	65013,
	65014,
	65015,
	65016,
	65017,
	65018,
	65019,
	65136,
	65137,
	65138,
	65139,
	65140,
	65142,
	65143,
	65144,
	65145,
	65146,
	65147,
	65148,
	65149,
	65150,
	65151,
	65152,
	65153,
	65154,
	65155,
	65156,
	65157,
	65158,
	65159,
	65160,
	65161,
	65162,
	65163,
	65164,
	65165,
	65166,
	65167,
	65168,
	65169,
	65170,
	65171,
	65172,
	65173,
	65174,
	65175,
	65176,
	65177,
	65178,
	65179,
	65180,
	65181,
	65182,
	65183,
	65184,
	65185,
	65186,
	65187,
	65188,
	65189,
	65190,
	65191,
	65192,
	65193,
	65194,
	65195,
	65196,
	65197,
	65198,
	65199,
	65200,
	65201,
	65202,
	65203,
	65204,
	65205,
	65206,
	65207,
	65208,
	65209,
	65210,
	65211,
	65212,
	65213,
	65214,
	65215,
	65216,
	65217,
	65218,
	65219,
	65220,
	65221,
	65222,
	65223,
	65224,
	65225,
	65226,
	65227,
	65228,
	65229,
	65230,
	65231,
	65232,
	65233,
	65234,
	65235,
	65236,
	65237,
	65238,
	65239,
	65240,
	65241,
	65242,
	65243,
	65244,
	65245,
	65246,
	65247,
	65248,
	65249,
	65250,
	65251,
	65252,
	65253,
	65254,
	65255,
	65256,
	65257,
	65258,
	65259,
	65260,
	65261,
	65262,
	65263,
	65264,
	65265,
	65266,
	65267,
	65268,
	65269,
	65270,
	65271,
	65272,
	65273,
	65274,
	65275,
	65276,
	65313,
	65314,
	65315,
	65316,
	65317,
	65318,
	65319,
	65320,
	65321,
	65322,
	65323,
	65324,
	65325,
	65326,
	65327,
	65328,
	65329,
	65330,
	65331,
	65332,
	65333,
	65334,
	65335,
	65336,
	65337,
	65338,
	65345,
	65346,
	65347,
	65348,
	65349,
	65350,
	65351,
	65352,
	65353,
	65354,
	65355,
	65356,
	65357,
	65358,
	65359,
	65360,
	65361,
	65362,
	65363,
	65364,
	65365,
	65366,
	65367,
	65368,
	65369,
	65370,
	65382,
	65383,
	65384,
	65385,
	65386,
	65387,
	65388,
	65389,
	65390,
	65391,
	65392,
	65393,
	65394,
	65395,
	65396,
	65397,
	65398,
	65399,
	65400,
	65401,
	65402,
	65403,
	65404,
	65405,
	65406,
	65407,
	65408,
	65409,
	65410,
	65411,
	65412,
	65413,
	65414,
	65415,
	65416,
	65417,
	65418,
	65419,
	65420,
	65421,
	65422,
	65423,
	65424,
	65425,
	65426,
	65427,
	65428,
	65429,
	65430,
	65431,
	65432,
	65433,
	65434,
	65435,
	65436,
	65437,
	65438,
	65439,
	65440,
	65441,
	65442,
	65443,
	65444,
	65445,
	65446,
	65447,
	65448,
	65449,
	65450,
	65451,
	65452,
	65453,
	65454,
	65455,
	65456,
	65457,
	65458,
	65459,
	65460,
	65461,
	65462,
	65463,
	65464,
	65465,
	65466,
	65467,
	65468,
	65469,
	65470,
	65474,
	65475,
	65476,
	65477,
	65478,
	65479,
	65482,
	65483,
	65484,
	65485,
	65486,
	65487,
	65490,
	65491,
	65492,
	65493,
	65494,
	65495,
	65498,
	65499,
	65500
];

},{}],69:[function(require,module,exports){
(function (global){/*global window, global*/
var util = require("util")
var assert = require("assert")

var slice = Array.prototype.slice
var console
var times = {}

if (typeof global !== "undefined" && global.console) {
    console = global.console
} else if (typeof window !== "undefined" && window.console) {
    console = window.console
} else {
    console = window.console = {}
}

var functions = [
    [log, "log"]
    , [info, "info"]
    , [warn, "warn"]
    , [error, "error"]
    , [time, "time"]
    , [timeEnd, "timeEnd"]
    , [trace, "trace"]
    , [dir, "dir"]
    , [assert, "assert"]
]

for (var i = 0; i < functions.length; i++) {
    var tuple = functions[i]
    var f = tuple[0]
    var name = tuple[1]

    if (!console[name]) {
        console[name] = f
    }
}

module.exports = console

function log() {}

function info() {
    console.log.apply(console, arguments)
}

function warn() {
    console.log.apply(console, arguments)
}

function error() {
    console.warn.apply(console, arguments)
}

function time(label) {
    times[label] = Date.now()
}

function timeEnd(label) {
    var time = times[label]
    if (!time) {
        throw new Error("No such label: " + label)
    }

    var duration = Date.now() - time
    console.log(label + ": " + duration + "ms")
}

function trace() {
    var err = new Error()
    err.name = "Trace"
    err.message = util.format.apply(null, arguments)
    console.error(err.stack)
}

function dir(object) {
    console.log(util.inspect(object) + "\n")
}

function assert(expression) {
    if (!expression) {
        var arr = slice.call(arguments, 1)
        assert.ok(false, util.format.apply(null, arr))
    }
}
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"assert":57,"util":65}],70:[function(require,module,exports){
//     Underscore.js 1.4.4
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.4.4';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? null : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value || _.identity);
    each(obj, function(value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function() {
      return func.apply(context, args.concat(slice.call(arguments)));
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function() {
      previous = new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] == null) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(n);
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

},{}],71:[function(require,module,exports){
/*!
 * JSHint, by JSHint Community.
 *
 * This file (and this file only) is licensed under the same slightly modified
 * MIT license that JSLint is. It stops evil-doers everywhere:
 *
 *	 Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)
 *
 *	 Permission is hereby granted, free of charge, to any person obtaining
 *	 a copy of this software and associated documentation files (the "Software"),
 *	 to deal in the Software without restriction, including without limitation
 *	 the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *	 and/or sell copies of the Software, and to permit persons to whom
 *	 the Software is furnished to do so, subject to the following conditions:
 *
 *	 The above copyright notice and this permission notice shall be included
 *	 in all copies or substantial portions of the Software.
 *
 *	 The Software shall be used for Good, not Evil.
 *
 *	 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *	 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *	 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *	 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *	 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *	 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *	 DEALINGS IN THE SOFTWARE.
 *
 */

/*jshint quotmark:double */
/*global console:true */
/*exported console */

var _        = require("underscore");
var events   = require("events");
var vars     = require("./vars.js");
var messages = require("./messages.js");
var Lexer    = require("./lex.js").Lexer;
var reg      = require("./reg.js");
var state    = require("./state.js").state;
var style    = require("./style.js");

// We need this module here because environments such as IE and Rhino
// don't necessarilly expose the 'console' API and browserify uses
// it to log things. It's a sad state of affair, really.
var console = require("console-browserify");

// We build the application inside a function so that we produce only a singleton
// variable. That function will be invoked immediately, and its return value is
// the JSHINT function itself.

var JSHINT = (function () {
	"use strict";

	var anonname, // The guessed name for anonymous functions.
		api, // Extension API

		// These are operators that should not be used with the ! operator.
		bang = {
			"<"  : true,
			"<=" : true,
			"==" : true,
			"===": true,
			"!==": true,
			"!=" : true,
			">"  : true,
			">=" : true,
			"+"  : true,
			"-"  : true,
			"*"  : true,
			"/"  : true,
			"%"  : true
		},

		// These are the JSHint boolean options.
		boolOptions = {
			asi         : true, // if automatic semicolon insertion should be tolerated
			bitwise     : true, // if bitwise operators should not be allowed
			boss        : true, // if advanced usage of assignments should be allowed
			browser     : true, // if the standard browser globals should be predefined
			camelcase   : true, // if identifiers should be required in camel case
			couch       : true, // if CouchDB globals should be predefined
			curly       : true, // if curly braces around all blocks should be required
			debug       : true, // if debugger statements should be allowed
			devel       : true, // if logging globals should be predefined (console, alert, etc.)
			dojo        : true, // if Dojo Toolkit globals should be predefined
			eqeqeq      : true, // if === should be required
			eqnull      : true, // if == null comparisons should be tolerated
			notypeof    : true, // if should report typos in typeof comparisons
			es3         : true, // if ES3 syntax should be allowed
			es5         : true, // if ES5 syntax should be allowed (is now set per default)
			esnext      : true, // if es.next specific syntax should be allowed
			moz         : true, // if mozilla specific syntax should be allowed
			evil        : true, // if eval should be allowed
			expr        : true, // if ExpressionStatement should be allowed as Programs
			forin       : true, // if for in statements must filter
			funcscope   : true, // if only function scope should be used for scope tests
			gcl         : true, // if JSHint should be compatible with Google Closure Linter
			globalstrict: true, // if global "use strict"; should be allowed (also enables 'strict')
			immed       : true, // if immediate invocations must be wrapped in parens
			iterator    : true, // if the `__iterator__` property should be allowed
			jquery      : true, // if jQuery globals should be predefined
			lastsemic   : true, // if semicolons may be ommitted for the trailing
			                    // statements inside of a one-line blocks.
			laxbreak    : true, // if line breaks should not be checked
			laxcomma    : true, // if line breaks should not be checked around commas
			loopfunc    : true, // if functions should be allowed to be defined within
			                    // loops
			mootools    : true, // if MooTools globals should be predefined
			multistr    : true, // allow multiline strings
			freeze      : true, // if modifying native object prototypes should be disallowed
			newcap      : true, // if constructor names must be capitalized
			noarg       : true, // if arguments.caller and arguments.callee should be
			                    // disallowed
			node        : true, // if the Node.js environment globals should be
			                    // predefined
			noempty     : true, // if empty blocks should be disallowed
			nonew       : true, // if using `new` for side-effects should be disallowed
			nonstandard : true, // if non-standard (but widely adopted) globals should
			                    // be predefined
			nomen       : true, // if names should be checked
			onevar      : true, // if only one var statement per function should be
			                    // allowed
			passfail    : true, // if the scan should stop on first error
			phantom     : true, // if PhantomJS symbols should be allowed
			plusplus    : true, // if increment/decrement should not be allowed
			proto       : true, // if the `__proto__` property should be allowed
			prototypejs : true, // if Prototype and Scriptaculous globals should be
			                    // predefined
			rhino       : true, // if the Rhino environment globals should be predefined
			shelljs     : true, // if ShellJS globals should be predefined
			typed       : true, // if typed array globals should be predefined
			undef       : true, // if variables should be declared before used
			scripturl   : true, // if script-targeted URLs should be tolerated
			shadow      : true, // if variable shadowing should be tolerated
			smarttabs   : true, // if smarttabs should be tolerated
			                    // (http://www.emacswiki.org/emacs/SmartTabs)
			strict      : true, // require the "use strict"; pragma
			sub         : true, // if all forms of subscript notation are tolerated
			supernew    : true, // if `new function () { ... };` and `new Object;`
			                    // should be tolerated
			trailing    : true, // if trailing whitespace rules apply
			validthis   : true, // if 'this' inside a non-constructor function is valid.
			                    // This is a function scoped option only.
			withstmt    : true, // if with statements should be allowed
			white       : true, // if strict whitespace rules apply
			worker      : true, // if Web Worker script symbols should be allowed
			wsh         : true, // if the Windows Scripting Host environment globals
			                    // should be predefined
			yui         : true, // YUI variables should be predefined

			// Obsolete options
			onecase     : true, // if one case switch statements should be allowed
			regexp      : true, // if the . should not be allowed in regexp literals
			regexdash   : true  // if unescaped first/last dash (-) inside brackets
			                    // should be tolerated
		},

		// These are the JSHint options that can take any value
		// (we use this object to detect invalid options)
		valOptions = {
			maxlen       : false,
			indent       : false,
			maxerr       : false,
			predef       : false, //predef is deprecated and being replaced by globals
			globals      : false,
			quotmark     : false, //'single'|'double'|true
			scope        : false,
			maxstatements: false, // {int} max statements per function
			maxdepth     : false, // {int} max nested block depth per function
			maxparams    : false, // {int} max params per function
			maxcomplexity: false, // {int} max cyclomatic complexity per function
			unused       : true,  // warn if variables are unused. Available options:
			                      //   false    - don't check for unused variables
			                      //   true     - "vars" + check last function param
			                      //   "vars"   - skip checking unused function params
			                      //   "strict" - "vars" + check all function params
			latedef      : false, // warn if the variable is used before its definition
			                      //   false    - don't emit any warnings
			                      //   true     - warn if any variable is used before its definition
			                      //   "nofunc" - warn for any variable but function declarations
			ignore       : false  // start/end ignoring lines of code, bypassing the lexer
			                      //   start    - start ignoring lines, including the current line
			                      //   end      - stop ignoring lines, starting on the next line
			                      //   line     - ignore warnings / errors for just a single line
			                      //              (this option does not bypass the lexer)
		},

		// These are JSHint boolean options which are shared with JSLint
		// where the definition in JSHint is opposite JSLint
		invertedOptions = {
			bitwise : true,
			forin   : true,
			newcap  : true,
			nomen   : true,
			plusplus: true,
			regexp  : true,
			undef   : true,
			white   : true,

			// Inverted and renamed, use JSHint name here
			eqeqeq  : true,
			onevar  : true,
			strict  : true
		},

		// These are JSHint boolean options which are shared with JSLint
		// where the name has been changed but the effect is unchanged
		renamedOptions = {
			eqeq   : "eqeqeq",
			vars   : "onevar",
			windows: "wsh",
			sloppy : "strict"
		},

		declared, // Globals that were declared using /*global ... */ syntax.
		exported, // Variables that are used outside of the current file.

		functionicity = [
			"closure", "exception", "global", "label",
			"outer", "unused", "var"
		],

		funct, // The current function
		functions, // All of the functions

		global, // The global scope
		implied, // Implied globals
		inblock,
		indent,
		lookahead,
		lex,
		member,
		membersOnly,
		noreach,
		predefined,		// Global variables defined by option

		scope,  // The current scope
		stack,
		unuseds,
		urls,
		warnings,

		extraModules = [],
		emitter = new events.EventEmitter();

	function checkOption(name, t) {
		name = name.trim();

		if (/^[+-]W\d{3}$/g.test(name)) {
			return true;
		}

		if (valOptions[name] === undefined && boolOptions[name] === undefined) {
			if (t.type !== "jslint") {
				error("E001", t, name);
				return false;
			}
		}

		return true;
	}

	function isString(obj) {
		return Object.prototype.toString.call(obj) === "[object String]";
	}

	function isIdentifier(tkn, value) {
		if (!tkn)
			return false;

		if (!tkn.identifier || tkn.value !== value)
			return false;

		return true;
	}

	function isReserved(token) {
		if (!token.reserved) {
			return false;
		}
		var meta = token.meta;

		if (meta && meta.isFutureReservedWord && state.option.inES5()) {
			// ES3 FutureReservedWord in an ES5 environment.
			if (!meta.es5) {
				return false;
			}

			// Some ES5 FutureReservedWord identifiers are active only
			// within a strict mode environment.
			if (meta.strictOnly) {
				if (!state.option.strict && !state.directive["use strict"]) {
					return false;
				}
			}

			if (token.isProperty) {
				return false;
			}
		}

		return true;
	}

	function supplant(str, data) {
		return str.replace(/\{([^{}]*)\}/g, function (a, b) {
			var r = data[b];
			return typeof r === "string" || typeof r === "number" ? r : a;
		});
	}

	function combine(t, o) {
		var n;
		for (n in o) {
			if (_.has(o, n) && !_.has(JSHINT.blacklist, n)) {
				t[n] = o[n];
			}
		}
	}

	function updatePredefined() {
		Object.keys(JSHINT.blacklist).forEach(function (key) {
			delete predefined[key];
		});
	}

	function assume() {
		if (state.option.es5) {
			warning("I003");
		}
		if (state.option.couch) {
			combine(predefined, vars.couch);
		}

		if (state.option.rhino) {
			combine(predefined, vars.rhino);
		}

		if (state.option.shelljs) {
			combine(predefined, vars.shelljs);
			combine(predefined, vars.node);
		}
		if (state.option.typed) {
			combine(predefined, vars.typed);
		}

		if (state.option.phantom) {
			combine(predefined, vars.phantom);
		}

		if (state.option.prototypejs) {
			combine(predefined, vars.prototypejs);
		}

		if (state.option.node) {
			combine(predefined, vars.node);
			combine(predefined, vars.typed);
		}

		if (state.option.devel) {
			combine(predefined, vars.devel);
		}

		if (state.option.dojo) {
			combine(predefined, vars.dojo);
		}

		if (state.option.browser) {
			combine(predefined, vars.browser);
			combine(predefined, vars.typed);
		}

		if (state.option.nonstandard) {
			combine(predefined, vars.nonstandard);
		}

		if (state.option.jquery) {
			combine(predefined, vars.jquery);
		}

		if (state.option.mootools) {
			combine(predefined, vars.mootools);
		}

		if (state.option.worker) {
			combine(predefined, vars.worker);
		}

		if (state.option.wsh) {
			combine(predefined, vars.wsh);
		}

		if (state.option.globalstrict && state.option.strict !== false) {
			state.option.strict = true;
		}

		if (state.option.yui) {
			combine(predefined, vars.yui);
		}

		// Let's assume that chronologically ES3 < ES5 < ES6/ESNext < Moz

		state.option.inMoz = function (strict) {
			if (strict) {
				return state.option.moz && !state.option.esnext;
			}
			return state.option.moz;
		};

		state.option.inESNext = function (strict) {
			if (strict) {
				return !state.option.moz && state.option.esnext;
			}
			return state.option.moz || state.option.esnext;
		};

		state.option.inES5 = function (/* strict */) {
			return !state.option.es3;
		};

		state.option.inES3 = function (strict) {
			if (strict) {
				return !state.option.moz && !state.option.esnext && state.option.es3;
			}
			return state.option.es3;
		};
	}

	// Produce an error warning.
	function quit(code, line, chr) {
		var percentage = Math.floor((line / state.lines.length) * 100);
		var message = messages.errors[code].desc;

		throw {
			name: "JSHintError",
			line: line,
			character: chr,
			message: message + " (" + percentage + "% scanned).",
			raw: message,
			code: code
		};
	}

	function isundef(scope, code, token, a) {
		return JSHINT.undefs.push([scope, code, token, a]);
	}

	function warning(code, t, a, b, c, d) {
		var ch, l, w, msg;

		if (/^W\d{3}$/.test(code)) {
			if (state.ignored[code])
				return;

			msg = messages.warnings[code];
		} else if (/E\d{3}/.test(code)) {
			msg = messages.errors[code];
		} else if (/I\d{3}/.test(code)) {
			msg = messages.info[code];
		}

		t = t || state.tokens.next;
		if (t.id === "(end)") {  // `~
			t = state.tokens.curr;
		}

		l = t.line || 0;
		ch = t.from || 0;

		w = {
			id: "(error)",
			raw: msg.desc,
			code: msg.code,
			evidence: state.lines[l - 1] || "",
			line: l,
			character: ch,
			scope: JSHINT.scope,
			a: a,
			b: b,
			c: c,
			d: d
		};

		w.reason = supplant(msg.desc, w);
		JSHINT.errors.push(w);

		if (state.option.passfail) {
			quit("E042", l, ch);
		}

		warnings += 1;
		if (warnings >= state.option.maxerr) {
			quit("E043", l, ch);
		}

		return w;
	}

	function warningAt(m, l, ch, a, b, c, d) {
		return warning(m, {
			line: l,
			from: ch
		}, a, b, c, d);
	}

	function error(m, t, a, b, c, d) {
		warning(m, t, a, b, c, d);
	}

	function errorAt(m, l, ch, a, b, c, d) {
		return error(m, {
			line: l,
			from: ch
		}, a, b, c, d);
	}

	// Tracking of "internal" scripts, like eval containing a static string
	function addInternalSrc(elem, src) {
		var i;
		i = {
			id: "(internal)",
			elem: elem,
			value: src
		};
		JSHINT.internals.push(i);
		return i;
	}

	function addlabel(t, type, tkn, islet) {
		// Define t in the current function in the current scope.
		if (type === "exception") {
			if (_.has(funct["(context)"], t)) {
				if (funct[t] !== true && !state.option.node) {
					warning("W002", state.tokens.next, t);
				}
			}
		}

		if (_.has(funct, t) && !funct["(global)"]) {
			if (funct[t] === true) {
				if (state.option.latedef) {
					if ((state.option.latedef === true && _.contains([funct[t], type], "unction")) ||
							!_.contains([funct[t], type], "unction")) {
						warning("W003", state.tokens.next, t);
					}
				}
			} else {
				if (!state.option.shadow && type !== "exception" ||
							(funct["(blockscope)"].getlabel(t))) {
					warning("W004", state.tokens.next, t);
				}
			}
		}

		// a double definition of a let variable in same block throws a TypeError
		if (funct["(blockscope)"] && funct["(blockscope)"].current.has(t)) {
			error("E044", state.tokens.next, t);
		}

		// if the identifier is from a let, adds it only to the current blockscope
		if (islet) {
			funct["(blockscope)"].current.add(t, type, state.tokens.curr);
		} else {

			funct[t] = type;

			if (tkn) {
				funct["(tokens)"][t] = tkn;
			}

			if (funct["(global)"]) {
				global[t] = funct;
				if (_.has(implied, t)) {
					if (state.option.latedef) {
						if ((state.option.latedef === true && _.contains([funct[t], type], "unction")) ||
								!_.contains([funct[t], type], "unction")) {
							warning("W003", state.tokens.next, t);
						}
					}

					delete implied[t];
				}
			} else {
				scope[t] = funct;
			}
		}
	}

	function doOption() {
		var nt = state.tokens.next;
		var body = nt.body.split(",").map(function (s) { return s.trim(); });
		var predef = {};

		if (nt.type === "globals") {
			body.forEach(function (g) {
				g = g.split(":");
				var key = (g[0] || "").trim();
				var val = (g[1] || "").trim();

				if (key.charAt(0) === "-") {
					key = key.slice(1);
					val = false;

					JSHINT.blacklist[key] = key;
					updatePredefined();
				} else {
					predef[key] = (val === "true");
				}
			});

			combine(predefined, predef);

			for (var key in predef) {
				if (_.has(predef, key)) {
					declared[key] = nt;
				}
			}
		}

		if (nt.type === "exported") {
			body.forEach(function (e) {
				exported[e] = true;
			});
		}

		if (nt.type === "members") {
			membersOnly = membersOnly || {};

			body.forEach(function (m) {
				var ch1 = m.charAt(0);
				var ch2 = m.charAt(m.length - 1);

				if (ch1 === ch2 && (ch1 === "\"" || ch1 === "'")) {
					m = m
						.substr(1, m.length - 2)
						.replace("\\b", "\b")
						.replace("\\t", "\t")
						.replace("\\n", "\n")
						.replace("\\v", "\v")
						.replace("\\f", "\f")
						.replace("\\r", "\r")
						.replace("\\\\", "\\")
						.replace("\\\"", "\"");
				}

				membersOnly[m] = false;
			});
		}

		var numvals = [
			"maxstatements",
			"maxparams",
			"maxdepth",
			"maxcomplexity",
			"maxerr",
			"maxlen",
			"indent"
		];

		if (nt.type === "jshint" || nt.type === "jslint") {
			body.forEach(function (g) {
				g = g.split(":");
				var key = (g[0] || "").trim();
				var val = (g[1] || "").trim();

				if (!checkOption(key, nt)) {
					return;
				}

				if (numvals.indexOf(key) >= 0) {

					// GH988 - numeric options can be disabled by setting them to `false`
					if (val !== "false") {
						val = +val;

						if (typeof val !== "number" || !isFinite(val) || val <= 0 || Math.floor(val) !== val) {
							error("E032", nt, g[1].trim());
							return;
						}

						if (key === "indent") {
							state.option["(explicitIndent)"] = true;
						}
						state.option[key] = val;
					} else {
						if (key === "indent") {
							state.option["(explicitIndent)"] = false;
						} else {
							state.option[key] = false;
						}
					}

					return;
				}

				if (key === "validthis") {
					// `validthis` is valid only within a function scope.
					if (funct["(global)"]) {
						error("E009");
					} else {
						if (val === "true" || val === "false") {
							state.option.validthis = (val === "true");
						} else {
							error("E002", nt);
						}
					}
					return;
				}

				if (key === "quotmark") {
					switch (val) {
					case "true":
					case "false":
						state.option.quotmark = (val === "true");
						break;
					case "double":
					case "single":
						state.option.quotmark = val;
						break;
					default:
						error("E002", nt);
					}
					return;
				}

				if (key === "unused") {
					switch (val) {
					case "true":
						state.option.unused = true;
						break;
					case "false":
						state.option.unused = false;
						break;
					case "vars":
					case "strict":
						state.option.unused = val;
						break;
					default:
						error("E002", nt);
					}
					return;
				}

				if (key === "latedef") {
					switch (val) {
					case "true":
						state.option.latedef = true;
						break;
					case "false":
						state.option.latedef = false;
						break;
					case "nofunc":
						state.option.latedef = "nofunc";
						break;
					default:
						error("E002", nt);
					}
					return;
				}

				if (key === "ignore") {
					switch (val) {
					case "start":
						state.ignoreLinterErrors = true;
						break;
					case "end":
						state.ignoreLinterErrors = false;
						break;
					case "line":
						// Any errors or warnings that happened on the current line, make them go away.
						JSHINT.errors = _.reject(JSHINT.errors, function (error) {
							// nt.line returns to the current line
							return error.line === nt.line;
						});
						break;
					default:
						error("E002", nt);
					}
					return;
				}

				var match = /^([+-])(W\d{3})$/g.exec(key);
				if (match) {
					// ignore for -W..., unignore for +W...
					state.ignored[match[2]] = (match[1] === "-");
					return;
				}

				var tn;
				if (val === "true" || val === "false") {
					if (nt.type === "jslint") {
						tn = renamedOptions[key] || key;
						state.option[tn] = (val === "true");

						if (invertedOptions[tn] !== undefined) {
							state.option[tn] = !state.option[tn];
						}
					} else {
						state.option[key] = (val === "true");
					}

					if (key === "newcap") {
						state.option["(explicitNewcap)"] = true;
					}
					return;
				}

				error("E002", nt);
			});

			assume();
		}
	}

	// We need a peek function. If it has an argument, it peeks that much farther
	// ahead. It is used to distinguish
	//	   for ( var i in ...
	// from
	//	   for ( var i = ...

	function peek(p) {
		var i = p || 0, j = 0, t;

		while (j <= i) {
			t = lookahead[j];
			if (!t) {
				t = lookahead[j] = lex.token();
			}
			j += 1;
		}
		return t;
	}

	// Produce the next token. It looks for programming errors.

	function advance(id, t) {
		switch (state.tokens.curr.id) {
		case "(number)":
			if (state.tokens.next.id === ".") {
				warning("W005", state.tokens.curr);
			}
			break;
		case "-":
			if (state.tokens.next.id === "-" || state.tokens.next.id === "--") {
				warning("W006");
			}
			break;
		case "+":
			if (state.tokens.next.id === "+" || state.tokens.next.id === "++") {
				warning("W007");
			}
			break;
		}

		if (state.tokens.curr.type === "(string)" || state.tokens.curr.identifier) {
			anonname = state.tokens.curr.value;
		}

		if (id && state.tokens.next.id !== id) {
			if (t) {
				if (state.tokens.next.id === "(end)") {
					error("E019", t, t.id);
				} else {
					error("E020", state.tokens.next, id, t.id, t.line, state.tokens.next.value);
				}
			} else if (state.tokens.next.type !== "(identifier)" || state.tokens.next.value !== id) {
				warning("W116", state.tokens.next, id, state.tokens.next.value);
			}
		}

		state.tokens.prev = state.tokens.curr;
		state.tokens.curr = state.tokens.next;
		for (;;) {
			state.tokens.next = lookahead.shift() || lex.token();

			if (!state.tokens.next) { // No more tokens left, give up
				quit("E041", state.tokens.curr.line);
			}

			if (state.tokens.next.id === "(end)" || state.tokens.next.id === "(error)") {
				return;
			}

			if (state.tokens.next.check) {
				state.tokens.next.check();
			}

			if (state.tokens.next.isSpecial) {
				doOption();
			} else {
				if (state.tokens.next.id !== "(endline)") {
					break;
				}
			}
		}
	}

	function isInfix(token) {
		return token.infix || (!token.identifier && !!token.led);
	}

	function isEndOfExpr() {
		var curr = state.tokens.curr;
		var next = state.tokens.next;
		if (next.id === ";" || next.id === "}" || next.id === ":") {
			return true;
		}
		if (isInfix(next) === isInfix(curr) || (curr.id === "yield" && state.option.inMoz(true))) {
			return curr.line !== next.line;
		}
		return false;
	}

	// This is the heart of JSHINT, the Pratt parser. In addition to parsing, it
	// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is
	// like .nud except that it is only used on the first token of a statement.
	// Having .fud makes it much easier to define statement-oriented languages like
	// JavaScript. I retained Pratt's nomenclature.

	// .nud  Null denotation
	// .fud  First null denotation
	// .led  Left denotation
	//  lbp  Left binding power
	//  rbp  Right binding power

	// They are elements of the parsing method called Top Down Operator Precedence.

	function expression(rbp, initial) {
		var left, isArray = false, isObject = false, isLetExpr = false;

		// if current expression is a let expression
		if (!initial && state.tokens.next.value === "let" && peek(0).value === "(") {
			if (!state.option.inMoz(true)) {
				warning("W118", state.tokens.next, "let expressions");
			}
			isLetExpr = true;
			// create a new block scope we use only for the current expression
			funct["(blockscope)"].stack();
			advance("let");
			advance("(");
			state.syntax["let"].fud.call(state.syntax["let"].fud, false);
			advance(")");
		}

		if (state.tokens.next.id === "(end)")
			error("E006", state.tokens.curr);

		advance();

		if (initial) {
			anonname = "anonymous";
			funct["(verb)"] = state.tokens.curr.value;
		}

		if (initial === true && state.tokens.curr.fud) {
			left = state.tokens.curr.fud();
		} else {
			if (state.tokens.curr.nud) {
				left = state.tokens.curr.nud();
			} else {
				error("E030", state.tokens.curr, state.tokens.curr.id);
			}

			while (rbp < state.tokens.next.lbp && !isEndOfExpr()) {
				isArray = state.tokens.curr.value === "Array";
				isObject = state.tokens.curr.value === "Object";

				// #527, new Foo.Array(), Foo.Array(), new Foo.Object(), Foo.Object()
				// Line breaks in IfStatement heads exist to satisfy the checkJSHint
				// "Line too long." error.
				if (left && (left.value || (left.first && left.first.value))) {
					// If the left.value is not "new", or the left.first.value is a "."
					// then safely assume that this is not "new Array()" and possibly
					// not "new Object()"...
					if (left.value !== "new" ||
					  (left.first && left.first.value && left.first.value === ".")) {
						isArray = false;
						// ...In the case of Object, if the left.value and state.tokens.curr.value
						// are not equal, then safely assume that this not "new Object()"
						if (left.value !== state.tokens.curr.value) {
							isObject = false;
						}
					}
				}

				advance();

				if (isArray && state.tokens.curr.id === "(" && state.tokens.next.id === ")") {
					warning("W009", state.tokens.curr);
				}

				if (isObject && state.tokens.curr.id === "(" && state.tokens.next.id === ")") {
					warning("W010", state.tokens.curr);
				}

				if (left && state.tokens.curr.led) {
					left = state.tokens.curr.led(left);
				} else {
					error("E033", state.tokens.curr, state.tokens.curr.id);
				}
			}
		}
		if (isLetExpr) {
			funct["(blockscope)"].unstack();
		}
		return left;
	}


// Functions for conformance of style.

	function adjacent(left, right) {
		left = left || state.tokens.curr;
		right = right || state.tokens.next;
		if (state.option.white) {
			if (left.character !== right.from && left.line === right.line) {
				left.from += (left.character - left.from);
				warning("W011", left, left.value);
			}
		}
	}

	function nobreak(left, right) {
		left = left || state.tokens.curr;
		right = right || state.tokens.next;
		if (state.option.white && (left.character !== right.from || left.line !== right.line)) {
			warning("W012", right, right.value);
		}
	}

	function nospace(left, right) {
		left = left || state.tokens.curr;
		right = right || state.tokens.next;
		if (state.option.white && !left.comment) {
			if (left.line === right.line) {
				adjacent(left, right);
			}
		}
	}

	function nonadjacent(left, right) {
		if (state.option.white) {
			left = left || state.tokens.curr;
			right = right || state.tokens.next;

			if (left.value === ";" && right.value === ";") {
				return;
			}

			if (left.line === right.line && left.character === right.from) {
				left.from += (left.character - left.from);
				warning("W013", left, left.value);
			}
		}
	}

	function nobreaknonadjacent(left, right) {
		left = left || state.tokens.curr;
		right = right || state.tokens.next;
		if (!state.option.laxbreak && left.line !== right.line) {
			warning("W014", right, right.value);
		} else if (state.option.white) {
			left = left || state.tokens.curr;
			right = right || state.tokens.next;
			if (left.character === right.from) {
				left.from += (left.character - left.from);
				warning("W013", left, left.value);
			}
		}
	}

	function indentation(bias) {
		if (!state.option.white && !state.option["(explicitIndent)"]) {
			return;
		}

		if (state.tokens.next.id === "(end)") {
			return;
		}

		var i = indent + (bias || 0);
		if (state.tokens.next.from !== i) {
			warning("W015", state.tokens.next, state.tokens.next.value, i, state.tokens.next.from);
		}
	}

	function nolinebreak(t) {
		t = t || state.tokens.curr;
		if (t.line !== state.tokens.next.line) {
			warning("E022", t, t.value);
		}
	}

	function nobreakcomma(left, right) {
		if (left.line !== right.line) {
			if (!state.option.laxcomma) {
				if (comma.first) {
					warning("I001");
					comma.first = false;
				}
				warning("W014", left, right.value);
			}
		} else if (!left.comment && left.character !== right.from && state.option.white) {
			left.from += (left.character - left.from);
			warning("W011", left, left.value);
		}
	}

	function comma(opts) {
		opts = opts || {};

		if (!opts.peek) {
			nobreakcomma(state.tokens.curr, state.tokens.next);
			advance(",");
		} else {
			nobreakcomma(state.tokens.prev, state.tokens.curr);
		}

		// TODO: This is a temporary solution to fight against false-positives in
		// arrays and objects with trailing commas (see GH-363). The best solution
		// would be to extract all whitespace rules out of parser.

		if (state.tokens.next.value !== "]" && state.tokens.next.value !== "}") {
			nonadjacent(state.tokens.curr, state.tokens.next);
		}

		if (state.tokens.next.identifier && !(opts.property && state.option.inES5())) {
			// Keywords that cannot follow a comma operator.
			switch (state.tokens.next.value) {
			case "break":
			case "case":
			case "catch":
			case "continue":
			case "default":
			case "do":
			case "else":
			case "finally":
			case "for":
			case "if":
			case "in":
			case "instanceof":
			case "return":
			case "switch":
			case "throw":
			case "try":
			case "var":
			case "let":
			case "while":
			case "with":
				error("E024", state.tokens.next, state.tokens.next.value);
				return false;
			}
		}

		if (state.tokens.next.type === "(punctuator)") {
			switch (state.tokens.next.value) {
			case "}":
			case "]":
			case ",":
				if (opts.allowTrailing) {
					return true;
				}

				/* falls through */
			case ")":
				error("E024", state.tokens.next, state.tokens.next.value);
				return false;
			}
		}
		return true;
	}

	// Functional constructors for making the symbols that will be inherited by
	// tokens.

	function symbol(s, p) {
		var x = state.syntax[s];
		if (!x || typeof x !== "object") {
			state.syntax[s] = x = {
				id: s,
				lbp: p,
				value: s
			};
		}
		return x;
	}

	function delim(s) {
		return symbol(s, 0);
	}

	function stmt(s, f) {
		var x = delim(s);
		x.identifier = x.reserved = true;
		x.fud = f;
		return x;
	}

	function blockstmt(s, f) {
		var x = stmt(s, f);
		x.block = true;
		return x;
	}

	function reserveName(x) {
		var c = x.id.charAt(0);
		if ((c >= "a" && c <= "z") || (c >= "A" && c <= "Z")) {
			x.identifier = x.reserved = true;
		}
		return x;
	}

	function prefix(s, f) {
		var x = symbol(s, 150);
		reserveName(x);
		x.nud = (typeof f === "function") ? f : function () {
			this.right = expression(150);
			this.arity = "unary";
			if (this.id === "++" || this.id === "--") {
				if (state.option.plusplus) {
					warning("W016", this, this.id);
				} else if ((!this.right.identifier || isReserved(this.right)) &&
						this.right.id !== "." && this.right.id !== "[") {
					warning("W017", this);
				}
			}
			return this;
		};
		return x;
	}

	function type(s, f) {
		var x = delim(s);
		x.type = s;
		x.nud = f;
		return x;
	}

	function reserve(name, func) {
		var x = type(name, func);
		x.identifier = true;
		x.reserved = true;
		return x;
	}

	function FutureReservedWord(name, meta) {
		var x = type(name, (meta && meta.nud) || function () {
			return this;
		});

		meta = meta || {};
		meta.isFutureReservedWord = true;

		x.value = name;
		x.identifier = true;
		x.reserved = true;
		x.meta = meta;

		return x;
	}

	function reservevar(s, v) {
		return reserve(s, function () {
			if (typeof v === "function") {
				v(this);
			}
			return this;
		});
	}

	function infix(s, f, p, w) {
		var x = symbol(s, p);
		reserveName(x);
		x.infix = true;
		x.led = function (left) {
			if (!w) {
				nobreaknonadjacent(state.tokens.prev, state.tokens.curr);
				nonadjacent(state.tokens.curr, state.tokens.next);
			}
			if (s === "in" && left.id === "!") {
				warning("W018", left, "!");
			}
			if (typeof f === "function") {
				return f(left, this);
			} else {
				this.left = left;
				this.right = expression(p);
				return this;
			}
		};
		return x;
	}


	function application(s) {
		var x = symbol(s, 42);

		x.led = function (left) {
			if (!state.option.inESNext()) {
				warning("W104", state.tokens.curr, "arrow function syntax (=>)");
			}

			nobreaknonadjacent(state.tokens.prev, state.tokens.curr);
			nonadjacent(state.tokens.curr, state.tokens.next);

			this.left = left;
			this.right = doFunction(undefined, undefined, false, left);
			return this;
		};
		return x;
	}

	function relation(s, f) {
		var x = symbol(s, 100);

		x.led = function (left) {
			nobreaknonadjacent(state.tokens.prev, state.tokens.curr);
			nonadjacent(state.tokens.curr, state.tokens.next);
			var right = expression(100);

			if (isIdentifier(left, "NaN") || isIdentifier(right, "NaN")) {
				warning("W019", this);
			} else if (f) {
				f.apply(this, [left, right]);
			}

			if (!left || !right) {
				quit("E041", state.tokens.curr.line);
			}

			if (left.id === "!") {
				warning("W018", left, "!");
			}

			if (right.id === "!") {
				warning("W018", right, "!");
			}

			this.left = left;
			this.right = right;
			return this;
		};
		return x;
	}

	function isPoorRelation(node) {
		return node &&
			  ((node.type === "(number)" && +node.value === 0) ||
			   (node.type === "(string)" && node.value === "") ||
			   (node.type === "null" && !state.option.eqnull) ||
				node.type === "true" ||
				node.type === "false" ||
				node.type === "undefined");
	}

	// Checks whether the 'typeof' operator is used with the correct
	// value. For docs on 'typeof' see:
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof

	function isTypoTypeof(left, right) {
		if (state.option.notypeof)
			return false;

		if (!left || !right)
			return false;

		var values = [
			"undefined", "object", "boolean", "number",
			"string", "function", "xml", "object"
		];

		if (right.type === "(identifier)" && right.value === "typeof" && left.type === "(string)")
			return !_.contains(values, left.value);

		return false;
	}

	function findNativePrototype(left) {
		var natives = [
			"Array", "ArrayBuffer", "Boolean", "Collator", "DataView", "Date",
			"DateTimeFormat", "Error", "EvalError", "Float32Array", "Float64Array",
			"Function", "Infinity", "Intl", "Int16Array", "Int32Array", "Int8Array",
			"Iterator", "Number", "NumberFormat", "Object", "RangeError",
			"ReferenceError", "RegExp", "StopIteration", "String", "SyntaxError",
			"TypeError", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray",
			"URIError"
		];

		function walkPrototype(obj) {
			if (typeof obj !== "object") return;
			return obj.right === "prototype" ? obj : walkPrototype(obj.left);
		}

		function walkNative(obj) {
			while (!obj.identifier && typeof obj.left === "object")
			  obj = obj.left;

			if (obj.identifier && natives.indexOf(obj.value) >= 0)
			  return obj.value;
		}

		var prototype = walkPrototype(left);
		if (prototype) return walkNative(prototype);
	}

	function assignop(s, f, p) {
		var x = infix(s, typeof f === "function" ? f : function (left, that) {
			that.left = left;

			if (left) {
				if (state.option.freeze) {
					var nativeObject = findNativePrototype(left);
					if (nativeObject)
						warning("W121", left, nativeObject);
				}

				if (predefined[left.value] === false &&
						scope[left.value]["(global)"] === true) {
					warning("W020", left);
				} else if (left["function"]) {
					warning("W021", left, left.value);
				}

				if (funct[left.value] === "const") {
					error("E013", left, left.value);
				}

				if (left.id === ".") {
					if (!left.left) {
						warning("E031", that);
					} else if (left.left.value === "arguments" && !state.directive["use strict"]) {
						warning("E031", that);
					}

					that.right = expression(10);
					return that;
				} else if (left.id === "[") {
					if (state.tokens.curr.left.first) {
						state.tokens.curr.left.first.forEach(function (t) {
							if (funct[t.value] === "const") {
								error("E013", t, t.value);
							}
						});
					} else if (!left.left) {
						warning("E031", that);
					} else if (left.left.value === "arguments" && !state.directive["use strict"]) {
						warning("E031", that);
					}
					that.right = expression(10);
					return that;
				} else if (left.identifier && !isReserved(left)) {
					if (funct[left.value] === "exception") {
						warning("W022", left);
					}
					that.right = expression(10);
					return that;
				}

				if (left === state.syntax["function"]) {
					warning("W023", state.tokens.curr);
				}
			}

			error("E031", that);
		}, p);

		x.exps = true;
		x.assign = true;
		return x;
	}


	function bitwise(s, f, p) {
		var x = symbol(s, p);
		reserveName(x);
		x.led = (typeof f === "function") ? f : function (left) {
			if (state.option.bitwise) {
				warning("W016", this, this.id);
			}
			this.left = left;
			this.right = expression(p);
			return this;
		};
		return x;
	}


	function bitwiseassignop(s) {
		return assignop(s, function (left, that) {
			if (state.option.bitwise) {
				warning("W016", that, that.id);
			}
			nonadjacent(state.tokens.prev, state.tokens.curr);
			nonadjacent(state.tokens.curr, state.tokens.next);
			if (left) {
				if (left.id === "." || left.id === "[" ||
						(left.identifier && !isReserved(left))) {
					expression(10);
					return that;
				}
				if (left === state.syntax["function"]) {
					warning("W023", state.tokens.curr);
				}
				return that;
			}
			error("E031", that);
		}, 20);
	}


	function suffix(s) {
		var x = symbol(s, 150);

		x.led = function (left) {
			if (state.option.plusplus) {
				warning("W016", this, this.id);
			} else if ((!left.identifier || isReserved(left)) && left.id !== "." && left.id !== "[") {
				warning("W017", this);
			}

			this.left = left;
			return this;
		};
		return x;
	}

	// fnparam means that this identifier is being defined as a function
	// argument (see identifier())
	// prop means that this identifier is that of an object property

	function optionalidentifier(fnparam, prop) {
		if (!state.tokens.next.identifier) {
			return;
		}

		advance();

		var curr = state.tokens.curr;
		var val  = state.tokens.curr.value;

		if (!isReserved(curr)) {
			return val;
		}

		if (prop) {
			if (state.option.inES5()) {
				return val;
			}
		}

		if (fnparam && val === "undefined") {
			return val;
		}

		// Display an info message about reserved words as properties
		// and ES5 but do it only once.
		if (prop && !api.getCache("displayed:I002")) {
			api.setCache("displayed:I002", true);
			warning("I002");
		}

		warning("W024", state.tokens.curr, state.tokens.curr.id);
		return val;
	}

	// fnparam means that this identifier is being defined as a function
	// argument
	// prop means that this identifier is that of an object property
	function identifier(fnparam, prop) {
		var i = optionalidentifier(fnparam, prop);
		if (i) {
			return i;
		}
		if (state.tokens.curr.id === "function" && state.tokens.next.id === "(") {
			warning("W025");
		} else {
			error("E030", state.tokens.next, state.tokens.next.value);
		}
	}


	function reachable(s) {
		var i = 0, t;
		if (state.tokens.next.id !== ";" || noreach) {
			return;
		}
		for (;;) {
			do {
				t = peek(i);
				i += 1;
			} while (t.id != "(end)" && t.id === "(comment)");

			if (t.reach) {
				return;
			}
			if (t.id !== "(endline)") {
				if (t.id === "function") {
					if (state.option.latedef === true) {
						warning("W026", t);
					}
					break;
				}

				warning("W027", t, t.value, s);
				break;
			}
		}
	}


	function statement(noindent) {
		var values;
		var i = indent, r, s = scope, t = state.tokens.next;

		if (t.id === ";") {
			advance(";");
			return;
		}

		// Is this a labelled statement?
		var res = isReserved(t);

		// We're being more tolerant here: if someone uses
		// a FutureReservedWord as a label, we warn but proceed
		// anyway.

		if (res && t.meta && t.meta.isFutureReservedWord && peek().id === ":") {
			warning("W024", t, t.id);
			res = false;
		}

		// detect a destructuring assignment
		if (_.has(["[", "{"], t.value)) {
			if (lookupBlockType().isDestAssign) {
				if (!state.option.inESNext()) {
					warning("W104", state.tokens.curr, "destructuring expression");
				}
				values = destructuringExpression();
				values.forEach(function (tok) {
					isundef(funct, "W117", tok.token, tok.id);
				});
				advance("=");
				destructuringExpressionMatch(values, expression(10, true));
				advance(";");
				return;
			}
		}
		if (t.identifier && !res && peek().id === ":") {
			advance();
			advance(":");
			scope = Object.create(s);
			addlabel(t.value, "label");

			if (!state.tokens.next.labelled && state.tokens.next.value !== "{") {
				warning("W028", state.tokens.next, t.value, state.tokens.next.value);
			}

			state.tokens.next.label = t.value;
			t = state.tokens.next;
		}

		// Is it a lonely block?

		if (t.id === "{") {
			// Is it a switch case block?
			//
			//	switch (foo) {
			//		case bar: { <= here.
			//			...
			//		}
			//	}
			var iscase = (funct["(verb)"] === "case" && state.tokens.curr.value === ":");
			block(true, true, false, false, iscase);
			return;
		}

		// Parse the statement.

		if (!noindent) {
			indentation();
		}
		r = expression(0, true);

		// Look for the final semicolon.

		if (!t.block) {
			if (!state.option.expr && (!r || !r.exps)) {
				warning("W030", state.tokens.curr);
			} else if (state.option.nonew && r && r.left && r.id === "(" && r.left.id === "new") {
				warning("W031", t);
			}

			if (state.tokens.next.id !== ";") {
				if (!state.option.asi) {
					// If this is the last statement in a block that ends on
					// the same line *and* option lastsemic is on, ignore the warning.
					// Otherwise, complain about missing semicolon.
					if (!state.option.lastsemic || state.tokens.next.id !== "}" ||
						state.tokens.next.line !== state.tokens.curr.line) {
						warningAt("W033", state.tokens.curr.line, state.tokens.curr.character);
					}
				}
			} else {
				adjacent(state.tokens.curr, state.tokens.next);
				advance(";");
				nonadjacent(state.tokens.curr, state.tokens.next);
			}
		}

		// Restore the indentation.

		indent = i;
		scope = s;
		return r;
	}


	function statements(startLine) {
		var a = [], p;

		while (!state.tokens.next.reach && state.tokens.next.id !== "(end)") {
			if (state.tokens.next.id === ";") {
				p = peek();

				if (!p || (p.id !== "(" && p.id !== "[")) {
					warning("W032");
				}

				advance(";");
			} else {
				a.push(statement(startLine === state.tokens.next.line));
			}
		}
		return a;
	}


	/*
	 * read all directives
	 * recognizes a simple form of asi, but always
	 * warns, if it is used
	 */
	function directives() {
		var i, p, pn;

		for (;;) {
			if (state.tokens.next.id === "(string)") {
				p = peek(0);
				if (p.id === "(endline)") {
					i = 1;
					do {
						pn = peek(i);
						i = i + 1;
					} while (pn.id === "(endline)");

					if (pn.id !== ";") {
						if (pn.id !== "(string)" && pn.id !== "(number)" &&
							pn.id !== "(regexp)" && pn.identifier !== true &&
							pn.id !== "}") {
							break;
						}
						warning("W033", state.tokens.next);
					} else {
						p = pn;
					}
				} else if (p.id === "}") {
					// Directive with no other statements, warn about missing semicolon
					warning("W033", p);
				} else if (p.id !== ";") {
					break;
				}

				indentation();
				advance();
				if (state.directive[state.tokens.curr.value]) {
					warning("W034", state.tokens.curr, state.tokens.curr.value);
				}

				if (state.tokens.curr.value === "use strict") {
					if (!state.option["(explicitNewcap)"])
						state.option.newcap = true;
					state.option.undef = true;
				}

				// there's no directive negation, so always set to true
				state.directive[state.tokens.curr.value] = true;

				if (p.id === ";") {
					advance(";");
				}
				continue;
			}
			break;
		}
	}


	/*
	 * Parses a single block. A block is a sequence of statements wrapped in
	 * braces.
	 *
	 * ordinary     - true for everything but function bodies and try blocks.
	 * stmt		- true if block can be a single statement (e.g. in if/for/while).
	 * isfunc	- true if block is a function body
	 * isfatarrow   -
	 * iscase	- true if block is a switch case block
	 */
	function block(ordinary, stmt, isfunc, isfatarrow, iscase) {
		var a,
			b = inblock,
			old_indent = indent,
			m,
			s = scope,
			t,
			line,
			d;

		inblock = ordinary;

		if (!ordinary || !state.option.funcscope)
			scope = Object.create(scope);

		nonadjacent(state.tokens.curr, state.tokens.next);
		t = state.tokens.next;

		var metrics = funct["(metrics)"];
		metrics.nestedBlockDepth += 1;
		metrics.verifyMaxNestedBlockDepthPerFunction();

		if (state.tokens.next.id === "{") {
			advance("{");

			// create a new block scope
			funct["(blockscope)"].stack();

			line = state.tokens.curr.line;
			if (state.tokens.next.id !== "}") {
				indent += state.option.indent;
				while (!ordinary && state.tokens.next.from > indent) {
					indent += state.option.indent;
				}

				if (isfunc) {
					m = {};
					for (d in state.directive) {
						if (_.has(state.directive, d)) {
							m[d] = state.directive[d];
						}
					}
					directives();

					if (state.option.strict && funct["(context)"]["(global)"]) {
						if (!m["use strict"] && !state.directive["use strict"]) {
							warning("E007");
						}
					}
				}

				a = statements(line);

				metrics.statementCount += a.length;

				if (isfunc) {
					state.directive = m;
				}

				indent -= state.option.indent;
				if (line !== state.tokens.next.line) {
					indentation();
				}
			} else if (line !== state.tokens.next.line) {
				indentation();
			}
			advance("}", t);

			funct["(blockscope)"].unstack();

			indent = old_indent;
		} else if (!ordinary) {
			if (isfunc) {
				m = {};
				if (stmt && !isfatarrow && !state.option.inMoz(true)) {
					error("W118", state.tokens.curr, "function closure expressions");
				}

				if (!stmt) {
					for (d in state.directive) {
						if (_.has(state.directive, d)) {
							m[d] = state.directive[d];
						}
					}
				}
				expression(10);

				if (state.option.strict && funct["(context)"]["(global)"]) {
					if (!m["use strict"] && !state.directive["use strict"]) {
						warning("E007");
					}
				}
			} else {
				error("E021", state.tokens.next, "{", state.tokens.next.value);
			}
		} else {

			// check to avoid let declaration not within a block
			funct["(nolet)"] = true;

			if (!stmt || state.option.curly) {
				warning("W116", state.tokens.next, "{", state.tokens.next.value);
			}

			noreach = true;
			indent += state.option.indent;
			// test indentation only if statement is in new line
			a = [statement(state.tokens.next.line === state.tokens.curr.line)];
			indent -= state.option.indent;
			noreach = false;

			delete funct["(nolet)"];
		}
		// Don't clear and let it propagate out if it is "break", "return", or "throw" in switch case
		if (!(iscase && ["break", "return", "throw"].indexOf(funct["(verb)"]) != -1)) {
			funct["(verb)"] = null;
		}

		if (!ordinary || !state.option.funcscope) scope = s;
		inblock = b;
		if (ordinary && state.option.noempty && (!a || a.length === 0)) {
			warning("W035");
		}
		metrics.nestedBlockDepth -= 1;
		return a;
	}


	function countMember(m) {
		if (membersOnly && typeof membersOnly[m] !== "boolean") {
			warning("W036", state.tokens.curr, m);
		}
		if (typeof member[m] === "number") {
			member[m] += 1;
		} else {
			member[m] = 1;
		}
	}


	function note_implied(tkn) {
		var name = tkn.value, line = tkn.line, a = implied[name];
		if (typeof a === "function") {
			a = false;
		}

		if (!a) {
			a = [line];
			implied[name] = a;
		} else if (a[a.length - 1] !== line) {
			a.push(line);
		}
	}


	// Build the syntax table by declaring the syntactic elements of the language.

	type("(number)", function () {
		return this;
	});

	type("(string)", function () {
		return this;
	});

	state.syntax["(identifier)"] = {
		type: "(identifier)",
		lbp: 0,
		identifier: true,
		nud: function () {
			var v = this.value,
				s = scope[v],
				f;

			if (typeof s === "function") {
				// Protection against accidental inheritance.
				s = undefined;
			} else if (typeof s === "boolean") {
				f = funct;
				funct = functions[0];
				addlabel(v, "var");
				s = funct;
				funct = f;
			}
			var block;
			if (_.has(funct, "(blockscope)")) {
				block = funct["(blockscope)"].getlabel(v);
			}

			// The name is in scope and defined in the current function.
			if (funct === s || block) {
				// Change 'unused' to 'var', and reject labels.
				// the name is in a block scope
				switch (block ? block[v]["(type)"] : funct[v]) {
				case "unused":
					if (block) block[v]["(type)"] = "var";
					else funct[v] = "var";
					break;
				case "unction":
					if (block) block[v]["(type)"] = "function";
					else funct[v] = "function";
					this["function"] = true;
					break;
				case "function":
					this["function"] = true;
					break;
				case "label":
					warning("W037", state.tokens.curr, v);
					break;
				}
			} else if (funct["(global)"]) {
				// The name is not defined in the function.  If we are in the global
				// scope, then we have an undefined variable.
				//
				// Operators typeof and delete do not raise runtime errors even if
				// the base object of a reference is null so no need to display warning
				// if we're inside of typeof or delete.

				if (typeof predefined[v] !== "boolean") {
					// Attempting to subscript a null reference will throw an
					// error, even within the typeof and delete operators
					if (!(anonname === "typeof" || anonname === "delete") ||
						(state.tokens.next && (state.tokens.next.value === "." ||
							state.tokens.next.value === "["))) {

						// if we're in a list comprehension, variables are declared
						// locally and used before being defined. So we check
						// the presence of the given variable in the comp array
						// before declaring it undefined.

						if (!funct["(comparray)"].check(v)) {
							isundef(funct, "W117", state.tokens.curr, v);
						}
					}
				}

				note_implied(state.tokens.curr);
			} else {
				// If the name is already defined in the current
				// function, but not as outer, then there is a scope error.

				switch (funct[v]) {
				case "closure":
				case "function":
				case "var":
				case "unused":
					warning("W038", state.tokens.curr, v);
					break;
				case "label":
					warning("W037", state.tokens.curr, v);
					break;
				case "outer":
				case "global":
					break;
				default:
					// If the name is defined in an outer function, make an outer entry,
					// and if it was unused, make it var.
					if (s === true) {
						funct[v] = true;
					} else if (s === null) {
						warning("W039", state.tokens.curr, v);
						note_implied(state.tokens.curr);
					} else if (typeof s !== "object") {
						// Operators typeof and delete do not raise runtime errors even
						// if the base object of a reference is null so no need to
						//
						// display warning if we're inside of typeof or delete.
						// Attempting to subscript a null reference will throw an
						// error, even within the typeof and delete operators
						if (!(anonname === "typeof" || anonname === "delete") ||
							(state.tokens.next &&
								(state.tokens.next.value === "." || state.tokens.next.value === "["))) {

							isundef(funct, "W117", state.tokens.curr, v);
						}
						funct[v] = true;
						note_implied(state.tokens.curr);
					} else {
						switch (s[v]) {
						case "function":
						case "unction":
							this["function"] = true;
							s[v] = "closure";
							funct[v] = s["(global)"] ? "global" : "outer";
							break;
						case "var":
						case "unused":
							s[v] = "closure";
							funct[v] = s["(global)"] ? "global" : "outer";
							break;
						case "closure":
							funct[v] = s["(global)"] ? "global" : "outer";
							break;
						case "label":
							warning("W037", state.tokens.curr, v);
						}
					}
				}
			}
			return this;
		},
		led: function () {
			error("E033", state.tokens.next, state.tokens.next.value);
		}
	};

	type("(regexp)", function () {
		return this;
	});

	// ECMAScript parser

	delim("(endline)");
	delim("(begin)");
	delim("(end)").reach = true;
	delim("(error)").reach = true;
	delim("}").reach = true;
	delim(")");
	delim("]");
	delim("\"").reach = true;
	delim("'").reach = true;
	delim(";");
	delim(":").reach = true;
	delim("#");

	reserve("else");
	reserve("case").reach = true;
	reserve("catch");
	reserve("default").reach = true;
	reserve("finally");
	reservevar("arguments", function (x) {
		if (state.directive["use strict"] && funct["(global)"]) {
			warning("E008", x);
		}
	});
	reservevar("eval");
	reservevar("false");
	reservevar("Infinity");
	reservevar("null");
	reservevar("this", function (x) {
		if (state.directive["use strict"] && !state.option.validthis && ((funct["(statement)"] &&
				funct["(name)"].charAt(0) > "Z") || funct["(global)"])) {
			warning("W040", x);
		}
	});
	reservevar("true");
	reservevar("undefined");

	assignop("=", "assign", 20);
	assignop("+=", "assignadd", 20);
	assignop("-=", "assignsub", 20);
	assignop("*=", "assignmult", 20);
	assignop("/=", "assigndiv", 20).nud = function () {
		error("E014");
	};
	assignop("%=", "assignmod", 20);

	bitwiseassignop("&=", "assignbitand", 20);
	bitwiseassignop("|=", "assignbitor", 20);
	bitwiseassignop("^=", "assignbitxor", 20);
	bitwiseassignop("<<=", "assignshiftleft", 20);
	bitwiseassignop(">>=", "assignshiftright", 20);
	bitwiseassignop(">>>=", "assignshiftrightunsigned", 20);
	infix(",", function (left, that) {
		var expr;
		that.exprs = [left];
		if (!comma({peek: true})) {
			return that;
		}
		while (true) {
			if (!(expr = expression(10)))  {
				break;
			}
			that.exprs.push(expr);
			if (state.tokens.next.value !== "," || !comma()) {
				break;
			}
		}
		return that;
	}, 10, true);

	infix("?", function (left, that) {
		increaseComplexityCount();
		that.left = left;
		that.right = expression(10);
		advance(":");
		that["else"] = expression(10);
		return that;
	}, 30);

	var orPrecendence = 40;
	infix("||", function (left, that) {
		increaseComplexityCount();
		that.left = left;
		that.right = expression(orPrecendence);
		return that;
	}, orPrecendence);
	infix("&&", "and", 50);
	bitwise("|", "bitor", 70);
	bitwise("^", "bitxor", 80);
	bitwise("&", "bitand", 90);
	relation("==", function (left, right) {
		var eqnull = state.option.eqnull && (left.value === "null" || right.value === "null");

		if (!eqnull && state.option.eqeqeq)
			warning("W116", this, "===", "==");
		else if (isPoorRelation(left))
			warning("W041", this, "===", left.value);
		else if (isPoorRelation(right))
			warning("W041", this, "===", right.value);
		else if (isTypoTypeof(right, left))
			warning("W122", this, right.value);
		else if (isTypoTypeof(left, right))
			warning("W122", this, left.value);
		return this;
	});
	relation("===", function (left, right) {
		if (isTypoTypeof(right, left)) {
			warning("W122", this, right.value);
		} else if (isTypoTypeof(left, right)) {
			warning("W122", this, left.value);
		}
		return this;
	});
	relation("!=", function (left, right) {
		var eqnull = state.option.eqnull &&
				(left.value === "null" || right.value === "null");

		if (!eqnull && state.option.eqeqeq) {
			warning("W116", this, "!==", "!=");
		} else if (isPoorRelation(left)) {
			warning("W041", this, "!==", left.value);
		} else if (isPoorRelation(right)) {
			warning("W041", this, "!==", right.value);
		} else if (isTypoTypeof(right, left)) {
			warning("W122", this, right.value);
		} else if (isTypoTypeof(left, right)) {
			warning("W122", this, left.value);
		}
		return this;
	});
	relation("!==", function (left, right) {
		if (isTypoTypeof(right, left)) {
			warning("W122", this, right.value);
		} else if (isTypoTypeof(left, right)) {
			warning("W122", this, left.value);
		}
		return this;
	});
	relation("<");
	relation(">");
	relation("<=");
	relation(">=");
	bitwise("<<", "shiftleft", 120);
	bitwise(">>", "shiftright", 120);
	bitwise(">>>", "shiftrightunsigned", 120);
	infix("in", "in", 120);
	infix("instanceof", "instanceof", 120);
	infix("+", function (left, that) {
		var right = expression(130);
		if (left && right && left.id === "(string)" && right.id === "(string)") {
			left.value += right.value;
			left.character = right.character;
			if (!state.option.scripturl && reg.javascriptURL.test(left.value)) {
				warning("W050", left);
			}
			return left;
		}
		that.left = left;
		that.right = right;
		return that;
	}, 130);
	prefix("+", "num");
	prefix("+++", function () {
		warning("W007");
		this.right = expression(150);
		this.arity = "unary";
		return this;
	});
	infix("+++", function (left) {
		warning("W007");
		this.left = left;
		this.right = expression(130);
		return this;
	}, 130);
	infix("-", "sub", 130);
	prefix("-", "neg");
	prefix("---", function () {
		warning("W006");
		this.right = expression(150);
		this.arity = "unary";
		return this;
	});
	infix("---", function (left) {
		warning("W006");
		this.left = left;
		this.right = expression(130);
		return this;
	}, 130);
	infix("*", "mult", 140);
	infix("/", "div", 140);
	infix("%", "mod", 140);

	suffix("++", "postinc");
	prefix("++", "preinc");
	state.syntax["++"].exps = true;

	suffix("--", "postdec");
	prefix("--", "predec");
	state.syntax["--"].exps = true;
	prefix("delete", function () {
		var p = expression(10);
		if (!p || (p.id !== "." && p.id !== "[")) {
			warning("W051");
		}
		this.first = p;
		return this;
	}).exps = true;

	prefix("~", function () {
		if (state.option.bitwise) {
			warning("W052", this, "~");
		}
		expression(150);
		return this;
	});

	prefix("...", function () {
		if (!state.option.inESNext()) {
			warning("W104", this, "spread/rest operator");
		}
		if (!state.tokens.next.identifier) {
			error("E030", state.tokens.next, state.tokens.next.value);
		}
		expression(150);
		return this;
	});

	prefix("!", function () {
		this.right = expression(150);
		this.arity = "unary";

		if (!this.right) { // '!' followed by nothing? Give up.
			quit("E041", this.line || 0);
		}

		if (bang[this.right.id] === true) {
			warning("W018", this, "!");
		}
		return this;
	});

	prefix("typeof", "typeof");
	prefix("new", function () {
		var c = expression(155), i;
		if (c && c.id !== "function") {
			if (c.identifier) {
				c["new"] = true;
				switch (c.value) {
				case "Number":
				case "String":
				case "Boolean":
				case "Math":
				case "JSON":
					warning("W053", state.tokens.prev, c.value);
					break;
				case "Function":
					if (!state.option.evil) {
						warning("W054");
					}
					break;
				case "Date":
				case "RegExp":
				case "this":
					break;
				default:
					if (c.id !== "function") {
						i = c.value.substr(0, 1);
						if (state.option.newcap && (i < "A" || i > "Z") && !_.has(global, c.value)) {
							warning("W055", state.tokens.curr);
						}
					}
				}
			} else {
				if (c.id !== "." && c.id !== "[" && c.id !== "(") {
					warning("W056", state.tokens.curr);
				}
			}
		} else {
			if (!state.option.supernew)
				warning("W057", this);
		}
		adjacent(state.tokens.curr, state.tokens.next);
		if (state.tokens.next.id !== "(" && !state.option.supernew) {
			warning("W058", state.tokens.curr, state.tokens.curr.value);
		}
		this.first = c;
		return this;
	});
	state.syntax["new"].exps = true;

	prefix("void").exps = true;

	infix(".", function (left, that) {
		adjacent(state.tokens.prev, state.tokens.curr);
		nobreak();
		var m = identifier(false, true);

		if (typeof m === "string") {
			countMember(m);
		}

		that.left = left;
		that.right = m;

		if (m && m === "hasOwnProperty" && state.tokens.next.value === "=") {
			warning("W001");
		}

		if (left && left.value === "arguments" && (m === "callee" || m === "caller")) {
			if (state.option.noarg)
				warning("W059", left, m);
			else if (state.directive["use strict"])
				error("E008");
		} else if (!state.option.evil && left && left.value === "document" &&
				(m === "write" || m === "writeln")) {
			warning("W060", left);
		}

		if (!state.option.evil && (m === "eval" || m === "execScript")) {
			warning("W061");
		}

		return that;
	}, 160, true);

	infix("(", function (left, that) {
		if (state.tokens.prev.id !== "}" && state.tokens.prev.id !== ")") {
			nobreak(state.tokens.prev, state.tokens.curr);
		}

		nospace();
		if (state.option.immed && left && !left.immed && left.id === "function") {
			warning("W062");
		}

		var n = 0;
		var p = [];

		if (left) {
			if (left.type === "(identifier)") {
				if (left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {
					if ("Number String Boolean Date Object".indexOf(left.value) === -1) {
						if (left.value === "Math") {
							warning("W063", left);
						} else if (state.option.newcap) {
							warning("W064", left);
						}
					}
				}
			}
		}

		if (state.tokens.next.id !== ")") {
			for (;;) {
				p[p.length] = expression(10);
				n += 1;
				if (state.tokens.next.id !== ",") {
					break;
				}
				comma();
			}
		}

		advance(")");
		nospace(state.tokens.prev, state.tokens.curr);

		if (typeof left === "object") {
			if (state.option.inES3() && left.value === "parseInt" && n === 1) {
				warning("W065", state.tokens.curr);
			}
			if (!state.option.evil) {
				if (left.value === "eval" || left.value === "Function" ||
						left.value === "execScript") {
					warning("W061", left);

					if (p[0] && [0].id === "(string)") {
						addInternalSrc(left, p[0].value);
					}
				} else if (p[0] && p[0].id === "(string)" &&
					   (left.value === "setTimeout" ||
						left.value === "setInterval")) {
					warning("W066", left);
					addInternalSrc(left, p[0].value);

				// window.setTimeout/setInterval
				} else if (p[0] && p[0].id === "(string)" &&
					   left.value === "." &&
					   left.left.value === "window" &&
					   (left.right === "setTimeout" ||
						left.right === "setInterval")) {
					warning("W066", left);
					addInternalSrc(left, p[0].value);
				}
			}
			if (!left.identifier && left.id !== "." && left.id !== "[" &&
					left.id !== "(" && left.id !== "&&" && left.id !== "||" &&
					left.id !== "?") {
				warning("W067", left);
			}
		}

		that.left = left;
		return that;
	}, 155, true).exps = true;

	prefix("(", function () {
		nospace();
		var bracket, brackets = [];
		var pn, pn1, i = 0;
		var ret;

		do {
			pn = peek(i);
			i += 1;
			pn1 = peek(i);
			i += 1;
		} while (pn.value !== ")" && pn1.value !== "=>" && pn1.value !== ";" && pn1.type !== "(end)");

		if (state.tokens.next.id === "function") {
			state.tokens.next.immed = true;
		}

		var exprs = [];

		if (state.tokens.next.id !== ")") {
			for (;;) {
				if (pn1.value === "=>" && state.tokens.next.value === "{") {
					bracket = state.tokens.next;
					bracket.left = destructuringExpression();
					brackets.push(bracket);
					for (var t in bracket.left) {
						exprs.push(bracket.left[t].token);
					}
				} else {
					exprs.push(expression(10));
				}
				if (state.tokens.next.id !== ",") {
					break;
				}
				comma();
			}
		}

		advance(")", this);
		nospace(state.tokens.prev, state.tokens.curr);
		if (state.option.immed && exprs[0] && exprs[0].id === "function") {
			if (state.tokens.next.id !== "(" &&
			  (state.tokens.next.id !== "." || (peek().value !== "call" && peek().value !== "apply"))) {
				warning("W068", this);
			}
		}

		if (state.tokens.next.value === "=>") {
			return exprs;
		}
		if (!exprs.length) {
			return;
		}
		if (exprs.length > 1) {
			ret = Object.create(state.syntax[","]);
			ret.exprs = exprs;
		} else {
			ret = exprs[0];
		}
		if (ret) {
			ret.paren = true;
		}
		return ret;
	});

	application("=>");

	infix("[", function (left, that) {
		nobreak(state.tokens.prev, state.tokens.curr);
		nospace();
		var e = expression(10), s;
		if (e && e.type === "(string)") {
			if (!state.option.evil && (e.value === "eval" || e.value === "execScript")) {
				warning("W061", that);
			}

			countMember(e.value);
			if (!state.option.sub && reg.identifier.test(e.value)) {
				s = state.syntax[e.value];
				if (!s || !isReserved(s)) {
					warning("W069", state.tokens.prev, e.value);
				}
			}
		}
		advance("]", that);

		if (e && e.value === "hasOwnProperty" && state.tokens.next.value === "=") {
			warning("W001");
		}

		nospace(state.tokens.prev, state.tokens.curr);
		that.left = left;
		that.right = e;
		return that;
	}, 160, true);

	function comprehensiveArrayExpression() {
		var res = {};
		res.exps = true;
		funct["(comparray)"].stack();

		// Handle reversed for expressions, used in spidermonkey
		var reversed = false;
		if (state.tokens.next.value !== "for") {
			reversed = true;
			if (!state.option.inMoz(true)) {
				warning("W116", state.tokens.next, "for", state.tokens.next.value);
			}
			funct["(comparray)"].setState("use");
			res.right = expression(10);
		}

		advance("for");
		if (state.tokens.next.value === "each") {
			advance("each");
			if (!state.option.inMoz(true)) {
				warning("W118", state.tokens.curr, "for each");
			}
		}
		advance("(");
		funct["(comparray)"].setState("define");
		res.left = expression(130);
		if (_.contains(["in", "of"], state.tokens.next.value)) {
			advance();
		} else {
			error("E045", state.tokens.curr);
		}
		funct["(comparray)"].setState("generate");
		expression(10);

		advance(")");
		if (state.tokens.next.value === "if") {
			advance("if");
			advance("(");
			funct["(comparray)"].setState("filter");
			res.filter = expression(10);
			advance(")");
		}

		if (!reversed) {
			funct["(comparray)"].setState("use");
			res.right = expression(10);
		}

		advance("]");
		funct["(comparray)"].unstack();
		return res;
	}

	prefix("[", function () {
		var blocktype = lookupBlockType(true);
		if (blocktype.isCompArray) {
			if (!state.option.inESNext()) {
				warning("W119", state.tokens.curr, "array comprehension");
			}
			return comprehensiveArrayExpression();
		} else if (blocktype.isDestAssign && !state.option.inESNext()) {
			warning("W104", state.tokens.curr, "destructuring assignment");
		}
		var b = state.tokens.curr.line !== state.tokens.next.line;
		this.first = [];
		if (b) {
			indent += state.option.indent;
			if (state.tokens.next.from === indent + state.option.indent) {
				indent += state.option.indent;
			}
		}
		while (state.tokens.next.id !== "(end)") {
			while (state.tokens.next.id === ",") {
				if (!state.option.inES5())
					warning("W070");
				advance(",");
			}
			if (state.tokens.next.id === "]") {
				break;
			}
			if (b && state.tokens.curr.line !== state.tokens.next.line) {
				indentation();
			}
			this.first.push(expression(10));
			if (state.tokens.next.id === ",") {
				comma({ allowTrailing: true });
				if (state.tokens.next.id === "]" && !state.option.inES5(true)) {
					warning("W070", state.tokens.curr);
					break;
				}
			} else {
				break;
			}
		}
		if (b) {
			indent -= state.option.indent;
			indentation();
		}
		advance("]", this);
		return this;
	}, 160);


	function property_name() {
		var id = optionalidentifier(false, true);

		if (!id) {
			if (state.tokens.next.id === "(string)") {
				id = state.tokens.next.value;
				advance();
			} else if (state.tokens.next.id === "(number)") {
				id = state.tokens.next.value.toString();
				advance();
			}
		}

		if (id === "hasOwnProperty") {
			warning("W001");
		}

		return id;
	}


	function functionparams(parsed) {
		var curr, next;
		var params = [];
		var ident;
		var tokens = [];
		var t;
		var pastDefault = false;

		if (parsed) {
			if (parsed instanceof Array) {
				for (var i in parsed) {
					curr = parsed[i];
					if (_.contains(["{", "["], curr.id)) {
						for (t in curr.left) {
							t = tokens[t];
							if (t.id) {
								params.push(t.id);
								addlabel(t.id, "unused", t.token);
							}
						}
					} else if (curr.value === "...") {
						if (!state.option.inESNext()) {
							warning("W104", curr, "spread/rest operator");
						}
						continue;
					} else {
						addlabel(curr.value, "unused", curr);
					}
				}
				return params;
			} else {
				if (parsed.identifier === true) {
					addlabel(parsed.value, "unused", parsed);
					return [parsed];
				}
			}
		}

		next = state.tokens.next;

		advance("(");
		nospace();

		if (state.tokens.next.id === ")") {
			advance(")");
			return;
		}

		for (;;) {
			if (_.contains(["{", "["], state.tokens.next.id)) {
				tokens = destructuringExpression();
				for (t in tokens) {
					t = tokens[t];
					if (t.id) {
						params.push(t.id);
						addlabel(t.id, "unused", t.token);
					}
				}
			} else if (state.tokens.next.value === "...") {
				if (!state.option.inESNext()) {
					warning("W104", state.tokens.next, "spread/rest operator");
				}
				advance("...");
				nospace();
				ident = identifier(true);
				params.push(ident);
				addlabel(ident, "unused", state.tokens.curr);
			} else {
				ident = identifier(true);
				params.push(ident);
				addlabel(ident, "unused", state.tokens.curr);
			}

			// it is a syntax error to have a regular argument after a default argument
			if (pastDefault) {
				if (state.tokens.next.id !== "=") {
					error("E051", state.tokens.current);
				}
			}
			if (state.tokens.next.id === "=") {
				if (!state.option.inESNext()) {
					warning("W119", state.tokens.next, "default parameters");
				}
				advance("=");
				pastDefault = true;
				expression(10);
			}
			if (state.tokens.next.id === ",") {
				comma();
			} else {
				advance(")", next);
				nospace(state.tokens.prev, state.tokens.curr);
				return params;
			}
		}
	}


	function doFunction(name, statement, generator, fatarrowparams) {
		var f;
		var oldOption = state.option;
		var oldIgnored = state.ignored;
		var oldScope  = scope;

		state.option = Object.create(state.option);
		state.ignored = Object.create(state.ignored);
		scope  = Object.create(scope);

		funct = {
			"(name)"      : name || "\"" + anonname + "\"",
			"(line)"      : state.tokens.next.line,
			"(character)" : state.tokens.next.character,
			"(context)"   : funct,
			"(breakage)"  : 0,
			"(loopage)"   : 0,
			"(metrics)"   : createMetrics(state.tokens.next),
			"(scope)"     : scope,
			"(statement)" : statement,
			"(tokens)"    : {},
			"(blockscope)": funct["(blockscope)"],
			"(comparray)" : funct["(comparray)"]
		};

		if (generator) {
			funct["(generator)"] = true;
		}

		f = funct;
		state.tokens.curr.funct = funct;

		functions.push(funct);

		if (name) {
			addlabel(name, "function");
		}

		funct["(params)"] = functionparams(fatarrowparams);
		funct["(metrics)"].verifyMaxParametersPerFunction(funct["(params)"]);

		block(false, true, true, fatarrowparams ? true:false);

		if (generator && funct["(generator)"] !== "yielded") {
			error("E047", state.tokens.curr);
		}

		funct["(metrics)"].verifyMaxStatementsPerFunction();
		funct["(metrics)"].verifyMaxComplexityPerFunction();
		funct["(unusedOption)"] = state.option.unused;

		scope = oldScope;
		state.option = oldOption;
		state.ignored = oldIgnored;
		funct["(last)"] = state.tokens.curr.line;
		funct["(lastcharacter)"] = state.tokens.curr.character;
		funct = funct["(context)"];

		return f;
	}

	function createMetrics(functionStartToken) {
		return {
			statementCount: 0,
			nestedBlockDepth: -1,
			ComplexityCount: 1,

			verifyMaxStatementsPerFunction: function () {
				if (state.option.maxstatements &&
					this.statementCount > state.option.maxstatements) {
					warning("W071", functionStartToken, this.statementCount);
				}
			},

			verifyMaxParametersPerFunction: function (params) {
				params = params || [];

				if (state.option.maxparams && params.length > state.option.maxparams) {
					warning("W072", functionStartToken, params.length);
				}
			},

			verifyMaxNestedBlockDepthPerFunction: function () {
				if (state.option.maxdepth &&
					this.nestedBlockDepth > 0 &&
					this.nestedBlockDepth === state.option.maxdepth + 1) {
					warning("W073", null, this.nestedBlockDepth);
				}
			},

			verifyMaxComplexityPerFunction: function () {
				var max = state.option.maxcomplexity;
				var cc = this.ComplexityCount;
				if (max && cc > max) {
					warning("W074", functionStartToken, cc);
				}
			}
		};
	}

	function increaseComplexityCount() {
		funct["(metrics)"].ComplexityCount += 1;
	}

	// Parse assignments that were found instead of conditionals.
	// For example: if (a = 1) { ... }

	function checkCondAssignment(expr) {
		var id, paren;
		if (expr) {
			id = expr.id;
			paren = expr.paren;
			if (id === "," && (expr = expr.exprs[expr.exprs.length - 1])) {
				id = expr.id;
				paren = paren || expr.paren;
			}
		}
		switch (id) {
		case "=":
		case "+=":
		case "-=":
		case "*=":
		case "%=":
		case "&=":
		case "|=":
		case "^=":
		case "/=":
			if (!paren && !state.option.boss) {
				warning("W084");
			}
		}
	}


	(function (x) {
		x.nud = function (isclassdef) {
			var b, f, i, p, t, g;
			var props = {}; // All properties, including accessors
			var tag = "";

			function saveProperty(name, tkn) {
				if (props[name] && _.has(props, name))
					warning("W075", state.tokens.next, i);
				else
					props[name] = {};

				props[name].basic = true;
				props[name].basictkn = tkn;
			}

			function saveSetter(name, tkn) {
				if (props[name] && _.has(props, name)) {
					if (props[name].basic || props[name].setter)
						warning("W075", state.tokens.next, i);
				} else {
					props[name] = {};
				}

				props[name].setter = true;
				props[name].setterToken = tkn;
			}

			function saveGetter(name) {
				if (props[name] && _.has(props, name)) {
					if (props[name].basic || props[name].getter)
						warning("W075", state.tokens.next, i);
				} else {
					props[name] = {};
				}

				props[name].getter = true;
				props[name].getterToken = state.tokens.curr;
			}

			b = state.tokens.curr.line !== state.tokens.next.line;
			if (b) {
				indent += state.option.indent;
				if (state.tokens.next.from === indent + state.option.indent) {
					indent += state.option.indent;
				}
			}

			for (;;) {
				if (state.tokens.next.id === "}") {
					break;
				}

				if (b) {
					indentation();
				}

				if (isclassdef && state.tokens.next.value === "static") {
					advance("static");
					tag = "static ";
				}

				if (state.tokens.next.value === "get" && peek().id !== ":") {
					advance("get");

					if (!state.option.inES5(!isclassdef)) {
						error("E034");
					}

					i = property_name();
					if (!i) {
						error("E035");
					}

					// It is a Syntax Error if PropName of MethodDefinition is
					// "constructor" and SpecialMethod of MethodDefinition is true.
					if (isclassdef && i === "constructor") {
						error("E049", state.tokens.next, "class getter method", i);
					}

					saveGetter(tag + i);
					t = state.tokens.next;
					adjacent(state.tokens.curr, state.tokens.next);
					f = doFunction();
					p = f["(params)"];

					if (p) {
						warning("W076", t, p[0], i);
					}

					adjacent(state.tokens.curr, state.tokens.next);
				} else if (state.tokens.next.value === "set" && peek().id !== ":") {
					advance("set");

					if (!state.option.inES5(!isclassdef)) {
						error("E034");
					}

					i = property_name();
					if (!i) {
						error("E035");
					}

					// It is a Syntax Error if PropName of MethodDefinition is
					// "constructor" and SpecialMethod of MethodDefinition is true.
					if (isclassdef && i === "constructor") {
						error("E049", state.tokens.next, "class setter method", i);
					}

					saveSetter(tag + i, state.tokens.next);
					t = state.tokens.next;
					adjacent(state.tokens.curr, state.tokens.next);
					f = doFunction();
					p = f["(params)"];

					if (!p || p.length !== 1) {
						warning("W077", t, i);
					}
				} else {
					g = false;
					if (state.tokens.next.value === "*" && state.tokens.next.type === "(punctuator)") {
						if (!state.option.inESNext()) {
							warning("W104", state.tokens.next, "generator functions");
						}
						advance("*");
						g = true;
					}
					i = property_name();
					saveProperty(tag + i, state.tokens.next);

					if (typeof i !== "string") {
						break;
					}

					if (state.tokens.next.value === "(") {
						if (!state.option.inESNext()) {
							warning("W104", state.tokens.curr, "concise methods");
						}
						doFunction(i, undefined, g);
					} else if (!isclassdef) {
						advance(":");
						nonadjacent(state.tokens.curr, state.tokens.next);
						expression(10);
					}
				}
				// It is a Syntax Error if PropName of MethodDefinition is "prototype".
				if (isclassdef && i === "prototype") {
					error("E049", state.tokens.next, "class method", i);
				}

				countMember(i);
				if (isclassdef) {
					tag = "";
					continue;
				}
				if (state.tokens.next.id === ",") {
					comma({ allowTrailing: true, property: true });
					if (state.tokens.next.id === ",") {
						warning("W070", state.tokens.curr);
					} else if (state.tokens.next.id === "}" && !state.option.inES5(true)) {
						warning("W070", state.tokens.curr);
					}
				} else {
					break;
				}
			}
			if (b) {
				indent -= state.option.indent;
				indentation();
			}
			advance("}", this);

			// Check for lonely setters if in the ES5 mode.
			if (state.option.inES5()) {
				for (var name in props) {
					if (_.has(props, name) && props[name].setter && !props[name].getter) {
						warning("W078", props[name].setterToken);
					}
				}
			}
			return this;
		};
		x.fud = function () {
			error("E036", state.tokens.curr);
		};
	}(delim("{")));

	function destructuringExpression() {
		var id, ids;
		var identifiers = [];
		if (!state.option.inESNext()) {
			warning("W104", state.tokens.curr, "destructuring expression");
		}
		var nextInnerDE = function () {
			var ident;
			if (_.contains(["[", "{"], state.tokens.next.value)) {
				ids = destructuringExpression();
				for (var id in ids) {
					id = ids[id];
					identifiers.push({ id: id.id, token: id.token });
				}
			} else if (state.tokens.next.value === ",") {
				identifiers.push({ id: null, token: state.tokens.curr });
			} else {
				ident = identifier();
				if (ident)
					identifiers.push({ id: ident, token: state.tokens.curr });
			}
		};
		if (state.tokens.next.value === "[") {
			advance("[");
			nextInnerDE();
			while (state.tokens.next.value !== "]") {
				advance(",");
				nextInnerDE();
			}
			advance("]");
		} else if (state.tokens.next.value === "{") {
			advance("{");
			id = identifier();
			if (state.tokens.next.value === ":") {
				advance(":");
				nextInnerDE();
			} else {
				identifiers.push({ id: id, token: state.tokens.curr });
			}
			while (state.tokens.next.value !== "}") {
				advance(",");
				id = identifier();
				if (state.tokens.next.value === ":") {
					advance(":");
					nextInnerDE();
				} else {
					identifiers.push({ id: id, token: state.tokens.curr });
				}
			}
			advance("}");
		}
		return identifiers;
	}
	function destructuringExpressionMatch(tokens, value) {
		if (value.first) {
			_.zip(tokens, value.first).forEach(function (val) {
				var token = val[0];
				var value = val[1];
				if (token && value) {
					token.first = value;
				} else if (token && token.first && !value) {
					warning("W080", token.first, token.first.value);
				} /* else {
					XXX value is discarded: wouldn't it need a warning ?
				} */
			});
		}
	}

	var conststatement = stmt("const", function (prefix) {
		var tokens, value;
		// state variable to know if it is a lone identifier, or a destructuring statement.
		var lone;

		if (!state.option.inESNext()) {
			warning("W104", state.tokens.curr, "const");
		}

		this.first = [];
		for (;;) {
			var names = [];
			nonadjacent(state.tokens.curr, state.tokens.next);
			if (_.contains(["{", "["], state.tokens.next.value)) {
				tokens = destructuringExpression();
				lone = false;
			} else {
				tokens = [ { id: identifier(), token: state.tokens.curr } ];
				lone = true;
			}
			for (var t in tokens) {
				t = tokens[t];
				if (funct[t.id] === "const") {
					warning("E011", null, t.id);
				}
				if (funct["(global)"] && predefined[t.id] === false) {
					warning("W079", t.token, t.id);
				}
				if (t.id) {
					addlabel(t.id, "const");
					names.push(t.token);
				}
			}
			if (prefix) {
				break;
			}

			this.first = this.first.concat(names);

			if (state.tokens.next.id !== "=") {
				warning("E012", state.tokens.curr, state.tokens.curr.value);
			}

			if (state.tokens.next.id === "=") {
				nonadjacent(state.tokens.curr, state.tokens.next);
				advance("=");
				nonadjacent(state.tokens.curr, state.tokens.next);
				if (state.tokens.next.id === "undefined") {
					warning("W080", state.tokens.prev, state.tokens.prev.value);
				}
				if (peek(0).id === "=" && state.tokens.next.identifier) {
					warning("W120", state.tokens.next, state.tokens.next.value);
				}
				value = expression(10);
				if (lone) {
					tokens[0].first = value;
				} else {
					destructuringExpressionMatch(names, value);
				}
			}

			if (state.tokens.next.id !== ",") {
				break;
			}
			comma();
		}
		return this;
	});
	conststatement.exps = true;
	var varstatement = stmt("var", function (prefix) {
		// JavaScript does not have block scope. It only has function scope. So,
		// declaring a variable in a block can have unexpected consequences.
		var tokens, lone, value;

		if (funct["(onevar)"] && state.option.onevar) {
			warning("W081");
		} else if (!funct["(global)"]) {
			funct["(onevar)"] = true;
		}

		this.first = [];
		for (;;) {
			var names = [];
			nonadjacent(state.tokens.curr, state.tokens.next);
			if (_.contains(["{", "["], state.tokens.next.value)) {
				tokens = destructuringExpression();
				lone = false;
			} else {
				tokens = [ { id: identifier(), token: state.tokens.curr } ];
				lone = true;
			}
			for (var t in tokens) {
				t = tokens[t];
				if (state.option.inESNext() && funct[t.id] === "const") {
					warning("E011", null, t.id);
				}
				if (funct["(global)"] && predefined[t.id] === false) {
					warning("W079", t.token, t.id);
				}
				if (t.id) {
					addlabel(t.id, "unused", t.token);
					names.push(t.token);
				}
			}
			if (prefix) {
				break;
			}

			this.first = this.first.concat(names);

			if (state.tokens.next.id === "=") {
				nonadjacent(state.tokens.curr, state.tokens.next);
				advance("=");
				nonadjacent(state.tokens.curr, state.tokens.next);
				if (state.tokens.next.id === "undefined") {
					warning("W080", state.tokens.prev, state.tokens.prev.value);
				}
				if (peek(0).id === "=" && state.tokens.next.identifier) {
					warning("W120", state.tokens.next, state.tokens.next.value);
				}
				value = expression(10);
				if (lone) {
					tokens[0].first = value;
				} else {
					destructuringExpressionMatch(names, value);
				}
			}

			if (state.tokens.next.id !== ",") {
				break;
			}
			comma();
		}
		return this;
	});
	varstatement.exps = true;
	var letstatement = stmt("let", function (prefix) {
		var tokens, lone, value, letblock;

		if (!state.option.inESNext()) {
			warning("W104", state.tokens.curr, "let");
		}

		if (state.tokens.next.value === "(") {
			if (!state.option.inMoz(true)) {
				warning("W118", state.tokens.next, "let block");
			}
			advance("(");
			funct["(blockscope)"].stack();
			letblock = true;
		} else if (funct["(nolet)"]) {
			error("E048", state.tokens.curr);
		}

		if (funct["(onevar)"] && state.option.onevar) {
			warning("W081");
		} else if (!funct["(global)"]) {
			funct["(onevar)"] = true;
		}

		this.first = [];
		for (;;) {
			var names = [];
			nonadjacent(state.tokens.curr, state.tokens.next);
			if (_.contains(["{", "["], state.tokens.next.value)) {
				tokens = destructuringExpression();
				lone = false;
			} else {
				tokens = [ { id: identifier(), token: state.tokens.curr.value } ];
				lone = true;
			}
			for (var t in tokens) {
				t = tokens[t];
				if (state.option.inESNext() && funct[t.id] === "const") {
					warning("E011", null, t.id);
				}
				if (funct["(global)"] && predefined[t.id] === false) {
					warning("W079", t.token, t.id);
				}
				if (t.id && !funct["(nolet)"]) {
					addlabel(t.id, "unused", t.token, true);
					names.push(t.token);
				}
			}
			if (prefix) {
				break;
			}

			this.first = this.first.concat(names);

			if (state.tokens.next.id === "=") {
				nonadjacent(state.tokens.curr, state.tokens.next);
				advance("=");
				nonadjacent(state.tokens.curr, state.tokens.next);
				if (state.tokens.next.id === "undefined") {
					warning("W080", state.tokens.prev, state.tokens.prev.value);
				}
				if (peek(0).id === "=" && state.tokens.next.identifier) {
					warning("W120", state.tokens.next, state.tokens.next.value);
				}
				value = expression(10);
				if (lone) {
					tokens[0].first = value;
				} else {
					destructuringExpressionMatch(names, value);
				}
			}

			if (state.tokens.next.id !== ",") {
				break;
			}
			comma();
		}
		if (letblock) {
			advance(")");
			block(true, true);
			this.block = true;
			funct["(blockscope)"].unstack();
		}

		return this;
	});
	letstatement.exps = true;

	blockstmt("class", function () {
		return classdef.call(this, true);
	});

	function classdef(stmt) {
		/*jshint validthis:true */
		if (!state.option.inESNext()) {
			warning("W104", state.tokens.curr, "class");
		}
		if (stmt) {
			// BindingIdentifier
			this.name = identifier();
			addlabel(this.name, "unused", state.tokens.curr);
		} else if (state.tokens.next.identifier && state.tokens.next.value !== "extends") {
			// BindingIdentifier(opt)
			this.name = identifier();
		}
		classtail(this);
		return this;
	}

	function classtail(c) {
		var strictness = state.directive["use strict"];

		// ClassHeritage(opt)
		if (state.tokens.next.value === "extends") {
			advance("extends");
			c.heritage = expression(10);
		}

		// A ClassBody is always strict code.
		state.directive["use strict"] = true;
		advance("{");
		// ClassBody(opt)
		c.body = state.syntax["{"].nud(true);
		state.directive["use strict"] = strictness;
	}

	blockstmt("function", function () {
		var generator = false;
		if (state.tokens.next.value === "*") {
			advance("*");
			if (state.option.inESNext(true)) {
				generator = true;
			} else {
				warning("W119", state.tokens.curr, "function*");
			}
		}
		if (inblock) {
			warning("W082", state.tokens.curr);

		}
		var i = identifier();
		if (funct[i] === "const") {
			warning("E011", null, i);
		}
		adjacent(state.tokens.curr, state.tokens.next);
		addlabel(i, "unction", state.tokens.curr);

		doFunction(i, { statement: true }, generator);
		if (state.tokens.next.id === "(" && state.tokens.next.line === state.tokens.curr.line) {
			error("E039");
		}
		return this;
	});

	prefix("function", function () {
		var generator = false;
		if (state.tokens.next.value === "*") {
			if (!state.option.inESNext()) {
				warning("W119", state.tokens.curr, "function*");
			}
			advance("*");
			generator = true;
		}
		var i = optionalidentifier();
		if (i || state.option.gcl) {
			adjacent(state.tokens.curr, state.tokens.next);
		} else {
			nonadjacent(state.tokens.curr, state.tokens.next);
		}
		doFunction(i, undefined, generator);
		if (!state.option.loopfunc && funct["(loopage)"]) {
			warning("W083");
		}
		return this;
	});

	blockstmt("if", function () {
		var t = state.tokens.next;
		increaseComplexityCount();
		state.condition = true;
		advance("(");
		nonadjacent(this, t);
		nospace();
		checkCondAssignment(expression(0));
		advance(")", t);
		state.condition = false;
		nospace(state.tokens.prev, state.tokens.curr);
		block(true, true);
		if (state.tokens.next.id === "else") {
			nonadjacent(state.tokens.curr, state.tokens.next);
			advance("else");
			if (state.tokens.next.id === "if" || state.tokens.next.id === "switch") {
				statement(true);
			} else {
				block(true, true);
			}
		}
		return this;
	});

	blockstmt("try", function () {
		var b;

		function doCatch() {
			var oldScope = scope;
			var e;

			advance("catch");
			nonadjacent(state.tokens.curr, state.tokens.next);
			advance("(");

			scope = Object.create(oldScope);

			e = state.tokens.next.value;
			if (state.tokens.next.type !== "(identifier)") {
				e = null;
				warning("E030", state.tokens.next, e);
			}

			advance();

			funct = {
				"(name)"     : "(catch)",
				"(line)"     : state.tokens.next.line,
				"(character)": state.tokens.next.character,
				"(context)"  : funct,
				"(breakage)" : funct["(breakage)"],
				"(loopage)"  : funct["(loopage)"],
				"(scope)"    : scope,
				"(statement)": false,
				"(metrics)"  : createMetrics(state.tokens.next),
				"(catch)"    : true,
				"(tokens)"   : {},
				"(blockscope)": funct["(blockscope)"],
				"(comparray)": funct["(comparray)"]
			};

			if (e) {
				addlabel(e, "exception");
			}

			if (state.tokens.next.value === "if") {
				if (!state.option.inMoz(true)) {
					warning("W118", state.tokens.curr, "catch filter");
				}
				advance("if");
				expression(0);
			}

			advance(")");

			state.tokens.curr.funct = funct;
			functions.push(funct);

			block(false);

			scope = oldScope;

			funct["(last)"] = state.tokens.curr.line;
			funct["(lastcharacter)"] = state.tokens.curr.character;
			funct = funct["(context)"];
		}

		block(false);

		while (state.tokens.next.id === "catch") {
			increaseComplexityCount();
			if (b && (!state.option.inMoz(true))) {
				warning("W118", state.tokens.next, "multiple catch blocks");
			}
			doCatch();
			b = true;
		}

		if (state.tokens.next.id === "finally") {
			advance("finally");
			block(false);
			return;
		}

		if (!b) {
			error("E021", state.tokens.next, "catch", state.tokens.next.value);
		}

		return this;
	});

	blockstmt("while", function () {
		var t = state.tokens.next;
		funct["(breakage)"] += 1;
		funct["(loopage)"] += 1;
		increaseComplexityCount();
		advance("(");
		nonadjacent(this, t);
		nospace();
		checkCondAssignment(expression(0));
		advance(")", t);
		nospace(state.tokens.prev, state.tokens.curr);
		block(true, true);
		funct["(breakage)"] -= 1;
		funct["(loopage)"] -= 1;
		return this;
	}).labelled = true;

	blockstmt("with", function () {
		var t = state.tokens.next;
		if (state.directive["use strict"]) {
			error("E010", state.tokens.curr);
		} else if (!state.option.withstmt) {
			warning("W085", state.tokens.curr);
		}

		advance("(");
		nonadjacent(this, t);
		nospace();
		expression(0);
		advance(")", t);
		nospace(state.tokens.prev, state.tokens.curr);
		block(true, true);

		return this;
	});

	blockstmt("switch", function () {
		var t = state.tokens.next;
		var g = false;
		var noindent = false;

		funct["(breakage)"] += 1;
		advance("(");
		nonadjacent(this, t);
		nospace();
		checkCondAssignment(expression(0));
		advance(")", t);
		nospace(state.tokens.prev, state.tokens.curr);
		nonadjacent(state.tokens.curr, state.tokens.next);
		t = state.tokens.next;
		advance("{");
		nonadjacent(state.tokens.curr, state.tokens.next);

		if (state.tokens.next.from === indent)
			noindent = true;

		if (!noindent)
			indent += state.option.indent;

		this.cases = [];

		for (;;) {
			switch (state.tokens.next.id) {
			case "case":
				switch (funct["(verb)"]) {
				case "yield":
				case "break":
				case "case":
				case "continue":
				case "return":
				case "switch":
				case "throw":
					break;
				default:
					// You can tell JSHint that you don't use break intentionally by
					// adding a comment /* falls through */ on a line just before
					// the next `case`.
					if (!reg.fallsThrough.test(state.lines[state.tokens.next.line - 2])) {
						warning("W086", state.tokens.curr, "case");
					}
				}
				indentation();
				advance("case");
				this.cases.push(expression(20));
				increaseComplexityCount();
				g = true;
				advance(":");
				funct["(verb)"] = "case";
				break;
			case "default":
				switch (funct["(verb)"]) {
				case "yield":
				case "break":
				case "continue":
				case "return":
				case "throw":
					break;
				default:
					// Do not display a warning if 'default' is the first statement or if
					// there is a special /* falls through */ comment.
					if (this.cases.length) {
						if (!reg.fallsThrough.test(state.lines[state.tokens.next.line - 2])) {
							warning("W086", state.tokens.curr, "default");
						}
					}
				}
				indentation();
				advance("default");
				g = true;
				advance(":");
				break;
			case "}":
				if (!noindent)
					indent -= state.option.indent;
				indentation();
				advance("}", t);
				funct["(breakage)"] -= 1;
				funct["(verb)"] = undefined;
				return;
			case "(end)":
				error("E023", state.tokens.next, "}");
				return;
			default:
				indent += state.option.indent;
				if (g) {
					switch (state.tokens.curr.id) {
					case ",":
						error("E040");
						return;
					case ":":
						g = false;
						statements();
						break;
					default:
						error("E025", state.tokens.curr);
						return;
					}
				} else {
					if (state.tokens.curr.id === ":") {
						advance(":");
						error("E024", state.tokens.curr, ":");
						statements();
					} else {
						error("E021", state.tokens.next, "case", state.tokens.next.value);
						return;
					}
				}
				indent -= state.option.indent;
			}
		}
	}).labelled = true;

	stmt("debugger", function () {
		if (!state.option.debug) {
			warning("W087", this);
		}
		return this;
	}).exps = true;

	(function () {
		var x = stmt("do", function () {
			funct["(breakage)"] += 1;
			funct["(loopage)"] += 1;
			increaseComplexityCount();

			this.first = block(true, true);
			advance("while");
			var t = state.tokens.next;
			nonadjacent(state.tokens.curr, t);
			advance("(");
			nospace();
			checkCondAssignment(expression(0));
			advance(")", t);
			nospace(state.tokens.prev, state.tokens.curr);
			funct["(breakage)"] -= 1;
			funct["(loopage)"] -= 1;
			return this;
		});
		x.labelled = true;
		x.exps = true;
	}());

	blockstmt("for", function () {
		var s, t = state.tokens.next;
		var letscope = false;
		var foreachtok = null;

		if (t.value === "each") {
			foreachtok = t;
			advance("each");
			if (!state.option.inMoz(true)) {
				warning("W118", state.tokens.curr, "for each");
			}
		}

		funct["(breakage)"] += 1;
		funct["(loopage)"] += 1;
		increaseComplexityCount();
		advance("(");
		nonadjacent(this, t);
		nospace();

		// what kind of for(…) statement it is? for(…of…)? for(…in…)? for(…;…;…)?
		var nextop; // contains the token of the "in" or "of" operator
		var i = 0;
		var inof = ["in", "of"];
		do {
			nextop = peek(i);
			++i;
		} while (!_.contains(inof, nextop.value) && nextop.value !== ";" &&
					nextop.type !== "(end)");

		// if we're in a for (… in|of …) statement
		if (_.contains(inof, nextop.value)) {
			if (!state.option.inESNext() && nextop.value === "of") {
				error("W104", nextop, "for of");
			}
			if (state.tokens.next.id === "var") {
				advance("var");
				state.syntax["var"].fud.call(state.syntax["var"].fud, true);
			} else if (state.tokens.next.id === "let") {
				advance("let");
				// create a new block scope
				letscope = true;
				funct["(blockscope)"].stack();
				state.syntax["let"].fud.call(state.syntax["let"].fud, true);
			} else {
				switch (funct[state.tokens.next.value]) {
				case "unused":
					funct[state.tokens.next.value] = "var";
					break;
				case "var":
					break;
				default:
					if (!funct["(blockscope)"].getlabel(state.tokens.next.value))
						warning("W088", state.tokens.next, state.tokens.next.value);
				}
				advance();
			}
			advance(nextop.value);
			expression(20);
			advance(")", t);
			s = block(true, true);
			if (state.option.forin && s && (s.length > 1 || typeof s[0] !== "object" ||
					s[0].value !== "if")) {
				warning("W089", this);
			}
			funct["(breakage)"] -= 1;
			funct["(loopage)"] -= 1;
		} else {
			if (foreachtok) {
				error("E045", foreachtok);
			}
			if (state.tokens.next.id !== ";") {
				if (state.tokens.next.id === "var") {
					advance("var");
					state.syntax["var"].fud.call(state.syntax["var"].fud);
				} else if (state.tokens.next.id === "let") {
					advance("let");
					// create a new block scope
					letscope = true;
					funct["(blockscope)"].stack();
					state.syntax["let"].fud.call(state.syntax["let"].fud);
				} else {
					for (;;) {
						expression(0, "for");
						if (state.tokens.next.id !== ",") {
							break;
						}
						comma();
					}
				}
			}
			nolinebreak(state.tokens.curr);
			advance(";");
			if (state.tokens.next.id !== ";") {
				checkCondAssignment(expression(0));
			}
			nolinebreak(state.tokens.curr);
			advance(";");
			if (state.tokens.next.id === ";") {
				error("E021", state.tokens.next, ")", ";");
			}
			if (state.tokens.next.id !== ")") {
				for (;;) {
					expression(0, "for");
					if (state.tokens.next.id !== ",") {
						break;
					}
					comma();
				}
			}
			advance(")", t);
			nospace(state.tokens.prev, state.tokens.curr);
			block(true, true);
			funct["(breakage)"] -= 1;
			funct["(loopage)"] -= 1;

		}
		// unstack loop blockscope
		if (letscope) {
			funct["(blockscope)"].unstack();
		}
		return this;
	}).labelled = true;


	stmt("break", function () {
		var v = state.tokens.next.value;

		if (funct["(breakage)"] === 0)
			warning("W052", state.tokens.next, this.value);

		if (!state.option.asi)
			nolinebreak(this);

		if (state.tokens.next.id !== ";" && !state.tokens.next.reach) {
			if (state.tokens.curr.line === state.tokens.next.line) {
				if (funct[v] !== "label") {
					warning("W090", state.tokens.next, v);
				} else if (scope[v] !== funct) {
					warning("W091", state.tokens.next, v);
				}
				this.first = state.tokens.next;
				advance();
			}
		}
		reachable("break");
		return this;
	}).exps = true;


	stmt("continue", function () {
		var v = state.tokens.next.value;

		if (funct["(breakage)"] === 0)
			warning("W052", state.tokens.next, this.value);

		if (!state.option.asi)
			nolinebreak(this);

		if (state.tokens.next.id !== ";" && !state.tokens.next.reach) {
			if (state.tokens.curr.line === state.tokens.next.line) {
				if (funct[v] !== "label") {
					warning("W090", state.tokens.next, v);
				} else if (scope[v] !== funct) {
					warning("W091", state.tokens.next, v);
				}
				this.first = state.tokens.next;
				advance();
			}
		} else if (!funct["(loopage)"]) {
			warning("W052", state.tokens.next, this.value);
		}
		reachable("continue");
		return this;
	}).exps = true;


	stmt("return", function () {
		if (this.line === state.tokens.next.line) {
			if (state.tokens.next.id === "(regexp)")
				warning("W092");

			if (state.tokens.next.id !== ";" && !state.tokens.next.reach) {
				nonadjacent(state.tokens.curr, state.tokens.next);
				this.first = expression(0);

				if (this.first &&
						this.first.type === "(punctuator)" && this.first.value === "=" && !state.option.boss) {
					warningAt("W093", this.first.line, this.first.character);
				}
			}
		} else {
			if (state.tokens.next.type === "(punctuator)" &&
				["[", "{", "+", "-"].indexOf(state.tokens.next.value) > -1) {
				nolinebreak(this); // always warn (Line breaking error)
			}
		}
		reachable("return");
		return this;
	}).exps = true;

	(function (x) {
		x.exps = true;
		x.lbp = 25;
	}(prefix("yield", function () {
		var prev = state.tokens.prev;
		if (state.option.inESNext(true) && !funct["(generator)"]) {
			error("E046", state.tokens.curr, "yield");
		} else if (!state.option.inESNext()) {
			warning("W104", state.tokens.curr, "yield");
		}
		funct["(generator)"] = "yielded";
		if (this.line === state.tokens.next.line || !state.option.inMoz(true)) {
			if (state.tokens.next.id === "(regexp)")
				warning("W092");

			if (state.tokens.next.id !== ";" && !state.tokens.next.reach && state.tokens.next.nud) {
				nobreaknonadjacent(state.tokens.curr, state.tokens.next);
				this.first = expression(10);

				if (this.first.type === "(punctuator)" && this.first.value === "=" && !state.option.boss) {
					warningAt("W093", this.first.line, this.first.character);
				}
			}

			if (state.option.inMoz(true) && state.tokens.next.id !== ")" &&
					(prev.lbp > 30 || (!prev.assign && !isEndOfExpr()) || prev.id === "yield")) {
				error("E050", this);
			}
		} else if (!state.option.asi) {
			nolinebreak(this); // always warn (Line breaking error)
		}
		return this;
	})));


	stmt("throw", function () {
		nolinebreak(this);
		nonadjacent(state.tokens.curr, state.tokens.next);
		this.first = expression(20);
		reachable("throw");
		return this;
	}).exps = true;

	stmt("import", function () {
		if (!state.option.inESNext()) {
			warning("W119", state.tokens.curr, "import");
		}

		if (state.tokens.next.identifier) {
			this.name = identifier();
			addlabel(this.name, "unused", state.tokens.curr);
		} else {
			advance("{");
			for (;;) {
				var importName;
				if (state.tokens.next.type === "default") {
					importName = "default";
					advance("default");
				} else {
					importName = identifier();
				}
				if (state.tokens.next.value === "as") {
					advance("as");
					importName = identifier();
				}
				addlabel(importName, "unused", state.tokens.curr);

				if (state.tokens.next.value === ",") {
					advance(",");
				} else if (state.tokens.next.value === "}") {
					advance("}");
					break;
				} else {
					error("E024", state.tokens.next, state.tokens.next.value);
					break;
				}
			}
		}

		advance("from");
		advance("(string)");
		return this;
	}).exps = true;

	stmt("export", function () {
		if (!state.option.inESNext()) {
			warning("W119", state.tokens.curr, "export");
		}

		if (state.tokens.next.type === "default") {
			advance("default");
			if (state.tokens.next.id === "function" || state.tokens.next.id === "class") {
				this.block = true;
			}
			this.exportee = expression(10);

			return this;
		}

		if (state.tokens.next.value === "{") {
			advance("{");
			for (;;) {
				identifier();

				if (state.tokens.next.value === ",") {
					advance(",");
				} else if (state.tokens.next.value === "}") {
					advance("}");
					break;
				} else {
					error("E024", state.tokens.next, state.tokens.next.value);
					break;
				}
			}
			return this;
		}

		if (state.tokens.next.id === "var") {
			advance("var");
			state.syntax["var"].fud.call(state.syntax["var"].fud);
		} else if (state.tokens.next.id === "let") {
			advance("let");
			state.syntax["let"].fud.call(state.syntax["let"].fud);
		} else if (state.tokens.next.id === "const") {
			advance("const");
			state.syntax["const"].fud.call(state.syntax["const"].fud);
		} else if (state.tokens.next.id === "function") {
			this.block = true;
			advance("function");
			state.syntax["function"].fud();
		} else if (state.tokens.next.id === "class") {
			this.block = true;
			advance("class");
			state.syntax["class"].fud();
		} else {
			error("E024", state.tokens.next, state.tokens.next.value);
		}

		return this;
	}).exps = true;

	// Future Reserved Words

	FutureReservedWord("abstract");
	FutureReservedWord("boolean");
	FutureReservedWord("byte");
	FutureReservedWord("char");
	FutureReservedWord("class", { es5: true, nud: classdef });
	FutureReservedWord("double");
	FutureReservedWord("enum", { es5: true });
	FutureReservedWord("export", { es5: true });
	FutureReservedWord("extends", { es5: true });
	FutureReservedWord("final");
	FutureReservedWord("float");
	FutureReservedWord("goto");
	FutureReservedWord("implements", { es5: true, strictOnly: true });
	FutureReservedWord("import", { es5: true });
	FutureReservedWord("int");
	FutureReservedWord("interface", { es5: true, strictOnly: true });
	FutureReservedWord("long");
	FutureReservedWord("native");
	FutureReservedWord("package", { es5: true, strictOnly: true });
	FutureReservedWord("private", { es5: true, strictOnly: true });
	FutureReservedWord("protected", { es5: true, strictOnly: true });
	FutureReservedWord("public", { es5: true, strictOnly: true });
	FutureReservedWord("short");
	FutureReservedWord("static", { es5: true, strictOnly: true });
	FutureReservedWord("super", { es5: true });
	FutureReservedWord("synchronized");
	FutureReservedWord("throws");
	FutureReservedWord("transient");
	FutureReservedWord("volatile");

	// this function is used to determine wether a squarebracket or a curlybracket
	// expression is a comprehension array, destructuring assignment or a json value.

	var lookupBlockType = function () {
		var pn, pn1;
		var i = -1;
		var bracketStack = 0;
		var ret = {};
		if (_.contains(["[", "{"], state.tokens.curr.value))
			bracketStack += 1;
		do {
			pn = (i === -1) ? state.tokens.next : peek(i);
			pn1 = peek(i + 1);
			i = i + 1;
			if (_.contains(["[", "{"], pn.value)) {
				bracketStack += 1;
			} else if (_.contains(["]", "}"], pn.value)) {
				bracketStack -= 1;
			}
			if (pn.identifier && pn.value === "for" && bracketStack === 1) {
				ret.isCompArray = true;
				ret.notJson = true;
				break;
			}
			if (_.contains(["}", "]"], pn.value) && pn1.value === "=" && bracketStack === 0) {
				ret.isDestAssign = true;
				ret.notJson = true;
				break;
			}
			if (pn.value === ";") {
				ret.isBlock = true;
				ret.notJson = true;
			}
		} while (bracketStack > 0 && pn.id !== "(end)" && i < 15);
		return ret;
	};

	// Check whether this function has been reached for a destructuring assign with undeclared values
	function destructuringAssignOrJsonValue() {
		// lookup for the assignment (esnext only)
		// if it has semicolons, it is a block, so go parse it as a block
		// or it's not a block, but there are assignments, check for undeclared variables

		var block = lookupBlockType();
		if (block.notJson) {
			if (!state.option.inESNext() && block.isDestAssign) {
				warning("W104", state.tokens.curr, "destructuring assignment");
			}
			statements();
		// otherwise parse json value
		} else {
			state.option.laxbreak = true;
			state.jsonMode = true;
			jsonValue();
		}
	}

	// array comprehension parsing function
	// parses and defines the three states of the list comprehension in order
	// to avoid defining global variables, but keeping them to the list comprehension scope
	// only. The order of the states are as follows:
	//  * "use" which will be the returned iterative part of the list comprehension
	//  * "define" which will define the variables local to the list comprehension
	//  * "filter" which will help filter out values

	var arrayComprehension = function () {
		var CompArray = function () {
			this.mode = "use";
			this.variables = [];
		};
		var _carrays = [];
		var _current;
		function declare(v) {
			var l = _current.variables.filter(function (elt) {
				// if it has, change its undef state
				if (elt.value === v) {
					elt.undef = false;
					return v;
				}
			}).length;
			return l !== 0;
		}
		function use(v) {
			var l = _current.variables.filter(function (elt) {
				// and if it has been defined
				if (elt.value === v && !elt.undef) {
					if (elt.unused === true) {
						elt.unused = false;
					}
					return v;
				}
			}).length;
			// otherwise we warn about it
			return (l === 0);
		}
		return {stack: function () {
					_current = new CompArray();
					_carrays.push(_current);
				},
				unstack: function () {
					_current.variables.filter(function (v) {
						if (v.unused)
							warning("W098", v.token, v.value);
						if (v.undef)
							isundef(v.funct, "W117", v.token, v.value);
					});
					_carrays.splice(-1, 1);
					_current = _carrays[_carrays.length - 1];
				},
				setState: function (s) {
					if (_.contains(["use", "define", "generate", "filter"], s))
						_current.mode = s;
				},
				check: function (v) {
					if (!_current) {
						return;
					}
					// When we are in "use" state of the list comp, we enqueue that var
					if (_current && _current.mode === "use") {
						if (use(v)) {
							_current.variables.push({
								funct: funct,
								token: state.tokens.curr,
								value: v,
								undef: true,
								unused: false
							});
						}
						return true;
					// When we are in "define" state of the list comp,
					} else if (_current && _current.mode === "define") {
						// check if the variable has been used previously
						if (!declare(v)) {
							_current.variables.push({
								funct: funct,
								token: state.tokens.curr,
								value: v,
								undef: false,
								unused: true
							});
						}
						return true;
					// When we are in the "generate" state of the list comp,
					} else if (_current && _current.mode === "generate") {
						isundef(funct, "W117", state.tokens.curr, v);
						return true;
					// When we are in "filter" state,
					} else if (_current && _current.mode === "filter") {
						// we check whether current variable has been declared
						if (use(v)) {
							// if not we warn about it
							isundef(funct, "W117", state.tokens.curr, v);
						}
						return true;
					}
					return false;
				}
				};
	};


	// Parse JSON

	function jsonValue() {

		function jsonObject() {
			var o = {}, t = state.tokens.next;
			advance("{");
			if (state.tokens.next.id !== "}") {
				for (;;) {
					if (state.tokens.next.id === "(end)") {
						error("E026", state.tokens.next, t.line);
					} else if (state.tokens.next.id === "}") {
						warning("W094", state.tokens.curr);
						break;
					} else if (state.tokens.next.id === ",") {
						error("E028", state.tokens.next);
					} else if (state.tokens.next.id !== "(string)") {
						warning("W095", state.tokens.next, state.tokens.next.value);
					}
					if (o[state.tokens.next.value] === true) {
						warning("W075", state.tokens.next, state.tokens.next.value);
					} else if ((state.tokens.next.value === "__proto__" &&
						!state.option.proto) || (state.tokens.next.value === "__iterator__" &&
						!state.option.iterator)) {
						warning("W096", state.tokens.next, state.tokens.next.value);
					} else {
						o[state.tokens.next.value] = true;
					}
					advance();
					advance(":");
					jsonValue();
					if (state.tokens.next.id !== ",") {
						break;
					}
					advance(",");
				}
			}
			advance("}");
		}

		function jsonArray() {
			var t = state.tokens.next;
			advance("[");
			if (state.tokens.next.id !== "]") {
				for (;;) {
					if (state.tokens.next.id === "(end)") {
						error("E027", state.tokens.next, t.line);
					} else if (state.tokens.next.id === "]") {
						warning("W094", state.tokens.curr);
						break;
					} else if (state.tokens.next.id === ",") {
						error("E028", state.tokens.next);
					}
					jsonValue();
					if (state.tokens.next.id !== ",") {
						break;
					}
					advance(",");
				}
			}
			advance("]");
		}

		switch (state.tokens.next.id) {
		case "{":
			jsonObject();
			break;
		case "[":
			jsonArray();
			break;
		case "true":
		case "false":
		case "null":
		case "(number)":
		case "(string)":
			advance();
			break;
		case "-":
			advance("-");
			if (state.tokens.curr.character !== state.tokens.next.from) {
				warning("W011", state.tokens.curr);
			}
			adjacent(state.tokens.curr, state.tokens.next);
			advance("(number)");
			break;
		default:
			error("E003", state.tokens.next);
		}
	}

	var blockScope = function () {
		var _current = {};
		var _variables = [_current];

		function _checkBlockLabels() {
			for (var t in _current) {
				if (_current[t]["(type)"] === "unused") {
					if (state.option.unused) {
						var tkn = _current[t]["(token)"];
						var line = tkn.line;
						var chr  = tkn.character;
						warningAt("W098", line, chr, t);
					}
				}
			}
		}

		return {
			stack: function () {
				_current = {};
				_variables.push(_current);
			},

			unstack: function () {
				_checkBlockLabels();
				_variables.splice(_variables.length - 1, 1);
				_current = _.last(_variables);
			},

			getlabel: function (l) {
				for (var i = _variables.length - 1 ; i >= 0; --i) {
					if (_.has(_variables[i], l)) {
						return _variables[i];
					}
				}
			},

			current: {
				has: function (t) {
					return _.has(_current, t);
				},
				add: function (t, type, tok) {
					_current[t] = { "(type)" : type,
									"(token)": tok };
				}
			}
		};
	};

	// The actual JSHINT function itself.
	var itself = function (s, o, g) {
		var i, k, x;
		var optionKeys;
		var newOptionObj = {};
		var newIgnoredObj = {};

		state.reset();

		if (o && o.scope) {
			JSHINT.scope = o.scope;
		} else {
			JSHINT.errors = [];
			JSHINT.undefs = [];
			JSHINT.internals = [];
			JSHINT.blacklist = {};
			JSHINT.scope = "(main)";
		}

		predefined = Object.create(null);
		combine(predefined, vars.ecmaIdentifiers);
		combine(predefined, vars.reservedVars);

		combine(predefined, g || {});

		declared = Object.create(null);
		exported = Object.create(null);

		function each(obj, cb) {
			if (!obj)
				return;

			if (!Array.isArray(obj) && typeof obj === "object")
				obj = Object.keys(obj);

			obj.forEach(cb);
		}

		if (o) {
			each(o.predef || null, function (item) {
				var slice, prop;

				if (item[0] === "-") {
					slice = item.slice(1);
					JSHINT.blacklist[slice] = slice;
				} else {
					prop = Object.getOwnPropertyDescriptor(o.predef, item);
					predefined[item] = prop ? prop.value : false;
				}
			});

			each(o.exported || null, function (item) {
				exported[item] = true;
			});

			delete o.predef;
			delete o.exported;

			optionKeys = Object.keys(o);
			for (x = 0; x < optionKeys.length; x++) {
				if (/^-W\d{3}$/g.test(optionKeys[x])) {
					newIgnoredObj[optionKeys[x].slice(1)] = true;
				} else {
					newOptionObj[optionKeys[x]] = o[optionKeys[x]];

					if (optionKeys[x] === "newcap" && o[optionKeys[x]] === false)
						newOptionObj["(explicitNewcap)"] = true;

					if (optionKeys[x] === "indent")
						newOptionObj["(explicitIndent)"] = o[optionKeys[x]] === false ? false : true;
				}
			}
		}

		state.option = newOptionObj;
		state.ignored = newIgnoredObj;

		state.option.indent = state.option.indent || 4;
		state.option.maxerr = state.option.maxerr || 50;

		indent = 1;
		global = Object.create(predefined);
		scope = global;
		funct = {
			"(global)":   true,
			"(name)":	  "(global)",
			"(scope)":	  scope,
			"(breakage)": 0,
			"(loopage)":  0,
			"(tokens)":   {},
			"(metrics)":   createMetrics(state.tokens.next),
			"(blockscope)": blockScope(),
			"(comparray)": arrayComprehension()
		};
		functions = [funct];
		urls = [];
		stack = null;
		member = {};
		membersOnly = null;
		implied = {};
		inblock = false;
		lookahead = [];
		warnings = 0;
		unuseds = [];

		if (!isString(s) && !Array.isArray(s)) {
			errorAt("E004", 0);
			return false;
		}

		api = {
			get isJSON() {
				return state.jsonMode;
			},

			getOption: function (name) {
				return state.option[name] || null;
			},

			getCache: function (name) {
				return state.cache[name];
			},

			setCache: function (name, value) {
				state.cache[name] = value;
			},

			warn: function (code, data) {
				warningAt.apply(null, [ code, data.line, data.char ].concat(data.data));
			},

			on: function (names, listener) {
				names.split(" ").forEach(function (name) {
					emitter.on(name, listener);
				}.bind(this));
			}
		};

		emitter.removeAllListeners();
		(extraModules || []).forEach(function (func) {
			func(api);
		});

		state.tokens.prev = state.tokens.curr = state.tokens.next = state.syntax["(begin)"];

		lex = new Lexer(s);

		lex.on("warning", function (ev) {
			warningAt.apply(null, [ ev.code, ev.line, ev.character].concat(ev.data));
		});

		lex.on("error", function (ev) {
			errorAt.apply(null, [ ev.code, ev.line, ev.character ].concat(ev.data));
		});

		lex.on("fatal", function (ev) {
			quit("E041", ev.line, ev.from);
		});

		lex.on("Identifier", function (ev) {
			emitter.emit("Identifier", ev);
		});

		lex.on("String", function (ev) {
			emitter.emit("String", ev);
		});

		lex.on("Number", function (ev) {
			emitter.emit("Number", ev);
		});

		lex.start();

		// Check options
		for (var name in o) {
			if (_.has(o, name)) {
				checkOption(name, state.tokens.curr);
			}
		}

		assume();

		// combine the passed globals after we've assumed all our options
		combine(predefined, g || {});

		//reset values
		comma.first = true;

		try {
			advance();
			switch (state.tokens.next.id) {
			case "{":
			case "[":
				destructuringAssignOrJsonValue();
				break;
			default:
				directives();

				if (state.directive["use strict"]) {
					if (!state.option.globalstrict && !(state.option.node || state.option.phantom)) {
						warning("W097", state.tokens.prev);
					}
				}

				statements();
			}
			advance((state.tokens.next && state.tokens.next.value !== ".")	? "(end)" : undefined);
			funct["(blockscope)"].unstack();

			var markDefined = function (name, context) {
				do {
					if (typeof context[name] === "string") {
						// JSHINT marks unused variables as 'unused' and
						// unused function declaration as 'unction'. This
						// code changes such instances back 'var' and
						// 'closure' so that the code in JSHINT.data()
						// doesn't think they're unused.

						if (context[name] === "unused")
							context[name] = "var";
						else if (context[name] === "unction")
							context[name] = "closure";

						return true;
					}

					context = context["(context)"];
				} while (context);

				return false;
			};

			var clearImplied = function (name, line) {
				if (!implied[name])
					return;

				var newImplied = [];
				for (var i = 0; i < implied[name].length; i += 1) {
					if (implied[name][i] !== line)
						newImplied.push(implied[name][i]);
				}

				if (newImplied.length === 0)
					delete implied[name];
				else
					implied[name] = newImplied;
			};

			var warnUnused = function (name, tkn, type, unused_opt) {
				var line = tkn.line;
				var chr  = tkn.character;

				if (unused_opt === undefined) {
					unused_opt = state.option.unused;
				}

				if (unused_opt === true) {
					unused_opt = "last-param";
				}

				var warnable_types = {
					"vars": ["var"],
					"last-param": ["var", "param"],
					"strict": ["var", "param", "last-param"]
				};

				if (unused_opt) {
					if (warnable_types[unused_opt] && warnable_types[unused_opt].indexOf(type) !== -1) {
						warningAt("W098", line, chr, name);
					}
				}

				unuseds.push({
					name: name,
					line: line,
					character: chr
				});
			};

			var checkUnused = function (func, key) {
				var type = func[key];
				var tkn = func["(tokens)"][key];

				if (key.charAt(0) === "(")
					return;

				if (type !== "unused" && type !== "unction")
					return;

				// Params are checked separately from other variables.
				if (func["(params)"] && func["(params)"].indexOf(key) !== -1)
					return;

				// Variable is in global scope and defined as exported.
				if (func["(global)"] && _.has(exported, key)) {
					return;
				}

				warnUnused(key, tkn, "var");
			};

			// Check queued 'x is not defined' instances to see if they're still undefined.
			for (i = 0; i < JSHINT.undefs.length; i += 1) {
				k = JSHINT.undefs[i].slice(0);

				if (markDefined(k[2].value, k[0])) {
					clearImplied(k[2].value, k[2].line);
				} else if (state.option.undef) {
					warning.apply(warning, k.slice(1));
				}
			}

			functions.forEach(function (func) {
				if (func["(unusedOption)"] === false) {
					return;
				}

				for (var key in func) {
					if (_.has(func, key)) {
						checkUnused(func, key);
					}
				}

				if (!func["(params)"])
					return;

				var params = func["(params)"].slice();
				var param  = params.pop();
				var type, unused_opt;

				while (param) {
					type = func[param];
					unused_opt = func["(unusedOption)"] || state.option.unused;
					unused_opt = unused_opt === true ? "last-param" : unused_opt;

					// 'undefined' is a special case for (function (window, undefined) { ... })();
					// patterns.

					if (param === "undefined")
						return;

					if (type === "unused" || type === "unction") {
						warnUnused(param, func["(tokens)"][param], "param", func["(unusedOption)"]);
					} else if (unused_opt === "last-param") {
						return;
					}

					param = params.pop();
				}
			});

			for (var key in declared) {
				if (_.has(declared, key) && !_.has(global, key)) {
					warnUnused(key, declared[key], "var");
				}
			}

		} catch (err) {
			if (err && err.name === "JSHintError") {
				var nt = state.tokens.next || {};
				JSHINT.errors.push({
					scope     : "(main)",
					raw       : err.raw,
					code      : err.code,
					reason    : err.message,
					line      : err.line || nt.line,
					character : err.character || nt.from
				}, null);
			} else {
				throw err;
			}
		}

		// Loop over the listed "internals", and check them as well.

		if (JSHINT.scope === "(main)") {
			o = o || {};

			for (i = 0; i < JSHINT.internals.length; i += 1) {
				k = JSHINT.internals[i];
				o.scope = k.elem;
				itself(k.value, o, g);
			}
		}

		return JSHINT.errors.length === 0;
	};

	// Modules.
	itself.addModule = function (func) {
		extraModules.push(func);
	};

	itself.addModule(style.register);

	// Data summary.
	itself.data = function () {
		var data = {
			functions: [],
			options: state.option
		};

		var implieds = [];
		var members = [];
		var fu, f, i, j, n, globals;

		if (itself.errors.length) {
			data.errors = itself.errors;
		}

		if (state.jsonMode) {
			data.json = true;
		}

		for (n in implied) {
			if (_.has(implied, n)) {
				implieds.push({
					name: n,
					line: implied[n]
				});
			}
		}

		if (implieds.length > 0) {
			data.implieds = implieds;
		}

		if (urls.length > 0) {
			data.urls = urls;
		}

		globals = Object.keys(scope);
		if (globals.length > 0) {
			data.globals = globals;
		}

		for (i = 1; i < functions.length; i += 1) {
			f = functions[i];
			fu = {};

			for (j = 0; j < functionicity.length; j += 1) {
				fu[functionicity[j]] = [];
			}

			for (j = 0; j < functionicity.length; j += 1) {
				if (fu[functionicity[j]].length === 0) {
					delete fu[functionicity[j]];
				}
			}

			fu.name = f["(name)"];
			fu.param = f["(params)"];
			fu.line = f["(line)"];
			fu.character = f["(character)"];
			fu.last = f["(last)"];
			fu.lastcharacter = f["(lastcharacter)"];

			fu.metrics = {
				complexity: f["(metrics)"].ComplexityCount,
				parameters: (f["(params)"] || []).length,
				statements: f["(metrics)"].statementCount
			};

			data.functions.push(fu);
		}

		if (unuseds.length > 0) {
			data.unused = unuseds;
		}

		members = [];
		for (n in member) {
			if (typeof member[n] === "number") {
				data.member = member;
				break;
			}
		}

		return data;
	};

	itself.jshint = itself;

	return itself;
}());

// Make JSHINT a Node module, if possible.
if (typeof exports === "object" && exports) {
	exports.JSHINT = JSHINT;
}

},{"./lex.js":72,"./messages.js":73,"./reg.js":74,"./state.js":75,"./style.js":76,"./vars.js":77,"console-browserify":69,"events":60,"underscore":70}],72:[function(require,module,exports){
/*
 * Lexical analysis and token construction.
 */

"use strict";

var _      = require("underscore");
var events = require("events");
var reg    = require("./reg.js");
var state  = require("./state.js").state;

var unicodeData = require("../data/ascii-identifier-data.js");
var asciiIdentifierStartTable = unicodeData.asciiIdentifierStartTable;
var asciiIdentifierPartTable = unicodeData.asciiIdentifierPartTable;
var nonAsciiIdentifierStartTable = require("../data/non-ascii-identifier-start.js");
var nonAsciiIdentifierPartTable = require("../data/non-ascii-identifier-part-only.js");

// Some of these token types are from JavaScript Parser API
// while others are specific to JSHint parser.
// JS Parser API: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

var Token = {
	Identifier: 1,
	Punctuator: 2,
	NumericLiteral: 3,
	StringLiteral: 4,
	Comment: 5,
	Keyword: 6,
	NullLiteral: 7,
	BooleanLiteral: 8,
	RegExp: 9
};

// Object that handles postponed lexing verifications that checks the parsed
// environment state.

function asyncTrigger() {
	var _checks = [];

	return {
		push: function (fn) {
			_checks.push(fn);
		},

		check: function () {
			for (var check = 0; check < _checks.length; ++check) {
				_checks[check]();
			}

			_checks.splice(0, _checks.length);
		}
	};
}

/*
 * Lexer for JSHint.
 *
 * This object does a char-by-char scan of the provided source code
 * and produces a sequence of tokens.
 *
 *   var lex = new Lexer("var i = 0;");
 *   lex.start();
 *   lex.token(); // returns the next token
 *
 * You have to use the token() method to move the lexer forward
 * but you don't have to use its return value to get tokens. In addition
 * to token() method returning the next token, the Lexer object also
 * emits events.
 *
 *   lex.on("Identifier", function (data) {
 *     if (data.name.indexOf("_") >= 0) {
 *       // Produce a warning.
 *     }
 *   });
 *
 * Note that the token() method returns tokens in a JSLint-compatible
 * format while the event emitter uses a slightly modified version of
 * Mozilla's JavaScript Parser API. Eventually, we will move away from
 * JSLint format.
 */
function Lexer(source) {
	var lines = source;

	if (typeof lines === "string") {
		lines = lines
			.replace(/\r\n/g, "\n")
			.replace(/\r/g, "\n")
			.split("\n");
	}

	// If the first line is a shebang (#!), make it a blank and move on.
	// Shebangs are used by Node scripts.

	if (lines[0] && lines[0].substr(0, 2) === "#!") {
		if (lines[0].indexOf("node") !== -1) {
			state.option.node = true;
		}
		lines[0] = "";
	}

	this.emitter = new events.EventEmitter();
	this.source = source;
	this.setLines(lines);
	this.prereg = true;

	this.line = 0;
	this.char = 1;
	this.from = 1;
	this.input = "";

	for (var i = 0; i < state.option.indent; i += 1) {
		state.tab += " ";
	}
}

Lexer.prototype = {
	_lines: [],

	getLines: function () {
		this._lines = state.lines;
		return this._lines;
	},

	setLines: function (val) {
		this._lines = val;
		state.lines = this._lines;
	},

	/*
	 * Return the next i character without actually moving the
	 * char pointer.
	 */
	peek: function (i) {
		return this.input.charAt(i || 0);
	},

	/*
	 * Move the char pointer forward i times.
	 */
	skip: function (i) {
		i = i || 1;
		this.char += i;
		this.input = this.input.slice(i);
	},

	/*
	 * Subscribe to a token event. The API for this method is similar
	 * Underscore.js i.e. you can subscribe to multiple events with
	 * one call:
	 *
	 *   lex.on("Identifier Number", function (data) {
	 *     // ...
	 *   });
	 */
	on: function (names, listener) {
		names.split(" ").forEach(function (name) {
			this.emitter.on(name, listener);
		}.bind(this));
	},

	/*
	 * Trigger a token event. All arguments will be passed to each
	 * listener.
	 */
	trigger: function () {
		this.emitter.emit.apply(this.emitter, Array.prototype.slice.call(arguments));
	},

	/*
	 * Postpone a token event. the checking condition is set as
	 * last parameter, and the trigger function is called in a
	 * stored callback. To be later called using the check() function
	 * by the parser. This avoids parser's peek() to give the lexer
	 * a false context.
	 */
	triggerAsync: function (type, args, checks, fn) {
		checks.push(function () {
			if (fn()) {
				this.trigger(type, args);
			}
		}.bind(this));
	},

	/*
	 * Extract a punctuator out of the next sequence of characters
	 * or return 'null' if its not possible.
	 *
	 * This method's implementation was heavily influenced by the
	 * scanPunctuator function in the Esprima parser's source code.
	 */
	scanPunctuator: function () {
		var ch1 = this.peek();
		var ch2, ch3, ch4;

		switch (ch1) {
		// Most common single-character punctuators
		case ".":
			if ((/^[0-9]$/).test(this.peek(1))) {
				return null;
			}
			if (this.peek(1) === "." && this.peek(2) === ".") {
				return {
					type: Token.Punctuator,
					value: "..."
				};
			}
			/* falls through */
		case "(":
		case ")":
		case ";":
		case ",":
		case "{":
		case "}":
		case "[":
		case "]":
		case ":":
		case "~":
		case "?":
			return {
				type: Token.Punctuator,
				value: ch1
			};

		// A pound sign (for Node shebangs)
		case "#":
			return {
				type: Token.Punctuator,
				value: ch1
			};

		// We're at the end of input
		case "":
			return null;
		}

		// Peek more characters

		ch2 = this.peek(1);
		ch3 = this.peek(2);
		ch4 = this.peek(3);

		// 4-character punctuator: >>>=

		if (ch1 === ">" && ch2 === ">" && ch3 === ">" && ch4 === "=") {
			return {
				type: Token.Punctuator,
				value: ">>>="
			};
		}

		// 3-character punctuators: === !== >>> <<= >>=

		if (ch1 === "=" && ch2 === "=" && ch3 === "=") {
			return {
				type: Token.Punctuator,
				value: "==="
			};
		}

		if (ch1 === "!" && ch2 === "=" && ch3 === "=") {
			return {
				type: Token.Punctuator,
				value: "!=="
			};
		}

		if (ch1 === ">" && ch2 === ">" && ch3 === ">") {
			return {
				type: Token.Punctuator,
				value: ">>>"
			};
		}

		if (ch1 === "<" && ch2 === "<" && ch3 === "=") {
			return {
				type: Token.Punctuator,
				value: "<<="
			};
		}

		if (ch1 === ">" && ch2 === ">" && ch3 === "=") {
			return {
				type: Token.Punctuator,
				value: ">>="
			};
		}

		// Fat arrow punctuator
		if (ch1 === "=" && ch2 === ">") {
			return {
				type: Token.Punctuator,
				value: ch1 + ch2
			};
		}

		// 2-character punctuators: <= >= == != ++ -- << >> && ||
		// += -= *= %= &= |= ^= (but not /=, see below)
		if (ch1 === ch2 && ("+-<>&|".indexOf(ch1) >= 0)) {
			return {
				type: Token.Punctuator,
				value: ch1 + ch2
			};
		}

		if ("<>=!+-*%&|^".indexOf(ch1) >= 0) {
			if (ch2 === "=") {
				return {
					type: Token.Punctuator,
					value: ch1 + ch2
				};
			}

			return {
				type: Token.Punctuator,
				value: ch1
			};
		}

		// Special case: /=. We need to make sure that this is an
		// operator and not a regular expression.

		if (ch1 === "/") {
			if (ch2 === "=" && /\/=(?!(\S*\/[gim]?))/.test(this.input)) {
				// /= is not a part of a regular expression, return it as a
				// punctuator.
				return {
					type: Token.Punctuator,
					value: "/="
				};
			}

			return {
				type: Token.Punctuator,
				value: "/"
			};
		}

		return null;
	},

	/*
	 * Extract a comment out of the next sequence of characters and/or
	 * lines or return 'null' if its not possible. Since comments can
	 * span across multiple lines this method has to move the char
	 * pointer.
	 *
	 * In addition to normal JavaScript comments (// and /*) this method
	 * also recognizes JSHint- and JSLint-specific comments such as
	 * /*jshint, /*jslint, /*globals and so on.
	 */
	scanComments: function () {
		var ch1 = this.peek();
		var ch2 = this.peek(1);
		var rest = this.input.substr(2);
		var startLine = this.line;
		var startChar = this.char;

		// Create a comment token object and make sure it
		// has all the data JSHint needs to work with special
		// comments.

		function commentToken(label, body, opt) {
			var special = ["jshint", "jslint", "members", "member", "globals", "global", "exported"];
			var isSpecial = false;
			var value = label + body;
			var commentType = "plain";
			opt = opt || {};

			if (opt.isMultiline) {
				value += "*/";
			}

			special.forEach(function (str) {
				if (isSpecial) {
					return;
				}

				// Don't recognize any special comments other than jshint for single-line
				// comments. This introduced many problems with legit comments.
				if (label === "//" && str !== "jshint") {
					return;
				}

				if (body.substr(0, str.length) === str) {
					isSpecial = true;
					label = label + str;
					body = body.substr(str.length);
				}

				if (!isSpecial && body.charAt(0) === " " && body.substr(1, str.length) === str) {
					isSpecial = true;
					label = label + " " + str;
					body = body.substr(str.length + 1);
				}

				if (!isSpecial) {
					return;
				}

				switch (str) {
				case "member":
					commentType = "members";
					break;
				case "global":
					commentType = "globals";
					break;
				default:
					commentType = str;
				}
			});

			return {
				type: Token.Comment,
				commentType: commentType,
				value: value,
				body: body,
				isSpecial: isSpecial,
				isMultiline: opt.isMultiline || false,
				isMalformed: opt.isMalformed || false
			};
		}

		// End of unbegun comment. Raise an error and skip that input.
		if (ch1 === "*" && ch2 === "/") {
			this.trigger("error", {
				code: "E018",
				line: startLine,
				character: startChar
			});

			this.skip(2);
			return null;
		}

		// Comments must start either with // or /*
		if (ch1 !== "/" || (ch2 !== "*" && ch2 !== "/")) {
			return null;
		}

		// One-line comment
		if (ch2 === "/") {
			this.skip(this.input.length); // Skip to the EOL.
			return commentToken("//", rest);
		}

		var body = "";

		/* Multi-line comment */
		if (ch2 === "*") {
			this.skip(2);

			while (this.peek() !== "*" || this.peek(1) !== "/") {
				if (this.peek() === "") { // End of Line
					body += "\n";

					// If we hit EOF and our comment is still unclosed,
					// trigger an error and end the comment implicitly.
					if (!this.nextLine()) {
						this.trigger("error", {
							code: "E017",
							line: startLine,
							character: startChar
						});

						return commentToken("/*", body, {
							isMultiline: true,
							isMalformed: true
						});
					}
				} else {
					body += this.peek();
					this.skip();
				}
			}

			this.skip(2);
			return commentToken("/*", body, { isMultiline: true });
		}
	},

	/*
	 * Extract a keyword out of the next sequence of characters or
	 * return 'null' if its not possible.
	 */
	scanKeyword: function () {
		var result = /^[a-zA-Z_$][a-zA-Z0-9_$]*/.exec(this.input);
		var keywords = [
			"if", "in", "do", "var", "for", "new",
			"try", "let", "this", "else", "case",
			"void", "with", "enum", "while", "break",
			"catch", "throw", "const", "yield", "class",
			"super", "return", "typeof", "delete",
			"switch", "export", "import", "default",
			"finally", "extends", "function", "continue",
			"debugger", "instanceof"
		];

		if (result && keywords.indexOf(result[0]) >= 0) {
			return {
				type: Token.Keyword,
				value: result[0]
			};
		}

		return null;
	},

	/*
	 * Extract a JavaScript identifier out of the next sequence of
	 * characters or return 'null' if its not possible. In addition,
	 * to Identifier this method can also produce BooleanLiteral
	 * (true/false) and NullLiteral (null).
	 */
	scanIdentifier: function () {
		var id = "";
		var index = 0;
		var type, char;

		function isNonAsciiIdentifierStart(code) {
			return nonAsciiIdentifierStartTable.indexOf(code) > -1;
		}

		function isNonAsciiIdentifierPart(code) {
			return isNonAsciiIdentifierStart(code) || nonAsciiIdentifierPartTable.indexOf(code) > -1;
		}

		function isHexDigit(str) {
			return (/^[0-9a-fA-F]$/).test(str);
		}

		var readUnicodeEscapeSequence = function () {
			/*jshint validthis:true */
			index += 1;

			if (this.peek(index) !== "u") {
				return null;
			}

			var ch1 = this.peek(index + 1);
			var ch2 = this.peek(index + 2);
			var ch3 = this.peek(index + 3);
			var ch4 = this.peek(index + 4);
			var code;

			if (isHexDigit(ch1) && isHexDigit(ch2) && isHexDigit(ch3) && isHexDigit(ch4)) {
				code = parseInt(ch1 + ch2 + ch3 + ch4, 16);

				if (asciiIdentifierPartTable[code] || isNonAsciiIdentifierPart(code)) {
					index += 5;
					return "\\u" + ch1 + ch2 + ch3 + ch4;
				}

				return null;
			}

			return null;
		}.bind(this);

		var getIdentifierStart = function () {
			/*jshint validthis:true */
			var chr = this.peek(index);
			var code = chr.charCodeAt(0);

			if (code === 92) {
				return readUnicodeEscapeSequence();
			}

			if (code < 128) {
				if (asciiIdentifierStartTable[code]) {
					index += 1;
					return chr;
				}

				return null;
			}

			if (isNonAsciiIdentifierStart(code)) {
				index += 1;
				return chr;
			}

			return null;
		}.bind(this);

		var getIdentifierPart = function () {
			/*jshint validthis:true */
			var chr = this.peek(index);
			var code = chr.charCodeAt(0);

			if (code === 92) {
				return readUnicodeEscapeSequence();
			}

			if (code < 128) {
				if (asciiIdentifierPartTable[code]) {
					index += 1;
					return chr;
				}

				return null;
			}

			if (isNonAsciiIdentifierPart(code)) {
				index += 1;
				return chr;
			}

			return null;
		}.bind(this);

		char = getIdentifierStart();
		if (char === null) {
			return null;
		}

		id = char;
		for (;;) {
			char = getIdentifierPart();

			if (char === null) {
				break;
			}

			id += char;
		}

		switch (id) {
		case "true":
		case "false":
			type = Token.BooleanLiteral;
			break;
		case "null":
			type = Token.NullLiteral;
			break;
		default:
			type = Token.Identifier;
		}

		return {
			type: type,
			value: id
		};
	},

	/*
	 * Extract a numeric literal out of the next sequence of
	 * characters or return 'null' if its not possible. This method
	 * supports all numeric literals described in section 7.8.3
	 * of the EcmaScript 5 specification.
	 *
	 * This method's implementation was heavily influenced by the
	 * scanNumericLiteral function in the Esprima parser's source code.
	 */
	scanNumericLiteral: function () {
		var index = 0;
		var value = "";
		var length = this.input.length;
		var char = this.peek(index);
		var bad;

		function isDecimalDigit(str) {
			return (/^[0-9]$/).test(str);
		}

		function isOctalDigit(str) {
			return (/^[0-7]$/).test(str);
		}

		function isHexDigit(str) {
			return (/^[0-9a-fA-F]$/).test(str);
		}

		function isIdentifierStart(ch) {
			return (ch === "$") || (ch === "_") || (ch === "\\") ||
				(ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z");
		}

		// Numbers must start either with a decimal digit or a point.

		if (char !== "." && !isDecimalDigit(char)) {
			return null;
		}

		if (char !== ".") {
			value = this.peek(index);
			index += 1;
			char = this.peek(index);

			if (value === "0") {
				// Base-16 numbers.
				if (char === "x" || char === "X") {
					index += 1;
					value += char;

					while (index < length) {
						char = this.peek(index);
						if (!isHexDigit(char)) {
							break;
						}
						value += char;
						index += 1;
					}

					if (value.length <= 2) { // 0x
						return {
							type: Token.NumericLiteral,
							value: value,
							isMalformed: true
						};
					}

					if (index < length) {
						char = this.peek(index);
						if (isIdentifierStart(char)) {
							return null;
						}
					}

					return {
						type: Token.NumericLiteral,
						value: value,
						base: 16,
						isMalformed: false
					};
				}

				// Base-8 numbers.
				if (isOctalDigit(char)) {
					index += 1;
					value += char;
					bad = false;

					while (index < length) {
						char = this.peek(index);

						// Numbers like '019' (note the 9) are not valid octals
						// but we still parse them and mark as malformed.

						if (isDecimalDigit(char)) {
							bad = true;
						} else if (!isOctalDigit(char)) {
							break;
						}
						value += char;
						index += 1;
					}

					if (index < length) {
						char = this.peek(index);
						if (isIdentifierStart(char)) {
							return null;
						}
					}

					return {
						type: Token.NumericLiteral,
						value: value,
						base: 8,
						isMalformed: false
					};
				}

				// Decimal numbers that start with '0' such as '09' are illegal
				// but we still parse them and return as malformed.

				if (isDecimalDigit(char)) {
					index += 1;
					value += char;
				}
			}

			while (index < length) {
				char = this.peek(index);
				if (!isDecimalDigit(char)) {
					break;
				}
				value += char;
				index += 1;
			}
		}

		// Decimal digits.

		if (char === ".") {
			value += char;
			index += 1;

			while (index < length) {
				char = this.peek(index);
				if (!isDecimalDigit(char)) {
					break;
				}
				value += char;
				index += 1;
			}
		}

		// Exponent part.

		if (char === "e" || char === "E") {
			value += char;
			index += 1;
			char = this.peek(index);

			if (char === "+" || char === "-") {
				value += this.peek(index);
				index += 1;
			}

			char = this.peek(index);
			if (isDecimalDigit(char)) {
				value += char;
				index += 1;

				while (index < length) {
					char = this.peek(index);
					if (!isDecimalDigit(char)) {
						break;
					}
					value += char;
					index += 1;
				}
			} else {
				return null;
			}
		}

		if (index < length) {
			char = this.peek(index);
			if (isIdentifierStart(char)) {
				return null;
			}
		}

		return {
			type: Token.NumericLiteral,
			value: value,
			base: 10,
			isMalformed: !isFinite(value)
		};
	},

	/*
	 * Extract a string out of the next sequence of characters and/or
	 * lines or return 'null' if its not possible. Since strings can
	 * span across multiple lines this method has to move the char
	 * pointer.
	 *
	 * This method recognizes pseudo-multiline JavaScript strings:
	 *
	 *   var str = "hello\
	 *   world";
	 */
	scanStringLiteral: function (checks) {
		/*jshint loopfunc:true */
		var quote = this.peek();

		// String must start with a quote.
		if (quote !== "\"" && quote !== "'") {
			return null;
		}

		// In JSON strings must always use double quotes.
		this.triggerAsync("warning", {
			code: "W108",
			line: this.line,
			character: this.char // +1?
		}, checks, function () { return state.jsonMode && quote !== "\""; });

		var value = "";
		var startLine = this.line;
		var startChar = this.char;
		var allowNewLine = false;

		this.skip();

		while (this.peek() !== quote) {
			while (this.peek() === "") { // End Of Line

				// If an EOL is not preceded by a backslash, show a warning
				// and proceed like it was a legit multi-line string where
				// author simply forgot to escape the newline symbol.
				//
				// Another approach is to implicitly close a string on EOL
				// but it generates too many false positives.

				if (!allowNewLine) {
					this.trigger("warning", {
						code: "W112",
						line: this.line,
						character: this.char
					});
				} else {
					allowNewLine = false;

					// Otherwise show a warning if multistr option was not set.
					// For JSON, show warning no matter what.

					this.triggerAsync("warning", {
						code: "W043",
						line: this.line,
						character: this.char
					}, checks, function () { return !state.option.multistr; });

					this.triggerAsync("warning", {
						code: "W042",
						line: this.line,
						character: this.char
					}, checks, function () { return state.jsonMode && state.option.multistr; });
				}

				// If we get an EOF inside of an unclosed string, show an
				// error and implicitly close it at the EOF point.

				if (!this.nextLine()) {
					this.trigger("error", {
						code: "E029",
						line: startLine,
						character: startChar
					});

					return {
						type: Token.StringLiteral,
						value: value,
						isUnclosed: true,
						quote: quote
					};
				}
			}

			allowNewLine = false;
			var char = this.peek();
			var jump = 1; // A length of a jump, after we're done
			              // parsing this character.

			if (char < " ") {
				// Warn about a control character in a string.
				this.trigger("warning", {
					code: "W113",
					line: this.line,
					character: this.char,
					data: [ "<non-printable>" ]
				});
			}

			// Special treatment for some escaped characters.

			if (char === "\\") {
				this.skip();
				char = this.peek();

				switch (char) {
				case "'":
					this.triggerAsync("warning", {
						code: "W114",
						line: this.line,
						character: this.char,
						data: [ "\\'" ]
					}, checks, function () {return state.jsonMode; });
					break;
				case "b":
					char = "\b";
					break;
				case "f":
					char = "\f";
					break;
				case "n":
					char = "\n";
					break;
				case "r":
					char = "\r";
					break;
				case "t":
					char = "\t";
					break;
				case "0":
					char = "\0";

					// Octal literals fail in strict mode.
					// Check if the number is between 00 and 07.
					var n = parseInt(this.peek(1), 10);
					this.triggerAsync("warning", {
						code: "W115",
						line: this.line,
						character: this.char
					}, checks,
					function () { return n >= 0 && n <= 7 && state.directive["use strict"]; });
					break;
				case "u":
					char = String.fromCharCode(parseInt(this.input.substr(1, 4), 16));
					jump = 5;
					break;
				case "v":
					this.triggerAsync("warning", {
						code: "W114",
						line: this.line,
						character: this.char,
						data: [ "\\v" ]
					}, checks, function () { return state.jsonMode; });

					char = "\v";
					break;
				case "x":
					var	x = parseInt(this.input.substr(1, 2), 16);

					this.triggerAsync("warning", {
						code: "W114",
						line: this.line,
						character: this.char,
						data: [ "\\x-" ]
					}, checks, function () { return state.jsonMode; });

					char = String.fromCharCode(x);
					jump = 3;
					break;
				case "\\":
				case "\"":
				case "/":
					break;
				case "":
					allowNewLine = true;
					char = "";
					break;
				case "!":
					if (value.slice(value.length - 2) === "<") {
						break;
					}

					/*falls through */
				default:
					// Weird escaping.
					this.trigger("warning", {
						code: "W044",
						line: this.line,
						character: this.char
					});
				}
			}

			value += char;
			this.skip(jump);
		}

		this.skip();
		return {
			type: Token.StringLiteral,
			value: value,
			isUnclosed: false,
			quote: quote
		};
	},

	/*
	 * Extract a regular expression out of the next sequence of
	 * characters and/or lines or return 'null' if its not possible.
	 *
	 * This method is platform dependent: it accepts almost any
	 * regular expression values but then tries to compile and run
	 * them using system's RegExp object. This means that there are
	 * rare edge cases where one JavaScript engine complains about
	 * your regular expression while others don't.
	 */
	scanRegExp: function () {
		var index = 0;
		var length = this.input.length;
		var char = this.peek();
		var value = char;
		var body = "";
		var flags = [];
		var malformed = false;
		var isCharSet = false;
		var terminated;

		var scanUnexpectedChars = function () {
			// Unexpected control character
			if (char < " ") {
				malformed = true;
				this.trigger("warning", {
					code: "W048",
					line: this.line,
					character: this.char
				});
			}

			// Unexpected escaped character
			if (char === "<") {
				malformed = true;
				this.trigger("warning", {
					code: "W049",
					line: this.line,
					character: this.char,
					data: [ char ]
				});
			}
		}.bind(this);

		// Regular expressions must start with '/'
		if (!this.prereg || char !== "/") {
			return null;
		}

		index += 1;
		terminated = false;

		// Try to get everything in between slashes. A couple of
		// cases aside (see scanUnexpectedChars) we don't really
		// care whether the resulting expression is valid or not.
		// We will check that later using the RegExp object.

		while (index < length) {
			char = this.peek(index);
			value += char;
			body += char;

			if (isCharSet) {
				if (char === "]") {
					if (this.peek(index - 1) !== "\\" || this.peek(index - 2) === "\\") {
						isCharSet = false;
					}
				}

				if (char === "\\") {
					index += 1;
					char = this.peek(index);
					body += char;
					value += char;

					scanUnexpectedChars();
				}

				index += 1;
				continue;
			}

			if (char === "\\") {
				index += 1;
				char = this.peek(index);
				body += char;
				value += char;

				scanUnexpectedChars();

				if (char === "/") {
					index += 1;
					continue;
				}

				if (char === "[") {
					index += 1;
					continue;
				}
			}

			if (char === "[") {
				isCharSet = true;
				index += 1;
				continue;
			}

			if (char === "/") {
				body = body.substr(0, body.length - 1);
				terminated = true;
				index += 1;
				break;
			}

			index += 1;
		}

		// A regular expression that was never closed is an
		// error from which we cannot recover.

		if (!terminated) {
			this.trigger("error", {
				code: "E015",
				line: this.line,
				character: this.from
			});

			return void this.trigger("fatal", {
				line: this.line,
				from: this.from
			});
		}

		// Parse flags (if any).

		while (index < length) {
			char = this.peek(index);
			if (!/[gim]/.test(char)) {
				break;
			}
			flags.push(char);
			value += char;
			index += 1;
		}

		// Check regular expression for correctness.

		try {
			new RegExp(body, flags.join(""));
		} catch (err) {
			malformed = true;
			this.trigger("error", {
				code: "E016",
				line: this.line,
				character: this.char,
				data: [ err.message ] // Platform dependent!
			});
		}

		return {
			type: Token.RegExp,
			value: value,
			flags: flags,
			isMalformed: malformed
		};
	},

	/*
	 * Scan for any occurence of mixed tabs and spaces. If smarttabs option
	 * is on, ignore tabs followed by spaces.
	 *
	 * Tabs followed by one space followed by a block comment are allowed.
	 */
	scanMixedSpacesAndTabs: function () {
		var at, match;

		if (state.option.smarttabs) {
			// Negative look-behind for "//"
			match = this.input.match(/(\/\/|^\s?\*)? \t/);
			at = match && !match[1] ? 0 : -1;
		} else {
			at = this.input.search(/ \t|\t [^\*]/);
		}

		return at;
	},

	/*
	 * Scan for characters that get silently deleted by one or more browsers.
	 */
	scanUnsafeChars: function () {
		return this.input.search(reg.unsafeChars);
	},

	/*
	 * Produce the next raw token or return 'null' if no tokens can be matched.
	 * This method skips over all space characters.
	 */
	next: function (checks) {
		this.from = this.char;

		// Move to the next non-space character.
		var start;
		if (/\s/.test(this.peek())) {
			start = this.char;

			while (/\s/.test(this.peek())) {
				this.from += 1;
				this.skip();
			}

			if (this.peek() === "") { // EOL
				if (!/^\s*$/.test(this.getLines()[this.line - 1]) && state.option.trailing) {
					this.trigger("warning", { code: "W102", line: this.line, character: start });
				}
			}
		}

		// Methods that work with multi-line structures and move the
		// character pointer.

		var match = this.scanComments() ||
			this.scanStringLiteral(checks);

		if (match) {
			return match;
		}

		// Methods that don't move the character pointer.

		match =
			this.scanRegExp() ||
			this.scanPunctuator() ||
			this.scanKeyword() ||
			this.scanIdentifier() ||
			this.scanNumericLiteral();

		if (match) {
			this.skip(match.value.length);
			return match;
		}

		// No token could be matched, give up.

		return null;
	},

	/*
	 * Switch to the next line and reset all char pointers. Once
	 * switched, this method also checks for mixed spaces and tabs
	 * and other minor warnings.
	 */
	nextLine: function () {
		var char;

		if (this.line >= this.getLines().length) {
			return false;
		}

		this.input = this.getLines()[this.line];
		this.line += 1;
		this.char = 1;
		this.from = 1;

		// If we are ignoring linter errors, replace the input with empty string
		// if it doesn't already at least start or end a multi-line comment
		if (state.ignoreLinterErrors === true) {
			var startsWith = function (prefix) {
				return this.indexOf(prefix) === 0;
			};
			var endsWith = function (suffix) {
				return this.indexOf(suffix, this.length - suffix.length) !== -1;
			};
			var inputTrimmed = this.input.trim();
			if (! (startsWith.call(inputTrimmed, "/*") || endsWith.call(inputTrimmed, "*/"))) {
				this.input = "";
			}
		}

		char = this.scanMixedSpacesAndTabs();
		if (char >= 0) {
			this.trigger("warning", { code: "W099", line: this.line, character: char + 1 });
		}

		this.input = this.input.replace(/\t/g, state.tab);
		char = this.scanUnsafeChars();

		if (char >= 0) {
			this.trigger("warning", { code: "W100", line: this.line, character: char });
		}

		// If there is a limit on line length, warn when lines get too
		// long.

		if (state.option.maxlen && state.option.maxlen < this.input.length) {
			this.trigger("warning", { code: "W101", line: this.line, character: this.input.length });
		}

		return true;
	},

	/*
	 * This is simply a synonym for nextLine() method with a friendlier
	 * public name.
	 */
	start: function () {
		this.nextLine();
	},

	/*
	 * Produce the next token. This function is called by advance() to get
	 * the next token. It retuns a token in a JSLint-compatible format.
	 */
	token: function () {
		/*jshint loopfunc:true */
		var checks = asyncTrigger();
		var token;


		function isReserved(token, isProperty) {
			if (!token.reserved) {
				return false;
			}
			var meta = token.meta;

			if (meta && meta.isFutureReservedWord && state.option.inES5()) {
				// ES3 FutureReservedWord in an ES5 environment.
				if (!meta.es5) {
					return false;
				}

				// Some ES5 FutureReservedWord identifiers are active only
				// within a strict mode environment.
				if (meta.strictOnly) {
					if (!state.option.strict && !state.directive["use strict"]) {
						return false;
					}
				}

				if (isProperty) {
					return false;
				}
			}

			return true;
		}

		// Produce a token object.
		var create = function (type, value, isProperty) {
			/*jshint validthis:true */
			var obj;

			if (type !== "(endline)" && type !== "(end)") {
				this.prereg = false;
			}

			if (type === "(punctuator)") {
				switch (value) {
				case ".":
				case ")":
				case "~":
				case "#":
				case "]":
					this.prereg = false;
					break;
				default:
					this.prereg = true;
				}

				obj = Object.create(state.syntax[value] || state.syntax["(error)"]);
			}

			if (type === "(identifier)") {
				if (value === "return" || value === "case" || value === "typeof") {
					this.prereg = true;
				}

				if (_.has(state.syntax, value)) {
					obj = Object.create(state.syntax[value] || state.syntax["(error)"]);

					// If this can't be a reserved keyword, reset the object.
					if (!isReserved(obj, isProperty && type === "(identifier)")) {
						obj = null;
					}
				}
			}

			if (!obj) {
				obj = Object.create(state.syntax[type]);
			}

			obj.identifier = (type === "(identifier)");
			obj.type = obj.type || type;
			obj.value = value;
			obj.line = this.line;
			obj.character = this.char;
			obj.from = this.from;

			if (isProperty && obj.identifier) {
				obj.isProperty = isProperty;
			}

			obj.check = checks.check;

			return obj;
		}.bind(this);

		for (;;) {
			if (!this.input.length) {
				return create(this.nextLine() ? "(endline)" : "(end)", "");
			}

			token = this.next(checks);

			if (!token) {
				if (this.input.length) {
					// Unexpected character.
					this.trigger("error", {
						code: "E024",
						line: this.line,
						character: this.char,
						data: [ this.peek() ]
					});

					this.input = "";
				}

				continue;
			}

			switch (token.type) {
			case Token.StringLiteral:
				this.triggerAsync("String", {
					line: this.line,
					char: this.char,
					from: this.from,
					value: token.value,
					quote: token.quote
				}, checks, function () { return true; });

				return create("(string)", token.value);
			case Token.Identifier:
				this.trigger("Identifier", {
					line: this.line,
					char: this.char,
					from: this.form,
					name: token.value,
					isProperty: state.tokens.curr.id === "."
				});

				/* falls through */
			case Token.Keyword:
			case Token.NullLiteral:
			case Token.BooleanLiteral:
				return create("(identifier)", token.value, state.tokens.curr.id === ".");

			case Token.NumericLiteral:
				if (token.isMalformed) {
					this.trigger("warning", {
						code: "W045",
						line: this.line,
						character: this.char,
						data: [ token.value ]
					});
				}

				this.triggerAsync("warning", {
					code: "W114",
					line: this.line,
					character: this.char,
					data: [ "0x-" ]
				}, checks, function () { return token.base === 16 && state.jsonMode; });

				this.triggerAsync("warning", {
					code: "W115",
					line: this.line,
					character: this.char
				}, checks, function () {
					return state.directive["use strict"] && token.base === 8;
				});

				this.trigger("Number", {
					line: this.line,
					char: this.char,
					from: this.from,
					value: token.value,
					base: token.base,
					isMalformed: token.malformed
				});

				return create("(number)", token.value);

			case Token.RegExp:
				return create("(regexp)", token.value);

			case Token.Comment:
				state.tokens.curr.comment = true;

				if (token.isSpecial) {
					return {
						id: '(comment)',
						value: token.value,
						body: token.body,
						type: token.commentType,
						isSpecial: token.isSpecial,
						line: this.line,
						character: this.char,
						from: this.from
					};
				}

				break;

			case "":
				break;

			default:
				return create("(punctuator)", token.value);
			}
		}
	}
};

exports.Lexer = Lexer;

},{"../data/ascii-identifier-data.js":66,"../data/non-ascii-identifier-part-only.js":67,"../data/non-ascii-identifier-start.js":68,"./reg.js":74,"./state.js":75,"events":60,"underscore":70}],73:[function(require,module,exports){
"use strict";

var _ = require("underscore");

var errors = {
	// JSHint options
	E001: "Bad option: '{a}'.",
	E002: "Bad option value.",

	// JSHint input
	E003: "Expected a JSON value.",
	E004: "Input is neither a string nor an array of strings.",
	E005: "Input is empty.",
	E006: "Unexpected early end of program.",

	// Strict mode
	E007: "Missing \"use strict\" statement.",
	E008: "Strict violation.",
	E009: "Option 'validthis' can't be used in a global scope.",
	E010: "'with' is not allowed in strict mode.",

	// Constants
	E011: "const '{a}' has already been declared.",
	E012: "const '{a}' is initialized to 'undefined'.",
	E013: "Attempting to override '{a}' which is a constant.",

	// Regular expressions
	E014: "A regular expression literal can be confused with '/='.",
	E015: "Unclosed regular expression.",
	E016: "Invalid regular expression.",

	// Tokens
	E017: "Unclosed comment.",
	E018: "Unbegun comment.",
	E019: "Unmatched '{a}'.",
	E020: "Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.",
	E021: "Expected '{a}' and instead saw '{b}'.",
	E022: "Line breaking error '{a}'.",
	E023: "Missing '{a}'.",
	E024: "Unexpected '{a}'.",
	E025: "Missing ':' on a case clause.",
	E026: "Missing '}' to match '{' from line {a}.",
	E027: "Missing ']' to match '[' form line {a}.",
	E028: "Illegal comma.",
	E029: "Unclosed string.",

	// Everything else
	E030: "Expected an identifier and instead saw '{a}'.",
	E031: "Bad assignment.", // FIXME: Rephrase
	E032: "Expected a small integer or 'false' and instead saw '{a}'.",
	E033: "Expected an operator and instead saw '{a}'.",
	E034: "get/set are ES5 features.",
	E035: "Missing property name.",
	E036: "Expected to see a statement and instead saw a block.",
	E037: null, // Vacant
	E038: null, // Vacant
	E039: "Function declarations are not invocable. Wrap the whole function invocation in parens.",
	E040: "Each value should have its own case label.",
	E041: "Unrecoverable syntax error.",
	E042: "Stopping.",
	E043: "Too many errors.",
	E044: "'{a}' is already defined and can't be redefined.",
	E045: "Invalid for each loop.",
	E046: "A yield statement shall be within a generator function (with syntax: `function*`)",
	E047: "A generator function shall contain a yield statement.",
	E048: "Let declaration not directly within block.",
	E049: "A {a} cannot be named '{b}'.",
	E050: "Mozilla requires the yield expression to be parenthesized here.",
	E051: "Regular parameters cannot come after default parameters."
};

var warnings = {
	W001: "'hasOwnProperty' is a really bad name.",
	W002: "Value of '{a}' may be overwritten in IE 8 and earlier.",
	W003: "'{a}' was used before it was defined.",
	W004: "'{a}' is already defined.",
	W005: "A dot following a number can be confused with a decimal point.",
	W006: "Confusing minuses.",
	W007: "Confusing pluses.",
	W008: "A leading decimal point can be confused with a dot: '{a}'.",
	W009: "The array literal notation [] is preferrable.",
	W010: "The object literal notation {} is preferrable.",
	W011: "Unexpected space after '{a}'.",
	W012: "Unexpected space before '{a}'.",
	W013: "Missing space after '{a}'.",
	W014: "Bad line breaking before '{a}'.",
	W015: "Expected '{a}' to have an indentation at {b} instead at {c}.",
	W016: "Unexpected use of '{a}'.",
	W017: "Bad operand.",
	W018: "Confusing use of '{a}'.",
	W019: "Use the isNaN function to compare with NaN.",
	W020: "Read only.",
	W021: "'{a}' is a function.",
	W022: "Do not assign to the exception parameter.",
	W023: "Expected an identifier in an assignment and instead saw a function invocation.",
	W024: "Expected an identifier and instead saw '{a}' (a reserved word).",
	W025: "Missing name in function declaration.",
	W026: "Inner functions should be listed at the top of the outer function.",
	W027: "Unreachable '{a}' after '{b}'.",
	W028: "Label '{a}' on {b} statement.",
	W030: "Expected an assignment or function call and instead saw an expression.",
	W031: "Do not use 'new' for side effects.",
	W032: "Unnecessary semicolon.",
	W033: "Missing semicolon.",
	W034: "Unnecessary directive \"{a}\".",
	W035: "Empty block.",
	W036: "Unexpected /*member '{a}'.",
	W037: "'{a}' is a statement label.",
	W038: "'{a}' used out of scope.",
	W039: "'{a}' is not allowed.",
	W040: "Possible strict violation.",
	W041: "Use '{a}' to compare with '{b}'.",
	W042: "Avoid EOL escaping.",
	W043: "Bad escaping of EOL. Use option multistr if needed.",
	W044: "Bad or unnecessary escaping.",
	W045: "Bad number '{a}'.",
	W046: "Don't use extra leading zeros '{a}'.",
	W047: "A trailing decimal point can be confused with a dot: '{a}'.",
	W048: "Unexpected control character in regular expression.",
	W049: "Unexpected escaped character '{a}' in regular expression.",
	W050: "JavaScript URL.",
	W051: "Variables should not be deleted.",
	W052: "Unexpected '{a}'.",
	W053: "Do not use {a} as a constructor.",
	W054: "The Function constructor is a form of eval.",
	W055: "A constructor name should start with an uppercase letter.",
	W056: "Bad constructor.",
	W057: "Weird construction. Is 'new' unnecessary?",
	W058: "Missing '()' invoking a constructor.",
	W059: "Avoid arguments.{a}.",
	W060: "document.write can be a form of eval.",
	W061: "eval can be harmful.",
	W062: "Wrap an immediate function invocation in parens " +
		"to assist the reader in understanding that the expression " +
		"is the result of a function, and not the function itself.",
	W063: "Math is not a function.",
	W064: "Missing 'new' prefix when invoking a constructor.",
	W065: "Missing radix parameter.",
	W066: "Implied eval. Consider passing a function instead of a string.",
	W067: "Bad invocation.",
	W068: "Wrapping non-IIFE function literals in parens is unnecessary.",
	W069: "['{a}'] is better written in dot notation.",
	W070: "Extra comma. (it breaks older versions of IE)",
	W071: "This function has too many statements. ({a})",
	W072: "This function has too many parameters. ({a})",
	W073: "Blocks are nested too deeply. ({a})",
	W074: "This function's cyclomatic complexity is too high. ({a})",
	W075: "Duplicate key '{a}'.",
	W076: "Unexpected parameter '{a}' in get {b} function.",
	W077: "Expected a single parameter in set {a} function.",
	W078: "Setter is defined without getter.",
	W079: "Redefinition of '{a}'.",
	W080: "It's not necessary to initialize '{a}' to 'undefined'.",
	W081: "Too many var statements.",
	W082: "Function declarations should not be placed in blocks. " +
		"Use a function expression or move the statement to the top of " +
		"the outer function.",
	W083: "Don't make functions within a loop.",
	W084: "Expected a conditional expression and instead saw an assignment.",
	W085: "Don't use 'with'.",
	W086: "Expected a 'break' statement before '{a}'.",
	W087: "Forgotten 'debugger' statement?",
	W088: "Creating global 'for' variable. Should be 'for (var {a} ...'.",
	W089: "The body of a for in should be wrapped in an if statement to filter " +
		"unwanted properties from the prototype.",
	W090: "'{a}' is not a statement label.",
	W091: "'{a}' is out of scope.",
	W092: "Wrap the /regexp/ literal in parens to disambiguate the slash operator.",
	W093: "Did you mean to return a conditional instead of an assignment?",
	W094: "Unexpected comma.",
	W095: "Expected a string and instead saw {a}.",
	W096: "The '{a}' key may produce unexpected results.",
	W097: "Use the function form of \"use strict\".",
	W098: "'{a}' is defined but never used.",
	W099: "Mixed spaces and tabs.",
	W100: "This character may get silently deleted by one or more browsers.",
	W101: "Line is too long.",
	W102: "Trailing whitespace.",
	W103: "The '{a}' property is deprecated.",
	W104: "'{a}' is only available in JavaScript 1.7.",
	W105: "Unexpected {a} in '{b}'.",
	W106: "Identifier '{a}' is not in camel case.",
	W107: "Script URL.",
	W108: "Strings must use doublequote.",
	W109: "Strings must use singlequote.",
	W110: "Mixed double and single quotes.",
	W112: "Unclosed string.",
	W113: "Control character in string: {a}.",
	W114: "Avoid {a}.",
	W115: "Octal literals are not allowed in strict mode.",
	W116: "Expected '{a}' and instead saw '{b}'.",
	W117: "'{a}' is not defined.",
	W118: "'{a}' is only available in Mozilla JavaScript extensions (use moz option).",
	W119: "'{a}' is only available in ES6 (use esnext option).",
	W120: "You might be leaking a variable ({a}) here.",
	W121: "Extending prototype of native object: '{a}'.",
	W122: "Invalid typeof value '{a}'"
};

var info = {
	I001: "Comma warnings can be turned off with 'laxcomma'.",
	I002: "Reserved words as properties can be used under the 'es5' option.",
	I003: "ES5 option is now set per default"
};

exports.errors = {};
exports.warnings = {};
exports.info = {};

_.each(errors, function (desc, code) {
	exports.errors[code] = { code: code, desc: desc };
});

_.each(warnings, function (desc, code) {
	exports.warnings[code] = { code: code, desc: desc };
});

_.each(info, function (desc, code) {
	exports.info[code] = { code: code, desc: desc };
});

},{"underscore":70}],74:[function(require,module,exports){
/*
 * Regular expressions. Some of these are stupidly long.
 */

/*jshint maxlen:1000 */

"use string";

// Unsafe comment or string (ax)
exports.unsafeString =
	/@cc|<\/?|script|\]\s*\]|<\s*!|&lt/i;

// Unsafe characters that are silently deleted by one or more browsers (cx)
exports.unsafeChars =
	/[\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/;

// Characters in strings that need escaping (nx and nxg)
exports.needEsc =
	/[\u0000-\u001f&<"\/\\\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/;

exports.needEscGlobal =
	/[\u0000-\u001f&<"\/\\\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

// Star slash (lx)
exports.starSlash = /\*\//;

// Identifier (ix)
exports.identifier = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/;

// JavaScript URL (jx)
exports.javascriptURL = /^(?:javascript|jscript|ecmascript|vbscript|mocha|livescript)\s*:/i;

// Catches /* falls through */ comments (ft)
exports.fallsThrough = /^\s*\/\*\s*falls?\sthrough\s*\*\/\s*$/;

},{}],75:[function(require,module,exports){
"use strict";

var state = {
	syntax: {},

	reset: function () {
		this.tokens = {
			prev: null,
			next: null,
			curr: null
		};

		this.option = {};
		this.ignored = {};
		this.directive = {};
		this.jsonMode = false;
		this.jsonWarnings = [];
		this.lines = [];
		this.tab = "";
		this.cache = {}; // Node.JS doesn't have Map. Sniff.
		this.ignoreLinterErrors = false;    // Blank out non-multi-line-commented
											// lines when ignoring linter errors
	}
};

exports.state = state;

},{}],76:[function(require,module,exports){
"use strict";

exports.register = function (linter) {
	// Check for properties named __proto__. This special property was
	// deprecated and then re-introduced for ES6.

	linter.on("Identifier", function style_scanProto(data) {
		if (linter.getOption("proto")) {
			return;
		}

		if (data.name === "__proto__") {
			linter.warn("W103", {
				line: data.line,
				char: data.char,
				data: [ data.name ]
			});
		}
	});

	// Check for properties named __iterator__. This is a special property
	// available only in browsers with JavaScript 1.7 implementation.

	linter.on("Identifier", function style_scanIterator(data) {
		if (linter.getOption("iterator")) {
			return;
		}

		if (data.name === "__iterator__") {
			linter.warn("W104", {
				line: data.line,
				char: data.char,
				data: [ data.name ]
			});
		}
	});

	// Check for dangling underscores.

	linter.on("Identifier", function style_scanDangling(data) {
		if (!linter.getOption("nomen")) {
			return;
		}

		// Underscore.js
		if (data.name === "_") {
			return;
		}

		// In Node, __dirname and __filename should be ignored.
		if (linter.getOption("node")) {
			if (/^(__dirname|__filename)$/.test(data.name) && !data.isProperty) {
				return;
			}
		}

		if (/^(_+.*|.*_+)$/.test(data.name)) {
			linter.warn("W105", {
				line: data.line,
				char: data.from,
				data: [ "dangling '_'", data.name ]
			});
		}
	});

	// Check that all identifiers are using camelCase notation.
	// Exceptions: names like MY_VAR and _myVar.

	linter.on("Identifier", function style_scanCamelCase(data) {
		if (!linter.getOption("camelcase")) {
			return;
		}

		if (data.name.replace(/^_+|_+$/g, "").indexOf("_") > -1 && !data.name.match(/^[A-Z0-9_]*$/)) {
			linter.warn("W106", {
				line: data.line,
				char: data.from,
				data: [ data.name ]
			});
		}
	});

	// Enforce consistency in style of quoting.

	linter.on("String", function style_scanQuotes(data) {
		var quotmark = linter.getOption("quotmark");
		var code;

		if (!quotmark) {
			return;
		}

		// If quotmark is set to 'single' warn about all double-quotes.

		if (quotmark === "single" && data.quote !== "'") {
			code = "W109";
		}

		// If quotmark is set to 'double' warn about all single-quotes.

		if (quotmark === "double" && data.quote !== "\"") {
			code = "W108";
		}

		// If quotmark is set to true, remember the first quotation style
		// and then warn about all others.

		if (quotmark === true) {
			if (!linter.getCache("quotmark")) {
				linter.setCache("quotmark", data.quote);
			}

			if (linter.getCache("quotmark") !== data.quote) {
				code = "W110";
			}
		}

		if (code) {
			linter.warn(code, {
				line: data.line,
				char: data.char,
			});
		}
	});

	linter.on("Number", function style_scanNumbers(data) {
		if (data.value.charAt(0) === ".") {
			// Warn about a leading decimal point.
			linter.warn("W008", {
				line: data.line,
				char: data.char,
				data: [ data.value ]
			});
		}

		if (data.value.substr(data.value.length - 1) === ".") {
			// Warn about a trailing decimal point.
			linter.warn("W047", {
				line: data.line,
				char: data.char,
				data: [ data.value ]
			});
		}

		if (/^00+/.test(data.value)) {
			// Multiple leading zeroes.
			linter.warn("W046", {
				line: data.line,
				char: data.char,
				data: [ data.value ]
			});
		}
	});

	// Warn about script URLs.

	linter.on("String", function style_scanJavaScriptURLs(data) {
		var re = /^(?:javascript|jscript|ecmascript|vbscript|mocha|livescript)\s*:/i;

		if (linter.getOption("scripturl")) {
			return;
		}

		if (re.test(data.value)) {
			linter.warn("W107", {
				line: data.line,
				char: data.char
			});
		}
	});
};
},{}],77:[function(require,module,exports){
// jshint -W001

"use strict";

// Identifiers provided by the ECMAScript standard.

exports.reservedVars = {
	arguments : false,
	NaN       : false
};

exports.ecmaIdentifiers = {
	Array              : false,
	Boolean            : false,
	Date               : false,
	decodeURI          : false,
	decodeURIComponent : false,
	encodeURI          : false,
	encodeURIComponent : false,
	Error              : false,
	"eval"             : false,
	EvalError          : false,
	Function           : false,
	hasOwnProperty     : false,
	isFinite           : false,
	isNaN              : false,
	JSON               : false,
	Math               : false,
	Map                : false,
	Number             : false,
	Object             : false,
	parseInt           : false,
	parseFloat         : false,
	RangeError         : false,
	ReferenceError     : false,
	RegExp             : false,
	Set                : false,
	String             : false,
	SyntaxError        : false,
	TypeError          : false,
	URIError           : false,
	WeakMap            : false
};

// Global variables commonly provided by a web browser environment.

exports.browser = {
	Audio                : false,
	Blob                 : false,
	addEventListener     : false,
	applicationCache     : false,
	atob                 : false,
	blur                 : false,
	btoa                 : false,
	clearInterval        : false,
	clearTimeout         : false,
	close                : false,
	closed               : false,
	CustomEvent          : false,
	DOMParser            : false,
	defaultStatus        : false,
	document             : false,
	Element              : false,
	ElementTimeControl   : false,
	event                : false,
	FileReader           : false,
	FormData             : false,
	focus                : false,
	frames               : false,
	getComputedStyle     : false,
	HTMLElement          : false,
	HTMLAnchorElement    : false,
	HTMLBaseElement      : false,
	HTMLBlockquoteElement: false,
	HTMLBodyElement      : false,
	HTMLBRElement        : false,
	HTMLButtonElement    : false,
	HTMLCanvasElement    : false,
	HTMLDirectoryElement : false,
	HTMLDivElement       : false,
	HTMLDListElement     : false,
	HTMLFieldSetElement  : false,
	HTMLFontElement      : false,
	HTMLFormElement      : false,
	HTMLFrameElement     : false,
	HTMLFrameSetElement  : false,
	HTMLHeadElement      : false,
	HTMLHeadingElement   : false,
	HTMLHRElement        : false,
	HTMLHtmlElement      : false,
	HTMLIFrameElement    : false,
	HTMLImageElement     : false,
	HTMLInputElement     : false,
	HTMLIsIndexElement   : false,
	HTMLLabelElement     : false,
	HTMLLayerElement     : false,
	HTMLLegendElement    : false,
	HTMLLIElement        : false,
	HTMLLinkElement      : false,
	HTMLMapElement       : false,
	HTMLMenuElement      : false,
	HTMLMetaElement      : false,
	HTMLModElement       : false,
	HTMLObjectElement    : false,
	HTMLOListElement     : false,
	HTMLOptGroupElement  : false,
	HTMLOptionElement    : false,
	HTMLParagraphElement : false,
	HTMLParamElement     : false,
	HTMLPreElement       : false,
	HTMLQuoteElement     : false,
	HTMLScriptElement    : false,
	HTMLSelectElement    : false,
	HTMLStyleElement     : false,
	HTMLTableCaptionElement: false,
	HTMLTableCellElement : false,
	HTMLTableColElement  : false,
	HTMLTableElement     : false,
	HTMLTableRowElement  : false,
	HTMLTableSectionElement: false,
	HTMLTextAreaElement  : false,
	HTMLTitleElement     : false,
	HTMLUListElement     : false,
	HTMLVideoElement     : false,
	history              : false,
	Image                : false,
	length               : false,
	localStorage         : false,
	location             : false,
	MessageChannel       : false,
	MessageEvent         : false,
	MessagePort          : false,
	MouseEvent           : false,
	moveBy               : false,
	moveTo               : false,
	MutationObserver     : false,
	name                 : false,
	Node                 : false,
	NodeFilter           : false,
	navigator            : false,
	onbeforeunload       : true,
	onblur               : true,
	onerror              : true,
	onfocus              : true,
	onload               : true,
	onresize             : true,
	onunload             : true,
	open                 : false,
	openDatabase         : false,
	opener               : false,
	Option               : false,
	parent               : false,
	print                : false,
	removeEventListener  : false,
	resizeBy             : false,
	resizeTo             : false,
	screen               : false,
	scroll               : false,
	scrollBy             : false,
	scrollTo             : false,
	sessionStorage       : false,
	setInterval          : false,
	setTimeout           : false,
	SharedWorker         : false,
	status               : false,
	SVGAElement          : false,
	SVGAltGlyphDefElement: false,
	SVGAltGlyphElement   : false,
	SVGAltGlyphItemElement: false,
	SVGAngle             : false,
	SVGAnimateColorElement: false,
	SVGAnimateElement    : false,
	SVGAnimateMotionElement: false,
	SVGAnimateTransformElement: false,
	SVGAnimatedAngle     : false,
	SVGAnimatedBoolean   : false,
	SVGAnimatedEnumeration: false,
	SVGAnimatedInteger   : false,
	SVGAnimatedLength    : false,
	SVGAnimatedLengthList: false,
	SVGAnimatedNumber    : false,
	SVGAnimatedNumberList: false,
	SVGAnimatedPathData  : false,
	SVGAnimatedPoints    : false,
	SVGAnimatedPreserveAspectRatio: false,
	SVGAnimatedRect      : false,
	SVGAnimatedString    : false,
	SVGAnimatedTransformList: false,
	SVGAnimationElement  : false,
	SVGCSSRule           : false,
	SVGCircleElement     : false,
	SVGClipPathElement   : false,
	SVGColor             : false,
	SVGColorProfileElement: false,
	SVGColorProfileRule  : false,
	SVGComponentTransferFunctionElement: false,
	SVGCursorElement     : false,
	SVGDefsElement       : false,
	SVGDescElement       : false,
	SVGDocument          : false,
	SVGElement           : false,
	SVGElementInstance   : false,
	SVGElementInstanceList: false,
	SVGEllipseElement    : false,
	SVGExternalResourcesRequired: false,
	SVGFEBlendElement    : false,
	SVGFEColorMatrixElement: false,
	SVGFEComponentTransferElement: false,
	SVGFECompositeElement: false,
	SVGFEConvolveMatrixElement: false,
	SVGFEDiffuseLightingElement: false,
	SVGFEDisplacementMapElement: false,
	SVGFEDistantLightElement: false,
	SVGFEFloodElement    : false,
	SVGFEFuncAElement    : false,
	SVGFEFuncBElement    : false,
	SVGFEFuncGElement    : false,
	SVGFEFuncRElement    : false,
	SVGFEGaussianBlurElement: false,
	SVGFEImageElement    : false,
	SVGFEMergeElement    : false,
	SVGFEMergeNodeElement: false,
	SVGFEMorphologyElement: false,
	SVGFEOffsetElement   : false,
	SVGFEPointLightElement: false,
	SVGFESpecularLightingElement: false,
	SVGFESpotLightElement: false,
	SVGFETileElement     : false,
	SVGFETurbulenceElement: false,
	SVGFilterElement     : false,
	SVGFilterPrimitiveStandardAttributes: false,
	SVGFitToViewBox      : false,
	SVGFontElement       : false,
	SVGFontFaceElement   : false,
	SVGFontFaceFormatElement: false,
	SVGFontFaceNameElement: false,
	SVGFontFaceSrcElement: false,
	SVGFontFaceUriElement: false,
	SVGForeignObjectElement: false,
	SVGGElement          : false,
	SVGGlyphElement      : false,
	SVGGlyphRefElement   : false,
	SVGGradientElement   : false,
	SVGHKernElement      : false,
	SVGICCColor          : false,
	SVGImageElement      : false,
	SVGLangSpace         : false,
	SVGLength            : false,
	SVGLengthList        : false,
	SVGLineElement       : false,
	SVGLinearGradientElement: false,
	SVGLocatable         : false,
	SVGMPathElement      : false,
	SVGMarkerElement     : false,
	SVGMaskElement       : false,
	SVGMatrix            : false,
	SVGMetadataElement   : false,
	SVGMissingGlyphElement: false,
	SVGNumber            : false,
	SVGNumberList        : false,
	SVGPaint             : false,
	SVGPathElement       : false,
	SVGPathSeg           : false,
	SVGPathSegArcAbs     : false,
	SVGPathSegArcRel     : false,
	SVGPathSegClosePath  : false,
	SVGPathSegCurvetoCubicAbs: false,
	SVGPathSegCurvetoCubicRel: false,
	SVGPathSegCurvetoCubicSmoothAbs: false,
	SVGPathSegCurvetoCubicSmoothRel: false,
	SVGPathSegCurvetoQuadraticAbs: false,
	SVGPathSegCurvetoQuadraticRel: false,
	SVGPathSegCurvetoQuadraticSmoothAbs: false,
	SVGPathSegCurvetoQuadraticSmoothRel: false,
	SVGPathSegLinetoAbs  : false,
	SVGPathSegLinetoHorizontalAbs: false,
	SVGPathSegLinetoHorizontalRel: false,
	SVGPathSegLinetoRel  : false,
	SVGPathSegLinetoVerticalAbs: false,
	SVGPathSegLinetoVerticalRel: false,
	SVGPathSegList       : false,
	SVGPathSegMovetoAbs  : false,
	SVGPathSegMovetoRel  : false,
	SVGPatternElement    : false,
	SVGPoint             : false,
	SVGPointList         : false,
	SVGPolygonElement    : false,
	SVGPolylineElement   : false,
	SVGPreserveAspectRatio: false,
	SVGRadialGradientElement: false,
	SVGRect              : false,
	SVGRectElement       : false,
	SVGRenderingIntent   : false,
	SVGSVGElement        : false,
	SVGScriptElement     : false,
	SVGSetElement        : false,
	SVGStopElement       : false,
	SVGStringList        : false,
	SVGStylable          : false,
	SVGStyleElement      : false,
	SVGSwitchElement     : false,
	SVGSymbolElement     : false,
	SVGTRefElement       : false,
	SVGTSpanElement      : false,
	SVGTests             : false,
	SVGTextContentElement: false,
	SVGTextElement       : false,
	SVGTextPathElement   : false,
	SVGTextPositioningElement: false,
	SVGTitleElement      : false,
	SVGTransform         : false,
	SVGTransformList     : false,
	SVGTransformable     : false,
	SVGURIReference      : false,
	SVGUnitTypes         : false,
	SVGUseElement        : false,
	SVGVKernElement      : false,
	SVGViewElement       : false,
	SVGViewSpec          : false,
	SVGZoomAndPan        : false,
	TimeEvent            : false,
	top                  : false,
	URL                  : false,
	WebSocket            : false,
	window               : false,
	Worker               : false,
	XMLHttpRequest       : false,
	XMLSerializer        : false,
	XPathEvaluator       : false,
	XPathException       : false,
	XPathExpression      : false,
	XPathNamespace       : false,
	XPathNSResolver      : false,
	XPathResult          : false
};

exports.devel = {
	alert  : false,
	confirm: false,
	console: false,
	Debug  : false,
	opera  : false,
	prompt : false
};

exports.worker = {
	importScripts: true,
	postMessage  : true,
	self         : true
};

// Widely adopted global names that are not part of ECMAScript standard
exports.nonstandard = {
	escape  : false,
	unescape: false
};

// Globals provided by popular JavaScript environments.

exports.couch = {
	"require" : false,
	respond   : false,
	getRow    : false,
	emit      : false,
	send      : false,
	start     : false,
	sum       : false,
	log       : false,
	exports   : false,
	module    : false,
	provides  : false
};

exports.node = {
	__filename    : false,
	__dirname     : false,
	Buffer        : false,
	console       : false,
	exports       : true,  // In Node it is ok to exports = module.exports = foo();
	GLOBAL        : false,
	global        : false,
	module        : false,
	process       : false,
	require       : false,
	setTimeout    : false,
	clearTimeout  : false,
	setInterval   : false,
	clearInterval : false,
	setImmediate  : false, // v0.9.1+
	clearImmediate: false  // v0.9.1+
};

exports.phantom = {
	phantom      : true,
	require      : true,
	WebPage      : true,
	console      : true, // in examples, but undocumented
	exports      : true  // v1.7+
};

exports.rhino = {
	defineClass  : false,
	deserialize  : false,
	gc           : false,
	help         : false,
	importPackage: false,
	"java"       : false,
	load         : false,
	loadClass    : false,
	print        : false,
	quit         : false,
	readFile     : false,
	readUrl      : false,
	runCommand   : false,
	seal         : false,
	serialize    : false,
	spawn        : false,
	sync         : false,
	toint32      : false,
	version      : false
};

exports.shelljs = {
	target       : false,
	echo         : false,
	exit         : false,
	cd           : false,
	pwd          : false,
	ls           : false,
	find         : false,
	cp           : false,
	rm           : false,
	mv           : false,
	mkdir        : false,
	test         : false,
	cat          : false,
	sed          : false,
	grep         : false,
	which        : false,
	dirs         : false,
	pushd        : false,
	popd         : false,
	env          : false,
	exec         : false,
	chmod        : false,
	config       : false,
	error        : false,
	tempdir      : false
};

exports.typed = {
	ArrayBuffer         : false,
	ArrayBufferView     : false,
	DataView            : false,
	Float32Array        : false,
	Float64Array        : false,
	Int16Array          : false,
	Int32Array          : false,
	Int8Array           : false,
	Uint16Array         : false,
	Uint32Array         : false,
	Uint8Array          : false,
	Uint8ClampedArray   : false
};

exports.wsh = {
	ActiveXObject            : true,
	Enumerator               : true,
	GetObject                : true,
	ScriptEngine             : true,
	ScriptEngineBuildVersion : true,
	ScriptEngineMajorVersion : true,
	ScriptEngineMinorVersion : true,
	VBArray                  : true,
	WSH                      : true,
	WScript                  : true,
	XDomainRequest           : true
};

// Globals provided by popular JavaScript libraries.

exports.dojo = {
	dojo     : false,
	dijit    : false,
	dojox    : false,
	define   : false,
	"require": false
};

exports.jquery = {
	"$"    : false,
	jQuery : false
};

exports.mootools = {
	"$"           : false,
	"$$"          : false,
	Asset         : false,
	Browser       : false,
	Chain         : false,
	Class         : false,
	Color         : false,
	Cookie        : false,
	Core          : false,
	Document      : false,
	DomReady      : false,
	DOMEvent      : false,
	DOMReady      : false,
	Drag          : false,
	Element       : false,
	Elements      : false,
	Event         : false,
	Events        : false,
	Fx            : false,
	Group         : false,
	Hash          : false,
	HtmlTable     : false,
	Iframe        : false,
	IframeShim    : false,
	InputValidator: false,
	instanceOf    : false,
	Keyboard      : false,
	Locale        : false,
	Mask          : false,
	MooTools      : false,
	Native        : false,
	Options       : false,
	OverText      : false,
	Request       : false,
	Scroller      : false,
	Slick         : false,
	Slider        : false,
	Sortables     : false,
	Spinner       : false,
	Swiff         : false,
	Tips          : false,
	Type          : false,
	typeOf        : false,
	URI           : false,
	Window        : false
};

exports.prototypejs = {
	"$"               : false,
	"$$"              : false,
	"$A"              : false,
	"$F"              : false,
	"$H"              : false,
	"$R"              : false,
	"$break"          : false,
	"$continue"       : false,
	"$w"              : false,
	Abstract          : false,
	Ajax              : false,
	Class             : false,
	Enumerable        : false,
	Element           : false,
	Event             : false,
	Field             : false,
	Form              : false,
	Hash              : false,
	Insertion         : false,
	ObjectRange       : false,
	PeriodicalExecuter: false,
	Position          : false,
	Prototype         : false,
	Selector          : false,
	Template          : false,
	Toggle            : false,
	Try               : false,
	Autocompleter     : false,
	Builder           : false,
	Control           : false,
	Draggable         : false,
	Draggables        : false,
	Droppables        : false,
	Effect            : false,
	Sortable          : false,
	SortableObserver  : false,
	Sound             : false,
	Scriptaculous     : false
};

exports.yui = {
	YUI       : false,
	Y         : false,
	YUI_config: false
};


},{}],78:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"./source-map/source-map-consumer":83,"./source-map/source-map-generator":84,"./source-map/source-node":85}],79:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[util.toSetString(aStr)] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":86,"amdefine":87}],80:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * is placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string.
   */
  exports.decode = function base64VLQ_decode(aStr) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    return {
      value: fromVLQSigned(result),
      rest: aStr.slice(i)
    };
  };

});

},{"./base64":81,"amdefine":87}],81:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var charToIntMap = {};
  var intToCharMap = {};

  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    .split('')
    .forEach(function (ch, index) {
      charToIntMap[ch] = index;
      intToCharMap[index] = ch;
    });

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function base64_encode(aNumber) {
    if (aNumber in intToCharMap) {
      return intToCharMap[aNumber];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 digit to an integer.
   */
  exports.decode = function base64_decode(aChar) {
    if (aChar in charToIntMap) {
      return charToIntMap[aChar];
    }
    throw new TypeError("Not a valid base 64 digit: " + aChar);
  };

});

},{"amdefine":87}],82:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the next
    //      closest element that is less than that element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element which is less than the one we are searching for, so we
    //      return null.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return aHaystack[mid];
    }
    else if (cmp > 0) {
      // aHaystack[mid] is greater than our needle.
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      // We did not find an exact match, return the next closest one
      // (termination case 2).
      return aHaystack[mid];
    }
    else {
      // aHaystack[mid] is less than our needle.
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (2) or (3) and return the appropriate thing.
      return aLow < 0
        ? null
        : aHaystack[aLow];
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the next lowest value checked if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare) {
    return aHaystack.length > 0
      ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
      : null;
  };

});

},{"amdefine":87}],83:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');

  /**
   * A SourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  /**
   * Create a SourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns SourceMapConsumer
   */
  SourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(SourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.slice()
        .sort(util.compareByGeneratedPositions);
      smc.__originalMappings = aSourceMap._mappings.slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var mappingSeparator = /^[,;]/;
      var str = aStr;
      var mapping;
      var temp;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          temp = base64VLQ.decode(str);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
            // Original source.
            temp = base64VLQ.decode(str);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            temp = base64VLQ.decode(str);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            temp = base64VLQ.decode(str);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
              // Original name.
              temp = base64VLQ.decode(str);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__generatedMappings.sort(util.compareByGeneratedPositions);
      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  SourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  SourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var mapping = this._findMapping(needle,
                                      this._generatedMappings,
                                      "generatedLine",
                                      "generatedColumn",
                                      util.compareByGeneratedPositions);

      if (mapping && mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source && this.sourceRoot) {
          source = util.join(this.sourceRoot, source);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: util.getArg(mapping, 'name', null)
        };
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  SourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mapping = this._findMapping(needle,
                                      this._originalMappings,
                                      "originalLine",
                                      "originalColumn",
                                      util.compareByOriginalPositions);

      if (mapping) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null)
        };
      }

      return {
        line: null,
        column: null
      };
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source && sourceRoot) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./array-set":79,"./base64-vlq":80,"./binary-search":82,"./util":86,"amdefine":87}],84:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = [];
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source) {
          newMapping.source = mapping.source;
          if (sourceRoot) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      this._validateMapping(generated, original, source, name);

      if (source && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.push({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent !== null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (!aSourceFile) {
        if (!aSourceMapConsumer.file) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        aSourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "aSourceFile" relative if an absolute Url is passed.
      if (sourceRoot) {
        aSourceFile = util.relative(sourceRoot, aSourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "aSourceFile"
      this._mappings.forEach(function (mapping) {
        if (mapping.source === aSourceFile && mapping.originalLine) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source !== null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath) {
              mapping.source = util.join(aSourceMapPath, mapping.source)
            }
            if (sourceRoot) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name !== null && mapping.name !== null) {
              // Only use the identifier name if it's an identifier
              // in both SourceMaps
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          if (sourceRoot) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      // The mappings must be guaranteed to be in sorted order before we start
      // serializing them or else the generated line numbers (which are defined
      // via the ';' separators) will be all messed up. Note: it might be more
      // performant to maintain the sorting as we insert them, rather than as we
      // serialize them, but the big O is the same either way.
      this._mappings.sort(util.compareByGeneratedPositions);

      for (var i = 0, len = this._mappings.length; i < len; i++) {
        mapping = this._mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        file: this._file,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._sourceRoot) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":79,"./base64-vlq":80,"./util":86,"amdefine":87}],85:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine === undefined ? null : aLine;
    this.column = aColumn === undefined ? null : aColumn;
    this.source = aSource === undefined ? null : aSource;
    this.name = aName === undefined ? null : aName;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // The generated code
      // Processed fragments are removed from this array.
      var remainingLines = aGeneratedCode.split('\n');

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate first line with "lastMapping"
            addMappingWithCode(lastMapping, remainingLines.shift() + "\n");
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
            // The remaining code is added without mapping
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            // No more remaining code, continue
            lastMapping = mapping;
            return;
          }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(remainingLines.shift() + "\n");
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[0];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      if (remainingLines.length > 0) {
        if (lastMapping) {
          // Associate the remaining code in the current line with "lastMapping"
          var lastLine = remainingLines.shift();
          if (remainingLines.length > 0) lastLine += "\n";
          addMappingWithCode(lastMapping, lastLine);
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.join("\n"));
      }

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content) {
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  mapping.source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk instanceof SourceNode) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild instanceof SourceNode) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i] instanceof SourceNode) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      chunk.split('').forEach(function (ch, idx, array) {
        if (ch === '\n') {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === array.length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      });
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":84,"./util":86,"amdefine":87}],86:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consequtive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = (path.charAt(0) === '/');

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  function relative(aRoot, aPath) {
    aRoot = aRoot.replace(/\/$/, '');

    var url = urlParse(aRoot);
    if (aPath.charAt(0) == "/" && url && url.path == "/") {
      return aPath.slice(1);
    }

    return aPath.indexOf(aRoot + '/') === 0
      ? aPath.substr(aRoot.length + 1)
      : aPath;
  }
  exports.relative = relative;

  function strcmp(aStr1, aStr2) {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2) - (s1 < s2);
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal) {
      return cmp;
    }

    cmp = strcmp(mappingA.name, mappingB.name);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    return mappingA.generatedColumn - mappingB.generatedColumn;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings where the generated positions are
   * compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
    var cmp;

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositions = compareByGeneratedPositions;

});

},{"amdefine":87}],87:[function(require,module,exports){
(function (process,__filename){/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                process.nextTick(function () {
                    callback.apply(null, deps);
                });
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;
}).call(this,require("/Users/honambang/git/aether/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js"),"/../node_modules/source-map/node_modules/amdefine/amdefine.js")
},{"/Users/honambang/git/aether/node_modules/grunt-browserify/node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js":62,"path":63}],88:[function(require,module,exports){
/*
Author: Geraint Luff and others
Year: 2013

This code is released into the "public domain" by its author(s).  Anybody may use, alter and distribute the code without restriction.  The author makes no guarantees, and takes no liability of any kind for use of this code.

If you find a bug or make an improvement, it would be courteous to let the author know, but it is not compulsory.
*/
(function (global) {
'use strict';

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FObject%2Fkeys
if (!Object.keys) {
	Object.keys = (function () {
		var hasOwnProperty = Object.prototype.hasOwnProperty,
			hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
			dontEnums = [
				'toString',
				'toLocaleString',
				'valueOf',
				'hasOwnProperty',
				'isPrototypeOf',
				'propertyIsEnumerable',
				'constructor'
			],
			dontEnumsLength = dontEnums.length;

		return function (obj) {
			if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {
				throw new TypeError('Object.keys called on non-object');
			}

			var result = [];

			for (var prop in obj) {
				if (hasOwnProperty.call(obj, prop)) {
					result.push(prop);
				}
			}

			if (hasDontEnumBug) {
				for (var i=0; i < dontEnumsLength; i++) {
					if (hasOwnProperty.call(obj, dontEnums[i])) {
						result.push(dontEnums[i]);
					}
				}
			}
			return result;
		};
	})();
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
if (!Object.create) {
	Object.create = (function(){
		function F(){}

		return function(o){
			if (arguments.length !== 1) {
				throw new Error('Object.create implementation only accepts one parameter.');
			}
			F.prototype = o;
			return new F();
		};
	})();
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FisArray
if(!Array.isArray) {
	Array.isArray = function (vArg) {
		return Object.prototype.toString.call(vArg) === "[object Array]";
	};
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf
if (!Array.prototype.indexOf) {
	Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
		if (this === null) {
			throw new TypeError();
		}
		var t = Object(this);
		var len = t.length >>> 0;

		if (len === 0) {
			return -1;
		}
		var n = 0;
		if (arguments.length > 1) {
			n = Number(arguments[1]);
			if (n !== n) { // shortcut for verifying if it's NaN
				n = 0;
			} else if (n !== 0 && n !== Infinity && n !== -Infinity) {
				n = (n > 0 || -1) * Math.floor(Math.abs(n));
			}
		}
		if (n >= len) {
			return -1;
		}
		var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
		for (; k < len; k++) {
			if (k in t && t[k] === searchElement) {
				return k;
			}
		}
		return -1;
	};
}

// Grungey Object.isFrozen hack
if (!Object.isFrozen) {
	Object.isFrozen = function (obj) {
		var key = "tv4_test_frozen_key";
		while (obj.hasOwnProperty(key)) {
			key += Math.random();
		}
		try {
			obj[key] = true;
			delete obj[key];
			return false;
		} catch (e) {
			return true;
		}
	};
}
var ValidatorContext = function ValidatorContext(parent, collectMultiple, errorMessages, checkRecursive, trackUnknownProperties) {
	this.missing = [];
	this.missingMap = {};
	this.formatValidators = parent ? Object.create(parent.formatValidators) : {};
	this.schemas = parent ? Object.create(parent.schemas) : {};
	this.collectMultiple = collectMultiple;
	this.errors = [];
	this.handleError = collectMultiple ? this.collectError : this.returnError;
	if (checkRecursive) {
		this.checkRecursive = true;
		this.scanned = [];
		this.scannedFrozen = [];
		this.scannedFrozenSchemas = [];
		this.scannedFrozenValidationErrors = [];
		this.validatedSchemasKey = 'tv4_validation_id';
		this.validationErrorsKey = 'tv4_validation_errors_id';
	}
	if (trackUnknownProperties) {
		this.trackUnknownProperties = true;
		this.knownPropertyPaths = {};
		this.unknownPropertyPaths = {};
	}
	this.errorMessages = errorMessages;
};
ValidatorContext.prototype.createError = function (code, messageParams, dataPath, schemaPath, subErrors) {
	var messageTemplate = this.errorMessages[code] || ErrorMessagesDefault[code];
	if (typeof messageTemplate !== 'string') {
		return new ValidationError(code, "Unknown error code " + code + ": " + JSON.stringify(messageParams), dataPath, schemaPath, subErrors);
	}
	// Adapted from Crockford's supplant()
	var message = messageTemplate.replace(/\{([^{}]*)\}/g, function (whole, varName) {
		var subValue = messageParams[varName];
		return typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;
	});
	return new ValidationError(code, message, dataPath, schemaPath, subErrors);
};
ValidatorContext.prototype.returnError = function (error) {
	return error;
};
ValidatorContext.prototype.collectError = function (error) {
	if (error) {
		this.errors.push(error);
	}
	return null;
};
ValidatorContext.prototype.prefixErrors = function (startIndex, dataPath, schemaPath) {
	for (var i = startIndex; i < this.errors.length; i++) {
		this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);
	}
	return this;
};
ValidatorContext.prototype.banUnknownProperties = function () {
	for (var unknownPath in this.unknownPropertyPaths) {
		var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, "");
		var result = this.handleError(error);
		if (result) {
			return result;
		}
	}
	return null;
};

ValidatorContext.prototype.addFormat = function (format, validator) {
	if (typeof format === 'object') {
		for (var key in format) {
			this.addFormat(key, format[key]);
		}
		return this;
	}
	this.formatValidators[format] = validator;
};
ValidatorContext.prototype.resolveRefs = function (schema, urlHistory) {
	if (schema['$ref'] !== undefined) {
		urlHistory = urlHistory || {};
		if (urlHistory[schema['$ref']]) {
			return this.createError(ErrorCodes.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(', ')}, '', '');
		}
		urlHistory[schema['$ref']] = true;
		schema = this.getSchema(schema['$ref'], urlHistory);
	}
	return schema;
};
ValidatorContext.prototype.getSchema = function (url, urlHistory) {
	var schema;
	if (this.schemas[url] !== undefined) {
		schema = this.schemas[url];
		return this.resolveRefs(schema, urlHistory);
	}
	var baseUrl = url;
	var fragment = "";
	if (url.indexOf('#') !== -1) {
		fragment = url.substring(url.indexOf("#") + 1);
		baseUrl = url.substring(0, url.indexOf("#"));
	}
	if (typeof this.schemas[baseUrl] === 'object') {
		schema = this.schemas[baseUrl];
		var pointerPath = decodeURIComponent(fragment);
		if (pointerPath === "") {
			return this.resolveRefs(schema, urlHistory);
		} else if (pointerPath.charAt(0) !== "/") {
			return undefined;
		}
		var parts = pointerPath.split("/").slice(1);
		for (var i = 0; i < parts.length; i++) {
			var component = parts[i].replace(/~1/g, "/").replace(/~0/g, "~");
			if (schema[component] === undefined) {
				schema = undefined;
				break;
			}
			schema = schema[component];
		}
		if (schema !== undefined) {
			return this.resolveRefs(schema, urlHistory);
		}
	}
	if (this.missing[baseUrl] === undefined) {
		this.missing.push(baseUrl);
		this.missing[baseUrl] = baseUrl;
		this.missingMap[baseUrl] = baseUrl;
	}
};
ValidatorContext.prototype.searchSchemas = function (schema, url) {
	if (schema && typeof schema === "object") {
		if (typeof schema.id === "string") {
			if (isTrustedUrl(url, schema.id)) {
				if (this.schemas[schema.id] === undefined) {
					this.schemas[schema.id] = schema;
				}
			}
		}
		for (var key in schema) {
			if (key !== "enum") {
				if (typeof schema[key] === "object") {
					this.searchSchemas(schema[key], url);
				} else if (key === "$ref") {
					var uri = getDocumentUri(schema[key]);
					if (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {
						this.missingMap[uri] = uri;
					}
				}
			}
		}
	}
};
ValidatorContext.prototype.addSchema = function (url, schema) {
	//overload
	if (typeof url !== 'string' || typeof schema === 'undefined') {
		if (typeof url === 'object' && typeof url.id === 'string') {
			schema = url;
			url = schema.id;
		}
		else {
			return;
		}
	}
	if (url = getDocumentUri(url) + "#") {
		// Remove empty fragment
		url = getDocumentUri(url);
	}
	this.schemas[url] = schema;
	delete this.missingMap[url];
	normSchema(schema, url);
	this.searchSchemas(schema, url);
};

ValidatorContext.prototype.getSchemaMap = function () {
	var map = {};
	for (var key in this.schemas) {
		map[key] = this.schemas[key];
	}
	return map;
};

ValidatorContext.prototype.getSchemaUris = function (filterRegExp) {
	var list = [];
	for (var key in this.schemas) {
		if (!filterRegExp || filterRegExp.test(key)) {
			list.push(key);
		}
	}
	return list;
};

ValidatorContext.prototype.getMissingUris = function (filterRegExp) {
	var list = [];
	for (var key in this.missingMap) {
		if (!filterRegExp || filterRegExp.test(key)) {
			list.push(key);
		}
	}
	return list;
};

ValidatorContext.prototype.dropSchemas = function () {
	this.schemas = {};
	this.reset();
};
ValidatorContext.prototype.reset = function () {
	this.missing = [];
	this.missingMap = {};
	this.errors = [];
};

ValidatorContext.prototype.validateAll = function (data, schema, dataPathParts, schemaPathParts, dataPointerPath) {
	var topLevel;
	schema = this.resolveRefs(schema);
	if (!schema) {
		return null;
	} else if (schema instanceof ValidationError) {
		this.errors.push(schema);
		return schema;
	}

	var startErrorCount = this.errors.length;
	var frozenIndex, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;
	if (this.checkRecursive && data && typeof data === 'object') {
		topLevel = !this.scanned.length;
		if (data[this.validatedSchemasKey]) {
			var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);
			if (schemaIndex !== -1) {
				this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);
				return null;
			}
		}
		if (Object.isFrozen(data)) {
			frozenIndex = this.scannedFrozen.indexOf(data);
			if (frozenIndex !== -1) {
				var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);
				if (frozenSchemaIndex !== -1) {
					this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);
					return null;
				}
			}
		}
		this.scanned.push(data);
		if (Object.isFrozen(data)) {
			if (frozenIndex === -1) {
				frozenIndex = this.scannedFrozen.length;
				this.scannedFrozen.push(data);
				this.scannedFrozenSchemas.push([]);
			}
			scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;
			this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;
			this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];
		} else {
			if (!data[this.validatedSchemasKey]) {
				try {
					Object.defineProperty(data, this.validatedSchemasKey, {
						value: [],
						configurable: true
					});
					Object.defineProperty(data, this.validationErrorsKey, {
						value: [],
						configurable: true
					});
				} catch (e) {
					//IE 7/8 workaround
					data[this.validatedSchemasKey] = [];
					data[this.validationErrorsKey] = [];
				}
			}
			scannedSchemasIndex = data[this.validatedSchemasKey].length;
			data[this.validatedSchemasKey][scannedSchemasIndex] = schema;
			data[this.validationErrorsKey][scannedSchemasIndex] = [];
		}
	}

	var errorCount = this.errors.length;
	var error = this.validateBasic(data, schema, dataPointerPath)
		|| this.validateNumeric(data, schema, dataPointerPath)
		|| this.validateString(data, schema, dataPointerPath)
		|| this.validateArray(data, schema, dataPointerPath)
		|| this.validateObject(data, schema, dataPointerPath)
		|| this.validateCombinations(data, schema, dataPointerPath)
		|| this.validateFormat(data, schema, dataPointerPath)
		|| null;

	if (topLevel) {
		while (this.scanned.length) {
			var item = this.scanned.pop();
			delete item[this.validatedSchemasKey];
		}
		this.scannedFrozen = [];
		this.scannedFrozenSchemas = [];
	}

	if (error || errorCount !== this.errors.length) {
		while ((dataPathParts && dataPathParts.length) || (schemaPathParts && schemaPathParts.length)) {
			var dataPart = (dataPathParts && dataPathParts.length) ? "" + dataPathParts.pop() : null;
			var schemaPart = (schemaPathParts && schemaPathParts.length) ? "" + schemaPathParts.pop() : null;
			if (error) {
				error = error.prefixWith(dataPart, schemaPart);
			}
			this.prefixErrors(errorCount, dataPart, schemaPart);
		}
	}
	
	if (scannedFrozenSchemaIndex !== null) {
		this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);
	} else if (scannedSchemasIndex !== null) {
		data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);
	}

	return this.handleError(error);
};
ValidatorContext.prototype.validateFormat = function (data, schema) {
	if (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {
		return null;
	}
	var errorMessage = this.formatValidators[schema.format].call(null, data, schema);
	if (typeof errorMessage === 'string' || typeof errorMessage === 'number') {
		return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage}).prefixWith(null, "format");
	} else if (errorMessage && typeof errorMessage === 'object') {
		return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage.message || "?"}, errorMessage.dataPath || null, errorMessage.schemaPath || "/format");
	}
	return null;
};

function recursiveCompare(A, B) {
	if (A === B) {
		return true;
	}
	if (typeof A === "object" && typeof B === "object") {
		if (Array.isArray(A) !== Array.isArray(B)) {
			return false;
		} else if (Array.isArray(A)) {
			if (A.length !== B.length) {
				return false;
			}
			for (var i = 0; i < A.length; i++) {
				if (!recursiveCompare(A[i], B[i])) {
					return false;
				}
			}
		} else {
			var key;
			for (key in A) {
				if (B[key] === undefined && A[key] !== undefined) {
					return false;
				}
			}
			for (key in B) {
				if (A[key] === undefined && B[key] !== undefined) {
					return false;
				}
			}
			for (key in A) {
				if (!recursiveCompare(A[key], B[key])) {
					return false;
				}
			}
		}
		return true;
	}
	return false;
}

ValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {
	var error;
	if (error = this.validateType(data, schema, dataPointerPath)) {
		return error.prefixWith(null, "type");
	}
	if (error = this.validateEnum(data, schema, dataPointerPath)) {
		return error.prefixWith(null, "type");
	}
	return null;
};

ValidatorContext.prototype.validateType = function validateType(data, schema) {
	if (schema.type === undefined) {
		return null;
	}
	var dataType = typeof data;
	if (data === null) {
		dataType = "null";
	} else if (Array.isArray(data)) {
		dataType = "array";
	}
	var allowedTypes = schema.type;
	if (typeof allowedTypes !== "object") {
		allowedTypes = [allowedTypes];
	}

	for (var i = 0; i < allowedTypes.length; i++) {
		var type = allowedTypes[i];
		if (type === dataType || (type === "integer" && dataType === "number" && (data % 1 === 0))) {
			return null;
		}
	}
	return this.createError(ErrorCodes.INVALID_TYPE, {type: dataType, expected: allowedTypes.join("/")});
};

ValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {
	if (schema["enum"] === undefined) {
		return null;
	}
	for (var i = 0; i < schema["enum"].length; i++) {
		var enumVal = schema["enum"][i];
		if (recursiveCompare(data, enumVal)) {
			return null;
		}
	}
	return this.createError(ErrorCodes.ENUM_MISMATCH, {value: (typeof JSON !== 'undefined') ? JSON.stringify(data) : data});
};

ValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {
	return this.validateMultipleOf(data, schema, dataPointerPath)
		|| this.validateMinMax(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {
	var multipleOf = schema.multipleOf || schema.divisibleBy;
	if (multipleOf === undefined) {
		return null;
	}
	if (typeof data === "number") {
		if (data % multipleOf !== 0) {
			return this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {value: data, multipleOf: multipleOf});
		}
	}
	return null;
};

ValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {
	if (typeof data !== "number") {
		return null;
	}
	if (schema.minimum !== undefined) {
		if (data < schema.minimum) {
			return this.createError(ErrorCodes.NUMBER_MINIMUM, {value: data, minimum: schema.minimum}).prefixWith(null, "minimum");
		}
		if (schema.exclusiveMinimum && data === schema.minimum) {
			return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {value: data, minimum: schema.minimum}).prefixWith(null, "exclusiveMinimum");
		}
	}
	if (schema.maximum !== undefined) {
		if (data > schema.maximum) {
			return this.createError(ErrorCodes.NUMBER_MAXIMUM, {value: data, maximum: schema.maximum}).prefixWith(null, "maximum");
		}
		if (schema.exclusiveMaximum && data === schema.maximum) {
			return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {value: data, maximum: schema.maximum}).prefixWith(null, "exclusiveMaximum");
		}
	}
	return null;
};

ValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {
	return this.validateStringLength(data, schema, dataPointerPath)
		|| this.validateStringPattern(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {
	if (typeof data !== "string") {
		return null;
	}
	if (schema.minLength !== undefined) {
		if (data.length < schema.minLength) {
			return this.createError(ErrorCodes.STRING_LENGTH_SHORT, {length: data.length, minimum: schema.minLength}).prefixWith(null, "minLength");
		}
	}
	if (schema.maxLength !== undefined) {
		if (data.length > schema.maxLength) {
			return this.createError(ErrorCodes.STRING_LENGTH_LONG, {length: data.length, maximum: schema.maxLength}).prefixWith(null, "maxLength");
		}
	}
	return null;
};

ValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {
	if (typeof data !== "string" || schema.pattern === undefined) {
		return null;
	}
	var regexp = new RegExp(schema.pattern);
	if (!regexp.test(data)) {
		return this.createError(ErrorCodes.STRING_PATTERN, {pattern: schema.pattern}).prefixWith(null, "pattern");
	}
	return null;
};
ValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {
	if (!Array.isArray(data)) {
		return null;
	}
	return this.validateArrayLength(data, schema, dataPointerPath)
		|| this.validateArrayUniqueItems(data, schema, dataPointerPath)
		|| this.validateArrayItems(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {
	var error;
	if (schema.minItems !== undefined) {
		if (data.length < schema.minItems) {
			error = (this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {length: data.length, minimum: schema.minItems})).prefixWith(null, "minItems");
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	if (schema.maxItems !== undefined) {
		if (data.length > schema.maxItems) {
			error = (this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {length: data.length, maximum: schema.maxItems})).prefixWith(null, "maxItems");
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {
	if (schema.uniqueItems) {
		for (var i = 0; i < data.length; i++) {
			for (var j = i + 1; j < data.length; j++) {
				if (recursiveCompare(data[i], data[j])) {
					var error = (this.createError(ErrorCodes.ARRAY_UNIQUE, {match1: i, match2: j})).prefixWith(null, "uniqueItems");
					if (this.handleError(error)) {
						return error;
					}
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {
	if (schema.items === undefined) {
		return null;
	}
	var error, i;
	if (Array.isArray(schema.items)) {
		for (i = 0; i < data.length; i++) {
			if (i < schema.items.length) {
				if (error = this.validateAll(data[i], schema.items[i], [i], ["items", i], dataPointerPath + "/" + i)) {
					return error;
				}
			} else if (schema.additionalItems !== undefined) {
				if (typeof schema.additionalItems === "boolean") {
					if (!schema.additionalItems) {
						error = (this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {})).prefixWith("" + i, "additionalItems");
						if (this.handleError(error)) {
							return error;
						}
					}
				} else if (error = this.validateAll(data[i], schema.additionalItems, [i], ["additionalItems"], dataPointerPath + "/" + i)) {
					return error;
				}
			}
		}
	} else {
		for (i = 0; i < data.length; i++) {
			if (error = this.validateAll(data[i], schema.items, [i], ["items"], dataPointerPath + "/" + i)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {
	if (typeof data !== "object" || data === null || Array.isArray(data)) {
		return null;
	}
	return this.validateObjectMinMaxProperties(data, schema, dataPointerPath)
		|| this.validateObjectRequiredProperties(data, schema, dataPointerPath)
		|| this.validateObjectProperties(data, schema, dataPointerPath)
		|| this.validateObjectDependencies(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {
	var keys = Object.keys(data);
	var error;
	if (schema.minProperties !== undefined) {
		if (keys.length < schema.minProperties) {
			error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {propertyCount: keys.length, minimum: schema.minProperties}).prefixWith(null, "minProperties");
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	if (schema.maxProperties !== undefined) {
		if (keys.length > schema.maxProperties) {
			error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {propertyCount: keys.length, maximum: schema.maxProperties}).prefixWith(null, "maxProperties");
			if (this.handleError(error)) {
				return error;
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {
	if (schema.required !== undefined) {
		for (var i = 0; i < schema.required.length; i++) {
			var key = schema.required[i];
			if (data[key] === undefined) {
				var error = this.createError(ErrorCodes.OBJECT_REQUIRED, {key: key}).prefixWith(null, "" + i).prefixWith(null, "required");
				if (this.handleError(error)) {
					return error;
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {
	var error;
	for (var key in data) {
		var keyPointerPath = dataPointerPath + "/" + key.replace(/~/g, '~0').replace(/\//g, '~1');
		var foundMatch = false;
		if (schema.properties !== undefined && schema.properties[key] !== undefined) {
			foundMatch = true;
			if (error = this.validateAll(data[key], schema.properties[key], [key], ["properties", key], keyPointerPath)) {
				return error;
			}
		}
		if (schema.patternProperties !== undefined) {
			for (var patternKey in schema.patternProperties) {
				var regexp = new RegExp(patternKey);
				if (regexp.test(key)) {
					foundMatch = true;
					if (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], ["patternProperties", patternKey], keyPointerPath)) {
						return error;
					}
				}
			}
		}
		if (!foundMatch) {
			if (schema.additionalProperties !== undefined) {
				if (this.trackUnknownProperties) {
					this.knownPropertyPaths[keyPointerPath] = true;
					delete this.unknownPropertyPaths[keyPointerPath];
				}
				if (typeof schema.additionalProperties === "boolean") {
					if (!schema.additionalProperties) {
						error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {}).prefixWith(key, "additionalProperties");
						if (this.handleError(error)) {
							return error;
						}
					}
				} else {
					if (error = this.validateAll(data[key], schema.additionalProperties, [key], ["additionalProperties"], keyPointerPath)) {
						return error;
					}
				}
			} else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {
				this.unknownPropertyPaths[keyPointerPath] = true;
			}
		} else if (this.trackUnknownProperties) {
			this.knownPropertyPaths[keyPointerPath] = true;
			delete this.unknownPropertyPaths[keyPointerPath];
		}
	}
	return null;
};

ValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {
	var error;
	if (schema.dependencies !== undefined) {
		for (var depKey in schema.dependencies) {
			if (data[depKey] !== undefined) {
				var dep = schema.dependencies[depKey];
				if (typeof dep === "string") {
					if (data[dep] === undefined) {
						error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: dep}).prefixWith(null, depKey).prefixWith(null, "dependencies");
						if (this.handleError(error)) {
							return error;
						}
					}
				} else if (Array.isArray(dep)) {
					for (var i = 0; i < dep.length; i++) {
						var requiredKey = dep[i];
						if (data[requiredKey] === undefined) {
							error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: requiredKey}).prefixWith(null, "" + i).prefixWith(null, depKey).prefixWith(null, "dependencies");
							if (this.handleError(error)) {
								return error;
							}
						}
					}
				} else {
					if (error = this.validateAll(data, dep, [], ["dependencies", depKey], dataPointerPath)) {
						return error;
					}
				}
			}
		}
	}
	return null;
};

ValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {
	return this.validateAllOf(data, schema, dataPointerPath)
		|| this.validateAnyOf(data, schema, dataPointerPath)
		|| this.validateOneOf(data, schema, dataPointerPath)
		|| this.validateNot(data, schema, dataPointerPath)
		|| null;
};

ValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {
	if (schema.allOf === undefined) {
		return null;
	}
	var error;
	for (var i = 0; i < schema.allOf.length; i++) {
		var subSchema = schema.allOf[i];
		if (error = this.validateAll(data, subSchema, [], ["allOf", i], dataPointerPath)) {
			return error;
		}
	}
	return null;
};

ValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {
	if (schema.anyOf === undefined) {
		return null;
	}
	var errors = [];
	var startErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
	}
	var errorAtEnd = true;
	for (var i = 0; i < schema.anyOf.length; i++) {
		if (this.trackUnknownProperties) {
			this.unknownPropertyPaths = {};
			this.knownPropertyPaths = {};
		}
		var subSchema = schema.anyOf[i];

		var errorCount = this.errors.length;
		var error = this.validateAll(data, subSchema, [], ["anyOf", i], dataPointerPath);

		if (error === null && errorCount === this.errors.length) {
			this.errors = this.errors.slice(0, startErrorCount);

			if (this.trackUnknownProperties) {
				for (var knownKey in this.knownPropertyPaths) {
					oldKnownPropertyPaths[knownKey] = true;
					delete oldUnknownPropertyPaths[knownKey];
				}
				for (var unknownKey in this.unknownPropertyPaths) {
					if (!oldKnownPropertyPaths[unknownKey]) {
						oldUnknownPropertyPaths[unknownKey] = true;
					}
				}
				// We need to continue looping so we catch all the property definitions, but we don't want to return an error
				errorAtEnd = false;
				continue;
			}

			return null;
		}
		if (error) {
			errors.push(error.prefixWith(null, "" + i).prefixWith(null, "anyOf"));
		}
	}
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (errorAtEnd) {
		errors = errors.concat(this.errors.slice(startErrorCount));
		this.errors = this.errors.slice(0, startErrorCount);
		return this.createError(ErrorCodes.ANY_OF_MISSING, {}, "", "/anyOf", errors);
	}
};

ValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {
	if (schema.oneOf === undefined) {
		return null;
	}
	var validIndex = null;
	var errors = [];
	var startErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
	}
	for (var i = 0; i < schema.oneOf.length; i++) {
		if (this.trackUnknownProperties) {
			this.unknownPropertyPaths = {};
			this.knownPropertyPaths = {};
		}
		var subSchema = schema.oneOf[i];

		var errorCount = this.errors.length;
		var error = this.validateAll(data, subSchema, [], ["oneOf", i], dataPointerPath);

		if (error === null && errorCount === this.errors.length) {
			if (validIndex === null) {
				validIndex = i;
			} else {
				this.errors = this.errors.slice(0, startErrorCount);
				return this.createError(ErrorCodes.ONE_OF_MULTIPLE, {index1: validIndex, index2: i}, "", "/oneOf");
			}
			if (this.trackUnknownProperties) {
				for (var knownKey in this.knownPropertyPaths) {
					oldKnownPropertyPaths[knownKey] = true;
					delete oldUnknownPropertyPaths[knownKey];
				}
				for (var unknownKey in this.unknownPropertyPaths) {
					if (!oldKnownPropertyPaths[unknownKey]) {
						oldUnknownPropertyPaths[unknownKey] = true;
					}
				}
			}
		} else if (error) {
			errors.push(error.prefixWith(null, "" + i).prefixWith(null, "oneOf"));
		}
	}
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (validIndex === null) {
		errors = errors.concat(this.errors.slice(startErrorCount));
		this.errors = this.errors.slice(0, startErrorCount);
		return this.createError(ErrorCodes.ONE_OF_MISSING, {}, "", "/oneOf", errors);
	} else {
		this.errors = this.errors.slice(0, startErrorCount);
	}
	return null;
};

ValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {
	if (schema.not === undefined) {
		return null;
	}
	var oldErrorCount = this.errors.length;
	var oldUnknownPropertyPaths, oldKnownPropertyPaths;
	if (this.trackUnknownProperties) {
		oldUnknownPropertyPaths = this.unknownPropertyPaths;
		oldKnownPropertyPaths = this.knownPropertyPaths;
		this.unknownPropertyPaths = {};
		this.knownPropertyPaths = {};
	}
	var error = this.validateAll(data, schema.not, null, null, dataPointerPath);
	var notErrors = this.errors.slice(oldErrorCount);
	this.errors = this.errors.slice(0, oldErrorCount);
	if (this.trackUnknownProperties) {
		this.unknownPropertyPaths = oldUnknownPropertyPaths;
		this.knownPropertyPaths = oldKnownPropertyPaths;
	}
	if (error === null && notErrors.length === 0) {
		return this.createError(ErrorCodes.NOT_PASSED, {}, "", "/not");
	}
	return null;
};

// parseURI() and resolveUrl() are from https://gist.github.com/1088850
//   -  released as public domain by author ("Yaffle") - see comments on gist

function parseURI(url) {
	var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
	// authority = '//' + user + ':' + pass '@' + hostname + ':' port
	return (m ? {
		href     : m[0] || '',
		protocol : m[1] || '',
		authority: m[2] || '',
		host     : m[3] || '',
		hostname : m[4] || '',
		port     : m[5] || '',
		pathname : m[6] || '',
		search   : m[7] || '',
		hash     : m[8] || ''
	} : null);
}

function resolveUrl(base, href) {// RFC 3986

	function removeDotSegments(input) {
		var output = [];
		input.replace(/^(\.\.?(\/|$))+/, '')
			.replace(/\/(\.(\/|$))+/g, '/')
			.replace(/\/\.\.$/, '/../')
			.replace(/\/?[^\/]*/g, function (p) {
				if (p === '/..') {
					output.pop();
				} else {
					output.push(p);
				}
		});
		return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
	}

	href = parseURI(href || '');
	base = parseURI(base || '');

	return !href || !base ? null : (href.protocol || base.protocol) +
		(href.protocol || href.authority ? href.authority : base.authority) +
		removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +
		(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +
		href.hash;
}

function getDocumentUri(uri) {
	return uri.split('#')[0];
}
function normSchema(schema, baseUri) {
	if (schema && typeof schema === "object") {
		if (baseUri === undefined) {
			baseUri = schema.id;
		} else if (typeof schema.id === "string") {
			baseUri = resolveUrl(baseUri, schema.id);
			schema.id = baseUri;
		}
		if (Array.isArray(schema)) {
			for (var i = 0; i < schema.length; i++) {
				normSchema(schema[i], baseUri);
			}
		} else if (typeof schema['$ref'] === "string") {
			schema['$ref'] = resolveUrl(baseUri, schema['$ref']);
		} else {
			for (var key in schema) {
				if (key !== "enum") {
					normSchema(schema[key], baseUri);
				}
			}
		}
	}
}

var ErrorCodes = {
	INVALID_TYPE: 0,
	ENUM_MISMATCH: 1,
	ANY_OF_MISSING: 10,
	ONE_OF_MISSING: 11,
	ONE_OF_MULTIPLE: 12,
	NOT_PASSED: 13,
	// Numeric errors
	NUMBER_MULTIPLE_OF: 100,
	NUMBER_MINIMUM: 101,
	NUMBER_MINIMUM_EXCLUSIVE: 102,
	NUMBER_MAXIMUM: 103,
	NUMBER_MAXIMUM_EXCLUSIVE: 104,
	// String errors
	STRING_LENGTH_SHORT: 200,
	STRING_LENGTH_LONG: 201,
	STRING_PATTERN: 202,
	// Object errors
	OBJECT_PROPERTIES_MINIMUM: 300,
	OBJECT_PROPERTIES_MAXIMUM: 301,
	OBJECT_REQUIRED: 302,
	OBJECT_ADDITIONAL_PROPERTIES: 303,
	OBJECT_DEPENDENCY_KEY: 304,
	// Array errors
	ARRAY_LENGTH_SHORT: 400,
	ARRAY_LENGTH_LONG: 401,
	ARRAY_UNIQUE: 402,
	ARRAY_ADDITIONAL_ITEMS: 403,
	// Format errors
	FORMAT_CUSTOM: 500,
	// Schema structure
	CIRCULAR_REFERENCE: 600,
	// Non-standard validation options
	UNKNOWN_PROPERTY: 1000
};
var ErrorMessagesDefault = {
	INVALID_TYPE: "invalid type: {type} (expected {expected})",
	ENUM_MISMATCH: "No enum match for: {value}",
	ANY_OF_MISSING: "Data does not match any schemas from \"anyOf\"",
	ONE_OF_MISSING: "Data does not match any schemas from \"oneOf\"",
	ONE_OF_MULTIPLE: "Data is valid against more than one schema from \"oneOf\": indices {index1} and {index2}",
	NOT_PASSED: "Data matches schema from \"not\"",
	// Numeric errors
	NUMBER_MULTIPLE_OF: "Value {value} is not a multiple of {multipleOf}",
	NUMBER_MINIMUM: "Value {value} is less than minimum {minimum}",
	NUMBER_MINIMUM_EXCLUSIVE: "Value {value} is equal to exclusive minimum {minimum}",
	NUMBER_MAXIMUM: "Value {value} is greater than maximum {maximum}",
	NUMBER_MAXIMUM_EXCLUSIVE: "Value {value} is equal to exclusive maximum {maximum}",
	// String errors
	STRING_LENGTH_SHORT: "String is too short ({length} chars), minimum {minimum}",
	STRING_LENGTH_LONG: "String is too long ({length} chars), maximum {maximum}",
	STRING_PATTERN: "String does not match pattern: {pattern}",
	// Object errors
	OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({propertyCount}), minimum {minimum}",
	OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({propertyCount}), maximum {maximum}",
	OBJECT_REQUIRED: "Missing required property: {key}",
	OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed",
	OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {missing} (due to key: {key})",
	// Array errors
	ARRAY_LENGTH_SHORT: "Array is too short ({length}), minimum {minimum}",
	ARRAY_LENGTH_LONG: "Array is too long ({length}), maximum {maximum}",
	ARRAY_UNIQUE: "Array items are not unique (indices {match1} and {match2})",
	ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed",
	// Format errors
	FORMAT_CUSTOM: "Format validation failed ({message})",
	// Schema structure
	CIRCULAR_REFERENCE: "Circular $refs: {urls}",
	// Non-standard validation options
	UNKNOWN_PROPERTY: "Unknown property (not in schema)"
};

function ValidationError(code, message, dataPath, schemaPath, subErrors) {
	Error.call(this);
	if (code === undefined) {
		throw new Error ("No code supplied for error: "+ message);
	}
	this.message = message;
	this.code = code;
	this.dataPath = dataPath || "";
	this.schemaPath = schemaPath || "";
	this.subErrors = subErrors || null;

	var err = new Error(this.message);
	this.stack = err.stack || err.stacktrace;
	if (!this.stack) {
		try {
			throw err;
		}
		catch(err) {
			this.stack = err.stack || err.stacktrace;
		}
	}
}
ValidationError.prototype = Object.create(Error.prototype);
ValidationError.prototype.constructor = ValidationError;
ValidationError.prototype.name = 'ValidationError';

ValidationError.prototype.prefixWith = function (dataPrefix, schemaPrefix) {
	if (dataPrefix !== null) {
		dataPrefix = dataPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
		this.dataPath = "/" + dataPrefix + this.dataPath;
	}
	if (schemaPrefix !== null) {
		schemaPrefix = schemaPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
		this.schemaPath = "/" + schemaPrefix + this.schemaPath;
	}
	if (this.subErrors !== null) {
		for (var i = 0; i < this.subErrors.length; i++) {
			this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);
		}
	}
	return this;
};

function isTrustedUrl(baseUrl, testUrl) {
	if(testUrl.substring(0, baseUrl.length) === baseUrl){
		var remainder = testUrl.substring(baseUrl.length);
		if ((testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === "/")
			|| remainder.charAt(0) === "#"
			|| remainder.charAt(0) === "?") {
			return true;
		}
	}
	return false;
}

var languages = {};
function createApi(language) {
	var globalContext = new ValidatorContext();
	var currentLanguage = language || 'en';
	var api = {
		addFormat: function () {
			globalContext.addFormat.apply(globalContext, arguments);
		},
		language: function (code) {
			if (!code) {
				return currentLanguage;
			}
			if (!languages[code]) {
				code = code.split('-')[0]; // fall back to base language
			}
			if (languages[code]) {
				currentLanguage = code;
				return code; // so you can tell if fall-back has happened
			}
			return false;
		},
		addLanguage: function (code, messageMap) {
			var key;
			for (key in ErrorCodes) {
				if (messageMap[key] && !messageMap[ErrorCodes[key]]) {
					messageMap[ErrorCodes[key]] = messageMap[key];
				}
			}
			var rootCode = code.split('-')[0];
			if (!languages[rootCode]) { // use for base language if not yet defined
				languages[code] = messageMap;
				languages[rootCode] = messageMap;
			} else {
				languages[code] = Object.create(languages[rootCode]);
				for (key in messageMap) {
					if (typeof languages[rootCode][key] === 'undefined') {
						languages[rootCode][key] = messageMap[key];
					}
					languages[code][key] = messageMap[key];
				}
			}
			return this;
		},
		freshApi: function (language) {
			var result = createApi();
			if (language) {
				result.language(language);
			}
			return result;
		},
		validate: function (data, schema, checkRecursive, banUnknownProperties) {
			var context = new ValidatorContext(globalContext, false, languages[currentLanguage], checkRecursive, banUnknownProperties);
			if (typeof schema === "string") {
				schema = {"$ref": schema};
			}
			context.addSchema("", schema);
			var error = context.validateAll(data, schema, null, null, "");
			if (!error && banUnknownProperties) {
				error = context.banUnknownProperties();
			}
			this.error = error;
			this.missing = context.missing;
			this.valid = (error === null);
			return this.valid;
		},
		validateResult: function () {
			var result = {};
			this.validate.apply(result, arguments);
			return result;
		},
		validateMultiple: function (data, schema, checkRecursive, banUnknownProperties) {
			var context = new ValidatorContext(globalContext, true, languages[currentLanguage], checkRecursive, banUnknownProperties);
			if (typeof schema === "string") {
				schema = {"$ref": schema};
			}
			context.addSchema("", schema);
			context.validateAll(data, schema, null, null, "");
			if (banUnknownProperties) {
				context.banUnknownProperties();
			}
			var result = {};
			result.errors = context.errors;
			result.missing = context.missing;
			result.valid = (result.errors.length === 0);
			return result;
		},
		addSchema: function () {
			return globalContext.addSchema.apply(globalContext, arguments);
		},
		getSchema: function () {
			return globalContext.getSchema.apply(globalContext, arguments);
		},
		getSchemaMap: function () {
			return globalContext.getSchemaMap.apply(globalContext, arguments);
		},
		getSchemaUris: function () {
			return globalContext.getSchemaUris.apply(globalContext, arguments);
		},
		getMissingUris: function () {
			return globalContext.getMissingUris.apply(globalContext, arguments);
		},
		dropSchemas: function () {
			globalContext.dropSchemas.apply(globalContext, arguments);
		},
		reset: function () {
			globalContext.reset();
			this.error = null;
			this.missing = [];
			this.valid = true;
		},
		missing: [],
		error: null,
		valid: true,
		normSchema: normSchema,
		resolveUrl: resolveUrl,
		getDocumentUri: getDocumentUri,
		errorCodes: ErrorCodes
	};
	return api;
}

var tv4 = createApi();
tv4.addLanguage('en-gb', ErrorMessagesDefault);

//legacy property
tv4.tv4 = tv4;

if (typeof module !== 'undefined' && module.exports){
	module.exports = tv4;
}
else {
	global.tv4 = tv4;
}

})(this);

},{}]},{},[1])